diff -Naur linux-2.6.14/arch/h8300/kernel/h8300_ksyms.c linux-2.6.14-uc0/arch/h8300/kernel/h8300_ksyms.c
--- linux-2.6.14/arch/h8300/kernel/h8300_ksyms.c	2005-10-31 15:39:11.000000000 +1000
+++ linux-2.6.14-uc0/arch/h8300/kernel/h8300_ksyms.c	2005-10-31 15:40:45.000000000 +1000
@@ -103,10 +103,6 @@
 EXPORT_SYMBOL(__umoddi3);
 EXPORT_SYMBOL(__umodsi3);
 
-#ifdef MAGIC_ROM_PTR
-EXPORT_SYMBOL(is_in_rom);
-#endif
-
 EXPORT_SYMBOL(h8300_reserved_gpio);
 EXPORT_SYMBOL(h8300_free_gpio);
 EXPORT_SYMBOL(h8300_set_gpio_dir);
diff -Naur linux-2.6.14/arch/h8300/mm/memory.c linux-2.6.14-uc0/arch/h8300/mm/memory.c
--- linux-2.6.14/arch/h8300/mm/memory.c	2005-10-31 15:39:11.000000000 +1000
+++ linux-2.6.14-uc0/arch/h8300/mm/memory.c	2005-10-31 15:40:45.000000000 +1000
@@ -55,16 +55,3 @@
 	return paddr;
 }
 
-#ifdef MAGIC_ROM_PTR
-
-int is_in_rom(unsigned long addr)
-{
-	/* Anything not in operational RAM is returned as in rom! */
-	if (addr < _ramstart || addr >= _ramend)
- 		return 1;
-	else
-		return 0;
-}
-
-#endif
-
diff -Naur linux-2.6.14/arch/m68knommu/defconfig linux-2.6.14-uc0/arch/m68knommu/defconfig
--- linux-2.6.14/arch/m68knommu/defconfig	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/defconfig	2005-10-31 15:40:39.000000000 +1000
@@ -99,7 +99,7 @@
 # CONFIG_NETtel is not set
 # CONFIG_CPU16B is not set
 # CONFIG_MOD5272 is not set
-CONFIG_MOTOROLA=y
+CONFIG_FREESCALE=y
 # CONFIG_LARGE_ALLOCS is not set
 CONFIG_4KSTACKS=y
 CONFIG_RAMAUTO=y
@@ -554,7 +554,6 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 CONFIG_ROMFS_FS=y
-CONFIG_MAGIC_ROM_PTR=y
 # CONFIG_INOTIFY is not set
 # CONFIG_QUOTA is not set
 # CONFIG_DNOTIFY is not set
diff -Naur linux-2.6.14/arch/m68knommu/Kconfig linux-2.6.14-uc0/arch/m68knommu/Kconfig
--- linux-2.6.14/arch/m68knommu/Kconfig	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/Kconfig	2005-10-31 15:40:39.000000000 +1000
@@ -71,6 +71,11 @@
 	help
 	  Motorola ColdFire 5206e processor support.
 
+config M520x
+	bool "MCF520x"
+	help
+	   Freescale Coldfire 5207/5208 processor support.
+
 config M523x
 	bool "MCF523x"
 	help
@@ -120,7 +125,7 @@
 
 config COLDFIRE
 	bool
-	depends on (M5206 || M5206e || M523x || M5249 || M527x || M5272 || M528x || M5307 || M5407)
+	depends on (M5206 || M5206e || M520x || M523x || M5249 || M527x || M5272 || M528x || M5307 || M5407)
 	default y
 
 choice
@@ -322,6 +327,12 @@
 	help
 	  Support for the Motorola M5206eLITE board.
 
+config M5208EVB
+	bool "Freescale M5208EVB board support"
+	depends on M520x
+	help
+	  Support for the Freescale Coldfire M5208EVB.
+
 config M5235EVB
 	bool "Freescale M5235EVB support"
 	depends on M523x
@@ -465,10 +476,10 @@
 	default y
 	depends on (ARN5206 || ARN5307)
 
-config MOTOROLA
+config FREESCALE
 	bool
 	default y
-	depends on (M5206eC3 || M5235EVB || M5249C3 || M5271EVB || M5272C3 || M5275EVB || M5282EVB || M5307C3 || M5407C3)
+	depends on (M5206eC3 || M5208EVB || M5235EVB || M5249C3 || M5271EVB || M5272C3 || M5275EVB || M5282EVB || M5307C3 || M5407C3)
 
 config HW_FEITH
 	bool
diff -Naur linux-2.6.14/arch/m68knommu/kernel/asm-offsets.c linux-2.6.14-uc0/arch/m68knommu/kernel/asm-offsets.c
--- linux-2.6.14/arch/m68knommu/kernel/asm-offsets.c	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/kernel/asm-offsets.c	2005-10-31 15:40:39.000000000 +1000
@@ -15,6 +15,7 @@
 #include <linux/hardirq.h>
 #include <asm/bootinfo.h>
 #include <asm/irq.h>
+#include <asm/irqnode.h>
 #include <asm/thread_info.h>
 
 #define DEFINE(sym, val) \
diff -Naur linux-2.6.14/arch/m68knommu/kernel/setup.c linux-2.6.14-uc0/arch/m68knommu/kernel/setup.c
--- linux-2.6.14/arch/m68knommu/kernel/setup.c	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/kernel/setup.c	2005-10-31 15:40:39.000000000 +1000
@@ -107,6 +107,9 @@
 #if defined(CONFIG_M5206e)
 	#define	CPU "COLDFIRE(m5206e)"
 #endif
+#if defined(CONFIG_M520x)
+	#define CPU "COLDFIRE(m520x)"
+#endif
 #if defined(CONFIG_M523x)
 	#define CPU "COLDFIRE(m523x)"
 #endif
@@ -132,7 +135,7 @@
 	#define	CPU "COLDFIRE(m5407)"
 #endif
 #ifndef CPU
-	#define	CPU "UNKOWN"
+	#define	CPU "UNKNOWN"
 #endif
 
 /* (es) */
diff -Naur linux-2.6.14/arch/m68knommu/kernel/vmlinux.lds.S linux-2.6.14-uc0/arch/m68knommu/kernel/vmlinux.lds.S
--- linux-2.6.14/arch/m68knommu/kernel/vmlinux.lds.S	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/kernel/vmlinux.lds.S	2005-10-31 15:40:39.000000000 +1000
@@ -125,6 +125,14 @@
 #endif
 
 /*
+ *	The Freescale 5208EVB board has 32MB of RAM.
+ */
+#if defined(CONFIG_M5208EVB)
+#define	RAM_START	0x40020000
+#define	RAM_LENGTH	0x01e00000
+#endif
+
+/*
  *	The senTec COBRA5272 board has nearly the same memory layout as 
  *	the M5272C3. We assume 16MiB ram.
  */
@@ -275,6 +283,7 @@
 		*(__ksymtab_strings)
 
 		/* Built-in module parameters */
+		. = ALIGN(4) ;
 		__start___param = .;
 		*(__param)
 		__stop___param = .;
diff -Naur linux-2.6.14/arch/m68knommu/Makefile linux-2.6.14-uc0/arch/m68knommu/Makefile
--- linux-2.6.14/arch/m68knommu/Makefile	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/Makefile	2005-10-31 15:40:39.000000000 +1000
@@ -14,6 +14,7 @@
 platform-$(CONFIG_M68360)	:= 68360
 platform-$(CONFIG_M5206)	:= 5206
 platform-$(CONFIG_M5206e)	:= 5206e
+platform-$(CONFIG_M520x)	:= 520x
 platform-$(CONFIG_M523x)	:= 523x
 platform-$(CONFIG_M5249)	:= 5249
 platform-$(CONFIG_M527x)	:= 527x
@@ -29,7 +30,7 @@
 board-$(CONFIG_UCQUICC)		:= uCquicc
 board-$(CONFIG_DRAGEN2)		:= de2
 board-$(CONFIG_ARNEWSH)		:= ARNEWSH
-board-$(CONFIG_MOTOROLA)	:= MOTOROLA
+board-$(CONFIG_FREESCALE)	:= FREESCALE
 board-$(CONFIG_M5235EVB)	:= M5235EVB
 board-$(CONFIG_M5271EVB)	:= M5271EVB
 board-$(CONFIG_M5275EVB)	:= M5275EVB
@@ -41,6 +42,7 @@
 board-$(CONFIG_CLEOPATRA)	:= CLEOPATRA
 board-$(CONFIG_senTec)		:= senTec
 board-$(CONFIG_SNEHA) 	        := SNEHA
+board-$(CONFIG_M5208EVB)	:= M5208EVB
 board-$(CONFIG_MOD5272)		:= MOD5272
 BOARD := $(board-y)
 
@@ -56,6 +58,7 @@
 #
 cpuclass-$(CONFIG_M5206)	:= 5307
 cpuclass-$(CONFIG_M5206e)	:= 5307
+cpuclass-$(CONFIG_M520x)	:= 5307
 cpuclass-$(CONFIG_M523x)	:= 5307
 cpuclass-$(CONFIG_M5249)	:= 5307
 cpuclass-$(CONFIG_M527x)	:= 5307
@@ -80,6 +83,7 @@
 #
 cflags-$(CONFIG_M5206)		:= -m5200 -Wa,-S -Wa,-m5200
 cflags-$(CONFIG_M5206e)		:= -m5200 -Wa,-S -Wa,-m5200
+cflags-$(CONFIG_M520x)		:= -m5307 -Wa,-S -Wa,-m5307
 cflags-$(CONFIG_M523x)		:= -m5307 -Wa,-S -Wa,-m5307
 cflags-$(CONFIG_M5249)		:= -m5200 -Wa,-S -Wa,-m5200
 cflags-$(CONFIG_M527x)		:= -m5307 -Wa,-S -Wa,-m5307
@@ -95,7 +99,6 @@
 AFLAGS += $(cflags-y)
 
 CFLAGS += $(cflags-y)
-CFLAGS += -fno-builtin
 CFLAGS += -O1 -g
 CFLAGS += -D__linux__
 CFLAGS += -DUTS_SYSNAME=\"uClinux\"
diff -Naur linux-2.6.14/arch/m68knommu/platform/520x/config.c linux-2.6.14-uc0/arch/m68knommu/platform/520x/config.c
--- linux-2.6.14/arch/m68knommu/platform/520x/config.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/platform/520x/config.c	2005-10-31 15:40:39.000000000 +1000
@@ -0,0 +1,65 @@
+/***************************************************************************/
+
+/*
+ *  linux/arch/m68knommu/platform/520x/config.c
+ *
+ *  Copyright (C) 2005,      Freescale (www.freescale.com)
+ *  Copyright (C) 2005,      Intec Automation (mike@steroidmicros.com)
+ *  Copyright (C) 1999-2003, Greg Ungerer (gerg@snapgear.com)
+ *  Copyright (C) 2001-2003, SnapGear Inc. (www.snapgear.com)
+ */
+
+/***************************************************************************/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <asm/machdep.h>
+#include <asm/dma.h>
+
+/***************************************************************************/
+
+/*
+ *	DMA channel base address table.
+ */
+unsigned int dma_base_addr[MAX_M68K_DMA_CHANNELS];
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
+/***************************************************************************/
+
+void coldfire_pit_tick(void);
+void coldfire_pit_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
+unsigned long coldfire_pit_offset(void);
+void coldfire_trap_init(void);
+void coldfire_reset(void);
+
+/***************************************************************************/
+
+/*
+ *  Program the vector to be an auto-vectored.
+ */
+
+void mcf_autovector(unsigned int vec)
+{
+    /* Everything is auto-vectored on the 520x devices */
+}
+
+/***************************************************************************/
+
+void config_BSP(char *commandp, int size)
+{
+#ifdef CONFIG_BOOTPARAM
+    strncpy(commandp, CONFIG_BOOTPARAM_STRING, size);
+    commandp[size-1] = 0;
+#else
+    memset(commandp, 0, size);
+#endif
+
+    mach_sched_init = coldfire_pit_init;
+    mach_tick = coldfire_pit_tick;
+    mach_gettimeoffset = coldfire_pit_offset;
+    mach_trap_init = coldfire_trap_init;
+    mach_reset = coldfire_reset;
+}
+
+/***************************************************************************/
diff -Naur linux-2.6.14/arch/m68knommu/platform/520x/Makefile linux-2.6.14-uc0/arch/m68knommu/platform/520x/Makefile
--- linux-2.6.14/arch/m68knommu/platform/520x/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/platform/520x/Makefile	2005-10-31 15:40:39.000000000 +1000
@@ -0,0 +1,19 @@
+#
+# Makefile for the M5208 specific file.
+#
+
+#
+# If you want to play with the HW breakpoints then you will
+# need to add define this,  which will give you a stack backtrace
+# on the console port whenever a DBG interrupt occurs.  You have to
+# set up you HW breakpoints to trigger a DBG interrupt:
+#
+# EXTRA_CFLAGS += -DTRAP_DBG_INTERRUPT
+# EXTRA_AFLAGS += -DTRAP_DBG_INTERRUPT
+#
+
+ifdef CONFIG_FULLDEBUG
+AFLAGS += -DDEBUGGER_COMPATIBLE_CACHE=1
+endif
+
+obj-y := config.o
diff -Naur linux-2.6.14/arch/m68knommu/platform/5307/head.S linux-2.6.14-uc0/arch/m68knommu/platform/5307/head.S
--- linux-2.6.14/arch/m68knommu/platform/5307/head.S	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/platform/5307/head.S	2005-10-31 15:40:39.000000000 +1000
@@ -113,6 +113,9 @@
 #define MEM_BASE	0x02000000
 #define VBR_BASE	0x20000000	/* vectors in SRAM */
 #endif
+#if defined(CONFIG_M5208EVB)
+#define MEM_BASE	0x40000000
+#endif
 
 #ifndef MEM_BASE
 #define	MEM_BASE	0x00000000	/* memory base at address 0 */
diff -Naur linux-2.6.14/arch/m68knommu/platform/5307/ints.c linux-2.6.14-uc0/arch/m68knommu/platform/5307/ints.c
--- linux-2.6.14/arch/m68knommu/platform/5307/ints.c	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/platform/5307/ints.c	2005-10-31 15:40:39.000000000 +1000
@@ -26,6 +26,7 @@
 
 #include <asm/system.h>
 #include <asm/irq.h>
+#include <asm/irqnode.h>
 #include <asm/traps.h>
 #include <asm/page.h>
 #include <asm/machdep.h>
diff -Naur linux-2.6.14/arch/m68knommu/platform/5307/Makefile linux-2.6.14-uc0/arch/m68knommu/platform/5307/Makefile
--- linux-2.6.14/arch/m68knommu/platform/5307/Makefile	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/platform/5307/Makefile	2005-10-31 15:40:39.000000000 +1000
@@ -19,6 +19,7 @@
 obj-$(CONFIG_COLDFIRE)	+= entry.o vectors.o ints.o
 obj-$(CONFIG_M5206)	+= timers.o
 obj-$(CONFIG_M5206e)	+= timers.o
+obj-$(CONFIG_M520x)	+= pit.o
 obj-$(CONFIG_M523x)	+= pit.o
 obj-$(CONFIG_M5249)	+= timers.o
 obj-$(CONFIG_M527x)     += pit.o
diff -Naur linux-2.6.14/arch/m68knommu/platform/5307/pit.c linux-2.6.14-uc0/arch/m68knommu/platform/5307/pit.c
--- linux-2.6.14/arch/m68knommu/platform/5307/pit.c	2005-10-31 15:39:07.000000000 +1000
+++ linux-2.6.14-uc0/arch/m68knommu/platform/5307/pit.c	2005-10-31 15:40:39.000000000 +1000
@@ -3,7 +3,7 @@
 /*
  *	pit.c -- Motorola ColdFire PIT timer. Currently this type of
  *	         hardware timer only exists in the Motorola ColdFire
- *		 5270/5271 and 5282 CPUs.
+ *		 5270/5271, 5282 and other CPUs.
  *
  *	Copyright (C) 1999-2004, Greg Ungerer (gerg@snapgear.com)
  *	Copyright (C) 2001-2004, SnapGear Inc. (www.snapgear.com)
@@ -47,10 +47,10 @@
 
 	icrp = (volatile unsigned char *) (MCF_IPSBAR + MCFICM_INTC0 +
 		MCFINTC_ICR0 + MCFINT_PIT1);
-	*icrp = 0x2b; /* PIT1 with level 5, priority 3 */
+	*icrp = ICR_INTRCONF;
 
-	imrp = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRH);
-	*imrp &= ~(1 << (MCFINT_PIT1 - 32));
+	imrp = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFPIT_IMR);
+	*imrp &= ~MCFPIT_IMR_IBIT;
 
 	/* Set up PIT timer 1 as poll clock */
 	tp = (volatile struct mcfpit *) (MCF_IPSBAR + MCFPIT_BASE1);
@@ -70,7 +70,7 @@
 	unsigned long pmr, pcntr, offset;
 
 	tp = (volatile struct mcfpit *) (MCF_IPSBAR + MCFPIT_BASE1);
-	ipr = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IPRH);
+	ipr = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFPIT_IMR);
 
 	pmr = *(&tp->pmr);
 	pcntr = *(&tp->pcntr);
@@ -80,7 +80,7 @@
 	 * timer interupt is pending, then add on a ticks worth of time.
 	 */
 	offset = ((pmr - pcntr) * (1000000 / HZ)) / pmr;
-	if ((offset < (1000000 / HZ / 2)) && (*ipr & (1 << (MCFINT_PIT1 - 32))))
+	if ((offset < (1000000 / HZ / 2)) && (*ipr & MCFPIT_IMR_IBIT))
 		offset += 1000000 / HZ;
 	return offset;	
 }
diff -Naur linux-2.6.14/drivers/char/mcf_qspi.c linux-2.6.14-uc0/drivers/char/mcf_qspi.c
--- linux-2.6.14/drivers/char/mcf_qspi.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.14-uc0/drivers/char/mcf_qspi.c	2005-10-31 15:42:12.000000000 +1000
@@ -0,0 +1,851 @@
+/************************************************************************/
+/*                                                                      */
+/*  mcf_qspi.c - QSPI driver for MCF5272, MCF5235, MCF5282              */
+/*                                                                      */
+/*  (C) Copyright 2001, Wayne Roberts (wroberts1@home.com)              */
+/*                                                                      */
+/*  Driver has an 8bit mode, and a 16bit mode.                          */
+/*  Transfer size QMR[BITS] is set thru QSPIIOCS_BITS.                  */
+/*  When size is 8, driver works normally:                              */
+/*        a char is sent for every transfer                             */
+/*  When size is 9 to 16bits, driver reads & writes the QDRs with       */
+/*  the buffer cast to unsigned shorts.  The QTR & QRR registers can    */
+/*  be filled with up to 16bits.  The length passed to read/write must  */
+/*  be of the number of chars (2x number of shorts). This has been      */
+/*  tested with 10bit a/d and d/a converters.                           */
+/*                                                                      */
+/*  * QSPIIOCS_READDATA:                                                */
+/*    data to send out during read                                      */
+/*  * all other ioctls are global                                       */
+/* -------------------------------------------------------------------- */
+/*  Ported to linux-2.4.x by Ron Fial (ron@fial.com) August 26,2002     */
+/*                                                                      */
+/*   Added new include files                                            */
+/*   Added module_init(),exit(),                                        */
+/*   qspi_read(),qspi_write():  Revised qspi_read & write argument      */
+/*     processing to handle new *filep argument. Changed i_rdev access  */
+/*     to use filep->f_dentry->d_inode->i_rdev  Changed memcpy_fromfs() */
+/*     to memcpy().                                                     */
+/*   Added '__init' to compiled-in init routine for memory recovery     */
+/*   Added '__exit' for loadable-driver module cleanup routine          */
+/*   changed  register_chrdev to  devfs_register_chrdev                 */
+/*   changed  unregister_chrdev to  devfs_unregister_chrdev             */
+/*   Changed various declarations from int to ssize_t or loff_t         */
+/* -------------------------------------------------------------------- */
+/*   Changed interruptible_sleep_on to sleep_on so the driver has       */
+/*           chance to finish the current transfer before application   */
+/*           quits when typing '^C'. Otherwise a write collision will   */
+/*           most likely occur.                                         */
+/*   Added   safe_flags(); cli; and frestore_flags() according to        */
+/*           gerg@snapgear.com. Otherwise in some cases (higher clock   */
+/*           rates) the transfer is finished before the current process */
+/*           is put to sleep and therefore never wakes up again.        */
+/*           09/12/2002 richard@opentcp.org                             */
+/* -------------------------------------------------------------------- */
+/*   02/06/2003 josef.baumgartner@telex.de                              */
+/*                                                                      */
+/*   Renamed cleanup_module() to qspi_exit() to be able to              */
+/*     compile as module.                                               */
+/*   Removed init_module() because module_init(qspi_init) does all      */
+/*     we need.                                                         */
+/*   Changed                                                            */
+/*     SPI register settings will be saved for each instance to be able */
+/*     to use different communication settings for different tasks.     */
+/*     An ioctl() does not longer write directly to the SPI registers.  */
+/*     It saves the settings which will be copied into the SPI          */
+/*     registers on every read()/write().                               */
+/*   Added MODULE_LICENSE("GPL") to avoid tainted kernel message.       */
+/*     I think it is GPL?? There's no comment about this??              */
+/*   Added polling mode                                                 */
+/*     Increases performance for small data transfers.                  */
+/*   Added odd mode                                                     */
+/*     If an odd number of bytes is transfered and 16bit transfers are  */
+/*     used, the last byte is transfered in byte mode.                  */
+/*   Added dsp mode                                                     */
+/*     If dsp mode is set, transfers will be limited to 15 bytes        */
+/*     instead of 16. This ensures that DSPs with 24bit words get       */
+/*     whole words within one transfer.                                 */
+/* -------------------------------------------------------------------- */
+/*   16/09/2003 ivan.zanin@bluewin.ch                                   */
+/*                                                                      */
+/*   Changed init and exit code to support the MCF5249                  */
+/* -------------------------------------------------------------------- */
+/*   Oct 19, 2004 jsujjavanich@syntech-fuelmaster.com                   */
+/*                                                                      */
+/*   Adjusted minor number detection to work with one dev per QSPI_CS   */
+/* -------------------------------------------------------------------- */
+/*   17/11/2004 chris_jones_oz@yahoo.com.au                             */
+/*                                                                      */
+/*   Changed init and exit code to support the MCF5282                  */
+/* -------------------------------------------------------------------- */
+/*   050712 jherrero@hvsistemas.es					*/
+/*   									*/
+/*   Ported to kernel 2.6.x, tested only write on MCF5272		*/
+/* -------------------------------------------------------------------- */
+/************************************************************************/
+
+/* **********************************************************************
+Chapter 14. (excerpt) Queued Serial Peripheral Interface (QSPI) Module
+   From:  http://e-www.motorola.com/brdata/PDFDB/docs/MCF5272UM.pdf
+
+The following steps are necessary to set up the QSPI 12-bit data transfers
+and a QSPI_CLK of 4.125 MHz. The QSPI RAM is set up for a queue of 16
+transfers. All four QSPI_CS signals are used in this example.
+
+1. Enable all QSPI_CS pins on the MCF5272. Write PACNT with 0x0080_4000 to
+enable QSPI_CS1 and QSPI_CS3.Write PDCNT with 0x0000_0030 to enable QSPI_CS2.
+
+2. Write the QMR with 0xB308 to set up 12-bit data words with the data
+shifted on the falling clock edge, and a clock frequency of 4.125 MHz
+(assuming a 66-MHz CLKIN).
+
+3. Write QDLYR with the desired delays.
+
+4. Write QIR with 0xD00F to enable write collision, abort bus errors, and
+clear any interrupts.
+
+5. Write QAR with 0x0020 to select the first command RAM entry.
+
+6. Write QDR with 0x7E00, 0x7E00, 0x7E00, 0x7E00, 0x7D00, 0x7D00, 0x7D00,
+0x7D00, 0x7B00, 0x7B00, 0x7B00, 0x7B00, 0x7700, 0x7700, 0x7700, and 0x7700
+to set up four transfers for each chip select. The chip selects are active
+low in this example.  NOTE: QDR value auto-increments after each write.
+
+7. Write QAR with 0x0000 to select the first transmit RAM entry.
+
+8. Write QDR with sixteen 12-bit words of data.
+
+9. Write QWR with 0x0F00 to set up a queue beginning at entry 0 and ending
+at entry 15.
+
+10. Set QDLYR[SPE] to enable the transfers.
+
+11.Wait until the transfers are complete. QIR[SPIF] is set when the
+transfers are complete.
+
+12. Write QAR with 0x0010 to select the first receive RAM entry.
+
+13. Read QDR to get the received data for each transfer.  NOTE: QDR
+auto-increments.
+
+14. Repeat steps 5 through 13 to do another transfer.
+
+************************************************************************* */
+#include <asm/coldfire.h>               /* gets us MCF_MBAR value */
+#include <asm/mcfsim.h>                 /* MCFSIM offsets */
+#include <asm/semaphore.h>
+#include <asm/system.h>                 /* cli() and friends */
+#include <asm/uaccess.h>
+#include <linux/config.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+#include <linux/interrupt.h>
+
+/* Include versioning info, if needed */
+#if (defined(MODULE) && defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS))
+#define MODVERSIONS
+#endif
+
+#if defined(MODVERSIONS)
+#include <linux/modversions.h>
+#endif
+
+#include "mcf_qspi.h" 
+
+
+#define DEVICE_NAME "qspi"
+
+int __init qspi_init(void);
+static int init(void);
+void __exit qspi_exit(void);
+
+
+/* struct wait_queue *wqueue; */
+static DECLARE_WAIT_QUEUE_HEAD(wqueue);   /* use ver 2.4 static declaration - ron */
+/* or should we use   wait_queue_heat_t *wqueue   ?? see page 141  */
+
+static unsigned char dbuf[1024];
+
+/*  static struct semaphore sem = MUTEX;   */
+
+
+#if LINUX_VERSION_CODE < 0x020100
+static struct semaphore sem = MUTEX;
+#else
+static DECLARE_MUTEX(sem);
+#endif
+
+
+static void qspi_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{	
+	u16 qir = (QIR & (QIR_WCEF | QIR_ABRT | QIR_SPIF));
+
+        /* Check write collision and transfer abort flags.  Report any
+         * goofiness. */
+        if (qir & QIR_WCEF)
+                printk(KERN_INFO "%s: WCEF\n", __FILE__);
+
+        if (qir & QIR_ABRT)
+                printk(KERN_INFO "%s: ABRT\n", __FILE__);
+
+        /* Check for completed transfer.  Wake any tasks sleeping on our
+         * global wait queue. */
+        if (qir & QIR_SPIF)
+                wake_up(&wqueue);
+
+        /* Clear any set flags. */
+        QIR |= qir;
+}
+
+
+static int qspi_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+                unsigned long arg)
+{
+        int ret = 0;
+        struct qspi_dev *dev = filp->private_data;
+        struct qspi_read_data *read_data;
+        int error;
+
+        down(&sem);
+
+        switch (cmd) {
+                /* Set QMR[DOHIE] (high-z Dout between transfers) */
+                case QSPIIOCS_DOUT_HIZ:
+                        dev->dohie = (arg ? 1 : 0);
+                        break;
+
+                /* Set QMR[BITS] */
+                case QSPIIOCS_BITS:
+                        if (((arg > 0) && (arg < 8)) || (arg > 16)) {
+                                ret = -EINVAL;
+                                break;
+                        }
+
+                        dev->bits = (u8)arg;
+                        break;
+
+                /* Get QMR[BITS] */
+                case QSPIIOCG_BITS:
+                        *((int *)arg) = dev->bits;
+                        break;
+
+                /* Set QMR[CPOL] (QSPI_CLK inactive state) */
+                case QSPIIOCS_CPOL:
+                        dev->cpol = (arg ? 1 : 0);
+                        break;
+
+                /* Set QMR[CPHA] (QSPI_CLK phase, 1 = rising edge) */
+                case QSPIIOCS_CPHA:
+                        dev->cpha = (arg ? 1 : 0);
+                        break;
+
+                /* Set QMR[BAUD] (QSPI_CLK baud rate divisor) */
+                case QSPIIOCS_BAUD:
+                        if (arg > 255) {
+                                ret = -EINVAL;
+                                break;
+                        }
+
+                        dev->baud = (u8)arg;
+                        break;
+
+                /* Set QDR[QCD] (QSPI_CS to QSPI_CLK setup) */
+                case QSPIIOCS_QCD:
+                        if (arg > 127) {
+                                ret = -EINVAL;
+                                break;
+                        }
+
+                        dev->qcd = (u8)arg;
+                        break;
+
+                /* Set QDR[DTL] (QSPI_CLK to QSPI_CS hold) */
+                case QSPIIOCS_DTL:
+                        if (arg > 255) {
+                                ret = -EINVAL;
+                                break;
+                        }
+
+                        dev->dtl = (u8)arg;
+                        break;
+
+                /* Set QCRn[CONT] (QSPI_CS continuous mode, 1 = remain
+                 * asserted after transfer of 16 data words) */
+                case QSPIIOCS_CONT:
+                        dev->qcr_cont = (arg ? 1 : 0);
+                        break;
+
+                /* Set DSP mode, used to limit transfers to 15 bytes for
+                 * 24-bit DSPs */
+                case QSPIIOCS_DSP_MOD:
+                        dev->dsp_mod  = (arg ? 1 : 0);
+                        break;
+
+                /* If an odd count of bytes is transferred, force the transfer
+                 * of the last byte to byte mode, even if word mode is used */
+                case QSPIIOCS_ODD_MOD:
+                        dev->odd_mod = (arg ? 1 : 0);
+                        break;
+
+                /* Set data buffer to be used as "send data" during reads */
+                case QSPIIOCS_READDATA:
+                        read_data = (struct qspi_read_data *)arg;
+                        error = verify_area(VERIFY_READ, read_data,
+                                        sizeof(struct qspi_read_data));
+                        if (error) {
+                                ret = error;
+                                break;
+                        }
+
+                        if (read_data->length > sizeof(read_data->buf)) {
+                                ret = -EINVAL;
+                                break;
+                        }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+                        memcpy_fromfs(&dev->read_data, read_data,
+                                        sizeof(struct qspi_read_data));
+#else
+                        copy_from_user(&dev->read_data, read_data,
+                                        sizeof(struct qspi_read_data));
+#endif
+                        break;
+
+                /* Set driver to use polling mode, which may increase
+                 * performance for small transfers */
+                case QSPIIOCS_POLL_MOD:
+                        dev->poll_mod = (arg ? 1 : 0);
+                        break;
+
+                default:
+                        ret = -EINVAL;
+                        break;
+        }
+
+        up(&sem);
+        return(ret);
+}
+
+
+static int qspi_open(struct inode *inode, struct file *file)
+{
+        qspi_dev *dev;
+
+/*    #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+        MOD_INC_USE_COUNT;
+   #endif   */
+
+        if ((dev = kmalloc(sizeof(qspi_dev), GFP_KERNEL)) == NULL) {
+  /*  #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+                MOD_DEC_USE_COUNT;
+        #endif  */
+		return(-ENOMEM);
+        }
+
+        /* set default values */
+        dev->read_data.length = 0;
+        dev->read_data.buf[0] = 0;
+        dev->read_data.buf[1] = 0;
+        dev->read_data.loop = 0;
+        dev->poll_mod = 0;              /* interrupt mode */
+        dev->bits = 8;
+        dev->cpol = 0;
+        dev->cpha = 0;
+        dev->qcr_cont = 1;
+        dev->dsp_mod = 0;               /* no DSP mode */
+        dev->odd_mod = 0;               /* no ODD mode */
+        dev->qcd = 17;
+        dev->dtl = 1;
+
+        file->private_data = dev;
+
+        return(0);
+}
+
+
+static int qspi_release(struct inode *inode, struct file *file)
+{
+        kfree(file->private_data);
+
+/*  #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+        MOD_DEC_USE_COUNT;
+        #endif    */
+
+        return(0);
+}
+
+
+//   basic 2.4 kernel function format
+// ssize_t qspi_read(struct file* w12f, char * w12c, size_t w12d, loff_t * w12e) { ; }
+
+
+static ssize_t qspi_read(struct file *filep, char *buffer, size_t length,
+                loff_t *off)
+/******** older 2.0 kernel format **********
+static int qspi_read(
+        struct inode *inode,
+        struct file *filep,
+        char *buffer,
+        int length)
+********************************************/
+{
+        int qcr_cs;
+        int total = 0;
+        int i = 0;
+        int max_trans;
+        unsigned char bits;
+        unsigned char word = 0;
+        unsigned long flag;
+        qspi_dev *dev;
+        int rdi = 0;
+
+        down(&sem);
+
+        dev = filep->private_data;
+
+        /* set the register with default values */
+        QMR = QMR_MSTR |
+                (dev->dohie << 14) |
+                (dev->bits << 10) |
+                (dev->cpol << 9) |
+                (dev->cpha << 8) |
+                (dev->baud);
+
+        QDLYR = (dev->qcd << 8) | dev->dtl;
+
+        if (dev->dsp_mod)
+                max_trans = 15;
+        else
+                max_trans = 16;
+
+	//qcr_cs = (~MINOR(filep->f_dentry->d_inode->i_rdev) << 8) & 0xf00;  /* CS for QCR */
+ 	qcr_cs = 0xf00 & ~(1 << (8 + MINOR(filep->f_dentry->d_inode->i_rdev))); 
+        
+	bits = dev->bits % 0x10;
+        if (bits == 0 || bits > 0x08)
+                word = 1; /* 9 to 16bit transfers */
+
+//              printk("\n READ driver -- ioctl xmit data fm dev->read_data.buf array  %x %x %x %x \n",dev->read_data.buf[0],dev->read_data.buf[1],dev->read_data.buf[2],dev->read_data.buf[3]);
+
+        while (i < length) {
+                unsigned short *sp = (unsigned short *)&buffer[i];
+                unsigned char *cp = &buffer[i];
+                unsigned short *rd_sp = (unsigned short *)dev->read_data.buf;
+                int x;
+                int n;
+
+                QAR = TX_RAM_START;             /* address first QTR */
+                for (n = 0; n < max_trans; n++) {
+                        if (rdi != -1) {
+                                if (word) {
+                                        QDR = rd_sp[rdi++];
+                                        if (rdi == dev->read_data.length >> 1)
+                                                rdi = dev->read_data.loop ? 0 : -1;
+                                } else {
+                                        QDR = dev->read_data.buf[rdi++];
+                                        if (rdi == dev->read_data.length)
+                                                rdi = dev->read_data.loop ? 0 : -1;
+                                }
+                        } else
+                                QDR = 0;
+
+                        i++;
+                        if (word)
+                                i++;
+                        if (i > length)
+                                break;
+                }
+
+                QAR = COMMAND_RAM_START;        /* address first QCR */
+                for (x = 0; x < n; x++) {
+                        /* QCR write */
+                        if (dev->qcr_cont) {
+                                if (x == n - 1 && i == length)
+                                        QDR = QCR_SETUP | qcr_cs;       /* last transfer */
+                                else
+                                        QDR = QCR_CONT | QCR_SETUP | qcr_cs;
+                        } else
+                                QDR = QCR_SETUP | qcr_cs;
+                }
+
+                QWR = QWR_CSIV | ((n - 1) << 8);
+
+                /* check if we are using polling mode. Polling increases
+                 * performance for samll data transfers but is dangerous
+                 * if we stay too long here, locking other tasks!!
+                 */
+                if (dev->poll_mod) {
+                        QIR = QIR_SETUP_POLL;
+                        QDLYR |= QDLYR_SPE;
+
+                        while ((QIR & QIR_SPIF) != QIR_SPIF)
+                                ;
+                        QIR = QIR | QIR_SPIF;
+                } else {
+                        QIR = QIR_SETUP;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) 
+			save_flags(flag); cli();                // like in write function
+#else
+			local_irq_save(flag);
+#endif			
+			
+                        QDLYR |= QDLYR_SPE;
+//                      interruptible_sleep_on(&wqueue);
+                        sleep_on(&wqueue);                      // changed richard@opentcp.org
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			restore_flags(flag);                    // like in write function
+#else
+			local_irq_restore(flag);
+#endif
+                }
+
+                QAR = RX_RAM_START;     /* address: first QRR */
+                if (word) {
+                        /* 9 to 16bit transfers */
+                        for (x = 0; x < n; x++) {
+                               put_user(*(volatile unsigned short *)(MCF_MBAR + MCFSIM_QDR), sp++);
+                        }
+                } else {
+                        /* 8bit transfers */
+                        for (x = 0; x < n; x++)
+                                put_user(*(volatile unsigned short *)(MCF_MBAR + MCFSIM_QDR), cp++);
+                }
+
+                if (word)
+                        n <<= 1;
+
+                total += n;
+        }
+
+        up(&sem);
+        return(total);
+}
+
+
+
+static ssize_t qspi_write(struct file *filep, const char *buffer, size_t length,
+                loff_t *off)
+{
+        int qcr_cs;
+        int i = 0;
+        int total = 0;
+        int z;
+        int max_trans;
+        unsigned char bits;
+        unsigned char word = 0;
+        unsigned long flag;
+        qspi_dev *dev;
+
+        down(&sem);
+
+	dev = filep->private_data;
+
+        QMR = QMR_MSTR |
+                (dev->dohie << 14) |
+                (dev->bits << 10) |
+                (dev->cpol << 9) |
+                (dev->cpha << 8) |
+                (dev->baud);
+
+        QDLYR = (dev->qcd << 8) | dev->dtl;
+
+        bits = (QMR >> 10) % 0x10;
+        if (bits == 0 || bits > 0x08)
+                word = 1;       /* 9 to 16 bit transfers */
+
+	//qcr_cs = (~MINOR(filep->f_dentry->d_inode->i_rdev) << 8) & 0xf00;  /* CS for QCR */
+ 	qcr_cs = 0xf00 & ~(1 << (8 + MINOR(filep->f_dentry->d_inode->i_rdev))); 
+	
+	/* next line was memcpy_fromfs()  */
+        copy_from_user (dbuf, buffer, length);
+
+//      printk("data to write is %x  %x  %x  %X  \n",dbuf[0],dbuf[1],dbuf[2],dbuf[3]);
+
+        if (dev->odd_mod)
+                z = QCR_SETUP8;
+        else
+                z = QCR_SETUP;
+
+        if (dev->dsp_mod)
+                max_trans = 15;
+        else
+                max_trans = 16;
+
+        while (i < length) {
+                int x;
+                int n;
+
+                QAR = TX_RAM_START;             /* address: first QTR */
+                if (word) {
+                        for (n = 0; n < max_trans; ) {
+                                /* in odd mode last byte will be transfered in byte mode */
+                                if (dev->odd_mod && (i + 1 == length)) {
+                                        QDR = dbuf[i];  /* tx data: QDR write */
+                                        // printk("0x%X ", dbuf[i]);
+                                        n++;
+                                        i++;
+                                        break;
+                                }
+                                else {
+                                        QDR = (dbuf[i] << 8) + dbuf[i+1]; /* tx data: QDR write */
+                                        //printk("0x%X 0x%X ", dbuf[i], dbuf[i+1]);
+                                        n++;
+                                        i += 2;
+                                        if (i >= length)
+                                                break;
+                                }
+                        }
+                } else {
+                        /* 8bit transfers */
+                        for (n = 0; n < max_trans; ) {
+                                QDR = dbuf[i];  /* tx data: QTR write */
+                                n++;
+                                i++;
+                                if (i == length)
+                                        break;
+                        }
+                }
+
+                QAR = COMMAND_RAM_START;        /* address: first QCR */
+                for (x = 0; x < n; x++) {
+                        /* QCR write */
+                        if (dev->qcr_cont) {
+                                if (x == n-1 && i == length)
+                                        if ((i % 2)!= 0)
+                                                QDR = z | qcr_cs; /* last transfer and odd number of chars */
+                                        else
+                                                QDR = QCR_SETUP | qcr_cs;       /* last transfer */
+                                else
+                                        QDR = QCR_CONT | QCR_SETUP | qcr_cs;
+                        } else {
+                                if (x == n - 1 && i == length)
+                                        QDR = z | qcr_cs; /* last transfer */
+                                else
+                                        QDR = QCR_SETUP | qcr_cs;
+                        }
+                }
+
+                QWR = QWR_CSIV | ((n - 1) << 8);  /* QWR[ENDQP] = n << 8 */
+
+                /* check if we are using polling mode. Polling increases
+                 * performance for samll data transfers but is dangerous
+                 * if we stay too long here, locking other tasks!!
+                 */
+                if (dev->poll_mod) {
+                        QIR = QIR_SETUP_POLL;
+                        QDLYR |= QDLYR_SPE;
+
+                        while ((QIR & QIR_SPIF) != QIR_SPIF)
+                                ;
+                        QIR = QIR | QIR_SPIF;
+                } else {
+                        QIR = QIR_SETUP;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			save_flags(flag); cli();                // added according to gerg@snapgear.com
+#else
+			local_irq_save(flag);
+#endif
+			QDLYR |= QDLYR_SPE;
+
+//                      interruptible_sleep_on(&wqueue);
+                        sleep_on(&wqueue);                      // changed richard@opentcp.org
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)			
+                        restore_flags(flag);                    // added according to gerg@snapgear.com
+#else
+			local_irq_restore(flag);
+#endif		
+		}
+
+
+                if (word)
+                        n <<= 1;
+
+                total += n;
+        }
+
+        up(&sem);
+        return(total);
+}
+
+
+/*  fixed for 2.4 kernel, owner was ifdef'ed out for 2.0 kernel */
+static struct file_operations Fops = {
+        owner:          THIS_MODULE,
+        read:           qspi_read,
+        write:          qspi_write,
+        ioctl:          qspi_ioctl,
+        open:           qspi_open,
+        release:        qspi_release  /* a.k.a. close */
+};
+
+
+static int init(void)
+{
+        volatile u32 *lp;
+        volatile u8 *cp;
+
+        /* common init: driver or module: */
+
+        if (request_irq(MCFQSPI_IRQ_VECTOR, qspi_interrupt, SA_INTERRUPT, "ColdFire QSPI", NULL)) {
+                printk("QSPI: Unable to attach ColdFire QSPI interrupt "
+                        "vector=%d\n", MCFQSPI_IRQ_VECTOR);
+                return(-EINVAL);
+        }
+
+#if defined(CONFIG_M5249)
+        cp = (volatile u8 *)(MCF_MBAR + MCFSIM_ICR10);
+        *cp = 0x8f;             /* autovector on, il=3, ip=3 */
+
+        lp = (volatile u32 *)(MCF_MBAR2 + 0x180);
+        *lp |= 0x00000800;      /* activate qspi_in and qspi_clk */
+
+        lp = (volatile u32 *)(MCF_MBAR2 + MCFSIM2_GPIOFUNC);
+        *lp &= 0xdc9FFFFF;      /* activate qspi_cs0 .. 3, qspi_dout */
+
+        lp = (volatile u32 *)(MCF_MBAR + MCFSIM_IMR);
+        *lp &= 0xFFFbFFFF;      /* enable qspi interrupt */
+#elif defined(CONFIG_M5235)
+	// interrupts mask here
+	{
+	 volatile unsigned char  *icrp;
+	 icrp = (volatile unsigned char *)(MCF_MBAR + MCF5235ICM_INTC0 + MCFINTC0_ICR);
+	 icrp[IRQ_SOURCE] = (( 3/*IL*/ & 0x3 ) << 3 ) | (3 /*IP*/ & 0x3);
+	}
+	{
+	 volatile unsigned int *imrl;
+	 imrl = (volatile unsigned int *)(MCF_MBAR + MCF5235ICM_INTC0 + MCF5235INTC_IMRL);
+	 *imrl &= ~(1 << IRQ_SOURCE);
+	}
+	// GPIO here
+	{
+		volatile unsigned char *parp;
+		parp = (volatile unsigned char *)(MCF_MBAR + 0x10004A);
+		*parp = 0xFF;
+	}
+#elif (defined(CONFIG_M5282) || defined(CONFIG_M5280))
+        cp = (volatile u8 *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_ICR0 +
+                              MCFINT_QSPI);
+        *cp = (5 << 3) + 3;     /* level 5, priority 3 */
+
+        cp = (volatile u8 *) (MCF_IPSBAR + MCF5282_GPIO_PQSPAR);
+        *cp = 0x7f;             /* activate din, dout, clk and cs[0..3] */
+
+        lp = (volatile u32 *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRL);
+        *lp &= ~(1 + (1 << MCFINT_QSPI));      /* enable qspi interrupt */
+#else
+        /* set our IPL */
+        lp = (volatile u32 *)(MCF_MBAR + MCFSIM_ICR4);
+        *lp = (*lp & 0x07777777) | 0xd0000000;
+
+        /* 1) CS pin setup 17.2.x
+         *      Dout, clk, cs0 always enabled. Din, cs[3:1] must be enabled.
+         *      CS1: PACNT[23:22] = 10
+         *      CS1: PBCNT[23:22] = 10 ?
+         *      CS2: PDCNT[05:04] = 11
+         *      CS3: PACNT[15:14] = 01
+         */
+        lp = (volatile u32 *)(MCF_MBAR + MCFSIM_PACNT);
+        *lp = (*lp & 0xFF3F3FFF) | 0x00804000;  /* 17.2.1 QSPI CS1 & CS3 */
+        lp = (volatile u32 *)(MCF_MBAR + MCFSIM_PDCNT);
+        *lp = (*lp & 0xFFFFFFCF) | 0x00000030;  /* QSPI_CS2 */
+#endif
+
+        /*
+         * These values have to be setup according to the applications
+         * using the qspi driver. Maybe some #defines at the beginning
+         * would be more appropriate. Especially the transfer size
+         * and speed settings
+         */
+        QMR = 0xA1A2; // default mode setup: 8 bits, baud, 160kHz clk.
+//      QMR = 0x81A2; // default mode setup: 16 bits, baud, 160kHz clk.
+        QDLYR = 0x0202; // default start & end delays
+
+        init_waitqueue_head(&wqueue);    /* was init_waitqueue() --Ron */
+
+#if defined(CONFIG_M5249)
+        printk("MCF5249 QSPI driver ok\n");
+#elif defined(CONFIG_M5235)
+	printk("MCF5235 QSPI driver ok\n");
+#elif (defined(CONFIG_M5282) || defined(CONFIG_M5280))
+        printk("MCF5282 QSPI driver ok\n");
+#else
+        printk("MCF5272 QSPI driver ok\n");
+#endif
+
+        return(0);
+}
+
+/* init for compiled-in driver: call from mem.c */
+int __init qspi_init(void)                                  /* the __init added by ron  */
+{
+        int ret;
+
+        if ((ret = register_chrdev(QSPI_MAJOR, DEVICE_NAME, &Fops) < 0)) {
+
+                printk ("%s device failed with %d\n",
+                        "Sorry, registering the character", ret);
+                return(ret);
+        }
+
+        printk ("QSPI device driver installed OK\n");
+        return(init());
+}
+
+/* Cleanup - undid whatever init_module did */
+void __exit qspi_exit(void)      /* the __exit added by ron  */
+{
+        int ret;
+
+        free_irq(MCFQSPI_IRQ_VECTOR, NULL);
+
+#if defined(CONFIG_M5249)
+        /* autovector on, il=0, ip=0 */
+        *(volatile u8 *)(MCF_MBAR + MCFSIM_ICR10) = 0x80;
+        /* disable qspi interrupt */
+        *(volatile u32 *)(MCF_MBAR + MCFSIM_IMR) |= 0x00040000;
+#elif defined(CONFIG_M5235)
+	{
+	 volatile unsigned char  *icrp;
+	 icrp = (volatile unsigned char *)(MCF_MBAR + MCF5235ICM_INTC0 + MCFINTC0_ICR);
+	 icrp[IRQ_SOURCE] = 0;
+	}
+	// GPIO here
+	{
+		volatile unsigned char *parp;
+		parp = (volatile unsigned char *)(MCF_MBAR + 0x10004A);
+		*parp = 0x00;
+	}
+#elif (defined(CONFIG_M5282) || defined(CONFIG_M5280))
+        /* interrupt level 0, priority 0 */
+        *(volatile u8 *) (MCF_IPSBAR + MCFICM_INTC0 +
+                          MCFINTC_ICR0 + MCFINT_QSPI) = 0;
+        /* disable qspi interrupt */
+        *(volatile u32 *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRL)
+                                                        |= (1 << MCFINT_QSPI);
+#else
+        /* zero our IPL */
+        *((volatile u32 *)(MCF_MBAR + MCFSIM_ICR4)) = 0x80000000;
+#endif
+
+        /* Unregister the device */
+	if ((ret = unregister_chrdev(QSPI_MAJOR, DEVICE_NAME)) < 0)
+
+                printk("Error in unregister_chrdev: %d\n", ret);
+}
+
+
+module_init(qspi_init);      /* added by ron so driver can compile directly into kernel */
+module_exit(qspi_exit);      /* added by ron so driver can compile directly into kernel */
+
+MODULE_LICENSE("GPL");
+
diff -Naur linux-2.6.14/drivers/char/mcf_qspi.h linux-2.6.14-uc0/drivers/char/mcf_qspi.h
--- linux-2.6.14/drivers/char/mcf_qspi.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.14-uc0/drivers/char/mcf_qspi.h	2005-10-31 15:42:12.000000000 +1000
@@ -0,0 +1,94 @@
+#if !defined(MCF_QSPI_H)
+#define MCF_QSPI_H
+
+#include <asm/mcfqspi.h>
+#include <linux/types.h>
+
+
+#define QSPI_MAJOR              126
+#if defined(CONFIG_M5249)
+#define MCFQSPI_IRQ_VECTOR      27
+#define QSPIMOD_OFFSET          0x400
+#elif defined(CONFIG_M5235)
+#define MCF5235ICM_INTC0	0xC00
+#define MCFINTC0_ICR		0x40
+#define MCFQSPI_IRQ_VECTOR  82
+#define QSPIMOD_OFFSET      0x340
+#define IRQ_SOURCE			18
+#define MCF5235INTC_IMRL	0x0C
+#elif (defined(CONFIG_M5282) || defined(CONFIG_M5280))
+#define MCFQSPI_IRQ_VECTOR      (64 + 18)
+#define QSPIMOD_OFFSET          0x340
+#else
+#define MCFQSPI_IRQ_VECTOR      89
+#define QSPIMOD_OFFSET          0xa0
+#endif
+
+
+/* QSPI registers */
+#define MCFSIM_QMR              (0x00 + QSPIMOD_OFFSET) /* mode */
+#define MCFSIM_QDLYR            (0x04 + QSPIMOD_OFFSET) /* delay */
+#define MCFSIM_QWR              (0x08 + QSPIMOD_OFFSET) /* wrap */
+#define MCFSIM_QIR              (0x0c + QSPIMOD_OFFSET) /* interrupt */
+#define MCFSIM_QAR              (0x10 + QSPIMOD_OFFSET) /* address */
+#define MCFSIM_QDR              (0x14 + QSPIMOD_OFFSET) /* address */
+
+#define TX_RAM_START            0x00
+#define RX_RAM_START            0x10
+#define COMMAND_RAM_START       0x20
+
+#define QMR                     *(volatile u16 *)(MCF_MBAR + MCFSIM_QMR)
+#define QAR                     *(volatile u16 *)(MCF_MBAR + MCFSIM_QAR)
+#define QDR                     *(volatile u16 *)(MCF_MBAR + MCFSIM_QDR)
+#define QWR                     *(volatile u16 *)(MCF_MBAR + MCFSIM_QWR)
+#define QDLYR                   *(volatile u16 *)(MCF_MBAR + MCFSIM_QDLYR)
+#define QIR                     *(volatile u16 *)(MCF_MBAR + MCFSIM_QIR)
+
+
+/* bits */
+#define QMR_MSTR                0x8000  /* master mode enable: must always be set */
+#define QMR_DOHIE               0x4000  /* shut off (hi-z) Dout between transfers */
+#define QMR_BITS                0x3c00  /* bits per transfer (size) */
+#define QMR_CPOL                0x0200  /* clock state when inactive */
+#define QMR_CPHA                0x0100  /* clock phase: 1 = data taken at rising edge */
+#define QMR_BAUD                0x00ff  /* clock rate divider */
+
+#define QIR_WCEF                0x0008  /* write collison */
+#define QIR_ABRT                0x0004  /* abort */
+#define QIR_SPIF                0x0001  /* finished */
+#define QIR_SETUP               0xdd0f  /* setup QIR for tranfer start */
+#define QIR_SETUP_POLL          0xdc0d  /* setup QIR for tranfer start */
+
+#define QWR_CSIV                0x1000  /* 1 = active low chip selects */
+
+#define QDLYR_SPE               0x8000  /* initiates transfer when set */
+#define QDLYR_QCD               0x7f00  /* start delay between CS and first clock */
+#define QDLYR_DTL               0x00ff  /* delay after CS release */
+
+/* QCR: chip selects return to inactive, bits set in QMR[BITS],
+ * after delay set in QDLYR[DTL], pre-delay set in QDLYR[QCD] */
+#define QCR_SETUP               0x7000
+#define QCR_CONT                0x8000  /* 1=continuous CS after transfer */
+#define QCR_SETUP8              0x3000  /* sets BITSE to 0 => eigth bits per transfer */
+
+
+typedef struct qspi_dev {
+        qspi_read_data read_data;
+        u8 bits;                        /* transfer size, number of bits to transfer for each entry */
+        u8 baud;                        /* baud rate */
+        u8 qcd;                         /* QSPILCK delay */
+        u8 dtl;                         /* delay after transfer */
+        unsigned int qcr_cont   : 1;    /* keep CS active throughout transfer */
+        unsigned int odd_mod    : 1;    /* if length of buffer is a odd number, 16-bit transfers
+                                           are finalized with a 8-bit transfer */
+        unsigned int dsp_mod    : 1;    /* transfers are bounded to 15/30 bytes
+                                           (= a multiple of 3 bytes = 1 word) */
+        unsigned int poll_mod   : 1;    /* mode polling or interrupt */
+        unsigned int cpol       : 1;    /* SPI clock polarity */
+        unsigned int cpha       : 1;    /* SPI clock phase */
+        unsigned int dohie      : 1;    /* data output high impedance enable */
+} qspi_dev;
+
+
+#endif  /* MCF_QSPI_H */
+
diff -Naur linux-2.6.14/drivers/mtd/chips/cfi_cmdset_0001.c linux-2.6.14-uc0/drivers/mtd/chips/cfi_cmdset_0001.c
--- linux-2.6.14/drivers/mtd/chips/cfi_cmdset_0001.c	2005-10-31 15:39:45.000000000 +1000
+++ linux-2.6.14-uc0/drivers/mtd/chips/cfi_cmdset_0001.c	2005-10-31 15:41:57.000000000 +1000
@@ -562,6 +562,15 @@
 		map->fldrv_priv = newcfi;
 		*pcfi = newcfi;
 		kfree(cfi);
+	} else {
+		struct flchip *chip;
+		int i;
+		for (i = 0; i < cfi->numchips; i++) {
+			chip = &cfi->chips[i];
+			init_waitqueue_head(&chip->wq);
+			spin_lock_init(&chip->_spinlock);
+			chip->mutex = &chip->_spinlock;
+		}
 	}
 
 	return 0;
diff -Naur linux-2.6.14/drivers/mtd/chips/cfi_cmdset_0002.c linux-2.6.14-uc0/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-2.6.14/drivers/mtd/chips/cfi_cmdset_0002.c	2005-10-31 15:39:45.000000000 +1000
+++ linux-2.6.14-uc0/drivers/mtd/chips/cfi_cmdset_0002.c	2005-10-31 15:41:57.000000000 +1000
@@ -297,6 +297,13 @@
 			cfi->addr_unlock1 = 0xaaa;
 			cfi->addr_unlock2 = 0x555;
 		}
+		if (cfi->device_type == CFI_DEVICETYPE_X32) {
+			if (map->bankwidth == cfi->interleave)
+				cfi->addr_unlock1 = 0x1555;
+			else
+				cfi->addr_unlock1 = 0x1554;
+			cfi->addr_unlock2 = 0xaaa;
+		}
 
 	} /* CFI mode */
 	else if (cfi->cfi_mode == CFI_MODE_JEDEC) {
diff -Naur linux-2.6.14/drivers/mtd/chips/cfi_probe.c linux-2.6.14-uc0/drivers/mtd/chips/cfi_probe.c
--- linux-2.6.14/drivers/mtd/chips/cfi_probe.c	2005-10-31 15:39:45.000000000 +1000
+++ linux-2.6.14-uc0/drivers/mtd/chips/cfi_probe.c	2005-10-31 15:41:57.000000000 +1000
@@ -388,6 +388,7 @@
 		break;
 		
 	case 4:
+	case 5:
 		printk("  - supports x16 and x32 via Word# with asynchronous interface\n");
 		break;
 		
diff -Naur linux-2.6.14/drivers/mtd/inftlmount.c linux-2.6.14-uc0/drivers/mtd/inftlmount.c
--- linux-2.6.14/drivers/mtd/inftlmount.c	2005-10-31 15:39:45.000000000 +1000
+++ linux-2.6.14-uc0/drivers/mtd/inftlmount.c	2005-10-31 15:41:57.000000000 +1000
@@ -574,6 +574,12 @@
 
 	/* Temporary buffer to store ANAC numbers. */
 	ANACtable = kmalloc(s->nb_blocks * sizeof(u8), GFP_KERNEL);
+	if (!ANACtable) {
+		printk(KERN_WARNING "INFTL: allocation of ANACtable "
+				"failed (%zd bytes)\n",
+				s->nb_blocks * sizeof(u8));
+		return -ENOMEM;
+	}
 	memset(ANACtable, 0, s->nb_blocks);
 
 	/*
diff -Naur linux-2.6.14/drivers/mtd/maps/cobra5272.c linux-2.6.14-uc0/drivers/mtd/maps/cobra5272.c
--- linux-2.6.14/drivers/mtd/maps/cobra5272.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.14-uc0/drivers/mtd/maps/cobra5272.c	2005-10-31 15:41:57.000000000 +1000
@@ -0,0 +1,153 @@
+/*
+ *  Copyright  Boris Koprinarov <crumpz@gmail.com>
+ *
+ *  cobra5272.c ,v 1.14 2005/08/31 13:24:14 
+ *  
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define FLASH_PHYS_ADDR 0xffe00000
+#define FLASH_SIZE 0x200000
+
+#define FLASH_PARTITION0_ADDR 0x1000000
+#define FLASH_PARTITION0_SIZE 0x1000000
+
+struct map_info flagadm_map = {
+		.name =		"Flash chip on COBRA5272",
+		.size =		FLASH_SIZE,
+		.bankwidth =	2,
+};
+
+struct mtd_partition flagadm_parts[] = {
+	{
+		.name =		"boot (16K)",
+		.offset	=	0x0,
+		.size =		0x4000
+
+	},
+	{
+		.name =		"kernel (512K)",
+		.offset =	0x80000,
+		.size =		0x80000
+	},
+        {
+                .name =         "rootfs (1024K)",
+                .offset =       0x100000,
+                .size =         0x100000
+        },
+        {
+                .name =         "spare (8K)",
+                .offset =       0x4000,
+                .size =         0x2000
+        },
+        {
+                .name =         "spare (8K)",
+                .offset =       0x6000,
+                .size =         0x2000
+        },
+        {
+                .name =         "spare (256K)",
+                .offset =       0x40000,
+                .size =         0x40000
+        },
+        {
+                .name =         "complete (2048K)",
+                .offset =       0x0,
+                .size =         0x200000
+        },
+	{
+                .name =         "boot J13 (256K)",
+                .offset =       0x100000,
+                .size =         0x40000
+        },
+	{
+		.name =		"kernel J13 (512K)",
+		.offset =	0x140000,
+		.size =		0x80000
+	},
+	{	
+		.name =		"rootfs J13 (256K)",
+		.offset =	0x1c0000,
+		.size =		0x40000
+	}
+
+};
+
+#define PARTITION_COUNT (sizeof(flagadm_parts)/sizeof(struct mtd_partition))
+
+static struct mtd_info *mymtd;
+
+int __init init_flagadm(void)
+{	
+	printk(KERN_NOTICE "COBRA5272 flash device: %x at %x\n",
+			FLASH_SIZE, FLASH_PHYS_ADDR);
+	
+	flagadm_map.phys = FLASH_PHYS_ADDR;
+	flagadm_map.virt = ioremap(FLASH_PHYS_ADDR,
+					FLASH_SIZE);
+
+	if (!flagadm_map.virt) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	simple_map_init(&flagadm_map);
+
+	mymtd = do_map_probe("cfi_probe", &flagadm_map);
+	if (mymtd) {
+		mymtd->owner = THIS_MODULE;
+		add_mtd_partitions(mymtd, flagadm_parts, PARTITION_COUNT);
+		printk(KERN_NOTICE "COBRA5272 flash device initialized\n");
+		return 0;
+	}
+
+	iounmap((void *)flagadm_map.virt);
+	return -ENXIO;
+}
+
+static void __exit cleanup_flagadm(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (flagadm_map.virt) {
+		iounmap((void *)flagadm_map.virt);
+		flagadm_map.virt = 0;
+	}
+}
+
+module_init(init_flagadm);
+module_exit(cleanup_flagadm);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Boris Koprinarov <crumpz@gmail.com>");
+MODULE_DESCRIPTION("MTD map driver for COBRA5272 board");
diff -Naur linux-2.6.14/drivers/mtd/maps/cobra5282.c linux-2.6.14-uc0/drivers/mtd/maps/cobra5282.c
--- linux-2.6.14/drivers/mtd/maps/cobra5282.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.14-uc0/drivers/mtd/maps/cobra5282.c	2005-10-31 15:41:57.000000000 +1000
@@ -0,0 +1,138 @@
+/*
+ *  Copyright  Boris Koprinarov <crumpz@gmail.com>
+ *
+ *  cobra5282.c, v 1.14 2005/08/31 13:24:14 
+ *  
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define FLASH_PHYS_ADDR 0xffc00000
+#define FLASH_SIZE 0x400000
+
+#define FLASH_PARTITION0_ADDR 0xFFC00000
+#define FLASH_PARTITION0_SIZE 0x400000
+
+struct map_info flagadm_map = {
+		.name =		"Flash chip on COBRA5282",
+		.size =		FLASH_SIZE,
+		.bankwidth =	2,
+};
+
+struct mtd_partition flagadm_parts[] = {
+	{
+		.name =		"boot (256K)",
+		.offset	=	0x0,
+		.size =		0x40000
+
+	},
+	{
+		.name =		"kernel (1408K)",
+		.offset =	0x40000,
+		.size =		0x160000
+	},
+        {
+                .name =         "rootfs (2048K)",
+                .offset =       0x1A0000,
+                .size =         0x200000
+        },
+        {
+                .name =         "spare (32K)",
+                .offset =       0x0,
+                .size =         0x8000
+        },
+        {
+                .name =         "user 1 (384K)",
+                .offset =       0x3A0000,
+                .size =         0x60000
+        },
+	{
+                .name =         "user 2 (2432K)",
+                .offset =       0x1A0000,
+                .size =         0x260000
+        },
+	{
+		.name =		"complete (4096K)",
+		.offset =	0x0,
+		.size =		0x400000
+	}
+
+};
+
+#define PARTITION_COUNT (sizeof(flagadm_parts)/sizeof(struct mtd_partition))
+
+static struct mtd_info *mymtd;
+
+int __init init_flagadm(void)
+{	
+	printk(KERN_NOTICE "COBRA5282 flash device: %x at %x\n",
+			FLASH_SIZE, FLASH_PHYS_ADDR);
+	
+	flagadm_map.phys = FLASH_PHYS_ADDR;
+	flagadm_map.virt = ioremap(FLASH_PHYS_ADDR,
+					FLASH_SIZE);
+
+	if (!flagadm_map.virt) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	simple_map_init(&flagadm_map);
+
+	mymtd = do_map_probe("cfi_probe", &flagadm_map);
+	if (mymtd) {
+		mymtd->owner = THIS_MODULE;
+		add_mtd_partitions(mymtd, flagadm_parts, PARTITION_COUNT);
+		printk(KERN_NOTICE "COBRA5282 flash device initialized\n");
+		return 0;
+	}
+
+	iounmap((void *)flagadm_map.virt);
+	return -ENXIO;
+}
+
+static void __exit cleanup_flagadm(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (flagadm_map.virt) {
+		iounmap((void *)flagadm_map.virt);
+		flagadm_map.virt = 0;
+	}
+}
+
+module_init(init_flagadm);
+module_exit(cleanup_flagadm);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Boris Koprinarov <crumpz@gmail.com>");
+MODULE_DESCRIPTION("MTD map driver for COBRA5282 board");
diff -Naur linux-2.6.14/drivers/mtd/maps/m520x.c linux-2.6.14-uc0/drivers/mtd/maps/m520x.c
--- linux-2.6.14/drivers/mtd/maps/m520x.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.14-uc0/drivers/mtd/maps/m520x.c	2005-10-31 15:41:57.000000000 +1000
@@ -0,0 +1,242 @@
+/*
+ *
+ * Normal mappings of chips in physical memory.
+ *
+ * Copyright (C) 2005,  Freescale Semiconductor (Matt.Waddel@freescale.com)
+ * Copyright (C) 2005,  Intec Automation Inc. (mike@steroidmicros.com)
+ * Copyright (C) 2001-2002, David McCullough <davidm@snapgear.com>
+ *
+ * Based on snapgear-uc.c
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+#include <linux/kdev_t.h>
+#include <linux/ioport.h>
+#include <linux/devfs_fs_kernel.h>
+
+extern dev_t ROOT_DEV;
+
+#define WINDOW_ADDR 0x00000000
+#define WINDOW_SIZE 0x00200000
+#define BANKWIDTH 2
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *ram_mtdinfo;
+static struct map_info m520x_ram_map = {
+	.name		= "RAM",
+};
+static struct mtd_partition m520x_romfs[] = {
+	{
+		.name	= "Romfs"
+	}
+};
+
+static struct mtd_info *flash_mtdinfo;
+struct map_info m520x_flash_map = {
+	.name		= "Am29BDD160G 2.5v flash device (2MB)",
+	.size		= WINDOW_SIZE,
+	.bankwidth	= BANKWIDTH
+};
+static struct mtd_partition m520x_partitions[] = {
+        {
+                .name	= "dBUG (256K)",
+                .size	= 0x40000,
+                .offset	= 0x00000
+        },
+        {
+                .name	= "User FS (1792K)",
+                .size	= 0x1C0000,
+                .offset	= 0x40000
+        }
+};
+
+/****************************************************************************
+ *
+ * Find the MTD device with the given name
+ *
+ ****************************************************************************/
+
+static struct mtd_info 
+*get_mtd_named(char *name)
+{
+	int i;
+	struct mtd_info *mtd;
+
+	for (i = 0; i < MAX_MTD_DEVICES; i++) {
+		mtd = get_mtd_device(NULL, i);
+
+		if (mtd) {
+			if (strcmp(mtd->name, name) == 0)
+				return(mtd);
+			put_mtd_device(mtd);
+		}
+	}
+	return(NULL);
+}
+
+
+static int
+m520x_point(struct mtd_info *mtd, loff_t from, size_t len,
+            size_t *retlen, u_char **mtdbuf)
+{
+	struct map_info *map = (struct map_info *) mtd->priv;
+	*mtdbuf = (u_char *) (map->map_priv_1 + (int)from);
+	*retlen = len;
+	return(0);
+}
+
+
+static int __init
+m520x_probe(int type, unsigned long addr, int size, int bankwidth)
+{
+	static struct mtd_info *mymtd;
+	struct map_info *map_ptr;
+
+	if (type)
+		map_ptr = &m520x_ram_map;
+	else
+		map_ptr = &m520x_flash_map;
+
+	map_ptr->bankwidth = bankwidth;
+	map_ptr->map_priv_2 = addr;
+	map_ptr->phys = addr;
+	map_ptr->size = size;
+
+	printk(KERN_NOTICE "m520xevb %s probe(0x%lx,%x,%x): %lx at %lx\n",
+			   type ? "ram":"flash", addr, size, bankwidth, 
+			   map_ptr->size, map_ptr->map_priv_2);
+
+	map_ptr->virt = (unsigned long)
+			ioremap_nocache(map_ptr->map_priv_2, map_ptr->size);
+
+	simple_map_init(map_ptr);
+	if (type)
+		mymtd = do_map_probe("map_ram", map_ptr);
+	else
+		mymtd = do_map_probe("cfi_probe", map_ptr);
+
+	if (!mymtd) {
+		iounmap((void *)map_ptr->map_priv_1);
+		return -ENXIO;
+	}
+
+	mymtd->owner  = THIS_MODULE;
+	mymtd->point  = m520x_point;
+	mymtd->priv   = map_ptr;
+
+	if (type) {
+		ram_mtdinfo = mymtd;
+		add_mtd_partitions(mymtd, m520x_romfs, NB_OF(m520x_romfs));
+	} else {
+		flash_mtdinfo = mymtd;
+		add_mtd_partitions(mymtd, m520x_partitions, 
+			sizeof(m520x_partitions) / sizeof(struct mtd_partition));
+	}
+	return(0);
+}
+
+
+/*
+ * Initialize the mtd devices
+ */
+
+int __init init_m520x(void)
+{
+	int rc = -1;
+	struct mtd_info *mtd;
+	extern char _ebss;
+
+	rc = m520x_probe( 0, WINDOW_ADDR, WINDOW_SIZE, BANKWIDTH);
+
+	/* Map in the filesystem from RAM last so that, if the filesystem
+	 * is not in RAM for some reason we do not change the minor/major
+	 * for the flash devices
+	 */
+#ifndef CONFIG_ROMFS_FROM_ROM
+	if (0 != m520x_probe( 1, (unsigned long)&_ebss,
+			      PAGE_ALIGN(*(unsigned long *)(&_ebss + 8)), 4))
+		printk("Failed to probe RAM filesystem\n");
+#else
+	{
+		unsigned long start_area;
+		unsigned char *sp, *ep;
+		size_t len;
+
+		start_area = (unsigned long) &_ebss;
+
+		/* If romfs is in flash use it to boot */
+		if (strncmp((char *) start_area, "-rom1fs-", 8) != 0) {
+			mtd = get_mtd_named("Image");
+			if (mtd && mtd->point) {
+				if ((*mtd->point)(mtd, 0, mtd->size, &len, &sp) == 0){
+					ep = sp + len;
+					while (sp < ep && strncmp(sp,"-rom1fs-",8) != 0)
+						sp++;
+					if (sp < ep)
+						start_area = (unsigned long) sp;
+				}
+			}
+			if (mtd)
+				put_mtd_device(mtd);
+		}
+		if (0 != m520x_probe(1, start_area, 
+				     PAGE_ALIGN(*(unsigned long *)(start_area + 8)), 4))
+			printk("Failed to probe RAM filesystem\n");
+	}
+#endif
+
+	mtd = get_mtd_named("Romfs");
+	if (mtd) {
+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+		put_mtd_device(mtd);
+	} else
+		printk("%s: Failed to make root filesystem\n", __FUNCTION__);
+
+	mtd = get_mtd_named("User FS (1792K)");
+	if (mtd) {
+		blk_register_region(MKDEV(MTD_BLOCK_MAJOR, mtd->index), MAX_MTD_DEVICES,
+				THIS_MODULE, m520x_probe, NULL, NULL);
+		put_mtd_device(mtd);
+	} else
+		printk("%s: Failed to flash filesystem\n", __FUNCTION__);
+
+	return(rc);
+}
+
+static void __exit cleanup_m520x(void)
+{
+	if (flash_mtdinfo) {
+		del_mtd_partitions(flash_mtdinfo);
+		map_destroy(flash_mtdinfo);
+		flash_mtdinfo = NULL;
+	}
+	if (ram_mtdinfo) {
+		del_mtd_partitions(ram_mtdinfo);
+		map_destroy(ram_mtdinfo);
+		ram_mtdinfo = NULL;
+	}
+	if (m520x_ram_map.map_priv_1) {
+		iounmap((void *)m520x_ram_map.map_priv_1);
+		m520x_ram_map.map_priv_1 = 0;
+	}
+	if (m520x_flash_map.map_priv_1) {
+		iounmap((void *)m520x_flash_map.map_priv_1);
+		m520x_flash_map.map_priv_1 = 0;
+	}
+
+}
+
+module_init(init_m520x);
+module_exit(cleanup_m520x);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("<Matt.Waddel@freescale.com>");
+MODULE_DESCRIPTION("MTD map for M520xEVB");
diff -Naur linux-2.6.14/drivers/mtd/maps/physmap.c linux-2.6.14-uc0/drivers/mtd/maps/physmap.c
--- linux-2.6.14/drivers/mtd/maps/physmap.c	2005-10-31 15:39:45.000000000 +1000
+++ linux-2.6.14-uc0/drivers/mtd/maps/physmap.c	2005-10-31 15:41:57.000000000 +1000
@@ -53,10 +53,13 @@
        	printk(KERN_NOTICE "physmap flash device: %lx at %lx\n", physmap_map.size, physmap_map.phys);
 	physmap_map.virt = ioremap(physmap_map.phys, physmap_map.size);
 
+#ifndef CONFIG_MTD_M5208
+	/* The M5208EVB has flash mapped at 0. */
 	if (!physmap_map.virt) {
 		printk("Failed to ioremap\n");
 		return -EIO;
 	}
+#endif
 
 	simple_map_init(&physmap_map);
 
diff -Naur linux-2.6.14/drivers/mtd/maps/uclinux.c linux-2.6.14-uc0/drivers/mtd/maps/uclinux.c
--- linux-2.6.14/drivers/mtd/maps/uclinux.c	2005-10-31 15:39:45.000000000 +1000
+++ linux-2.6.14-uc0/drivers/mtd/maps/uclinux.c	2005-10-31 15:41:57.000000000 +1000
@@ -5,7 +5,7 @@
  *
  *	(C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
  *
- * 	$Id: uclinux.c,v 1.10 2005/01/05 18:05:13 dwmw2 Exp $
+ * 	$Id: uclinux.c,v 1.17 2005/10/28 06:25:49 gerg Exp $
  */
 
 /****************************************************************************/
diff -Naur linux-2.6.14/drivers/net/fec.c linux-2.6.14-uc0/drivers/net/fec.c
--- linux-2.6.14/drivers/net/fec.c	2005-10-31 15:39:48.000000000 +1000
+++ linux-2.6.14-uc0/drivers/net/fec.c	2005-10-31 15:42:04.000000000 +1000
@@ -18,8 +18,8 @@
  * Much better multiple PHY support by Magnus Damm.
  * Copyright (c) 2000 Ericsson Radio Systems AB.
  *
- * Support for FEC controller of ColdFire/5270/5271/5272/5274/5275/5280/5282.
- * Copyright (c) 2001-2004 Greg Ungerer (gerg@snapgear.com)
+ * Support for FEC controller of ColdFire processors.
+ * Copyright (c) 2001-2005 Greg Ungerer (gerg@snapgear.com)
  *
  * Bug fixes and cleanup by Philippe De Muyter (phdm@macqel.be)
  * Copyright (c) 2004-2005 Macq Electronique SA.
@@ -50,7 +50,8 @@
 #include <asm/pgtable.h>
 
 #if defined(CONFIG_M523x) || defined(CONFIG_M527x) || \
-    defined(CONFIG_M5272) || defined(CONFIG_M528x)
+    defined(CONFIG_M5272) || defined(CONFIG_M528x) || \
+    defined(CONFIG_M520x)
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
 #include "fec.h"
@@ -77,6 +78,8 @@
 	(MCF_MBAR + 0x1800),
 #elif defined(CONFIG_M523x) || defined(CONFIG_M528x)
 	(MCF_MBAR + 0x1000),
+#elif defined(CONFIG_M520x)
+	(MCF_MBAR+0x30000),
 #else
 	&(((immap_t *)IMAP_ADDR)->im_cpm.cp_fec),
 #endif
@@ -139,6 +142,10 @@
 #define TX_RING_SIZE		16	/* Must be power of two */
 #define TX_RING_MOD_MASK	15	/*   for this to work */
 
+#if (((RX_RING_SIZE + TX_RING_SIZE) * 8) > PAGE_SIZE)
+#error "FEC: descriptor ring size contants too large"
+#endif
+
 /* Interrupt events/masks.
 */
 #define FEC_ENET_HBERR	((uint)0x80000000)	/* Heartbeat error */
@@ -164,7 +171,8 @@
  * size bits. Other FEC hardware does not, so we need to take that into
  * account when setting it.
  */
-#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x)
+#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+    defined(CONFIG_M520x)
 #define	OPT_FRAME_SIZE	(PKT_MAXBUF_SIZE << 16)
 #else
 #define	OPT_FRAME_SIZE	0
@@ -1137,6 +1145,65 @@
 };
 
 /* ------------------------------------------------------------------------- */
+/* register definitions for the DP83848 */
+
+#define MII_DP8384X_PHYSTST    16  /* PHY Status Register */
+
+static void mii_parse_dp8384x_sr2(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK | PHY_STAT_LINK | PHY_STAT_ANC);
+
+	/* Link up */
+	if (mii_reg & 0x0001) {
+		fep->link = 1;
+		*s |= PHY_STAT_LINK;
+	} else
+		fep->link = 0;
+	/* Status of link */
+	if (mii_reg & 0x0010)   /* Autonegotioation complete */
+		*s |= PHY_STAT_ANC;
+	if (mii_reg & 0x0002) {   /* 10MBps? */
+		if (mii_reg & 0x0004)   /* Full Duplex? */
+			*s |= PHY_STAT_10FDX;
+		else
+			*s |= PHY_STAT_10HDX;
+	} else {                  /* 100 Mbps? */
+		if (mii_reg & 0x0004)   /* Full Duplex? */
+			*s |= PHY_STAT_100FDX;
+		else
+			*s |= PHY_STAT_100HDX;
+	}
+	if (mii_reg & 0x0008)
+		*s |= PHY_STAT_FAULT;
+}
+
+static phy_info_t phy_info_dp83848= {
+	0x020005c9,
+	"DP83848",
+
+	(const phy_cmd_t []) {  /* config */
+		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
+		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
+		{ mk_mii_read(MII_DP8384X_PHYSTST), mii_parse_dp8384x_sr2 },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {  /* startup - enable interrupts */
+		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
+		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* ack_int - never happens, no interrupt */
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {  /* shutdown */
+		{ mk_mii_end, }
+	},
+};
+
+/* ------------------------------------------------------------------------- */
 
 static phy_info_t const * const phy_info[] = {
 	&phy_info_lxt970,
@@ -1144,6 +1211,7 @@
 	&phy_info_qs6612,
 	&phy_info_am79c874,
 	&phy_info_ks8721bl,
+	&phy_info_dp83848,
 	NULL
 };
 
@@ -1422,6 +1490,134 @@
 
 /* ------------------------------------------------------------------------- */
 
+#elif defined(CONFIG_M520x)
+
+/*
+ *	Code specific to Coldfire 520x
+ */
+static void __inline__ fec_request_intrs(struct net_device *dev)
+{
+	struct fec_enet_private *fep;
+	int b;
+	static const struct idesc {
+		char *name;
+		unsigned short irq;
+	} *idp, id[] = {
+		{ "fec(TXF)", 23 },
+		{ "fec(TXB)", 24 },
+		{ "fec(TXFIFO)", 25 },
+		{ "fec(TXCR)", 26 },
+		{ "fec(RXF)", 27 },
+		{ "fec(RXB)", 28 },
+		{ "fec(MII)", 29 },
+		{ "fec(LC)", 30 },
+		{ "fec(HBERR)", 31 },
+		{ "fec(GRA)", 32 },
+		{ "fec(EBERR)", 33 },
+		{ "fec(BABT)", 34 },
+		{ "fec(BABR)", 35 },
+		{ NULL },
+	};
+
+	fep = netdev_priv(dev);
+	b = 64 + 13;
+
+	/* Setup interrupt handlers. */
+	for (idp = id; idp->name; idp++) {
+		if (request_irq(b+idp->irq,fec_enet_interrupt,0,idp->name,dev)!=0)
+			printk("FEC: Could not allocate %s IRQ(%d)!\n", idp->name, b+idp->irq);
+	}
+
+	/* Unmask interrupts at ColdFire interrupt controller */
+	{
+		volatile unsigned char  *icrp;
+		volatile unsigned long  *imrp;
+
+		icrp = (volatile unsigned char *) (MCF_IPSBAR + MCFICM_INTC0 +
+			MCFINTC_ICR0);
+		for (b = 36; (b < 49); b++)
+			icrp[b] = 0x04;
+		imrp = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 +
+			MCFINTC_IMRH);
+		*imrp &= ~0x0001FFF0;
+	}
+	*(volatile unsigned char *)(MCF_IPSBAR + MCF_GPIO_PAR_FEC) |= 0xf0;
+	*(volatile unsigned char *)(MCF_IPSBAR + MCF_GPIO_PAR_FECI2C) |= 0x0f;
+}
+
+static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
+{
+	volatile fec_t *fecp;
+
+	fecp = fep->hwp;
+	fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x04;
+	fecp->fec_x_cntrl = 0x00;
+
+	/*
+	 * Set MII speed to 2.5 MHz
+	 * See 5282 manual section 17.5.4.7: MSCR
+	 */
+	fep->phy_speed = ((((MCF_CLK / 2) / (2500000 / 10)) + 5) / 10) * 2;
+	fecp->fec_mii_speed = fep->phy_speed;
+
+	fec_restart(dev, 0);
+}
+
+static void __inline__ fec_get_mac(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+	volatile fec_t *fecp;
+	unsigned char *iap, tmpaddr[ETH_ALEN];
+
+	fecp = fep->hwp;
+
+	if (FEC_FLASHMAC) {
+		/*
+		 * Get MAC address from FLASH.
+		 * If it is all 1's or 0's, use the default.
+		 */
+		iap = FEC_FLASHMAC;
+		if ((iap[0] == 0) && (iap[1] == 0) && (iap[2] == 0) &&
+		   (iap[3] == 0) && (iap[4] == 0) && (iap[5] == 0))
+			iap = fec_mac_default;
+		if ((iap[0] == 0xff) && (iap[1] == 0xff) && (iap[2] == 0xff) &&
+		   (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
+			iap = fec_mac_default;
+	} else {
+		*((unsigned long *) &tmpaddr[0]) = fecp->fec_addr_low;
+		*((unsigned short *) &tmpaddr[4]) = (fecp->fec_addr_high >> 16);
+		iap = &tmpaddr[0];
+	}
+
+	memcpy(dev->dev_addr, iap, ETH_ALEN);
+
+	/* Adjust MAC if using default MAC address */
+	if (iap == fec_mac_default)
+		dev->dev_addr[ETH_ALEN-1] = fec_mac_default[ETH_ALEN-1] + fep->index;
+}
+
+static void __inline__ fec_enable_phy_intr(void)
+{
+}
+
+static void __inline__ fec_disable_phy_intr(void)
+{
+}
+
+static void __inline__ fec_phy_ack_intr(void)
+{
+}
+
+static void __inline__ fec_localhw_setup(void)
+{
+}
+
+static void __inline__ fec_uncache(unsigned long addr)
+{
+}
+
+/* ------------------------------------------------------------------------- */
+
 #else
 
 /*
@@ -1952,6 +2148,14 @@
 	if (index >= FEC_MAX_PORTS)
 		return -ENXIO;
 
+	/* Allocate memory for buffer descriptors.
+	*/
+	mem_addr = __get_free_page(GFP_KERNEL);
+	if (mem_addr == 0) {
+		printk("FEC: allocate descriptor memory failed?\n");
+		return -ENOMEM;
+	}
+
 	/* Create an Ethernet device instance.
 	*/
 	fecp = (volatile fec_t *) fec_hw[index];
@@ -1964,16 +2168,6 @@
 	fecp->fec_ecntrl = 1;
 	udelay(10);
 
-	/* Clear and enable interrupts */
-	fecp->fec_ievent = 0xffc00000;
-	fecp->fec_imask = (FEC_ENET_TXF | FEC_ENET_TXB |
-		FEC_ENET_RXF | FEC_ENET_RXB | FEC_ENET_MII);
-	fecp->fec_hash_table_high = 0;
-	fecp->fec_hash_table_low = 0;
-	fecp->fec_r_buff_size = PKT_MAXBLR_SIZE;
-        fecp->fec_ecntrl = 2;
-        fecp->fec_r_des_active = 0x01000000;
-
 	/* Set the Ethernet address.  If using multiple Enets on the 8xx,
 	 * this needs some work to get unique addresses.
 	 *
@@ -1982,14 +2176,6 @@
 	 */
 	fec_get_mac(dev);
 
-	/* Allocate memory for buffer descriptors.
-	*/
-	if (((RX_RING_SIZE + TX_RING_SIZE) * sizeof(cbd_t)) > PAGE_SIZE) {
-		printk("FEC init error.  Need more space.\n");
-		printk("FEC initialization failed.\n");
-		return 1;
-	}
-	mem_addr = __get_free_page(GFP_KERNEL);
 	cbd_base = (cbd_t *)mem_addr;
 	/* XXX: missing check for allocation failure */
 
@@ -2067,6 +2253,16 @@
 	*/
 	fec_request_intrs(dev);
 
+	/* Clear and enable interrupts */
+	fecp->fec_ievent = 0xffc00000;
+	fecp->fec_imask = (FEC_ENET_TXF | FEC_ENET_TXB |
+		FEC_ENET_RXF | FEC_ENET_RXB | FEC_ENET_MII);
+	fecp->fec_hash_table_high = 0;
+	fecp->fec_hash_table_low = 0;
+	fecp->fec_r_buff_size = PKT_MAXBLR_SIZE;
+	fecp->fec_ecntrl = 2;
+	fecp->fec_r_des_active = 0x01000000;
+
 	dev->base_addr = (unsigned long)fecp;
 
 	/* The FEC Ethernet specific entries in the device structure. */
diff -Naur linux-2.6.14/drivers/net/fec.h linux-2.6.14-uc0/drivers/net/fec.h
--- linux-2.6.14/drivers/net/fec.h	2005-10-31 15:39:47.000000000 +1000
+++ linux-2.6.14-uc0/drivers/net/fec.h	2005-10-31 15:42:04.000000000 +1000
@@ -1,11 +1,10 @@
 /****************************************************************************/
 
 /*
- *	fec.h  --  Fast Ethernet Controller for Motorola ColdFire 5230,
- *		   5231, 5232, 5234, 5235, 5270, 5271, 5272, 5274, 5275,
- *		   5280 and 5282.
+ *	fec.h  --  Fast Ethernet Controller for Motorola ColdFire SoC
+ *		   processors.
  *
- *	(C) Copyright 2000-2003, Greg Ungerer (gerg@snapgear.com)
+ *	(C) Copyright 2000-2005, Greg Ungerer (gerg@snapgear.com)
  *	(C) Copyright 2000-2001, Lineo (www.lineo.com)
  */
 
@@ -14,7 +13,8 @@
 #define	FEC_H
 /****************************************************************************/
 
-#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x)
+#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+    defined(CONFIG_M520x)
 /*
  *	Just figures, Motorola would have to change the offsets for
  *	registers in the same peripheral device on different models
diff -Naur linux-2.6.14/drivers/net/Kconfig linux-2.6.14-uc0/drivers/net/Kconfig
--- linux-2.6.14/drivers/net/Kconfig	2005-10-31 15:39:46.000000000 +1000
+++ linux-2.6.14-uc0/drivers/net/Kconfig	2005-10-31 15:41:58.000000000 +1000
@@ -730,7 +730,7 @@
 
 config NET_VENDOR_SMC
 	bool "Western Digital/SMC cards"
-	depends on NET_ETHERNET && (ISA || MCA || EISA || MAC)
+	depends on NET_ETHERNET && (ISA || MCA || EISA || MAC || EMBEDDED)
 	help
 	  If you have a network (Ethernet) card belonging to this class, say Y
 	  and read the Ethernet-HOWTO, available from
@@ -820,7 +820,7 @@
 
 config SMC9194
 	tristate "SMC 9194 support"
-	depends on NET_VENDOR_SMC && (ISA || MAC && BROKEN)
+	depends on NET_VENDOR_SMC && (ISA || MAC && BROKEN || EMBEDDED)
 	select CRC32
 	---help---
 	  This is support for the SMC9xxx based Ethernet cards. Choose this
@@ -1059,7 +1059,7 @@
 
 config NE2000
 	tristate "NE2000/NE1000 support"
-	depends on NET_ISA || (Q40 && m) || M32R
+	depends on NET_ISA || (Q40 && m) || M32R || EMBEDDED
 	select CRC32
 	---help---
 	  If you have a network (Ethernet) card of this type, say Y and read
@@ -1190,7 +1190,7 @@
 
 config NET_PCI
 	bool "EISA, VLB, PCI and on board controllers"
-	depends on NET_ETHERNET && (ISA || EISA || PCI)
+	depends on NET_ETHERNET && (ISA || EISA || PCI || EMBEDDED)
 	help
 	  This is another class of network cards which attach directly to the
 	  bus. If you have one of those, say Y and read the Ethernet-HOWTO,
@@ -1330,7 +1330,7 @@
 
 config CS89x0
 	tristate "CS89x0 support"
-	depends on (NET_PCI && (ISA || ARCH_IXDP2X01)) || ARCH_PNX0105
+	depends on (NET_PCI && (ISA || ARCH_IXDP2X01 || M68328 || M68EZ328 || M68VZ328 || MACH_DM270)) || ARCH_PNX0105
 	---help---
 	  Support for CS89x0 chipset based Ethernet cards. If you have a
 	  network (Ethernet) card of this type, say Y and read the
@@ -1342,6 +1342,14 @@
 	  <file:Documentation/networking/net-modules.txt>.  The module will be
 	  called cs89x.
 
+config CS89x0_SWAPPED
+	bool "Hardware swapped CS89x0"
+	depends on CS89x0 && !NET_PCI && !ISA
+	---help---
+	  Say Y if your CS89x0 data bus is swapped.
+	  This option is for single board computers using a CS89x0 chip. If you
+	  are using a regular Ethernet card, say N.
+
 config TC35815
 	tristate "TOSHIBA TC35815 Ethernet support"
 	depends on NET_PCI && PCI && TOSHIBA_JMR3927
@@ -1747,7 +1755,7 @@
 
 config FEC
 	bool "FEC ethernet controller (of ColdFire CPUs)"
-	depends on M523x || M527x || M5272 || M528x
+	depends on M523x || M527x || M5272 || M528x || M520x
 	help
 	  Say Y here if you want to use the built-in 10/100 Fast ethernet
 	  controller on some Motorola ColdFire processors.
diff -Naur linux-2.6.14/drivers/serial/mcfserial.c linux-2.6.14-uc0/drivers/serial/mcfserial.c
--- linux-2.6.14/drivers/serial/mcfserial.c	2005-10-31 15:39:44.000000000 +1000
+++ linux-2.6.14-uc0/drivers/serial/mcfserial.c	2005-10-31 15:41:48.000000000 +1000
@@ -57,7 +57,8 @@
  *	keep going.  Perhaps one day the cflag settings for the
  *	console can be used instead.
  */
-#if defined(CONFIG_ARNEWSH) || defined(CONFIG_MOTOROLA) || defined(CONFIG_senTec) || defined(CONFIG_SNEHA)
+#if defined(CONFIG_ARNEWSH) || defined(CONFIG_FREESCALE) || \
+    defined(CONFIG_senTec) || defined(CONFIG_SNEHA)
 #define	CONSOLE_BAUD_RATE	19200
 #define	DEFAULT_CBAUD		B19200
 #endif
@@ -67,7 +68,7 @@
 #define	DEFAULT_CBAUD		B38400
 #endif
 
-#if defined(CONFIG_MOD5272)
+#if defined(CONFIG_MOD5272) || defined(CONFIG_M5208EVB)
 #define CONSOLE_BAUD_RATE 	115200
 #define DEFAULT_CBAUD		B115200
 #endif
@@ -95,7 +96,8 @@
 #undef SERIAL_DEBUG_OPEN
 #undef SERIAL_DEBUG_FLOW
 
-#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x)
+#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+    defined(CONFIG_M520x)
 #define	IRQBASE	(MCFINT_VECBASE+MCFINT_UART0)
 #else
 #define	IRQBASE	73
@@ -1528,6 +1530,35 @@
 	imrp = (volatile unsigned long *) (MCF_MBAR + MCFICM_INTC0 +
 		MCFINTC_IMRL);
 	*imrp &= ~((1 << (info->irq - MCFINT_VECBASE)) | 1);
+#elif defined(CONFIG_M520x)
+	volatile unsigned char *icrp, *uartp;
+	volatile unsigned long *imrp;
+
+	uartp = info->addr;
+
+	icrp = (volatile unsigned char *) (MCF_MBAR + MCFICM_INTC0 +
+		MCFINTC_ICR0 + MCFINT_UART0 + info->line);
+	*icrp = 0x03;
+
+	imrp = (volatile unsigned long *) (MCF_MBAR + MCFICM_INTC0 +
+		MCFINTC_IMRL);
+	*imrp &= ~((1 << (info->irq - MCFINT_VECBASE)) | 1);
+	if (info->line < 2) {
+		unsigned short *uart_par;
+		uart_par = (unsigned short *)(MCF_IPSBAR + MCF_GPIO_PAR_UART);
+		if (info->line == 0)
+			*uart_par |=  MCF_GPIO_PAR_UART_PAR_UTXD0
+				  | MCF_GPIO_PAR_UART_PAR_URXD0;
+		else if (info->line == 1)
+			*uart_par |=  MCF_GPIO_PAR_UART_PAR_UTXD1
+				  | MCF_GPIO_PAR_UART_PAR_URXD1;
+		} else if (info->line == 2) {
+			unsigned char *feci2c_par;
+			feci2c_par = (unsigned char *)(MCF_IPSBAR +  MCF_GPIO_PAR_FECI2C);
+			*feci2c_par &= ~0x0F;
+			*feci2c_par |=  MCF_GPIO_PAR_FECI2C_PAR_SCL_UTXD2
+				    | MCF_GPIO_PAR_FECI2C_PAR_SDA_URXD2;
+		}
 #else
 	volatile unsigned char	*icrp, *uartp;
 
diff -Naur linux-2.6.14/fs/namei.c linux-2.6.14-uc0/fs/namei.c
--- linux-2.6.14/fs/namei.c	2005-10-31 15:39:30.000000000 +1000
+++ linux-2.6.14-uc0/fs/namei.c	2005-10-31 15:41:25.000000000 +1000
@@ -116,12 +116,14 @@
 	int retval;
 	unsigned long len = PATH_MAX;
 
+#ifdef CONFIG_MMU
 	if (!segment_eq(get_fs(), KERNEL_DS)) {
 		if ((unsigned long) filename >= TASK_SIZE)
 			return -EFAULT;
 		if (TASK_SIZE - (unsigned long) filename < PATH_MAX)
 			len = TASK_SIZE - (unsigned long) filename;
 	}
+#endif
 
 	retval = strncpy_from_user(page, filename, len);
 	if (retval > 0) {
diff -Naur linux-2.6.14/fs/romfs/inode.c linux-2.6.14-uc0/fs/romfs/inode.c
--- linux-2.6.14/fs/romfs/inode.c	2005-10-31 15:39:31.000000000 +1000
+++ linux-2.6.14-uc0/fs/romfs/inode.c	2005-10-31 15:41:27.000000000 +1000
@@ -457,6 +457,25 @@
 	return result;
 }
 
+#ifdef CONFIG_MAGIC_ROM_PTR
+static int
+romfs_romptr(struct file * filp, struct vm_area_struct * vma)
+{
+	struct inode * inode = filp->f_dentry->d_inode;
+	struct romfs_inode_info * romfs_inode = ROMFS_I(inode);
+	struct super_block * sb = filp->f_dentry->d_sb;
+
+	vma->vm_pgoff += romfs_inode->i_dataoffset >> PAGE_SHIFT;
+
+	if ((vma->vm_flags & VM_WRITE) || bromptr(sb->s_bdev, vma))
+		return -ENOSYS;
+
+	vma->vm_start += (romfs_inode->i_dataoffset & ~PAGE_MASK);
+
+	return 0;
+}
+#endif
+
 /* Mapping from our types to the kernel */
 
 static struct address_space_operations romfs_aops = {
@@ -468,6 +487,14 @@
 	.readdir	= romfs_readdir,
 };
 
+struct file_operations romfs_file_operations = {
+	read:		generic_file_read,
+	mmap:		generic_file_mmap,
+#ifdef CONFIG_MAGIC_ROM_PTR
+	romptr:		romfs_romptr,
+#endif
+};
+
 static struct inode_operations romfs_dir_inode_operations = {
 	.lookup		= romfs_lookup,
 };
@@ -486,7 +513,6 @@
 
 	ino = i->i_ino & ROMFH_MASK;
 	i->i_mode = 0;
-
 	/* Loop for finding the real hard link */
 	for(;;) {
 		if (romfs_copyfrom(i, &ri, ino, ROMFH_SIZE) <= 0) {
@@ -531,7 +557,7 @@
 			i->i_mode = ino;
 			break;
 		case 2:
-			i->i_fop = &generic_ro_fops;
+			i->i_fop = &romfs_file_operations;
 			i->i_data.a_ops = &romfs_aops;
 			if (nextfh & ROMFH_EXEC)
 				ino |= S_IXUGO;
diff -Naur linux-2.6.14/include/asm-m68knommu/anchor.h linux-2.6.14-uc0/include/asm-m68knommu/anchor.h
--- linux-2.6.14/include/asm-m68knommu/anchor.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/anchor.h	2005-10-31 15:40:56.000000000 +1000
@@ -14,7 +14,7 @@
 /*
  *	Define basic addressing info.
  */
-#if defined(CONFIG_MOTOROLA) && defined(CONFIG_M5407)
+#if defined(CONFIG_M5407C3)
 #define	COMEM_BASE	0xFFFF0000	/* Base of CO-MEM address space */
 #define	COMEM_IRQ	25		/* IRQ of anchor part */
 #else
@@ -96,7 +96,7 @@
  *	The PCI bus will be limited in what slots will actually be used.
  *	Define valid device numbers for different boards.
  */
-#if defined(CONFIG_MOTOROLA) && defined(CONFIG_M5407)
+#if defined(CONFIG_M5407C3)
 #define	COMEM_MINDEV	14		/* Minimum valid DEVICE */
 #define	COMEM_MAXDEV	14		/* Maximum valid DEVICE */
 #define	COMEM_BRIDGEDEV	15		/* Slot bridge is in */
diff -Naur linux-2.6.14/include/asm-m68knommu/asm-offsets.h linux-2.6.14-uc0/include/asm-m68knommu/asm-offsets.h
--- linux-2.6.14/include/asm-m68knommu/asm-offsets.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/asm-offsets.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,49 +0,0 @@
-#ifndef __ASM_OFFSETS_H__
-#define __ASM_OFFSETS_H__
-/*
- * DO NOT MODIFY.
- *
- * This file was generated by arch/m68knommu/Makefile
- *
- */
-
-#define TASK_STATE 0 /* offsetof(struct task_struct, state) */
-#define TASK_FLAGS 12 /* offsetof(struct task_struct, flags) */
-#define TASK_PTRACE 16 /* offsetof(struct task_struct, ptrace) */
-#define TASK_BLOCKED 922 /* offsetof(struct task_struct, blocked) */
-#define TASK_THREAD 772 /* offsetof(struct task_struct, thread) */
-#define TASK_THREAD_INFO 4 /* offsetof(struct task_struct, thread_info) */
-#define TASK_MM 92 /* offsetof(struct task_struct, mm) */
-#define TASK_ACTIVE_MM 96 /* offsetof(struct task_struct, active_mm) */
-#define CPUSTAT_SOFTIRQ_PENDING 0 /* offsetof(irq_cpustat_t, __softirq_pending) */
-#define THREAD_KSP 0 /* offsetof(struct thread_struct, ksp) */
-#define THREAD_USP 4 /* offsetof(struct thread_struct, usp) */
-#define THREAD_SR 8 /* offsetof(struct thread_struct, sr) */
-#define THREAD_FS 10 /* offsetof(struct thread_struct, fs) */
-#define THREAD_CRP 12 /* offsetof(struct thread_struct, crp) */
-#define THREAD_ESP0 20 /* offsetof(struct thread_struct, esp0) */
-#define THREAD_FPREG 24 /* offsetof(struct thread_struct, fp) */
-#define THREAD_FPCNTL 120 /* offsetof(struct thread_struct, fpcntl) */
-#define THREAD_FPSTATE 132 /* offsetof(struct thread_struct, fpstate) */
-#define PT_D0 32 /* offsetof(struct pt_regs, d0) */
-#define PT_ORIG_D0 36 /* offsetof(struct pt_regs, orig_d0) */
-#define PT_D1 0 /* offsetof(struct pt_regs, d1) */
-#define PT_D2 4 /* offsetof(struct pt_regs, d2) */
-#define PT_D3 8 /* offsetof(struct pt_regs, d3) */
-#define PT_D4 12 /* offsetof(struct pt_regs, d4) */
-#define PT_D5 16 /* offsetof(struct pt_regs, d5) */
-#define PT_A0 20 /* offsetof(struct pt_regs, a0) */
-#define PT_A1 24 /* offsetof(struct pt_regs, a1) */
-#define PT_A2 28 /* offsetof(struct pt_regs, a2) */
-#define PT_PC 48 /* offsetof(struct pt_regs, pc) */
-#define PT_SR 46 /* offsetof(struct pt_regs, sr) */
-#define PT_VECTOR 52 /* offsetof(struct pt_regs, pc) + 4 */
-#define STAT_IRQ 5140 /* offsetof(struct kernel_stat, irqs) */
-#define SIGSEGV 11 /* SIGSEGV */
-#define SEGV_MAPERR 196609 /* SEGV_MAPERR */
-#define SIGTRAP 5 /* SIGTRAP */
-#define TRAP_TRACE 196610 /* TRAP_TRACE */
-#define PT_PTRACED 1 /* PT_PTRACED */
-#define PT_DTRACE 2 /* PT_DTRACE */
-
-#endif
diff -Naur linux-2.6.14/include/asm-m68knommu/atomic.h linux-2.6.14-uc0/include/asm-m68knommu/atomic.h
--- linux-2.6.14/include/asm-m68knommu/atomic.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/atomic.h	2005-10-31 15:40:56.000000000 +1000
@@ -100,7 +100,7 @@
 #define smp_mb__before_atomic_inc()    barrier()
 #define smp_mb__after_atomic_inc() barrier()
 
-extern __inline__ int atomic_add_return(int i, atomic_t * v)
+static inline int atomic_add_return(int i, atomic_t * v)
 {
 	unsigned long temp, flags;
 
@@ -115,7 +115,7 @@
 
 #define atomic_add_negative(a, v)	(atomic_add_return((a), (v)) < 0)
 
-extern __inline__ int atomic_sub_return(int i, atomic_t * v)
+static inline int atomic_sub_return(int i, atomic_t * v)
 {
 	unsigned long temp, flags;
 
diff -Naur linux-2.6.14/include/asm-m68knommu/cacheflush.h linux-2.6.14-uc0/include/asm-m68knommu/cacheflush.h
--- linux-2.6.14/include/asm-m68knommu/cacheflush.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/cacheflush.h	2005-10-31 15:40:56.000000000 +1000
@@ -25,7 +25,7 @@
 #define copy_from_user_page(vma, page, vaddr, dst, src, len) \
 	memcpy(dst, src, len)
 
-extern inline void __flush_cache_all(void)
+static inline void __flush_cache_all(void)
 {
 #ifdef CONFIG_M5407
 	/*
@@ -64,7 +64,7 @@
 		"nop\n\t"
 		: : : "d0" );
 #endif /* CONFIG_M5272 */
-#if CONFIG_M5249
+#ifdef CONFIG_M5249
 	__asm__ __volatile__ (
         	"movel	#0xa1000200, %%d0\n\t"
         	"movec	%%d0, %%CACR\n\t"
diff -Naur linux-2.6.14/include/asm-m68knommu/coldfire.h linux-2.6.14-uc0/include/asm-m68knommu/coldfire.h
--- linux-2.6.14/include/asm-m68knommu/coldfire.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/coldfire.h	2005-10-31 15:40:56.000000000 +1000
@@ -20,9 +20,14 @@
  */
 #define	MCF_MBAR	0x10000000
 #define	MCF_MBAR2	0x80000000
+#if defined(CONFIG_M520x)
+#define	MCF_IPSBAR	0xFC000000
+#else
 #define	MCF_IPSBAR	0x40000000
+#endif
 
-#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x)
+#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+    defined(CONFIG_M520x)
 #undef MCF_MBAR
 #define	MCF_MBAR	MCF_IPSBAR
 #endif
@@ -78,7 +83,8 @@
  *	One some ColdFire family members the bus clock (used by internal
  *	peripherals) is not the same as the CPU clock.
  */
-#if defined(CONFIG_M523x) || defined(CONFIG_M5249) || defined(CONFIG_M527x)
+#if defined(CONFIG_M523x) || defined(CONFIG_M5249) || defined(CONFIG_M527x) || \
+    defined(CONFIG_M520x)
 #define	MCF_BUSCLK	(MCF_CLK / 2)
 #else
 #define	MCF_BUSCLK	MCF_CLK
diff -Naur linux-2.6.14/include/asm-m68knommu/delay.h linux-2.6.14-uc0/include/asm-m68knommu/delay.h
--- linux-2.6.14/include/asm-m68knommu/delay.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/delay.h	2005-10-31 15:40:56.000000000 +1000
@@ -8,7 +8,7 @@
 
 #include <asm/param.h>
 
-extern __inline__ void __delay(unsigned long loops)
+static inline void __delay(unsigned long loops)
 {
 #if defined(CONFIG_COLDFIRE)
 	/* The coldfire runs this loop at significantly different speeds
@@ -48,7 +48,7 @@
 
 extern unsigned long loops_per_jiffy;
 
-extern __inline__ void _udelay(unsigned long usecs)
+static inline void _udelay(unsigned long usecs)
 {
 #if defined(CONFIG_M68328) || defined(CONFIG_M68EZ328) || \
     defined(CONFIG_M68VZ328) || defined(CONFIG_M68360) || \
diff -Naur linux-2.6.14/include/asm-m68knommu/hardirq.h linux-2.6.14-uc0/include/asm-m68knommu/hardirq.h
--- linux-2.6.14/include/asm-m68knommu/hardirq.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/hardirq.h	2005-10-31 15:40:56.000000000 +1000
@@ -4,6 +4,7 @@
 #include <linux/config.h>
 #include <linux/cache.h>
 #include <linux/threads.h>
+#include <asm/irq.h>
 
 typedef struct {
 	unsigned int __softirq_pending;
diff -Naur linux-2.6.14/include/asm-m68knommu/ide.h linux-2.6.14-uc0/include/asm-m68knommu/ide.h
--- linux-2.6.14/include/asm-m68knommu/ide.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/ide.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,444 +0,0 @@
-/****************************************************************************/
-/*
- *  linux/include/asm-m68knommu/ide.h
- *
- *  Copyright (C) 1994-1996  Linus Torvalds & authors
- *	Copyright (C) 2001       Lineo Inc., davidm@uclinux.org
- */
-/****************************************************************************/
-#ifndef _M68KNOMMU_IDE_H
-#define _M68KNOMMU_IDE_H
-
-#ifdef __KERNEL__
-/****************************************************************************/
-
-#include <linux/config.h>
-#include <linux/interrupt.h>
-
-#include <asm/setup.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-
-/****************************************************************************/
-/*
- *	some coldfire specifics
- */
-
-#ifdef CONFIG_COLDFIRE
-#include <asm/coldfire.h>
-#include <asm/mcfsim.h>
-
-/*
- *	Save some space,  only have 1 interface
- */
-#define MAX_HWIFS		  1	/* we only have one interface for now */
-
-#ifdef CONFIG_SECUREEDGEMP3
-#define	MCFSIM_LOCALCS	  MCFSIM_CSCR4
-#else
-#define	MCFSIM_LOCALCS	  MCFSIM_CSCR6
-#endif
-
-#endif /* CONFIG_COLDFIRE */
-
-/****************************************************************************/
-/*
- *	Fix up things that may not have been provided
- */
-
-#ifndef MAX_HWIFS
-#define MAX_HWIFS	4	/* same as the other archs */
-#endif
-
-#undef SUPPORT_SLOW_DATA_PORTS
-#define SUPPORT_SLOW_DATA_PORTS 0
-
-#undef SUPPORT_VLB_SYNC
-#define SUPPORT_VLB_SYNC 0
-
-/* this definition is used only on startup .. */
-#undef HD_DATA
-#define HD_DATA NULL
-
-#define	DBGIDE(fmt,a...)
-// #define	DBGIDE(fmt,a...) printk(fmt, ##a)
-#define IDE_INLINE __inline__
-// #define IDE_INLINE
-
-/****************************************************************************/
-
-typedef union {
-	unsigned all			: 8;	/* all of the bits together */
-	struct {
-		unsigned bit7		: 1;	/* always 1 */
-		unsigned lba		: 1;	/* using LBA instead of CHS */
-		unsigned bit5		: 1;	/* always 1 */
-		unsigned unit		: 1;	/* drive select number, 0 or 1 */
-		unsigned head		: 4;	/* always zeros here */
-	} b;
-} select_t;
-
-/*
- *	our list of ports/irq's for different boards
- */
-
-static struct m68k_ide_defaults {
-	ide_ioreg_t	base;
-	int			irq;
-} m68k_ide_defaults[MAX_HWIFS] = {
-#if defined(CONFIG_SECUREEDGEMP3)
-	{ ((ide_ioreg_t)0x30800000), 29 },
-#elif defined(CONFIG_eLIA)
-	{ ((ide_ioreg_t)0x30c00000), 29 },
-#else
-	{ ((ide_ioreg_t)0x0), 0 }
-#endif
-};
-
-/****************************************************************************/
-
-static IDE_INLINE int ide_default_irq(ide_ioreg_t base)
-{
-	int i;
-
-	for (i = 0; i < MAX_HWIFS; i++)
-		if (m68k_ide_defaults[i].base == base)
-			return(m68k_ide_defaults[i].irq);
-	return 0;
-}
-
-static IDE_INLINE ide_ioreg_t ide_default_io_base(int index)
-{
-	if (index >= 0 && index < MAX_HWIFS)
-		return(m68k_ide_defaults[index].base);
-	return 0;
-}
-
-
-/*
- * Set up a hw structure for a specified data port, control port and IRQ.
- * This should follow whatever the default interface uses.
- */
-static IDE_INLINE void ide_init_hwif_ports(
-	hw_regs_t *hw,
-	ide_ioreg_t data_port,
-	ide_ioreg_t ctrl_port,
-	int *irq)
-{
-	ide_ioreg_t reg = data_port;
-	int i;
-
-	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
-		hw->io_ports[i] = reg;
-		reg += 1;
-	}
-	if (ctrl_port) {
-		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
-	} else {
-		hw->io_ports[IDE_CONTROL_OFFSET] = data_port + 0xe;
-	}
-}
-
-#define ide_init_default_irq(base)	ide_default_irq(base)
-
-static IDE_INLINE int
-ide_request_irq(
-	unsigned int irq,
-	void (*handler)(int, void *, struct pt_regs *),
-	unsigned long flags,
-	const char *device,
-	void *dev_id)
-{
-#ifdef CONFIG_COLDFIRE
-	mcf_autovector(irq);
-#endif
-	return(request_irq(irq, handler, flags, device, dev_id));
-}
-
-
-static IDE_INLINE void
-ide_free_irq(unsigned int irq, void *dev_id)
-{
-	free_irq(irq, dev_id);
-}
-
-
-static IDE_INLINE int
-ide_check_region(ide_ioreg_t from, unsigned int extent)
-{
-	return 0;
-}
-
-
-static IDE_INLINE void
-ide_request_region(ide_ioreg_t from, unsigned int extent, const char *name)
-{
-}
-
-
-static IDE_INLINE void
-ide_release_region(ide_ioreg_t from, unsigned int extent)
-{
-}
-
-
-static IDE_INLINE void
-ide_fix_driveid(struct hd_driveid *id)
-{
-#ifdef CONFIG_COLDFIRE
-	int i, n;
-	unsigned short *wp = (unsigned short *) id;
-	int avoid[] = {49, 51, 52, 59, -1 }; /* do not swap these words */
-
-	/* Need to byte swap shorts,  but not char fields */
-	for (i = n = 0; i < sizeof(*id) / sizeof(*wp); i++, wp++) {
-		if (avoid[n] == i) {
-			n++;
-			continue;
-		}
-		*wp = ((*wp & 0xff) << 8) | ((*wp >> 8) & 0xff);
-	}
-	/* have to word swap the one 32 bit field */
-	id->lba_capacity = ((id->lba_capacity & 0xffff) << 16) |
-				((id->lba_capacity >> 16) & 0xffff);
-#endif
-}
-
-
-static IDE_INLINE void
-ide_release_lock (int *ide_lock)
-{
-}
-
-
-static IDE_INLINE void
-ide_get_lock(
-	int *ide_lock,
-	void (*handler)(int, void *, struct pt_regs *),
-	void *data)
-{
-}
-
-
-#define ide_ack_intr(hwif) \
-	((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
-#define	ide__sti()	__sti()
-
-/****************************************************************************/
-/*
- *	System specific IO requirements
- */
-
-#ifdef CONFIG_COLDFIRE
-
-#ifdef CONFIG_SECUREEDGEMP3
-
-/* Replace standard IO functions for funky mapping of MP3 board */
-#undef outb
-#undef outb_p
-#undef inb
-#undef inb_p
-
-#define outb(v, a)          ide_outb(v, (unsigned long) (a))
-#define outb_p(v, a)        ide_outb(v, (unsigned long) (a))
-#define inb(a)              ide_inb((unsigned long) (a))
-#define inb_p(a)            ide_inb((unsigned long) (a))
-
-#define ADDR8_PTR(addr)		(((addr) & 0x1) ? (0x8000 + (addr) - 1) : (addr))
-#define ADDR16_PTR(addr)	(addr)
-#define ADDR32_PTR(addr)	(addr)
-#define SWAP8(w)			((((w) & 0xffff) << 8) | (((w) & 0xffff) >> 8))
-#define SWAP16(w)			(w)
-#define SWAP32(w)			(w)
-
-
-static IDE_INLINE void
-ide_outb(unsigned int val, unsigned int addr)
-{
-	volatile unsigned short	*rp;
-
-	DBGIDE("%s(val=%x,addr=%x)\n", __FUNCTION__, val, addr);
-	rp = (volatile unsigned short *) ADDR8_PTR(addr);
-	*rp = SWAP8(val);
-}
-
-
-static IDE_INLINE int
-ide_inb(unsigned int addr)
-{
-	volatile unsigned short	*rp, val;
-
-	DBGIDE("%s(addr=%x)\n", __FUNCTION__, addr);
-	rp = (volatile unsigned short *) ADDR8_PTR(addr);
-	val = *rp;
-	return(SWAP8(val));
-}
-
-
-static IDE_INLINE void
-ide_outw(unsigned int val, unsigned int addr)
-{
-	volatile unsigned short	*rp;
-
-	DBGIDE("%s(val=%x,addr=%x)\n", __FUNCTION__, val, addr);
-	rp = (volatile unsigned short *) ADDR16_PTR(addr);
-	*rp = SWAP16(val);
-}
-
-static IDE_INLINE void
-ide_outsw(unsigned int addr, const void *vbuf, unsigned long len)
-{
-	volatile unsigned short	*rp, val;
-	unsigned short   	*buf;
-
-	DBGIDE("%s(addr=%x,vbuf=%p,len=%x)\n", __FUNCTION__, addr, vbuf, len);
-	buf = (unsigned short *) vbuf;
-	rp = (volatile unsigned short *) ADDR16_PTR(addr);
-	for (; (len > 0); len--) {
-		val = *buf++;
-		*rp = SWAP16(val);
-	}
-}
-
-static IDE_INLINE int
-ide_inw(unsigned int addr)
-{
-	volatile unsigned short *rp, val;
-
-	DBGIDE("%s(addr=%x)\n", __FUNCTION__, addr);
-	rp = (volatile unsigned short *) ADDR16_PTR(addr);
-	val = *rp;
-	return(SWAP16(val));
-}
-
-static IDE_INLINE void
-ide_insw(unsigned int addr, void *vbuf, unsigned long len)
-{
-	volatile unsigned short *rp;
-	unsigned short          w, *buf;
-
-	DBGIDE("%s(addr=%x,vbuf=%p,len=%x)\n", __FUNCTION__, addr, vbuf, len);
-	buf = (unsigned short *) vbuf;
-	rp = (volatile unsigned short *) ADDR16_PTR(addr);
-	for (; (len > 0); len--) {
-		w = *rp;
-		*buf++ = SWAP16(w);
-	}
-}
-
-static IDE_INLINE void
-ide_insl(unsigned int addr, void *vbuf, unsigned long len)
-{
-	volatile unsigned long *rp;
-	unsigned long          w, *buf;
-
-	DBGIDE("%s(addr=%x,vbuf=%p,len=%x)\n", __FUNCTION__, addr, vbuf, len);
-	buf = (unsigned long *) vbuf;
-	rp = (volatile unsigned long *) ADDR32_PTR(addr);
-	for (; (len > 0); len--) {
-		w = *rp;
-		*buf++ = SWAP32(w);
-	}
-}
-
-static IDE_INLINE void
-ide_outsl(unsigned int addr, const void *vbuf, unsigned long len)
-{
-	volatile unsigned long	*rp, val;
-	unsigned long   	*buf;
-
-	DBGIDE("%s(addr=%x,vbuf=%p,len=%x)\n", __FUNCTION__, addr, vbuf, len);
-	buf = (unsigned long *) vbuf;
-	rp = (volatile unsigned long *) ADDR32_PTR(addr);
-	for (; (len > 0); len--) {
-		val = *buf++;
-		*rp = SWAP32(val);
-	}
-}
-
-#elif CONFIG_eLIA
-
-/* 8/16 bit acesses are controlled by flicking bits in the CS register */
-#define	ACCESS_MODE_16BIT()	\
-	*((volatile unsigned short *) (MCF_MBAR + MCFSIM_LOCALCS)) = 0x0080
-#define	ACCESS_MODE_8BIT()	\
-	*((volatile unsigned short *) (MCF_MBAR + MCFSIM_LOCALCS)) = 0x0040
-
-
-static IDE_INLINE void
-ide_outw(unsigned int val, unsigned int addr)
-{
-	ACCESS_MODE_16BIT();
-	outw(val, addr);
-	ACCESS_MODE_8BIT();
-}
-
-static IDE_INLINE void
-ide_outsw(unsigned int addr, const void *vbuf, unsigned long len)
-{
-	ACCESS_MODE_16BIT();
-	outsw(addr, vbuf, len);
-	ACCESS_MODE_8BIT();
-}
-
-static IDE_INLINE int
-ide_inw(unsigned int addr)
-{
-	int ret;
-
-	ACCESS_MODE_16BIT();
-	ret = inw(addr);
-	ACCESS_MODE_8BIT();
-	return(ret);
-}
-
-static IDE_INLINE void
-ide_insw(unsigned int addr, void *vbuf, unsigned long len)
-{
-	ACCESS_MODE_16BIT();
-	insw(addr, vbuf, len);
-	ACCESS_MODE_8BIT();
-}
-
-static IDE_INLINE void
-ide_insl(unsigned int addr, void *vbuf, unsigned long len)
-{
-	ACCESS_MODE_16BIT();
-	insl(addr, vbuf, len);
-	ACCESS_MODE_8BIT();
-}
-
-static IDE_INLINE void
-ide_outsl(unsigned int addr, const void *vbuf, unsigned long len)
-{
-	ACCESS_MODE_16BIT();
-	outsl(addr, vbuf, len);
-	ACCESS_MODE_8BIT();
-}
-
-#endif /* CONFIG_SECUREEDGEMP3 */
-
-#undef outw
-#undef outw_p
-#undef outsw
-#undef inw
-#undef inw_p
-#undef insw
-#undef insl
-#undef outsl
-
-#define	outw(v, a)	     ide_outw(v, (unsigned long) (a))
-#define	outw_p(v, a)     ide_outw(v, (unsigned long) (a))
-#define outsw(a, b, n)   ide_outsw((unsigned long) (a), b, n)
-#define	inw(a)	         ide_inw((unsigned long) (a))
-#define	inw_p(a)	     ide_inw((unsigned long) (a))
-#define insw(a, b, n)    ide_insw((unsigned long) (a), b, n)
-#define insl(a, b, n)    ide_insl((unsigned long) (a), b, n)
-#define outsl(a, b, n)   ide_outsl((unsigned long) (a), b, n)
-
-#endif CONFIG_COLDFIRE
-
-/****************************************************************************/
-#endif /* __KERNEL__ */
-#endif /* _M68KNOMMU_IDE_H */
-/****************************************************************************/
diff -Naur linux-2.6.14/include/asm-m68knommu/io.h linux-2.6.14-uc0/include/asm-m68knommu/io.h
--- linux-2.6.14/include/asm-m68knommu/io.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/io.h	2005-10-31 15:40:56.000000000 +1000
@@ -147,19 +147,19 @@
 extern void *__ioremap(unsigned long physaddr, unsigned long size, int cacheflag);
 extern void __iounmap(void *addr, unsigned long size);
 
-extern inline void *ioremap(unsigned long physaddr, unsigned long size)
+static inline void *ioremap(unsigned long physaddr, unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
 }
-extern inline void *ioremap_nocache(unsigned long physaddr, unsigned long size)
+static inline void *ioremap_nocache(unsigned long physaddr, unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
 }
-extern inline void *ioremap_writethrough(unsigned long physaddr, unsigned long size)
+static inline void *ioremap_writethrough(unsigned long physaddr, unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
 }
-extern inline void *ioremap_fullcache(unsigned long physaddr, unsigned long size)
+static inline void *ioremap_fullcache(unsigned long physaddr, unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_FULL_CACHING);
 }
diff -Naur linux-2.6.14/include/asm-m68knommu/irq.h linux-2.6.14-uc0/include/asm-m68knommu/irq.h
--- linux-2.6.14/include/asm-m68knommu/irq.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/irq.h	2005-10-31 15:40:56.000000000 +1000
@@ -2,7 +2,6 @@
 #define _M68K_IRQ_H_
 
 #include <linux/config.h>
-#include <linux/interrupt.h>
 #include <asm/ptrace.h>
 
 #ifdef CONFIG_COLDFIRE
@@ -83,36 +82,6 @@
 #endif /* CONFIG_M68360 */
 
 /*
- * This structure is used to chain together the ISRs for a particular
- * interrupt source (if it supports chaining).
- */
-typedef struct irq_node {
-	irqreturn_t	(*handler)(int, void *, struct pt_regs *);
-	unsigned long	flags;
-	void		*dev_id;
-	const char	*devname;
-	struct irq_node *next;
-} irq_node_t;
-
-/*
- * This structure has only 4 elements for speed reasons
- */
-typedef struct irq_handler {
-	irqreturn_t	(*handler)(int, void *, struct pt_regs *);
-	unsigned long	flags;
-	void		*dev_id;
-	const char	*devname;
-} irq_handler_t;
-
-/* count of spurious interrupts */
-extern volatile unsigned int num_spurious;
-
-/*
- * This function returns a new irq_node_t
- */
-extern irq_node_t *new_irq_node(void);
-
-/*
  * Some drivers want these entry points
  */
 #define enable_irq(x)	(mach_enable_irq  ? (*mach_enable_irq)(x)  : 0)
diff -Naur linux-2.6.14/include/asm-m68knommu/irqnode.h linux-2.6.14-uc0/include/asm-m68knommu/irqnode.h
--- linux-2.6.14/include/asm-m68knommu/irqnode.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/irqnode.h	2005-10-31 15:40:56.000000000 +1000
@@ -0,0 +1,36 @@
+#ifndef _M68K_IRQNODE_H_
+#define _M68K_IRQNODE_H_
+
+#include <linux/interrupt.h>
+
+/*
+ * This structure is used to chain together the ISRs for a particular
+ * interrupt source (if it supports chaining).
+ */
+typedef struct irq_node {
+	irqreturn_t	(*handler)(int, void *, struct pt_regs *);
+	unsigned long	flags;
+	void		*dev_id;
+	const char	*devname;
+	struct irq_node *next;
+} irq_node_t;
+
+/*
+ * This structure has only 4 elements for speed reasons
+ */
+typedef struct irq_handler {
+	irqreturn_t	(*handler)(int, void *, struct pt_regs *);
+	unsigned long	flags;
+	void		*dev_id;
+	const char	*devname;
+} irq_handler_t;
+
+/* count of spurious interrupts */
+extern volatile unsigned int num_spurious;
+
+/*
+ * This function returns a new irq_node_t
+ */
+extern irq_node_t *new_irq_node(void);
+
+#endif /* _M68K_IRQNODE_H_ */
diff -Naur linux-2.6.14/include/asm-m68knommu/m520xsim.h linux-2.6.14-uc0/include/asm-m68knommu/m520xsim.h
--- linux-2.6.14/include/asm-m68knommu/m520xsim.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/m520xsim.h	2005-10-31 15:40:56.000000000 +1000
@@ -0,0 +1,54 @@
+/****************************************************************************/
+
+/*
+ *  m520xsim.h -- ColdFire 5207/5208 System Integration Module support.
+ *
+ *  (C) Copyright 2005, Intec Automation (mike@steroidmicros.com)
+ */
+
+/****************************************************************************/
+#ifndef m520xsim_h
+#define m520xsim_h
+/****************************************************************************/
+
+#include <linux/config.h>
+
+/*
+ *  Define the 5282 SIM register set addresses.
+ */
+#define MCFICM_INTC0        0x48000     /* Base for Interrupt Ctrl 0 */
+#define MCFINTC_IPRH        0x00        /* Interrupt pending 32-63 */
+#define MCFINTC_IPRL        0x04        /* Interrupt pending 1-31 */
+#define MCFINTC_IMRH        0x08        /* Interrupt mask 32-63 */
+#define MCFINTC_IMRL        0x0c        /* Interrupt mask 1-31 */
+#define MCFINTC_INTFRCH     0x10        /* Interrupt force 32-63 */
+#define MCFINTC_INTFRCL     0x14        /* Interrupt force 1-31 */
+#define MCFINTC_ICR0        0x40        /* Base ICR register */
+
+#define MCFINT_VECBASE      64
+#define MCFINT_UART0        26          /* Interrupt number for UART0 */
+#define MCFINT_UART1        27          /* Interrupt number for UART1 */
+#define MCFINT_UART2        28          /* Interrupt number for UART2 */
+#define MCFINT_QSPI         31          /* Interrupt number for QSPI */
+#define MCFINT_PIT1         4           /* Interrupt number for PIT1 (PIT0 in processor) */
+
+
+#define MCF_GPIO_PAR_UART                   (0xA4036)
+#define MCF_GPIO_PAR_FECI2C                 (0xA4033)
+#define MCF_GPIO_PAR_FEC                    (0xA4038)
+
+#define MCF_GPIO_PAR_UART_PAR_URXD0         (0x0001)
+#define MCF_GPIO_PAR_UART_PAR_UTXD0         (0x0002)
+
+#define MCF_GPIO_PAR_UART_PAR_URXD1         (0x0040)
+#define MCF_GPIO_PAR_UART_PAR_UTXD1         (0x0080)
+
+#define MCF_GPIO_PAR_FECI2C_PAR_SDA_URXD2   (0x02)
+#define MCF_GPIO_PAR_FECI2C_PAR_SCL_UTXD2   (0x04)
+
+#define	ICR_INTRCONF	0x05
+#define	MCFPIT_IMR	MCFINTC_IMRL
+#define	MCFPIT_IMR_IBIT	(1 << MCFINT_PIT1)
+
+/****************************************************************************/
+#endif  /* m520xsim_h */
diff -Naur linux-2.6.14/include/asm-m68knommu/mcfcache.h linux-2.6.14-uc0/include/asm-m68knommu/mcfcache.h
--- linux-2.6.14/include/asm-m68knommu/mcfcache.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/mcfcache.h	2005-10-31 15:40:56.000000000 +1000
@@ -117,6 +117,20 @@
 .endm
 #endif /* CONFIG_M5407 */
 
+#if defined(CONFIG_M520x)
+.macro CACHE_ENABLE
+	move.l	#0x01000000,%d0		/* invalidate whole cache */
+	movec	%d0,%CACR
+	nop
+	move.l	#0x0000c000,%d0		/* set SDRAM cached (write-thru) */
+	movec	%d0,%ACR0
+	move.l	#0x00000000,%d0		/* no other regions cached */
+	movec	%d0,%ACR1
+	move.l	#0x80400000,%d0		/* enable 8K instruction cache */
+	movec	%d0,%CACR
+	nop
+.endm
+#endif /* CONFIG_M520x */
 
 /****************************************************************************/
 #endif	/* __M68KNOMMU_MCFCACHE_H */
diff -Naur linux-2.6.14/include/asm-m68knommu/mcfne.h linux-2.6.14-uc0/include/asm-m68knommu/mcfne.h
--- linux-2.6.14/include/asm-m68knommu/mcfne.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/mcfne.h	2005-10-31 15:40:56.000000000 +1000
@@ -35,7 +35,7 @@
  *	Define the basic hardware resources of NE2000 boards.
  */
 
-#if defined(CONFIG_M5206) && defined(CONFIG_ARNEWSH)
+#if defined(CONFIG_ARN5206)
 #define NE2000_ADDR		0x40000300
 #define NE2000_ODDOFFSET	0x00010000
 #define	NE2000_IRQ_VECTOR	0xf0
@@ -44,7 +44,7 @@
 #define	NE2000_BYTE		volatile unsigned short
 #endif
 
-#if defined(CONFIG_M5206e) && defined(CONFIG_MOTOROLA)
+#if defined(CONFIG_M5206eC3)
 #define	NE2000_ADDR		0x40000300
 #define	NE2000_ODDOFFSET	0x00010000
 #define	NE2000_IRQ_VECTOR	0x1c
@@ -61,7 +61,7 @@
 #define	NE2000_BYTE		volatile unsigned char
 #endif
 
-#if defined(CONFIG_M5206e) && defined(CONFIG_CFV240)
+#if defined(CONFIG_CFV240)
 #define NE2000_ADDR             0x40010000
 #define NE2000_ADDR1            0x40010001
 #define NE2000_ODDOFFSET        0x00000000
@@ -72,7 +72,7 @@
 #define	NE2000_BYTE		volatile unsigned char
 #endif
 
-#if defined(CONFIG_M5307) && defined(CONFIG_MOTOROLA)
+#if defined(CONFIG_M5307C3)
 #define NE2000_ADDR		0x40000300
 #define NE2000_ODDOFFSET	0x00010000
 #define NE2000_IRQ_VECTOR	0x1b
@@ -114,7 +114,7 @@
 #define	RSWAP(w)		(((w) << 8) | ((w) >> 8))
 #endif
 
-#if defined(CONFIG_M5307) && defined(CONFIG_ARNEWSH)
+#if defined(CONFIG_ARN5307)
 #define NE2000_ADDR		0xfe600300
 #define NE2000_ODDOFFSET	0x00010000
 #define NE2000_IRQ_VECTOR	0x1b
@@ -123,7 +123,7 @@
 #define	NE2000_BYTE		volatile unsigned short
 #endif
 
-#if defined(CONFIG_M5407)
+#if defined(CONFIG_M5407C3)
 #define NE2000_ADDR		0x40000300
 #define NE2000_ODDOFFSET	0x00010000
 #define NE2000_IRQ_VECTOR	0x1b
@@ -264,7 +264,7 @@
  *	Minor differences between the different board types.
  */
 
-#if defined(CONFIG_M5206) && defined(CONFIG_ARNEWSH)
+#if defined(CONFIG_ARN5206)
 void ne2000_irqsetup(int irq)
 {
 	volatile unsigned char  *icrp;
@@ -275,7 +275,7 @@
 }
 #endif
 
-#if defined(CONFIG_M5206e) && defined(CONFIG_MOTOROLA)
+#if defined(CONFIG_M5206eC3)
 void ne2000_irqsetup(int irq)
 {
 	volatile unsigned char  *icrp;
@@ -286,7 +286,7 @@
 }
 #endif
 
-#if defined(CONFIG_M5206e) && defined(CONFIG_CFV240)
+#if defined(CONFIG_CFV240)
 void ne2000_irqsetup(int irq)
 {
 	volatile unsigned char  *icrp;
diff -Naur linux-2.6.14/include/asm-m68knommu/mcfpit.h linux-2.6.14-uc0/include/asm-m68knommu/mcfpit.h
--- linux-2.6.14/include/asm-m68knommu/mcfpit.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/mcfpit.h	2005-10-31 15:40:56.000000000 +1000
@@ -14,13 +14,17 @@
 #include <linux/config.h>
 
 /*
- *	Get address specific defines for the 5270/5271 and 5280/5282.
+ *	Get address specific defines for the 5270/5271, 5280/5282, and 5208.
  */
+#if defined(CONFIG_M520x)
+#define	MCFPIT_BASE1		0x00080000	/* Base address of TIMER1 */
+#define	MCFPIT_BASE2		0x00084000	/* Base address of TIMER2 */
+#else
 #define	MCFPIT_BASE1		0x00150000	/* Base address of TIMER1 */
 #define	MCFPIT_BASE2		0x00160000	/* Base address of TIMER2 */
 #define	MCFPIT_BASE3		0x00170000	/* Base address of TIMER3 */
 #define	MCFPIT_BASE4		0x00180000	/* Base address of TIMER4 */
-
+#endif
 
 /*
  *	Define the PIT timer register set addresses.
diff -Naur linux-2.6.14/include/asm-m68knommu/mcfsim.h linux-2.6.14-uc0/include/asm-m68knommu/mcfsim.h
--- linux-2.6.14/include/asm-m68knommu/mcfsim.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/mcfsim.h	2005-10-31 15:40:56.000000000 +1000
@@ -22,6 +22,8 @@
 #include <asm/m5204sim.h>
 #elif defined(CONFIG_M5206) || defined(CONFIG_M5206e)
 #include <asm/m5206sim.h>
+#elif defined(CONFIG_M520x)
+#include <asm/m520xsim.h>
 #elif defined(CONFIG_M523x)
 #include <asm/m523xsim.h>
 #elif defined(CONFIG_M5249)
@@ -99,6 +101,19 @@
 #define	MCFSIM_IMR_MASKALL	0x3ffe		/* All intr sources */
 #endif
 
+/*
+ *	PIT interrupt settings, if not found in mXXXXsim.h file.
+ */
+#ifndef	ICR_INTRCONF
+#define	ICR_INTRCONF		0x2b            /* PIT1 level 5, priority 3 */
+#endif
+#ifndef	MCFPIT_IMR
+#define	MCFPIT_IMR		MCFINTC_IMRH
+#endif
+#ifndef	MCFPIT_IMR_IBIT
+#define	MCFPIT_IMR_IBIT		(1 << (MCFINT_PIT1 - 32))
+#endif
+
 
 #ifndef __ASSEMBLY__
 /*
diff -Naur linux-2.6.14/include/asm-m68knommu/mcfuart.h linux-2.6.14-uc0/include/asm-m68knommu/mcfuart.h
--- linux-2.6.14/include/asm-m68knommu/mcfuart.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/mcfuart.h	2005-10-31 15:40:56.000000000 +1000
@@ -41,6 +41,10 @@
 #define MCFUART_BASE1		0x1c0           /* Base address of UART1 */
 #define MCFUART_BASE2		0x200           /* Base address of UART2 */
 #endif
+#elif defined(CONFIG_M520x)
+#define MCFUART_BASE1		0x60000		/* Base address of UART1 */
+#define MCFUART_BASE2		0x64000		/* Base address of UART2 */
+#define MCFUART_BASE3		0x68000		/* Base address of UART2 */
 #endif
 
 
diff -Naur linux-2.6.14/include/asm-m68knommu/mcfwdebug.h linux-2.6.14-uc0/include/asm-m68knommu/mcfwdebug.h
--- linux-2.6.14/include/asm-m68knommu/mcfwdebug.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/mcfwdebug.h	2005-10-31 15:40:56.000000000 +1000
@@ -90,7 +90,7 @@
  * that the debug module instructions (2 longs) must be long word aligned and
  * some pointer fiddling is performed to ensure this.
  */
-extern inline void wdebug(int reg, unsigned long data) {
+static inline void wdebug(int reg, unsigned long data) {
 	unsigned short dbg_spc[6];
 	unsigned short *dbg;
 
diff -Naur linux-2.6.14/include/asm-m68knommu/mmu_context.h linux-2.6.14-uc0/include/asm-m68knommu/mmu_context.h
--- linux-2.6.14/include/asm-m68knommu/mmu_context.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/mmu_context.h	2005-10-31 15:40:56.000000000 +1000
@@ -10,7 +10,7 @@
 {
 }
 
-extern inline int
+static inline int
 init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
 	// mm->context = virt_to_phys(mm->pgd);
@@ -25,7 +25,7 @@
 
 #define deactivate_mm(tsk,mm)	do { } while (0)
 
-extern inline void activate_mm(struct mm_struct *prev_mm,
+static inline void activate_mm(struct mm_struct *prev_mm,
 			       struct mm_struct *next_mm)
 {
 }
diff -Naur linux-2.6.14/include/asm-m68knommu/processor.h linux-2.6.14-uc0/include/asm-m68knommu/processor.h
--- linux-2.6.14/include/asm-m68knommu/processor.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/processor.h	2005-10-31 15:40:56.000000000 +1000
@@ -21,7 +21,7 @@
 #include <asm/ptrace.h>
 #include <asm/current.h>
 
-extern inline unsigned long rdusp(void)
+static inline unsigned long rdusp(void)
 {
 #ifdef CONFIG_COLDFIRE
 	extern unsigned int sw_usp;
@@ -33,7 +33,7 @@
 #endif
 }
 
-extern inline void wrusp(unsigned long usp)
+static inline void wrusp(unsigned long usp)
 {
 #ifdef CONFIG_COLDFIRE
 	extern unsigned int sw_usp;
diff -Naur linux-2.6.14/include/asm-m68knommu/semaphore.h linux-2.6.14-uc0/include/asm-m68knommu/semaphore.h
--- linux-2.6.14/include/asm-m68knommu/semaphore.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/semaphore.h	2005-10-31 15:40:56.000000000 +1000
@@ -44,7 +44,7 @@
 #define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
 #define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
 
-extern inline void sema_init (struct semaphore *sem, int val)
+static inline void sema_init (struct semaphore *sem, int val)
 {
 	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER(*sem, val);
 }
@@ -76,7 +76,7 @@
  * "down_failed" is a special asm handler that calls the C
  * routine that actually waits. See arch/m68k/lib/semaphore.S
  */
-extern inline void down(struct semaphore * sem)
+static inline void down(struct semaphore * sem)
 {
 	might_sleep();
 	__asm__ __volatile__(
@@ -91,7 +91,7 @@
 		: "cc", "%a0", "%a1", "memory");
 }
 
-extern inline int down_interruptible(struct semaphore * sem)
+static inline int down_interruptible(struct semaphore * sem)
 {
 	int ret;
 
@@ -110,7 +110,7 @@
 	return(ret);
 }
 
-extern inline int down_trylock(struct semaphore * sem)
+static inline int down_trylock(struct semaphore * sem)
 {
 	register struct semaphore *sem1 __asm__ ("%a1") = sem;
 	register int result __asm__ ("%d0");
@@ -138,7 +138,7 @@
  * The default case (no contention) will result in NO
  * jumps for both down() and up().
  */
-extern inline void up(struct semaphore * sem)
+static inline void up(struct semaphore * sem)
 {
 	__asm__ __volatile__(
 		"| atomic up operation\n\t"
diff -Naur linux-2.6.14/include/asm-m68knommu/system.h linux-2.6.14-uc0/include/asm-m68knommu/system.h
--- linux-2.6.14/include/asm-m68knommu/system.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/system.h	2005-10-31 15:40:56.000000000 +1000
@@ -312,6 +312,19 @@
 	moveb #0x80, (%a0);		\
 	");				\
 })
+#elif defined(CONFIG_M520x)
+	/*
+	 * The MCF5208 has a bit (SOFTRST) in memory (Reset Control Register 
+	 * RCR), that when set, resets the MCF5208.
+	 */
+#define HARD_RESET_NOW() 		\
+({					\
+	unsigned char volatile *reset;	\
+	asm("move.w     #0x2700, %sr");	\
+	reset = ((volatile unsigned short *)(MCF_IPSBAR + 0xA0000));	\
+	while(1)			\
+		*reset |= 0x80;		\
+})
 #else
 #define HARD_RESET_NOW() ({		\
         asm("				\
diff -Naur linux-2.6.14/include/asm-m68knommu/tlbflush.h linux-2.6.14-uc0/include/asm-m68knommu/tlbflush.h
--- linux-2.6.14/include/asm-m68knommu/tlbflush.h	2005-10-31 15:39:17.000000000 +1000
+++ linux-2.6.14-uc0/include/asm-m68knommu/tlbflush.h	2005-10-31 15:40:56.000000000 +1000
@@ -47,12 +47,12 @@
 	BUG();
 }
 
-extern inline void flush_tlb_kernel_page(unsigned long addr)
+static inline void flush_tlb_kernel_page(unsigned long addr)
 {
 	BUG();
 }
 
-extern inline void flush_tlb_pgtables(struct mm_struct *mm,
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
 				      unsigned long start, unsigned long end)
 {
 	BUG();
diff -Naur linux-2.6.14/init/Kconfig linux-2.6.14-uc0/init/Kconfig
--- linux-2.6.14/init/Kconfig	2005-10-31 15:39:35.000000000 +1000
+++ linux-2.6.14-uc0/init/Kconfig	2005-10-31 15:41:36.000000000 +1000
@@ -402,6 +402,7 @@
 
 config TINY_SHMEM
 	default !SHMEM
+	depends MMU
 	bool
 
 config BASE_SMALL
diff -Naur linux-2.6.14/Makefile linux-2.6.14-uc0/Makefile
--- linux-2.6.14/Makefile	2005-10-31 15:39:12.000000000 +1000
+++ linux-2.6.14-uc0/Makefile	2005-10-31 15:40:50.000000000 +1000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 14
-EXTRAVERSION =
+EXTRAVERSION = -uc0
 NAME=Affluent Albatross
 
 # *DOCUMENTATION*
@@ -505,7 +505,7 @@
 all: vmlinux
 
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
-CFLAGS		+= -Os
+CFLAGS		+= -O
 else
 CFLAGS		+= -O2
 endif
@@ -586,12 +586,12 @@
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
-		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
+		     $(net-y) $(net-m) $(libs-y) $(libs-m) $(EXTRA_MODULE_DIRS)))
 
 vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
 		     $(init-n) $(init-) \
 		     $(core-n) $(core-) $(drivers-n) $(drivers-) \
-		     $(net-n)  $(net-)  $(libs-n)    $(libs-))))
+		     $(net-n)  $(net-)  $(libs-n)    $(libs-) $(EXTRA_MODULE_DIRS))))
 
 init-y		:= $(patsubst %/, %/built-in.o, $(init-y))
 core-y		:= $(patsubst %/, %/built-in.o, $(core-y))
@@ -949,11 +949,11 @@
 ifeq "$(strip $(INSTALL_MOD_PATH))" ""
 depmod_opts	:=
 else
-depmod_opts	:= -b $(INSTALL_MOD_PATH) -r
+depmod_opts	:= -b $(INSTALL_MOD_PATH)/lib/modules -r
 endif
 .PHONY: _modinst_post
 _modinst_post: _modinst_
-	if [ -r System.map -a -x $(DEPMOD) ]; then $(DEPMOD) -ae -F System.map $(depmod_opts) $(KERNELRELEASE); fi
+	if [ -r System.map -a -x $(word 1, $(DEPMOD)) ]; then $(DEPMOD) -ae -F System.map $(depmod_opts) $(KERNELRELEASE); fi
 
 else # CONFIG_MODULES
 
diff -Naur linux-2.6.14/scripts/Makefile.modinst linux-2.6.14-uc0/scripts/Makefile.modinst
--- linux-2.6.14/scripts/Makefile.modinst	2005-10-31 15:39:26.000000000 +1000
+++ linux-2.6.14-uc0/scripts/Makefile.modinst	2005-10-31 15:41:21.000000000 +1000
@@ -23,7 +23,8 @@
 INSTALL_MOD_DIR ?= extra
 ext-mod-dir = $(INSTALL_MOD_DIR)$(subst $(KBUILD_EXTMOD),,$(@D))
 
-modinst_dir = $(if $(KBUILD_EXTMOD),$(ext-mod-dir),kernel/$(@D))
+#modinst_dir = $(if $(KBUILD_EXTMOD),$(ext-mod-dir),kernel/$(@D))
+modinst_dir = $(subst $(dir $(TOPDIR))modules/,,$(if $(KBUILD_EXTMOD),$(ext-mod-dir),kernel/$(@D)))
 
 $(modules):
 	$(call cmd,modules_install,$(MODLIB)/$(modinst_dir))
