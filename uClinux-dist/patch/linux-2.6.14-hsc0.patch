diff -Naur linux-2.6.14-uc0/arch/arm/boot/compressed/head-espd_4510b.S linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/head-espd_4510b.S
--- linux-2.6.14-uc0/arch/arm/boot/compressed/head-espd_4510b.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/head-espd_4510b.S	2005-11-08 08:48:27.000000000 +0900
@@ -0,0 +1,448 @@
+/*
+ *  linux/arch/arm/boot/compressed/head-espd_4510b.S
+ *
+ *  Copyright (C) 1996-2002 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi (MPU support)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+
+/*
+ * Debugging stuff
+ *
+ * Note that these macros must not contain any code which is not
+ * 100% relocatable.  Any attempt to do so will result in a crash.
+ * Please select one of the following when turning on debugging.
+ */
+#ifdef DEBUG
+#if defined(CONFIG_DEBUG_ICEDCC)
+		.macro	loadsp, rb
+		.endm
+		.macro writeb, rb
+		mcr	p14, 0, \rb, c0, c1, 0
+		.endm
+#else
+#error no serial architecture defined
+#endif
+#endif
+
+		.macro	kputc,val
+		mov	r0, \val
+		bl	putc
+		.endm
+
+		.macro	kphex,val,len
+		mov	r0, \val
+		mov	r1, #\len
+		bl	phex
+		.endm
+
+		.macro	debug_reloc_start
+#ifdef DEBUG
+		kputc	#'\n'
+		kphex	r6, 8		/* processor id */
+		kputc	#':'
+		kphex	r7, 8		/* architecture id */
+		kputc	#':'
+		mrc	p15, 0, r0, c1, c0
+		kphex	r0, 8		/* control reg */
+		kputc	#'\n'
+		kphex	r5, 8		/* decompressed kernel start */
+		kputc	#'-'
+		kphex	r8, 8		/* decompressed kernel end  */
+		kputc	#'>'
+		kphex	r4, 8		/* kernel execution address */
+		kputc	#'\n'
+#endif
+		.endm
+
+		.macro	debug_reloc_end
+#ifdef DEBUG
+		kphex	r5, 8		/* end of kernel */
+		kputc	#'\n'
+		mov	r0, r4
+		bl	memdump		/* dump 256 bytes at start of kernel */
+#endif
+		.endm
+
+		.section ".start", #alloc, #execinstr
+/*
+ * sort out different calling conventions
+ */
+		.align
+start:
+		.type	start,#function
+		.rept	8
+		mov	r0, r0
+		.endr
+
+		b	1f
+		.word	0x016f2818		@ Magic numbers to help the loader
+		.word	start			@ absolute load/run zImage address
+		.word	_edata			@ zImage end address
+1:		mov	r7, r1			@ save architecture ID
+		mov	r8, #0			@ save r0
+
+#ifndef __ARM_ARCH_2__
+		/*
+		 * Booting from Angel - need to enter SVC mode and disable
+		 * FIQs/IRQs (numeric definitions from angel arm.h source).
+		 * We only do this if we were in user mode on entry.
+		 */
+		mrs	r2, cpsr		@ get current mode
+		tst	r2, #3			@ not user?
+		bne	not_angel
+		mov	r0, #0x17		@ angel_SWIreason_EnterSVC
+		swi	0x123456		@ angel_SWI_ARM
+not_angel:
+		mrs	r2, cpsr		@ turn off interrupts to
+		orr	r2, r2, #0xc0		@ prevent angel from running
+		msr	cpsr_c, r2
+#else
+		teqp	pc, #0x0c000003		@ turn off interrupts
+#endif
+
+		/*
+		 * Note that some cache flushing and other stuff may
+		 * be needed here - is there an Angel SWI call for this?
+		 */
+
+		/*
+		 * some architecture specific code can be inserted
+		 * by the linker here, but it should preserve r7 and r8.
+		 */
+
+		.text
+		adr	r0, LC0
+		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}
+		subs	r0, r0, r1		@ calculate the delta offset
+
+						@ if delta is zero, we are
+		beq	not_relocated		@ running at the address we
+						@ were linked at.
+
+		/*
+		 * We're running at a different address.  We need to fix
+		 * up various pointers:
+		 *   r5 - zImage base address
+		 *   r6 - GOT start
+		 *   ip - GOT end
+		 */
+		add	r5, r5, r0
+		add	r6, r6, r0
+		add	ip, ip, r0
+
+#ifndef CONFIG_ZBOOT_ROM
+		/*
+		 * If we're running fully PIC === CONFIG_ZBOOT_ROM = n,
+		 * we need to fix up pointers into the BSS region.
+		 *   r2 - BSS start
+		 *   r3 - BSS end
+		 *   sp - stack pointer
+		 */
+		add	r2, r2, r0
+		add	r3, r3, r0
+		add	sp, sp, r0
+
+		/*
+		 * Relocate all entries in the GOT table.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		add	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#else
+
+		/*
+		 * Relocate entries in the GOT table.  We only relocate
+		 * the entries that are outside the (relocated) BSS region.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		cmp	r1, r2			@ entry < bss_start ||
+		cmphs	r3, r1			@ _end < entry
+		addlo	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#endif
+
+not_relocated:	mov	r0, #0
+1:		str	r0, [r2], #4		@ clear bss
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		cmp	r2, r3
+		blo	1b
+
+		/*
+		 * Reset Ethernet BDMA (before cache on)
+		 */
+		ldr	r3, =0x8000		@ BDMA reset
+		ldr	r2, =0x3FF9000		@ BDMATXCON
+		str	r3, [r2]
+		ldr	r2, =0x3FF9004		@ BDMARXCON
+		str	r3, [r2]
+
+		/*
+		 * The C runtime environment should now be setup
+		 * sufficiently.  Turn the cache on, set up some
+		 * pointers, and start decompressing.
+		 */
+		bl	cache_on
+
+		mov	r1, sp			@ malloc space above stack
+		add	r2, sp, #0x10000	@ 64k max
+
+/*
+ * Check to see if we will overwrite ourselves.
+ *   r4 = final kernel address
+ *   r5 = start of this image
+ *   r2 = end of malloc space (and therefore this image)
+ * We basically want:
+ *   r4 >= r2 -> OK
+ *   r4 + image length <= r5 -> OK
+ */
+		cmp	r4, r2
+		bhs	wont_overwrite
+		add	r0, r4, #4096*1024	@ 4MB largest kernel size
+		cmp	r0, r5
+		bls	wont_overwrite
+
+		mov	r5, r2			@ decompress after malloc space
+		mov	r0, r5
+		mov	r3, r7
+		bl	decompress_kernel
+
+		add	r0, r0, #127
+		bic	r0, r0, #127		@ align the kernel length
+/*
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		add	r1, r5, r0		@ end of decompressed kernel
+		adr	r2, reloc_start
+		ldr	r3, LC1
+		add	r3, r2, r3
+1:		ldmia	r2!, {r8 - r13}		@ copy relocation code
+		stmia	r1!, {r8 - r13}
+		ldmia	r2!, {r8 - r13}
+		stmia	r1!, {r8 - r13}
+		cmp	r2, r3
+		blo	1b
+
+		bl	cache_clean_flush
+		add	pc, r5, r0		@ call relocation code
+
+/*
+ * We're not in danger of overwriting ourselves.  Do this the simple way.
+ *
+ * r4     = kernel execution address
+ * r7     = architecture ID
+ */
+wont_overwrite:	mov	r0, r4
+		mov	r3, r7
+		bl	decompress_kernel
+		b	call_kernel
+
+		.type	LC0, #object
+LC0:		.word	LC0			@ r1
+		.word	__bss_start		@ r2
+		.word	_end			@ r3
+		.word	zreladdr		@ r4
+		.word	_start			@ r5
+		.word	_got_start		@ r6
+		.word	_got_end		@ ip
+		.word	user_stack+4096		@ sp
+LC1:		.word	reloc_end - reloc_start
+		.size	LC0, . - LC0
+
+/*
+ * Turn on the cache.  We need to setup some page tables so that we
+ * can have both the I and D caches on.
+ *
+ * We place the page tables 16k down from the kernel execution address,
+ * and we hope that nothing else is using it.  If we're using it, we
+ * will go pop!
+ *
+ * On entry,
+ *  r4 = kernel execution address
+ *  r6 = processor ID
+ *  r7 = architecture number
+ *  r8 = run-time address of "start"
+ * On exit,
+ *  r1, r2, r3, r8, r9, r12 corrupted
+ * This routine must preserve:
+ *  r4, r5, r6, r7
+ */
+		.align	5
+cache_on:
+		/* cache/write buffer on */
+		ldr	r0, =0x3FF0000		@ SYSCFG
+		ldr	r2, [r0]
+		orr	r2, r2, #6		@ Cache and write buffer
+		str	r2, [r0]
+		mov	pc, lr
+
+/*
+ * All code following this line is relocatable.  It is relocated by
+ * the above code to the end of the decompressed kernel image and
+ * executed there.  During this time, we have no stacks.
+ *
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		.align	5
+reloc_start:	add	r8, r5, r0
+		debug_reloc_start
+		mov	r1, r4
+1:
+		.rept	4
+		ldmia	r5!, {r0, r2, r3, r9 - r13}	@ relocate kernel
+		stmia	r1!, {r0, r2, r3, r9 - r13}
+		.endr
+
+		cmp	r5, r8
+		blo	1b
+		debug_reloc_end
+
+call_kernel:	bl	cache_clean_flush
+		bl	cache_off
+		mov	r0, #0
+		mov	r1, r7			@ restore architecture number
+		mov	pc, r4			@ call kernel
+
+
+/*
+ * Turn off the Cache and MMU.  ARMv3 does not support
+ * reading the control register, but ARMv4 does.
+ *
+ * On entry,  r6 = processor ID
+ * On exit,   r0, r1, r2, r3, r12 corrupted
+ * This routine must preserve: r4, r6, r7
+ */
+		.align	5
+cache_off:
+		/* cache/write buffer off */
+		ldr	r0, =0x3FF0000		@ SYSCFG
+		ldr	r2, [r0]
+		bic	r2, r2, #6		@ Cache and write buffer
+		str	r2, [r0]
+		mov	pc, lr
+/*
+ * Clean and flush the cache to maintain consistency.
+ *
+ * On entry,
+ *  r6 = processor ID
+ * On exit,
+ *  r1, r2, r3, r11, r12 corrupted
+ * This routine must preserve:
+ *  r0, r4, r5, r6, r7
+ */
+		.align	5
+cache_clean_flush:
+/*
+ * cf. Ch-5 of S3C4510 user's manual for
+ *     "Cache flush operation"
+ * To clear Tag RAM area.
+ */
+		ldr	r1, =0x11000000
+		mov	r2, #0
+		mov	r12, #256
+cache_flush_loop:
+		str	r2, [r1], #4
+		subs	r12, r12, #1
+		bne	cache_flush_loop
+		mov	pc, lr
+
+/*
+ * Various debugging routines for printing hex characters and
+ * memory, which again must be relocatable.
+ */
+#ifdef DEBUG
+		.type	phexbuf,#object
+phexbuf:	.space	12
+		.size	phexbuf, . - phexbuf
+
+phex:		adr	r3, phexbuf
+		mov	r2, #0
+		strb	r2, [r3, r1]
+1:		subs	r1, r1, #1
+		movmi	r0, r3
+		bmi	puts
+		and	r2, r0, #15
+		mov	r0, r0, lsr #4
+		cmp	r2, #10
+		addge	r2, r2, #7
+		add	r2, r2, #'0'
+		strb	r2, [r3, r1]
+		b	1b
+
+puts:		loadsp	r3
+1:		ldrb	r2, [r0], #1
+		teq	r2, #0
+		moveq	pc, lr
+2:		writeb	r2
+		mov	r1, #0x00020000
+3:		subs	r1, r1, #1
+		bne	3b
+		teq	r2, #'\n'
+		moveq	r2, #'\r'
+		beq	2b
+		teq	r0, #0
+		bne	1b
+		mov	pc, lr
+putc:
+		mov	r2, r0
+		mov	r0, #0
+		loadsp	r3
+		b	2b
+
+memdump:	mov	r12, r0
+		mov	r10, lr
+		mov	r11, #0
+2:		mov	r0, r11, lsl #2
+		add	r0, r0, r12
+		mov	r1, #8
+		bl	phex
+		mov	r0, #':'
+		bl	putc
+1:		mov	r0, #' '
+		bl	putc
+		ldr	r0, [r12, r11, lsl #2]
+		mov	r1, #8
+		bl	phex
+		and	r0, r11, #7
+		teq	r0, #3
+		moveq	r0, #' '
+		bleq	putc
+		and	r0, r11, #7
+		add	r11, r11, #1
+		teq	r0, #7
+		bne	1b
+		mov	r0, #'\n'
+		bl	putc
+		cmp	r11, #64
+		blt	2b
+		mov	pc, r10
+#endif
+
+reloc_end:
+
+		.align
+		.section ".stack", "w"
+user_stack:	.space	4096
diff -Naur linux-2.6.14-uc0/arch/arm/boot/compressed/head-p2001.S linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/head-p2001.S
--- linux-2.6.14-uc0/arch/arm/boot/compressed/head-p2001.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/head-p2001.S	2005-11-08 08:48:26.000000000 +0900
@@ -0,0 +1,383 @@
+/*
+ *  linux/arch/armnommu/boot/compressed/head-p2001.S
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+
+/*
+ * Debugging stuff
+ *
+ * Note that these macros must not contain any code which is not
+ * 100% relocatable.  Any attempt to do so will result in a crash.
+ * Please select one of the following when turning on debugging.
+ */
+#ifdef DEBUG
+		.macro	loadsp, rb
+		mov	\rb, #0x00140000	@ Adr_UART_OLD_BASE
+		.endm
+
+		.macro	writeb, rb
+		str	\rb, [r3, #0x00]	@ REL_Adr_Uart_TX1
+		.endm
+#endif
+
+		.macro	kputc,val
+		mov	r0, \val
+		bl	putc
+		.endm
+
+		.macro	kphex,val,len
+		mov	r0, \val
+		mov	r1, #\len
+		bl	phex
+		.endm
+
+		.macro	debug_reloc_start
+#ifdef DEBUG
+		kputc	#'\n'
+		kphex	r6, 8		/* processor id */
+		kputc	#':'
+		kphex	r7, 8		/* architecture id */
+		kputc	#'\n'
+		kphex	r5, 8		/* decompressed kernel start */
+		kputc	#'-'
+		kphex	r8, 8		/* decompressed kernel end  */
+		kputc	#'>'
+		kphex	r4, 8		/* kernel execution address */
+		kputc	#'\n'
+#endif
+		.endm
+
+		.macro	debug_reloc_end
+#ifdef DEBUG
+		kphex	r5, 8		/* end of kernel */
+		kputc	#'\n'
+		mov	r0, r4
+		bl	memdump		/* dump 256 bytes at start of kernel */
+#endif
+		.endm
+
+
+		.section ".start", #alloc, #execinstr
+/*
+ * sort out different calling conventions
+ */
+		.align
+start:
+		.type	start,#function
+		.rept	8
+		mov	r0, r0
+		.endr
+
+		b	1f
+		.word	0x016f2818		@ Magic numbers to help the loader
+		.word	start			@ absolute load/run zImage address
+		.word	_edata			@ zImage end address
+1:		mov	r7, r1			@ save architecture ID
+		mov	r8, #0			@ save r0
+
+		/*
+		 * Booting from P2001 - need to enter SVC mode and disable
+		 * FIQs/IRQs (numeric definitions from angel arm.h source).
+		 * We only do this if we were in user mode on entry.
+		 */
+		mrs	r2, cpsr		@ get current mode
+		orr	r2, r2, #0xc0		@ turn off interrupts
+		msr	cpsr_c, r2
+
+		/*
+		 * Note that some cache flushing and other stuff may
+		 * be needed here - is there an Angel SWI call for this?
+		 */
+
+		/*
+		 * some architecture specific code can be inserted
+		 * by the linker here, but it should preserve r7 and r8.
+		 */
+
+		.text
+		adr	r0, LC0
+		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}
+		subs	r0, r0, r1		@ calculate the delta offset
+
+						@ if delta is zero, we're
+		beq	not_relocated		@ running at the address we
+						@ were linked at.
+
+		/*
+		 * We're running at a different address.  We need to fix
+		 * up various pointers:
+		 *   r5 - zImage base address
+		 *   r6 - GOT start
+		 *   ip - GOT end
+		 */
+		add	r5, r5, r0
+		add	r6, r6, r0
+		add	ip, ip, r0
+
+#ifndef CONFIG_ZBOOT_ROM
+		/*
+		 * If we're running fully PIC === CONFIG_ZBOOT_ROM = n,
+		 * we need to fix up pointers into the BSS region.
+		 *   r2 - BSS start
+		 *   r3 - BSS end
+		 *   sp - stack pointer
+		 */
+		add	r2, r2, r0
+		add	r3, r3, r0
+		add	sp, sp, r0
+
+		/*
+		 * Relocate all entries in the GOT table.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		add	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#else
+
+		/*
+		 * Relocate entries in the GOT table.  We only relocate
+		 * the entries that are outside the (relocated) BSS region.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		cmp	r1, r2			@ entry < bss_start ||
+		cmphs	r3, r1			@ _end < entry
+		addlo	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#endif
+
+not_relocated:	mov	r0, #0
+1:		str	r0, [r2], #4		@ clear bss
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		cmp	r2, r3
+		blo	1b
+
+		/*
+		 * The C runtime environment should now be setup
+		 * sufficiently.  Set up some pointers, and start decompressing.
+		 */
+		mov	r1, sp			@ malloc space above stack
+		add	r2, sp, #0x10000	@ 64k max
+
+/*
+ * Check to see if we will overwrite ourselves.
+ *   r4 = final kernel address
+ *   r5 = start of this image
+ *   r2 = end of malloc space (and therefore this image)
+ * We basically want:
+ *   r4 >= r2 -> OK
+ *   r4 + image length <= r5 -> OK
+ */
+		cmp	r4, r2
+		bhs	wont_overwrite
+		add	r0, r4, #4096*1024	@ 4MB largest kernel size
+		cmp	r0, r5
+		bls	wont_overwrite
+
+		mov	r5, r2			@ decompress after malloc space
+		mov	r0, r5
+		mov	r3, r7
+		bl	decompress_kernel
+
+		add	r0, r0, #127
+		bic	r0, r0, #127		@ align the kernel length
+/*
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		add	r1, r5, r0		@ end of decompressed kernel
+		adr	r2, reloc_start
+		ldr	r3, LC1
+		add	r3, r2, r3
+1:		ldmia	r2!, {r8 - r13}		@ copy relocation code
+		stmia	r1!, {r8 - r13}
+		ldmia	r2!, {r8 - r13}
+		stmia	r1!, {r8 - r13}
+		cmp	r2, r3
+		blo	1b
+
+		add	pc, r5, r0		@ call relocation code
+
+/*
+ * We're not in danger of overwriting ourselves.  Do this the simple way.
+ *
+ * r4     = kernel execution address
+ * r7     = architecture ID
+ */
+wont_overwrite:	mov	r0, r4
+		mov	r3, r7
+		bl	decompress_kernel
+		b	call_kernel
+
+		.type	LC0, #object
+LC0:		.word	LC0			@ r1
+		.word	__bss_start		@ r2
+		.word	_end			@ r3
+		.word	_load_addr		@ r4
+		.word	_start			@ r5
+		.word	_got_start		@ r6
+		.word	_got_end		@ ip
+		.word	user_stack+4096		@ sp
+LC1:		.word	reloc_end - reloc_start
+		.size	LC0, . - LC0
+
+/*
+ * Initialise the page tables, turning on the cacheable and bufferable
+ * bits for the RAM area only.
+ */
+		mov	r0, r3
+		mov	r8, r0, lsr #18
+		mov	r8, r8, lsl #18		@ start of RAM
+		add	r9, r8, #0x10000000	@ a reasonable RAM size
+		mov	r1, #0x12
+		orr	r1, r1, #3 << 10
+		add	r2, r3, #16384
+1:		cmp	r1, r8			@ if virt > start of RAM
+		orrhs	r1, r1, #0x0c		@ set cacheable, bufferable
+		cmp	r1, r9			@ if virt > end of RAM
+		bichs	r1, r1, #0x0c		@ clear cacheable, bufferable
+		str	r1, [r0], #4		@ 1:1 mapping
+		add	r1, r1, #1048576
+		teq	r0, r2
+		bne	1b
+/*
+ * If ever we are running from Flash, then we surely want the cache
+ * to be enabled also for our execution instance...  We map 2MB of it
+ * so there is no map overlap problem for up to 1 MB compressed kernel.
+ * If the execution is in RAM then we would only be duplicating the above.
+ */
+		mov	r1, #0x1e
+		orr	r1, r1, #3 << 10
+		mov	r2, pc, lsr #20
+		orr	r1, r1, r2, lsl #20
+		add	r0, r3, r2, lsl #2
+		str	r1, [r0], #4
+		add	r1, r1, #1048576
+		str	r1, [r0]
+		mov	pc, lr
+
+/*
+ * All code following this line is relocatable.  It is relocated by
+ * the above code to the end of the decompressed kernel image and
+ * executed there.  During this time, we have no stacks.
+ *
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		.align	5
+reloc_start:	add	r8, r5, r0
+		debug_reloc_start
+		mov	r1, r4
+1:
+		.rept	4
+		ldmia	r5!, {r0, r2, r3, r9 - r13}	@ relocate kernel
+		stmia	r1!, {r0, r2, r3, r9 - r13}
+		.endr
+
+		cmp	r5, r8
+		blo	1b
+		debug_reloc_end
+
+call_kernel: 	mov	r0, #0
+		mov	r1, r7			@ restore architecture number
+		mov	pc, r4			@ call kernel
+
+/*
+ * Various debugging routines for printing hex characters and
+ * memory, which again must be relocatable.
+ */
+#ifdef DEBUG
+		.type	phexbuf,#object
+phexbuf:	.space	12
+		.size	phexbuf, . - phexbuf
+
+phex:		adr	r3, phexbuf
+		mov	r2, #0
+		strb	r2, [r3, r1]
+1:		subs	r1, r1, #1
+		movmi	r0, r3
+		bmi	puts
+		and	r2, r0, #15
+		mov	r0, r0, lsr #4
+		cmp	r2, #10
+		addge	r2, r2, #7
+		add	r2, r2, #'0'
+		strb	r2, [r3, r1]
+		b	1b
+
+puts:		loadsp	r3
+1:		ldrb	r2, [r0], #1
+		teq	r2, #0
+		moveq	pc, lr
+2:		writeb	r2
+		mov	r1, #0x00020000
+3:		subs	r1, r1, #1
+		bne	3b
+		teq	r2, #'\n'
+		moveq	r2, #'\r'
+		beq	2b
+		teq	r0, #0
+		bne	1b
+		mov	pc, lr
+putc:
+		mov	r2, r0
+		mov	r0, #0
+		loadsp	r3
+		b	2b
+
+memdump:	mov	r12, r0
+		mov	r10, lr
+		mov	r11, #0
+2:		mov	r0, r11, lsl #2
+		add	r0, r0, r12
+		mov	r1, #8
+		bl	phex
+		mov	r0, #':'
+		bl	putc
+1:		mov	r0, #' '
+		bl	putc
+		ldr	r0, [r12, r11, lsl #2]
+		mov	r1, #8
+		bl	phex
+		and	r0, r11, #7
+		teq	r0, #3
+		moveq	r0, #' '
+		bleq	putc
+		and	r0, r11, #7
+		add	r11, r11, #1
+		teq	r0, #7
+		bne	1b
+		mov	r0, #'\n'
+		bl	putc
+		cmp	r11, #64
+		blt	2b
+		mov	pc, r10
+#endif
+
+reloc_end:
+
+		.align
+		.section ".stack", "w"
+user_stack:	.space	4096
diff -Naur linux-2.6.14-uc0/arch/arm/boot/compressed/head.S linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/head.S
--- linux-2.6.14-uc0/arch/arm/boot/compressed/head.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/head.S	2005-11-08 08:48:27.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/arch/arm/boot/compressed/head.S
  *
  *  Copyright (C) 1996-2002 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi (MPU support)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -326,6 +327,71 @@
 cache_on:	mov	r3, #8			@ cache_on function
 		b	call_cache_fn
 
+/*
+ * Initialize the the highest priority protection region, PR7
+ * to all 32bit address, cacheable and bufferable.
+ */
+__armv4_mpu_setup:
+		mov	r0, #0x3f		@ 4G, the whole
+		mcr	p15, 0, r0, c6, c7, 0	@ PR7 Area Setting
+		mcr 	p15, 0, r0, c6, c7, 1
+
+		mov	r0, #0x80		@ PR7
+		mcr	p15, 0, r0, c2, c0, 0	@ D-cache on
+		mcr	p15, 0, r0, c2, c0, 1	@ I-cache on
+		mcr	p15, 0, r0, c3, c0, 0	@ write-buffer on
+
+		mov	r0, #0xc000
+		mcr	p15, 0, r0, c5, c0, 1	@ I-access permission
+		mcr	p15, 0, r0, c5, c0, 0	@ D-access permission
+		mov	pc, lr
+
+__armv3_mpu_setup:
+		mov	r0, #0x3f		@ 4G, the whole
+		mcr	p15, 0, r0, c6, c7, 0	@ PR7 Area Setting
+
+		mov	r0, #0x80		@ PR7
+		mcr	p15, 0, r0, c2, c0, 0	@ cache on
+		mcr	p15, 0, r0, c3, c0, 0	@ write-buffer on
+
+		mov	r0, #0xc000
+		mcr	p15, 0, r0, c5, c0, 0	@ access permission
+		mov	pc, lr
+
+
+__armv4_mpu_cache_on:
+		mov	r12, lr
+		bl	__armv4_mpu_setup
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
+		mcr	p15, 0, r0, c7, c6, 0	@ flush D-Cache
+		mcr	p15, 0, r0, c7, c5, 0	@ flush I-Cache
+		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
+						@ ...I .... ..D. WC.M
+		orr	r0, r0, #0x002d		@ .... .... ..1. 11.1
+		orr	r0, r0, #0x1000		@ ...1 .... .... ....
+
+		mcr	p15, 0, r0, c1, c0, 0	@ write control reg
+
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c6, 0	@ flush D-Cache
+		mcr	p15, 0, r0, c7, c5, 0	@ flush I-Cache
+		mov	pc, r12
+
+__armv3_mpu_cache_on:
+		mov	r12, lr
+		bl	__armv3_mpu_setup
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
+		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
+						@ .... .... .... WC.M
+		orr	r0, r0, #0x000d		@ .... .... .... 11.1
+		mov	r0, #0
+		mcr	p15, 0, r0, c1, c0, 0	@ write control reg
+
+		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
+		mov	pc, r12
+
 __setup_mmu:	sub	r3, r4, #16384		@ Page directory size
 		bic	r3, r3, #0xff		@ Align the pointer
 		bic	r3, r3, #0x3f00
@@ -364,7 +430,7 @@
 		str	r1, [r0]
 		mov	pc, lr
 
-__armv4_cache_on:
+__armv4_mmu_cache_on:
 		mov	r12, lr
 		bl	__setup_mmu
 		mov	r0, #0
@@ -373,24 +439,24 @@
 		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
 		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
 		orr	r0, r0, #0x0030
-		bl	__common_cache_on
+		bl	__common_mmu_cache_on
 		mov	r0, #0
 		mcr	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
 		mov	pc, r12
 
-__arm6_cache_on:
+__arm6_mmu_cache_on:
 		mov	r12, lr
 		bl	__setup_mmu
 		mov	r0, #0
 		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
 		mcr	p15, 0, r0, c5, c0, 0	@ invalidate whole TLB v3
 		mov	r0, #0x30
-		bl	__common_cache_on
+		bl	__common_mmu_cache_on
 		mov	r0, #0
 		mcr	p15, 0, r0, c5, c0, 0	@ invalidate whole TLB v3
 		mov	pc, r12
 
-__common_cache_on:
+__common_mmu_cache_on:
 #ifndef DEBUG
 		orr	r0, r0, #0x000d		@ Write buffer, mmu
 #endif
@@ -475,12 +541,12 @@
 proc_types:
 		.word	0x41560600		@ ARM6/610
 		.word	0xffffffe0
-		b	__arm6_cache_off	@ works, but slow
-		b	__arm6_cache_off
+		b	__arm6_mmu_cache_off	@ works, but slow
+		b	__arm6_mmu_cache_off
 		mov	pc, lr
-@		b	__arm6_cache_on		@ untested
-@		b	__arm6_cache_off
-@		b	__armv3_cache_flush
+@		b	__arm6_mmu_cache_on		@ untested
+@		b	__arm6_mmu_cache_off
+@		b	__armv3_mmu_cache_flush
 
 		.word	0x00000000		@ old ARM ID
 		.word	0x0000f000
@@ -490,15 +556,26 @@
 
 		.word	0x41007000		@ ARM7/710
 		.word	0xfff8fe00
-		b	__arm7_cache_off
-		b	__arm7_cache_off
+		b	__arm7_mmu_cache_off
+		b	__arm7_mmu_cache_off
 		mov	pc, lr
 
 		.word	0x41807200		@ ARM720T (writethrough)
 		.word	0xffffff00
-		b	__armv4_cache_on
-		b	__armv4_cache_off
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
 		mov	pc, lr
+		.word	0x41007400		@ ARM74x
+		.word	0xff00ff00
+		b	__armv3_mpu_cache_on
+		b	__armv3_mpu_cache_off
+		b	__armv3_mpu_cache_flush
+		
+		.word	0x41009400		@ ARM94x
+		.word	0xff00ff00
+		b	__armv4_mpu_cache_on
+		b	__armv4_mpu_cache_off
+		b	__armv4_mpu_cache_flush
 
 		.word	0x00007000		@ ARM7 IDs
 		.word	0x0000f000
@@ -510,41 +587,41 @@
 
 		.word	0x4401a100		@ sa110 / sa1100
 		.word	0xffffffe0
-		b	__armv4_cache_on
-		b	__armv4_cache_off
-		b	__armv4_cache_flush
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
 
 		.word	0x6901b110		@ sa1110
 		.word	0xfffffff0
-		b	__armv4_cache_on
-		b	__armv4_cache_off
-		b	__armv4_cache_flush
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
 
 		@ These match on the architecture ID
 
 		.word	0x00020000		@ ARMv4T
 		.word	0x000f0000
-		b	__armv4_cache_on
-		b	__armv4_cache_off
-		b	__armv4_cache_flush
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
 
 		.word	0x00050000		@ ARMv5TE
 		.word	0x000f0000
-		b	__armv4_cache_on
-		b	__armv4_cache_off
-		b	__armv4_cache_flush
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
 
 		.word	0x00060000		@ ARMv5TEJ
 		.word	0x000f0000
-		b	__armv4_cache_on
-		b	__armv4_cache_off
-		b	__armv4_cache_flush
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
 
 		.word	0x00070000		@ ARMv6
 		.word	0x000f0000
-		b	__armv4_cache_on
-		b	__armv4_cache_off
-		b	__armv6_cache_flush
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv6_mmu_cache_flush
 
 		.word	0			@ unrecognised type
 		.word	0
@@ -566,7 +643,25 @@
 cache_off:	mov	r3, #12			@ cache_off function
 		b	call_cache_fn
 
-__armv4_cache_off:
+__armv4_mpu_cache_off:
+		mrc	p15, 0, r0, c1, c0
+		bic	r0, r0, #0x000d
+		mcr	p15, 0, r0, c1, c0	@ turn MPU and cache off
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
+		mcr	p15, 0, r0, c7, c6, 0	@ flush D-Cache
+		mcr	p15, 0, r0, c7, c5, 0	@ flush I-Cache
+		mov	pc, lr
+
+__armv3_mpu_cache_off:
+		mrc	p15, 0, r0, c1, c0
+		bic	r0, r0, #0x000d
+		mcr	p15, 0, r0, c1, c0, 0	@ turn MPU and cache off
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
+		mov	pc, lr
+
+__armv4_mmu_cache_off:
 		mrc	p15, 0, r0, c1, c0
 		bic	r0, r0, #0x000d
 		mcr	p15, 0, r0, c1, c0	@ turn MMU and cache off
@@ -575,15 +670,15 @@
 		mcr	p15, 0, r0, c8, c7	@ invalidate whole TLB v4
 		mov	pc, lr
 
-__arm6_cache_off:
+__arm6_mmu_cache_off:
 		mov	r0, #0x00000030		@ ARM6 control reg.
-		b	__armv3_cache_off
+		b	__armv3_mmu_cache_off
 
-__arm7_cache_off:
+__arm7_mmu_cache_off:
 		mov	r0, #0x00000070		@ ARM7 control reg.
-		b	__armv3_cache_off
+		b	__armv3_mmu_cache_off
 
-__armv3_cache_off:
+__armv3_mmu_cache_off:
 		mcr	p15, 0, r0, c1, c0, 0	@ turn MMU and cache off
 		mov	r0, #0
 		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
@@ -605,7 +700,25 @@
 		mov	r3, #16
 		b	call_cache_fn
 
-__armv6_cache_flush:
+__armv4_mpu_cache_flush:
+		mov	r2, #1
+		mov	r3, #0
+		mcr	p15, 0, ip, c7, c6, 0	@ invalidate D cache
+		mov	r1, #7 << 5		@ 8 segments
+1:		orr	r3, r1, #63 << 26	@ 64 entries
+2:		mcr	p15, 0, r3, c7, c14, 2	@ clean & invalidate D index
+		subs	r3, r3, #1 << 26
+		bcs	2b			@ entries 63 to 0
+		subs 	r1, r1, #1 << 5
+		bcs	1b			@ segments 7 to 0
+
+		teq	r2, #0
+		mcrne	p15, 0, ip, c7, c5, 0	@ invalidate I cache
+		mcr	p15, 0, ip, c7, c10, 4	@ drain WB
+		mov	pc, lr
+		
+
+__armv6_mmu_cache_flush:
 		mov	r1, #0
 		mcr	p15, 0, r1, c7, c14, 0	@ clean+invalidate D
 		mcr	p15, 0, r1, c7, c5, 0	@ invalidate I+BTB
@@ -613,7 +726,7 @@
 		mcr	p15, 0, r1, c7, c10, 4	@ drain WB
 		mov	pc, lr
 
-__armv4_cache_flush:
+__armv4_mmu_cache_flush:
 		mov	r2, #64*1024		@ default: 32K dcache size (*2)
 		mov	r11, #32		@ default: 32 byte line size
 		mrc	p15, 0, r3, c0, c0, 1	@ read cache type
@@ -641,7 +754,8 @@
 		mcr	p15, 0, r1, c7, c10, 4	@ drain WB
 		mov	pc, lr
 
-__armv3_cache_flush:
+__armv3_mmu_cache_flush:
+__armv3_mpu_cache_flush:
 		mov	r1, #0
 		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
 		mov	pc, lr
diff -Naur linux-2.6.14-uc0/arch/arm/boot/compressed/head-s3c44b0.S linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/head-s3c44b0.S
--- linux-2.6.14-uc0/arch/arm/boot/compressed/head-s3c44b0.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/head-s3c44b0.S	2005-11-08 08:48:26.000000000 +0900
@@ -0,0 +1,372 @@
+/*
+ *  linux/arch/armnommu/boot/compressed/head.S
+ *
+ *  Copyright (C) 1996-2002 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi (MPU support)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/mach-types.h>
+
+/*
+ * Debugging stuff
+ *
+ * Note that these macros must not contain any code which is not
+ * 100% relocatable.  Any attempt to do so will result in a crash.
+ * Please select one of the following when turning on debugging.
+ */
+
+		.macro	kputc,val
+		mov	r0, \val
+		bl	putc
+		.endm
+
+		.macro	kphex,val,len
+		mov	r0, \val
+		mov	r1, #\len
+		bl	phex
+		.endm
+
+		.macro	debug_reloc_start
+#ifdef DEBUG
+		kputc	#'\n'
+		kphex	r6, 8		/* processor id */
+		kputc	#':'
+		kphex	r7, 8		/* architecture id */
+		kputc	#':'
+		mrc	p15, 0, r0, c1, c0
+		kphex	r0, 8		/* control reg */
+		kputc	#'\n'
+		kphex	r5, 8		/* decompressed kernel start */
+		kputc	#'-'
+		kphex	r8, 8		/* decompressed kernel end  */
+		kputc	#'>'
+		kphex	r4, 8		/* kernel execution address */
+		kputc	#'\n'
+#endif
+		.endm
+
+		.macro	debug_reloc_end
+#ifdef DEBUG
+		kphex	r5, 8		/* end of kernel */
+		kputc	#'\n'
+		mov	r0, r4
+		bl	memdump		/* dump 256 bytes at start of kernel */
+#endif
+		.endm
+
+		.section ".start", #alloc, #execinstr
+/*
+ * sort out different calling conventions
+ */
+		.align
+start:
+		.type	start,#function
+		.rept	8
+		mov	r0, r0
+		.endr
+
+		b	1f
+		.word	0x016f2818		@ Magic numbers to help the loader
+		.word	start			@ absolute load/run zImage address
+		.word	_edata			@ zImage end address
+1:		mov	r7, r1			@ save architecture ID
+		mov	r8, #0			@ save r0
+
+#ifndef __ARM_ARCH_2__
+		/*
+		 * Booting from Angel - need to enter SVC mode and disable
+		 * FIQs/IRQs (numeric definitions from angel arm.h source).
+		 * We only do this if we were in user mode on entry.
+		 */
+		mrs	r2, cpsr		@ get current mode
+		tst	r2, #3			@ not user?
+		bne	not_angel
+		mov	r0, #0x17		@ angel_SWIreason_EnterSVC
+		swi	0x123456		@ angel_SWI_ARM
+not_angel:
+		mrs	r2, cpsr		@ turn off interrupts to
+		orr	r2, r2, #0xc0		@ prevent angel from running
+		msr	cpsr_c, r2
+#else
+		teqp	pc, #0x0c000003		@ turn off interrupts
+#endif
+
+		/*
+		 * Note that some cache flushing and other stuff may
+		 * be needed here - is there an Angel SWI call for this?
+		 */
+
+		/*
+		 * some architecture specific code can be inserted
+		 * by the linker here, but it should preserve r7 and r8.
+		 */
+
+		.text
+		adr	r0, LC0
+		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}
+		subs	r0, r0, r1		@ calculate the delta offset
+
+						@ if delta is zero, we're
+		beq	not_relocated		@ running at the address we
+						@ were linked at.
+
+		/*
+		 * We're running at a different address.  We need to fix
+		 * up various pointers:
+		 *   r5 - zImage base address
+		 *   r6 - GOT start
+		 *   ip - GOT end
+		 */
+		add	r5, r5, r0
+		add	r6, r6, r0
+		add	ip, ip, r0
+
+#ifndef CONFIG_ZBOOT_ROM
+		/*
+		 * If we're running fully PIC === CONFIG_ZBOOT_ROM = n,
+		 * we need to fix up pointers into the BSS region.
+		 *   r2 - BSS start
+		 *   r3 - BSS end
+		 *   sp - stack pointer
+		 */
+		add	r2, r2, r0
+		add	r3, r3, r0
+		add	sp, sp, r0
+
+		/*
+		 * Relocate all entries in the GOT table.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		add	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#else
+
+		/*
+		 * Relocate entries in the GOT table.  We only relocate
+		 * the entries that are outside the (relocated) BSS region.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		cmp	r1, r2			@ entry < bss_start ||
+		cmphs	r3, r1			@ _end < entry
+		addlo	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#endif
+
+not_relocated:	mov	r0, #0
+1:		str	r0, [r2], #4		@ clear bss
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		cmp	r2, r3
+		blo	1b
+
+		/*
+		 * The C runtime environment should now be setup
+		 * sufficiently.  Turn the cache on, set up some
+		 * pointers, and start decompressing.
+		 */
+
+		mov	r1, sp			@ malloc space above stack
+		add	r2, sp, #0x10000	@ 64k max
+
+/*
+ * Check to see if we will overwrite ourselves.
+ *   r4 = final kernel address
+ *   r5 = start of this image
+ *   r2 = end of malloc space (and therefore this image)
+ * We basically want:
+ *   r4 >= r2 -> OK
+ *   r4 + image length <= r5 -> OK
+ */
+		cmp	r4, r2
+		bhs	wont_overwrite
+		add	r0, r4, #4096*1024	@ 4MB largest kernel size
+		cmp	r0, r5
+		bls	wont_overwrite
+
+		mov	r5, r2			@ decompress after malloc space
+		mov	r0, r5
+		mov	r3, r7
+		bl	decompress_kernel
+
+		add	r0, r0, #127
+		bic	r0, r0, #127		@ align the kernel length
+/*
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		add	r1, r5, r0		@ end of decompressed kernel
+		adr	r2, reloc_start
+		ldr	r3, LC1
+		add	r3, r2, r3
+1:		ldmia	r2!, {r8 - r13}		@ copy relocation code
+		stmia	r1!, {r8 - r13}
+		ldmia	r2!, {r8 - r13}
+		stmia	r1!, {r8 - r13}
+		cmp	r2, r3
+		blo	1b
+
+		add	pc, r5, r0		@ call relocation code
+
+/*
+ * We're not in danger of overwriting ourselves.  Do this the simple way.
+ *
+ * r4     = kernel execution address
+ * r7     = architecture ID
+ */
+wont_overwrite:	mov	r0, r4
+		mov	r3, r7
+		bl	decompress_kernel
+		b	call_kernel
+
+		.type	LC0, #object
+LC0:		.word	LC0			@ r1
+		.word	__bss_start		@ r2
+		.word	_end			@ r3
+		.word	_load_addr		@ r4
+		.word	_start			@ r5
+		.word	_got_start		@ r6
+		.word	_got_end		@ ip
+		.word	user_stack+4096		@ sp
+LC1:		.word	reloc_end - reloc_start
+		.size	LC0, . - LC0
+
+/*
+ * All code following this line is relocatable.  It is relocated by
+ * the above code to the end of the decompressed kernel image and
+ * executed there.  During this time, we have no stacks.
+ *
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		.align	5
+reloc_start:	add	r8, r5, r0
+		debug_reloc_start
+		mov	r1, r4
+1:
+		.rept	4
+		ldmia	r5!, {r0, r2, r3, r9 - r13}	@ relocate kernel
+		stmia	r1!, {r0, r2, r3, r9 - r13}
+		.endr
+
+		cmp	r5, r8
+		blo	1b
+		debug_reloc_end
+
+call_kernel: 	
+
+#ifdef CONFIG_ARCH_S3C44B0
+		ldr	r2, S3C44B0_PROCESSOR_TYPE
+		str     r2, [r6]
+		ldr     r2, S3C44B0_MACH_TYPE
+		str     r2, [r9]
+        	mov 	fp, #0
+		b 	1f
+S3C44B0_PROCESSOR_TYPE:
+	.long	0x44b07700
+S3C44B0_MACH_TYPE:
+	.long	MACH_TYPE_S3C44B0
+
+1:
+#endif
+
+		mov	r0, #0
+		mov	r1, r7			@ restore architecture number
+		mov	pc, r4			@ call kernel
+
+/*
+ * Various debugging routines for printing hex characters and
+ * memory, which again must be relocatable.
+ */
+#ifdef DEBUG
+		.type	phexbuf,#object
+phexbuf:	.space	12
+		.size	phexbuf, . - phexbuf
+
+phex:		adr	r3, phexbuf
+		mov	r2, #0
+		strb	r2, [r3, r1]
+1:		subs	r1, r1, #1
+		movmi	r0, r3
+		bmi	puts
+		and	r2, r0, #15
+		mov	r0, r0, lsr #4
+		cmp	r2, #10
+		addge	r2, r2, #7
+		add	r2, r2, #'0'
+		strb	r2, [r3, r1]
+		b	1b
+
+puts:		loadsp	r3
+1:		ldrb	r2, [r0], #1
+		teq	r2, #0
+		moveq	pc, lr
+2:		writeb	r2
+		mov	r1, #0x00020000
+3:		subs	r1, r1, #1
+		bne	3b
+		teq	r2, #'\n'
+		moveq	r2, #'\r'
+		beq	2b
+		teq	r0, #0
+		bne	1b
+		mov	pc, lr
+putc:
+		mov	r2, r0
+		mov	r0, #0
+		loadsp	r3
+		b	2b
+
+memdump:	mov	r12, r0
+		mov	r10, lr
+		mov	r11, #0
+2:		mov	r0, r11, lsl #2
+		add	r0, r0, r12
+		mov	r1, #8
+		bl	phex
+		mov	r0, #':'
+		bl	putc
+1:		mov	r0, #' '
+		bl	putc
+		ldr	r0, [r12, r11, lsl #2]
+		mov	r1, #8
+		bl	phex
+		and	r0, r11, #7
+		teq	r0, #3
+		moveq	r0, #' '
+		bleq	putc
+		and	r0, r11, #7
+		add	r11, r11, #1
+		teq	r0, #7
+		bne	1b
+		mov	r0, #'\n'
+		bl	putc
+		cmp	r11, #64
+		blt	2b
+		mov	pc, r10
+#endif
+
+reloc_end:
+
+		.align
+		.section ".stack", "w"
+user_stack:	.space	4096
diff -Naur linux-2.6.14-uc0/arch/arm/boot/compressed/Makefile linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/Makefile
--- linux-2.6.14-uc0/arch/arm/boot/compressed/Makefile	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/boot/compressed/Makefile	2005-11-09 16:09:21.000000000 +0900
@@ -42,6 +42,17 @@
 OBJS		+= head-sa1100.o
 endif
 
+ifeq ($(CONFIG_ARCH_S3C44B0),y)
+HEAD		= head-s3c44b0.o
+endif
+
+ifeq ($(CONFIG_ARCH_P2001),y)
+HEAD		= head-p2001.o
+endif
+
+ifeq ($(CONFIG_ARCH_ESPD_4510B),y)
+HEAD		= head-espd_4510b.o
+endif
 ifeq ($(CONFIG_CPU_XSCALE),y)
 OBJS		+= head-xscale.o
 endif
diff -Naur linux-2.6.14-uc0/arch/arm/configs/atmel_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/atmel_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/atmel_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/atmel_defconfig	2005-11-08 08:48:30.000000000 +0900
@@ -0,0 +1,482 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc3-mm3-hsc0
+# Fri May  6 20:17:25 2005
+#
+CONFIG_ARM=y
+# CONFIG_MMU is not set
+# CONFIG_MPU is not set
+CONFIG_NO_MU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_S5C7375 is not set
+# CONFIG_ARCH_S3C24A0 is not set
+# CONFIG_ARCH_S3C2500 is not set
+CONFIG_ARCH_ATMEL=y
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
+# CONFIG_ARCH_P2001 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x01000000
+CONFIG_DRAM_SIZE=0x00400000
+CONFIG_FLASH_MEM_BASE=0x01400000
+CONFIG_FLASH_SIZE=0x00400000
+# CONFIG_ARCH_SUPPORTS_BIG_ENDIAN is not set
+
+#
+# ATMEL Options
+#
+CONFIG_ARM_CLK=40000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_MEM16_BASE=0x03000000
+CONFIG_MEM8_BASE=0x03000000
+CONFIG_IO16_BASE=0x02000000
+CONFIG_IO8_BASE=0x02000000
+CONFIG_CPU_AT91X40=y
+# CONFIG_CPU_AT91X63 is not set
+# CONFIG_ATMEL_DEBUG is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM7TDMI=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_CACHE_V4=y
+CONFIG_CPU_HAS_NO_CP15=y
+
+#
+# Processor Features
+#
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/ram initrd=0x01300000,768K keepinitrd"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=2048
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_KGDBOE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_DCC is not set
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISER4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_SYSFS is not set
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+CONFIG_DEBUG_PREEMPT=y
+CONFIG_DEBUG_SPINLOCK=y
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_WAITQ=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.14-uc0/arch/arm/configs/espd_4510b_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/espd_4510b_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/espd_4510b_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/espd_4510b_defconfig	2005-11-08 08:48:29.000000000 +0900
@@ -0,0 +1,649 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc3-mm3-hsc0
+# Fri May  6 20:27:49 2005
+#
+CONFIG_ARM=y
+# CONFIG_MMU is not set
+# CONFIG_MPU is not set
+CONFIG_NO_MU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_S5C7375 is not set
+# CONFIG_ARCH_S3C24A0 is not set
+# CONFIG_ARCH_S3C2500 is not set
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+CONFIG_ARCH_ESPD_4510B=y
+# CONFIG_ARCH_S3C44B0 is not set
+# CONFIG_ARCH_P2001 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x00000000
+CONFIG_DRAM_SIZE=0x01000000
+CONFIG_FLASH_MEM_BASE=0x01800000
+CONFIG_FLASH_SIZE=0x00200000
+CONFIG_ARM_CLK=50000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_REMAP_VECTORS_TO_RAM=y
+
+#
+# ESPD_4510B Options
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_S3C4510B=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_HAS_NO_CP15=y
+
+#
+# Processor Features
+#
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,19200 root=/dev/ram0 rw initrd=0xA00000,2048K keepinitrd ip=192.168.5.7:192.168.5.103:192.168.5.103:255.255.255.0:ARM7:eth0:any elevator=noop"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+CONFIG_BINFMT_SHARED_FLAT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_UNIX is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_KGDBOE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_ETH_S3C4510B=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_DCC is not set
+CONFIG_SERIAL_S3C4510B=y
+CONFIG_SERIAL_S3C4510B_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISER4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_WAITQ=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.14-uc0/arch/arm/configs/GDB_ARMulator_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/GDB_ARMulator_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/GDB_ARMulator_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/GDB_ARMulator_defconfig	2005-11-08 08:48:27.000000000 +0900
@@ -0,0 +1,482 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc3-mm3-hsc0
+# Fri May  6 20:17:25 2005
+#
+CONFIG_ARM=y
+# CONFIG_MMU is not set
+# CONFIG_MPU is not set
+CONFIG_NO_MU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_S5C7375 is not set
+# CONFIG_ARCH_S3C24A0 is not set
+# CONFIG_ARCH_S3C2500 is not set
+CONFIG_ARCH_ATMEL=y
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
+# CONFIG_ARCH_P2001 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x01000000
+CONFIG_DRAM_SIZE=0x00400000
+CONFIG_FLASH_MEM_BASE=0x01400000
+CONFIG_FLASH_SIZE=0x00400000
+# CONFIG_ARCH_SUPPORTS_BIG_ENDIAN is not set
+
+#
+# ATMEL Options
+#
+CONFIG_ARM_CLK=40000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_MEM16_BASE=0x03000000
+CONFIG_MEM8_BASE=0x03000000
+CONFIG_IO16_BASE=0x02000000
+CONFIG_IO8_BASE=0x02000000
+CONFIG_CPU_AT91X40=y
+# CONFIG_CPU_AT91X63 is not set
+# CONFIG_ATMEL_DEBUG is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM7TDMI=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_CACHE_V4=y
+CONFIG_CPU_HAS_NO_CP15=y
+
+#
+# Processor Features
+#
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/ram initrd=0x01300000,768K keepinitrd"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=2048
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_KGDBOE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_DCC is not set
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISER4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_SYSFS is not set
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+CONFIG_DEBUG_PREEMPT=y
+CONFIG_DEBUG_SPINLOCK=y
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_WAITQ=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.14-uc0/arch/arm/configs/omnimeter_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/omnimeter_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/omnimeter_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/omnimeter_defconfig	2005-11-08 08:48:30.000000000 +0900
@@ -0,0 +1,803 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc1-bk2
+# Sun Mar 27 21:31:45 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+CONFIG_ARCH_SA1100=y
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+
+#
+# SA11x0 Implementations
+#
+# CONFIG_SA1100_ASSABET is not set
+# CONFIG_SA1100_CERF is not set
+# CONFIG_SA1100_COLLIE is not set
+# CONFIG_SA1100_H3100 is not set
+# CONFIG_SA1100_H3600 is not set
+# CONFIG_SA1100_H3800 is not set
+# CONFIG_SA1100_BADGE4 is not set
+# CONFIG_SA1100_JORNADA720 is not set
+# CONFIG_SA1100_HACKKIT is not set
+# CONFIG_SA1100_LART is not set
+# CONFIG_SA1100_PLEB is not set
+# CONFIG_SA1100_SHANNON is not set
+# CONFIG_SA1100_SIMPAD is not set
+# CONFIG_SA1100_SSP is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_SA1100=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4=y
+CONFIG_CPU_CACHE_V4WB=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_TLB_V4WB=y
+CONFIG_CPU_MINICACHE=y
+
+#
+# Processor Features
+#
+
+#
+# Bus support
+#
+CONFIG_ISA=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+
+#
+# PC-card bridges
+#
+CONFIG_I82365=y
+# CONFIG_TCIC is not set
+CONFIG_PCMCIA_SA1100=y
+CONFIG_PCCARD_NONSTATIC=y
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+CONFIG_DISCONTIGMEM=y
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="keepinitrd mem=16M root=/dev/ram ramdisk=8192 initrd=0xd0000000,4M"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_SMC91X is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ARLAN is not set
+# CONFIG_WAVELAN is not set
+CONFIG_PCMCIA_WAVELAN=y
+# CONFIG_PCMCIA_NETWAVE is not set
+
+#
+# Wireless 802.11 Frequency Hopping cards support
+#
+# CONFIG_PCMCIA_RAYCS is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+# CONFIG_HERMES is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wireless 802.11b Pcmcia/Cardbus cards support
+#
+CONFIG_AIRO_CS=y
+CONFIG_PCMCIA_WL3501=y
+CONFIG_NET_WIRELESS=y
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+CONFIG_PCMCIA_3C589=y
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=y
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_AXNET is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_INPORT is not set
+# CONFIG_MOUSE_LOGIBM is not set
+# CONFIG_MOUSE_PC110PAD is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SA1100=y
+CONFIG_SERIAL_SA1100_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SOFT_CURSOR=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_SA1100=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+# CONFIG_VFAT_FS is not set
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.14-uc0/arch/arm/configs/p2001_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/p2001_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/p2001_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/p2001_defconfig	2005-11-08 08:48:29.000000000 +0900
@@ -0,0 +1,634 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc3-mm3-hsc0
+# Fri May  6 20:58:26 2005
+#
+CONFIG_ARM=y
+# CONFIG_MMU is not set
+# CONFIG_MPU is not set
+CONFIG_NO_MU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_KOBJECT_UEVENT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_S5C7375 is not set
+# CONFIG_ARCH_S3C24A0 is not set
+# CONFIG_ARCH_S3C2500 is not set
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
+CONFIG_ARCH_P2001=y
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x40000000
+CONFIG_DRAM_SIZE=0x01000000
+CONFIG_FLASH_MEM_BASE=0x02000000
+CONFIG_FLASH_SIZE=0x00400000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+
+#
+# P2001 Options
+#
+CONFIG_SYSCLK=73728000
+CONFIG_P2001_AUTO_DETECT_SDRAM=y
+CONFIG_P2001_WATCHDOG=y
+# CONFIG_P2001_TIMER2_LED_FREQ_INDICATOR is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM9TDMI=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_CACHE_V4=y
+CONFIG_CPU_HAS_NO_CP15=y
+
+#
+# Processor Features
+#
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="ip=dhcp root=/dev/nfs console=ttyS0,57600n8"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=m
+CONFIG_CPU_FREQ_GOV_ONDEMAND=m
+CONFIG_CPU_FREQ_P2001=m
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+CONFIG_BINFMT_SHARED_FLAT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+CONFIG_DEBUG_DRIVER=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_MULTIPLE_TABLES is not set
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IP_TCPDIAG is not set
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_KGDBOE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_P2001_ETH=y
+# CONFIG_P2001_ETH_RMII is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_DCC is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_P2001_UART=y
+CONFIG_SERIAL_P2001_UART_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=64
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISER4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_WAITQ=y
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.14-uc0/arch/arm/configs/realview_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/realview_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/realview_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/realview_defconfig	2005-11-08 08:48:29.000000000 +0900
@@ -0,0 +1,789 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14-rc2
+# Thu Sep 29 14:50:10 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+# CONFIG_EXPERIMENTAL is not set
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+CONFIG_ARCH_REALVIEW=y
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+
+#
+# RealView platform type
+#
+CONFIG_MACH_REALVIEW_EB=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+# CONFIG_CPU_V6 is not set
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_GIC=y
+CONFIG_ICST307=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs nfsroot=10.1.69.3:/work/nfsroot ip=dhcp console=ttyAMA0 mem=128M"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ARM_INTEGRATOR=y
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_SMC91X=y
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SOFT_CURSOR=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+# CONFIG_SND_ARMAACI is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.14-uc0/arch/arm/configs/s3c24a0_mmu_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/s3c24a0_mmu_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/s3c24a0_mmu_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/s3c24a0_mmu_defconfig	2005-11-08 08:48:30.000000000 +0900
@@ -0,0 +1,522 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc3-mm2-hsc0
+# Wed May  4 09:09:31 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+# CONFIG_MPU is not set
+# CONFIG_NO_MU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_S5C7375 is not set
+CONFIG_ARCH_S3C24A0=y
+# CONFIG_ARCH_S3C2500 is not set
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
+# CONFIG_ARCH_P2001 is not set
+
+#
+# S3C24A0 Implementations
+#
+CONFIG_ARCH_SMDK24A0=y
+CONFIG_ARCH_SPJ=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+CONFIG_ISA=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/ram initrd=0x10800000,4M keepinitrd"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_KGDBOE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_DCC=y
+CONFIG_SERIAL_DCC_CONSOLE=y
+# CONFIG_SERIAL_S3C24A0 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISER4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.14-uc0/arch/arm/configs/s3c24a0_nommu_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/s3c24a0_nommu_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/s3c24a0_nommu_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/s3c24a0_nommu_defconfig	2005-11-08 08:48:28.000000000 +0900
@@ -0,0 +1,518 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc3-mm3-hsc0
+# Fri May  6 14:28:27 2005
+#
+CONFIG_ARM=y
+# CONFIG_MMU is not set
+# CONFIG_MPU is not set
+CONFIG_NO_MU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_S5C7375 is not set
+CONFIG_ARCH_S3C24A0=y
+# CONFIG_ARCH_S3C2500 is not set
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
+# CONFIG_ARCH_P2001 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x10000000
+CONFIG_DRAM_SIZE=0x04000000
+CONFIG_FLASH_MEM_BASE=0x00400000
+CONFIG_FLASH_SIZE=0x00400000
+
+#
+# S3C24A0 Implementations
+#
+CONFIG_ARCH_SMDK24A0=y
+CONFIG_ARCH_SPJ=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+CONFIG_CPU_MXU_ENABLE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+CONFIG_ISA=y
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/ram initrd=0x10800000,4M keepinitrd"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_KGDBOE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_DCC=y
+CONFIG_SERIAL_DCC_CONSOLE=y
+# CONFIG_SERIAL_S3C24A0 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISER4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.14-uc0/arch/arm/configs/s3c3410_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/s3c3410_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/s3c3410_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/s3c3410_defconfig	2005-11-08 08:48:29.000000000 +0900
@@ -0,0 +1,470 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc3-mm3-hsc0
+# Fri May  6 20:55:42 2005
+#
+CONFIG_ARM=y
+# CONFIG_MMU is not set
+# CONFIG_MPU is not set
+CONFIG_NO_MU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+# CONFIG_EXPERIMENTAL is not set
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_S5C7375 is not set
+# CONFIG_ARCH_S3C24A0 is not set
+# CONFIG_ARCH_S3C2500 is not set
+# CONFIG_ARCH_ATMEL is not set
+CONFIG_ARCH_S3C3410=y
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
+# CONFIG_ARCH_P2001 is not set
+# CONFIG_SET_MEM_PARAM is not set
+CONFIG_DRAM_BASE=0x01000000
+CONFIG_DRAM_SIZE=0x01000000
+CONFIG_FLASH_MEM_BASE=0x00000000
+CONFIG_FLASH_SIZE=0x00200000
+CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
+CONFIG_ARM_CLK=40000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+
+#
+# S3C3410 Options
+#
+CONFIG_REMAP_VECTORS_TO_RAM=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM7TDMI=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_CACHE_V4=y
+CONFIG_CPU_HAS_NO_CP15=y
+
+#
+# Processor Features
+#
+CONFIG_CPU_BIG_ENDIAN=y
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_FLATMEM=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="ramdisk=8192 initrd=0x01300000,1M keepinitrd root=/dev/ram"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_KGDBOE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_DCC=y
+CONFIG_SERIAL_DCC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+# CONFIG_PROC_FS is not set
+# CONFIG_SYSFS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.14-uc0/arch/arm/configs/s3c44b0x_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/s3c44b0x_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/s3c44b0x_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/s3c44b0x_defconfig	2005-11-08 08:48:28.000000000 +0900
@@ -0,0 +1,619 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc3-mm3-hsc0
+# Fri May  6 20:57:35 2005
+#
+CONFIG_ARM=y
+# CONFIG_MMU is not set
+# CONFIG_MPU is not set
+CONFIG_NO_MU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_KOBJECT_UEVENT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_S5C7375 is not set
+# CONFIG_ARCH_S3C24A0 is not set
+# CONFIG_ARCH_S3C2500 is not set
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+CONFIG_ARCH_S3C44B0=y
+# CONFIG_ARCH_P2001 is not set
+# CONFIG_SET_MEM_PARAM is not set
+CONFIG_DRAM_BASE=0x0C000000
+CONFIG_DRAM_SIZE=0x01000000
+CONFIG_FLASH_MEM_BASE=0x00000000
+CONFIG_FLASH_SIZE=0x00200000
+CONFIG_ARM_CLK=60000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_REMAP_VECTORS_TO_RAM=y
+
+#
+# S3C44B0X Board Options
+#
+# CONFIG_DEBUG_NICKMIT is not set
+# CONFIG_ARM_CLK_ADJUST is not set
+
+#
+# S3C44B0X Board Driver Options
+#
+CONFIG_SERIAL_S3C44B0X=y
+# CONFIG_SERIAL_S3C44B0X_CONSOLE is not set
+# CONFIG_ETH_RTL8019AS is not set
+# CONFIG_S3C44B0X_GPIO_LED is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM7TDMI=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_CACHE_V4=y
+CONFIG_CPU_HAS_NO_CP15=y
+
+#
+# Processor Features
+#
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=1024
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_KGDBOE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_DCC=y
+CONFIG_SERIAL_DCC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISER4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.14-uc0/arch/arm/configs/s5c7375_defconfig linux-2.6.14-uc0-hsc0/arch/arm/configs/s5c7375_defconfig
--- linux-2.6.14-uc0/arch/arm/configs/s5c7375_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/configs/s5c7375_defconfig	2005-11-08 08:48:28.000000000 +0900
@@ -0,0 +1,482 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.12-rc3-mm3-hsc0
+# Fri May  6 20:51:37 2005
+#
+CONFIG_ARM=y
+# CONFIG_MMU is not set
+# CONFIG_MPU is not set
+CONFIG_NO_MU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+CONFIG_ARCH_S5C7375=y
+# CONFIG_ARCH_S3C24A0 is not set
+# CONFIG_ARCH_S3C2500 is not set
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
+# CONFIG_ARCH_P2001 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x00000000
+CONFIG_DRAM_SIZE=0x00400000
+CONFIG_FLASH_MEM_BASE=0x08000000
+CONFIG_FLASH_SIZE=0x00200000
+
+#
+# S5C7375 Options
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+CONFIG_CPU_MXU_ENABLE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/ram initrd=0x00300000,768K keepinitrd"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=2048
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_KGDBOE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_DCC=y
+CONFIG_SERIAL_DCC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISER4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_SYSFS is not set
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+CONFIG_DEBUG_PREEMPT=y
+CONFIG_DEBUG_SPINLOCK=y
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_WAITQ=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.14-uc0/arch/arm/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/Kconfig
--- linux-2.6.14-uc0/arch/arm/Kconfig	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/Kconfig	2005-11-09 18:44:26.000000000 +0900
@@ -13,12 +13,64 @@
 	  licensed by ARM ltd and targeted at embedded applications and
 	  handhelds such as the Compaq IPAQ.  ARM-based PCs are no longer
 	  manufactured, but  legacy ARM-based PC hardware remains popular in
-	  Europe.  There is an ARM Linux project with a web page at
+	  Europe.
+
+	  There is an ARM(w/MMU) Linux project with a web page at
 	  <http://www.arm.linux.org.uk/>.
 
+	  There is an ARM(w/o MMU) uClinux project with a web page at
+	  <http://opensrc.sec.samsung.com/>.
+choice    
+        prompt "Memory Management Support"
+	default MMU
+	help
+          The recent cores are designed to address a wide variety of applications.
+          Many cores for application platform have Memory Mangement Unit(MMU),
+          however, other cores for embedded systems, secure application have
+          only MPU or even NONE, although used in many SoCs.
+
+          By merging of uClinux, these type of cores supported as the singular
+          address space memory management. The architectures which have a MPU
+          or even no memory management related unit are supported.
+
 config MMU
-	bool
-	default y
+	bool "MMU"
+	help
+	  It's the traditional "Linux" memory mangement type.
+
+	  Select if you want MMU based virtualized addressing space support
+	  by paged memory management.
+
+	  If you don't know what is uClinux or MPU, simply select this.
+
+config MPU
+	bool "MPU"
+	help
+	  It's one of the "uClinux" memory management type.
+
+	  Some cores of ARM series have a Memory Processing Unit(MPU) which
+	  supports sectioned memory management. e.g. arm940T
+
+	  MPU can be supported as singular addressing space memory management
+	  which is linearly mapped from the physical address space.
+
+	  Refer your platform architecture manual and select this if your core has MPU.
+
+config NO_MU
+	bool "NONE"
+	help
+	  It's very typical memory management type of "uClinux."
+
+	  For example, arm7tdmi based platform has no memory management hardware unit
+	  like MMU or MPU.
+
+	  And for performance issue or somewhat other reasons, this type can be chosen
+	  even for MMU based platforms, too. In this case, the MMU table typically
+	  linearly mapped before the jump to kernel. e.g. S5C7375.
+
+	  It is supported as the singular address space memory management.
+
+endchoice
 
 config EISA
 	bool
@@ -79,7 +131,9 @@
 
 choice
 	prompt "ARM system type"
-	default ARCH_RPC
+	default ARCH_RPC if MMU
+	default ARCH_S3C2500 if MPU
+	default ARCH_ATMEL if !MMU && !MPU
 
 config ARCH_CLPS7500
 	bool "Cirrus-CL-PS7500FE"
@@ -207,8 +261,82 @@
 	help
 	  This enables support for systems based on the Agilent AAEC-2000
 
+config ARCH_S5C7375
+	bool "Samsung S5C7375"
+	select ARM_AMBA
+	depends !MPU
+	help
+	  Samsung's S5C7375 16/32-bit SOC(ARM920T) for internal use.
+	  It can be supported for memory management type MMU(Linux) and
+
+
+config ARCH_S3C24A0 
+	bool "Samsung S3C24A0"
+	select ISA
+	depends !MPU
+	help 
+	  Samsung's S3C24A0 media processor based on ARM926EJ core.
+
+if MPU
+
+config ARCH_S3C2500
+	bool "Samsung S3C2500"
+	help
+	  Samsung's S3C2500 SOC(ARM940T).
+
+endif
+
+if !MMU && !MPU
+config ARCH_ATMEL
+	bool "Atmel AT91xxx"
+	help
+	  The AT91xxx Series is a subset of the Atmel AT91 16/32-bit
+	  microcontroller family, which is based on the ARM7TDMI
+	  processor core.
+	  refer <http://www.atmel.com>
+
+	  You can also choose this architecture for The GDB/Armulator.
+	  It emulates AT91F40, include ARM7TDMI core and timers/serial.
+	  refer <http://www.uclinux.org/pub/uClinux/utilities/armulator/>.
+
+config ARCH_S3C3410
+	bool "Samsung S3C3410X"
+	help
+	  Samsung's S3C3410X(KS17C40100) 16/32-bit RISC MCU
+	  is a cost-effective and high-performance MCU solution for PDA and
+	  general purpose application. The core is ARM7TDMI. 
+	  
+	  refer <http://www.samsungsemi.com>.
+
+config ARCH_ESPD_4510B
+	bool "ESPD 4510B / Samsung S3C4510B"
+	help
+	  ESPD 4510B evaluation board built on Samsung's
+	  S3C4510B(KS32C50100) 16/32-bit RISC MCU
+	  is a high performance network controller based
+	  on the ARM7TDMI core.
+	  
+	  refer to  <http://www.espd-inc.com/prod01-arm-samsung4510.htm>
+
+config ARCH_S3C44B0
+	bool "Samsung S3C44B0"
+	help
+	  Samsung's S3C44B0X 16/32-bit SOC(ARM7TDMI) without coprocessor 
+ 
+config ARCH_P2001
+	bool "P2001"
+	help
+	  The LPEC P2001 evaluation board has an P2001 processor from
+	  MAZ Brandenburg GmbH, which is based an ARM9TDMI processor core.
+
+endif
+
 endchoice
 
+if !MMU
+source "arch/arm/Kconfig-nommu"
+endif
+
 source "arch/arm/mach-clps711x/Kconfig"
 
 source "arch/arm/mach-epxa10db/Kconfig"
@@ -243,6 +371,20 @@
 
 source "arch/arm/mach-aaec2000/Kconfig"
 
+source "arch/arm/mach-atmel/Kconfig"
+
+source "arch/arm/mach-s3c3410/Kconfig"
+
+source "arch/arm/mach-s3c44b0x/Kconfig"
+
+source "arch/arm/mach-s5c7375/Kconfig"
+
+source "arch/arm/mach-espd_4510b/Kconfig"
+
+source "arch/arm/mach-s3c24a0/Kconfig" 
+
+source "arch/arm/mach-p2001/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -432,7 +574,7 @@
 
 config ALIGNMENT_TRAP
 	bool
-	default y if !ARCH_EBSA110
+	default y if !ARCH_EBSA110 && !ARCH_S3C3410 && !ARCH_ATMEL && !ARCH_ESPD_4510B
 	help
 	  ARM processors can not fetch/store information which is not
 	  naturally aligned on the bus, i.e., a 4 byte fetch must start at an
@@ -520,7 +662,7 @@
 
 endmenu
 
-if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP1)
+if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP1 || ARCH_P2001)
 
 menu "CPU Frequency scaling"
 
@@ -547,6 +689,13 @@
 
 	  If in doubt, say Y.
 
+config CPU_FREQ_P2001
+	tristate 'P2001 cpufreq support'
+	depends on ARCH_P2001 && CPU_FREQ && CPU_FREQ_TABLE
+	default n
+	help
+	  Compiles P2001 cpu frequency scaling module.
+
 endmenu
 
 endif
diff -Naur linux-2.6.14-uc0/arch/arm/Kconfig-nommu linux-2.6.14-uc0-hsc0/arch/arm/Kconfig-nommu
--- linux-2.6.14-uc0/arch/arm/Kconfig-nommu	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/Kconfig-nommu	2005-11-09 18:45:06.000000000 +0900
@@ -0,0 +1,54 @@
+# Kconfig for uClinux(non-paged MM) depend configurations
+# Hyok S. Choi <hyok.choi@samsung.com>
+
+config SET_MEM_PARAM
+	bool "Set flash/sdram size and base addr"
+	help
+	  Say Y to manually set the base addresses and sizes.
+	  otherwise, the default values are assigned.
+
+config DRAM_BASE
+	hex '(S)DRAM Base Address' if SET_MEM_PARAM
+	default 0x01000000 if ARCH_ATMEL
+	default 0x01000000 if ARCH_S3C3410
+	default 0x0C000000 if ARCH_S3C44B0
+	default 0x00000000 if ARCH_S5C7375
+	default 0x00000000 if ARCH_ESPD_4510B
+	default 0x10000000 if ARCH_S3C24A0 
+	default 0x40000000 if ARCH_P2001
+	default 0x00000000 if ARCH_INTEGRATOR
+	default 0x00800000
+
+config DRAM_SIZE
+	hex '(S)DRAM SIZE' if SET_MEM_PARAM
+	default 0x00600000 if ARCH_ATMEL
+	default 0x01000000 if ARCH_S3C3410
+	default 0x01000000 if ARCH_S3C44B0
+	default 0x00400000 if ARCH_S5C7375
+	default 0x00800000 if ARCH_ESPD_4510B
+	default 0x04000000 if ARCH_S3C24A0 
+	default 0x04000000 if ARCH_P2001
+	default 0x08000000 if ARCH_INTEGRATOR
+	default 0x00800000
+
+config FLASH_MEM_BASE
+	hex 'FLASH Base Address' if SET_MEM_PARAM
+	default 0x01600000 if ARCH_ATMEL
+	default 0x00000000 if ARCH_S3C3410
+	default 0x00000000 if ARCH_S3C44B0
+	default 0x08000000 if ARCH_S5C7375
+	default 0x01000000 if ARCH_ESPD_4510B
+	default 0x02000000 if ARCH_P2001
+	default 0x24000000 if ARCH_INTEGRATOR
+	default 0x00400000
+
+config FLASH_SIZE
+	hex 'FLASH Size' if SET_MEM_PARAM
+	default 0x00200000 if ARCH_ATMEL
+	default 0x00200000 if ARCH_S3C3410
+	default 0x00200000 if ARCH_S3C44B0
+	default 0x00200000 if ARCH_S5C7375
+	default 0x00200000 if ARCH_ESPD_4510B
+	default 0x00400000 if ARCH_P2001
+	default 0x01000000 if ARCH_INTEGRATOR
+	default 0x00400000
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/calls.S linux-2.6.14-uc0-hsc0/arch/arm/kernel/calls.S
--- linux-2.6.14-uc0/arch/arm/kernel/calls.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/calls.S	2005-11-09 13:29:27.000000000 +0900
@@ -2,6 +2,8 @@
  *  linux/arch/arm/kernel/calls.S
  *
  *  Copyright (C) 1995-2005 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for nommu version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,6 +15,20 @@
 #define NR_syscalls 328
 #else
 
+/* excludes unsupported system calls in uClinux */
+#ifndef CONFIG_MMU
+#define sys_fork_wrapper	sys_ni_syscall
+#define sys_mprotect		sys_ni_syscall
+#define sys_msync		sys_ni_syscall
+#define sys_mlock		sys_ni_syscall
+#define sys_munlock		sys_ni_syscall
+#define sys_mlockall		sys_ni_syscall
+#define sys_munlockall		sys_ni_syscall
+#define sys_mincore		sys_ni_syscall
+#define sys_madvise		sys_ni_syscall
+#define sys_remap_file_pages	sys_ni_syscall
+#endif
+
 __syscall_start:
 /* 0 */		.long	sys_restart_syscall
 		.long	sys_exit
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/entry-armv.S linux-2.6.14-uc0-hsc0/arch/arm/kernel/entry-armv.S
--- linux-2.6.14-uc0/arch/arm/kernel/entry-armv.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/entry-armv.S	2005-11-09 18:16:37.000000000 +0900
@@ -3,6 +3,7 @@
  *
  *  Copyright (C) 1996,1997,1998 Russell King.
  *  ARM700 fix by Matthew Godbolt (linux-user@willothewisp.demon.co.uk)
+ *  uClinux/ARM fix and clean-up by Hyok S. Choi (hyok.choi@samsung.com)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -532,7 +533,11 @@
 	add	ip, r1, #TI_CPU_SAVE
 	ldr	r3, [r2, #TI_TP_VALUE]
 	stmia	ip!, {r4 - sl, fp, sp, lr}	@ Store most regs on stack
+#ifndef CONFIG_MMU
+	add	r2, r2, #TI_CPU_DOMAIN
+#else /* CONFIG_MMU */
 	ldr	r6, [r2, #TI_CPU_DOMAIN]!
+#endif /* CONFIG_MMU */
 #if __LINUX_ARM_ARCH__ >= 6
 #ifdef CONFIG_CPU_MPCORE
 	clrex
@@ -550,7 +555,9 @@
 	mov	r4, #0xffff0fff
 	str	r3, [r4, #-15]			@ TLS val at 0xffff0ff0
 #endif
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r6, c3, c0, 0		@ Set domain register
+#endif
 #ifdef CONFIG_VFP
 	@ Always disable VFP so we can lazily save/restore the old
 	@ state. This occurs in the context of the previous thread.
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/entry-common.S linux-2.6.14-uc0-hsc0/arch/arm/kernel/entry-common.S
--- linux-2.6.14-uc0/arch/arm/kernel/entry-common.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/entry-common.S	2005-11-09 13:29:27.000000000 +0900
@@ -219,9 +219,11 @@
 		ldrlo	pc, [tbl, scno, lsl #2]
 		b	sys_ni_syscall
 
+#ifdef CONFIG_MMU
 sys_fork_wrapper:
 		add	r0, sp, #S_OFF
 		b	sys_fork
+#endif
 
 sys_vfork_wrapper:
 		add	r0, sp, #S_OFF
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/head-common.S linux-2.6.14-uc0-hsc0/arch/arm/kernel/head-common.S
--- linux-2.6.14-uc0/arch/arm/kernel/head-common.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/head-common.S	2005-11-09 17:34:28.000000000 +0900
@@ -0,0 +1,175 @@
+/*
+ *  linux/arch/arm/kernel/head-common.S
+ *
+ *  Copyright (C) 1994-2002 Russell King
+ *  Copyright (c) 2003 ARM Limited
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Kernel common startup code for all 32-bit CPUs.
+ *  It is included in head.S and head-nommu.S
+ */
+
+/*
+ * Exception handling.  Something went wrong and we can't proceed.  We
+ * ought to tell the user, but since we don't have any guarantee that
+ * we're even running on the right architecture, we do virtually nothing.
+ *
+ * If CONFIG_DEBUG_LL is set we try to print out something about the error
+ * and hope for the best (useful if bootloader fails to pass a proper
+ * machine ID for example).
+ */
+
+	.type	__error_p, %function
+__error_p:
+#ifdef CONFIG_DEBUG_LL
+	adr	r0, str_p1
+	bl	printascii
+	b	__error
+str_p1:	.asciz	"\nError: unrecognized/unsupported processor variant.\n"
+	.align
+#endif
+
+	.type	__error_a, %function
+__error_a:
+#ifdef CONFIG_DEBUG_LL
+	mov	r4, r1				@ preserve machine ID
+	adr	r0, str_a1
+	bl	printascii
+	mov	r0, r4
+	bl	printhex8
+	adr	r0, str_a2
+	bl	printascii
+	adr	r3, 3f
+	ldmia	r3, {r4, r5, r6}		@ get machine desc list
+	sub	r4, r3, r4			@ get offset between virt&phys
+	add	r5, r5, r4			@ convert virt addresses to
+	add	r6, r6, r4			@ physical address space
+1:	ldr	r0, [r5, #MACHINFO_TYPE]	@ get machine type
+	bl	printhex8
+	mov	r0, #'\t'
+	bl	printch
+	ldr     r0, [r5, #MACHINFO_NAME]	@ get machine name
+	add	r0, r0, r4
+	bl	printascii
+	mov	r0, #'\n'
+	bl	printch
+	add	r5, r5, #SIZEOF_MACHINE_DESC	@ next machine_desc
+	cmp	r5, r6
+	blo	1b
+	adr	r0, str_a3
+	bl	printascii
+	b	__error
+str_a1:	.asciz	"\nError: unrecognized/unsupported machine ID (r1 = 0x"
+str_a2:	.asciz	").\n\nAvailable machine support:\n\nID (hex)\tNAME\n"
+str_a3:	.asciz	"\nPlease check your kernel config and/or bootloader.\n"
+	.align
+#endif
+
+	.type	__error, %function
+__error:
+#ifdef CONFIG_ARCH_RPC
+/*
+ * Turn the screen red on a error - RiscPC only.
+ */
+	mov	r0, #0x02000000
+	mov	r3, #0x11
+	orr	r3, r3, r3, lsl #8
+	orr	r3, r3, r3, lsl #16
+	str	r3, [r0], #4
+	str	r3, [r0], #4
+	str	r3, [r0], #4
+	str	r3, [r0], #4
+#endif
+1:	mov	r0, r0
+	b	1b
+
+
+/*
+ * Read processor ID register (CP#15, CR0), and look up in the linker-built
+ * supported processor list.  Note that we can't use the absolute addresses
+ * for the __proc_info lists since we aren't running with the MMU on
+ * (and therefore, we are not in the correct address space).  We have to
+ * calculate the offset.
+ *
+ * Returns:
+ *	r3, r4, r6 corrupted
+ *	r5 = proc_info pointer in physical address space
+ *	r9 = cpuid
+ */
+	.type	__lookup_processor_type, %function
+__lookup_processor_type:
+	adr	r3, 3f
+	ldmda	r3, {r5, r6, r9}
+	sub	r3, r3, r9			@ get offset between virt&phys
+	add	r5, r5, r3			@ convert virt addresses to
+	add	r6, r6, r3			@ physical address space
+	mrc	p15, 0, r9, c0, c0		@ get processor id
+1:	ldmia	r5, {r3, r4}			@ value, mask
+	and	r4, r4, r9			@ mask wanted bits
+	teq	r3, r4
+	beq	2f
+	add	r5, r5, #PROC_INFO_SZ		@ sizeof(proc_info_list)
+	cmp	r5, r6
+	blo	1b
+	mov	r5, #0				@ unknown processor
+2:	mov	pc, lr
+
+/*
+ * This provides a C-API version of the above function.
+ */
+ENTRY(lookup_processor_type)
+	stmfd	sp!, {r4 - r6, r9, lr}
+	bl	__lookup_processor_type
+	mov	r0, r5
+	ldmfd	sp!, {r4 - r6, r9, pc}
+
+/*
+ * Look in include/asm-arm/procinfo.h and arch/arm/kernel/arch.[ch] for
+ * more information about the __proc_info and __arch_info structures.
+ */
+	.long	__proc_info_begin
+	.long	__proc_info_end
+3:	.long	.
+	.long	__arch_info_begin
+	.long	__arch_info_end
+
+/*
+ * Lookup machine architecture in the linker-build list of architectures.
+ * Note that we can't use the absolute addresses for the __arch_info
+ * lists since we aren't running with the MMU on (and therefore, we are
+ * not in the correct address space).  We have to calculate the offset.
+ *
+ *  r1 = machine architecture number
+ * Returns:
+ *  r3, r4, r6 corrupted
+ *  r5 = mach_info pointer in physical address space
+ */
+	.type	__lookup_machine_type, %function
+__lookup_machine_type:
+	adr	r3, 3b
+	ldmia	r3, {r4, r5, r6}
+	sub	r3, r3, r4			@ get offset between virt&phys
+	add	r5, r5, r3			@ convert virt addresses to
+	add	r6, r6, r3			@ physical address space
+1:	ldr	r3, [r5, #MACHINFO_TYPE]	@ get machine type
+	teq	r3, r1				@ matches loader number?
+	beq	2f				@ found
+	add	r5, r5, #SIZEOF_MACHINE_DESC	@ next machine_desc
+	cmp	r5, r6
+	blo	1b
+	mov	r5, #0				@ unknown machine
+2:	mov	pc, lr
+
+/*
+ * This provides a C-API version of the above function.
+ */
+ENTRY(lookup_machine_type)
+	stmfd	sp!, {r4 - r6, lr}
+	mov	r1, r0
+	bl	__lookup_machine_type
+	mov	r0, r5
+	ldmfd	sp!, {r4 - r6, pc}
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/head-nommu.S linux-2.6.14-uc0-hsc0/arch/arm/kernel/head-nommu.S
--- linux-2.6.14-uc0/arch/arm/kernel/head-nommu.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/head-nommu.S	2005-11-09 17:35:18.000000000 +0900
@@ -0,0 +1,124 @@
+/*
+ *  linux/arch/arm/kernel/head-nommu.S
+ *
+ *  Copyright (C) 1994-2002 Russell King
+ *  Copyright (C) 2003,2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Common kernel startup code (non-paged MM)
+ *    for 32-bit CPUs which has a process ID register.
+ *
+ *  note:
+ *  For the architectures which has NO process ID register (MMU/MPU),
+ *   or which needs some architecture specific setup codes,
+ *   Please create a "head.S" in each machine directories.
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/asm-offsets.h>
+#include <asm/system.h>
+
+#define PROCINFO_INITFUNC       8
+
+#define MACHINFO_TYPE		0
+#define MACHINFO_PHYSRAM	4
+#define MACHINFO_PHYSIO		8
+#define MACHINFO_PGOFFIO	12
+#define MACHINFO_NAME		16
+
+/*
+ * Kernel startup entry point.
+ * ---------------------------
+ *
+ * This is normally called from the decompressor code.  The requirements
+ * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
+ * r1 = machine nr.
+ *
+ * See linux/arch/arm/tools/mach-types for the complete list of machine
+ * numbers for r1.
+ *
+ */
+	__INIT
+	.type	stext, %function
+ENTRY(stext)
+	msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | MODE_SVC @ ensure svc mode
+						@ and irqs disabled
+	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
+	movs	r10, r5				@ invalid processor (r5=0)?
+	beq	__error_p			@ yes, error 'p'
+	bl	__lookup_machine_type		@ r5=machinfo
+	movs	r8, r5				@ invalid machine (r5=0)?
+	beq	__error_a			@ yes, error 'a'
+
+	adr	lr, __after_proc_init		@ return (PIC) address
+	add	pc, r10, #PROCINFO_INITFUNC
+
+	.type	__LC0_init_data, %object
+__LC0_init_data:
+	.long	__data_loc			@ r4
+	.long	__data_start			@ r5
+	.long	__bss_start			@ r6
+	.long	_end				@ r7
+	.long	processor_id			@ r4
+	.long	__machine_arch_type		@ r5
+	.long	cr_alignment			@ r6
+	.long	init_thread_union+8192		@ sp
+
+/*
+ * Set the Control Register and Read the process ID.
+ */
+	.type	__after_proc_init, %function
+__after_proc_init:
+	mrc	p15, 0, r0, c1, c0, 0		@ read control reg
+#ifdef CONFIG_ALIGNMENT_TRAP
+	orr	r0, r0, #CR_A
+#else
+	bic	r0, r0, #CR_A
+#endif
+#ifdef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CR_C
+#endif
+#ifdef CONFIG_CPU_BPREDICT_DISABLE
+	bic	r0, r0, #CR_Z
+#endif
+#ifdef CONFIG_CPU_ICACHE_DISABLE
+	bic	r0, r0, #CR_I
+#endif
+	mcr	p15, 0, r0, c1, c0, 0		@ write control reg
+
+/*
+ *  r0  = processor control register
+ *  r1  = machine ID
+ *  r9  = processor ID
+ */
+	adr	r3, __LC0_init_data
+
+	ldmia	r3!, {r4, r5, r6, r7}
+	cmp	r4, r5				@ Copy data segment if needed
+1:	cmpne	r5, r6
+	ldrne	fp, [r4], #4
+	strne	fp, [r5], #4
+	bne	1b
+
+	mov	fp, #0				@ Clear BSS (and zero fp)
+1:	cmp	r6, r7
+	strcc	fp, [r6],#4
+	bcc	1b
+
+	ldmia	r3, {r4, r5, r6, sp}
+	str	r9, [r4]			@ Save processor ID
+	str	r1, [r5]			@ Save machine type
+	bic	r4, r0, #CR_A			@ Clear 'A' bit
+	stmia	r6, {r0, r4}			@ Save control register values
+	b	start_kernel
+
+#include "head-common.S"
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/head.S linux-2.6.14-uc0-hsc0/arch/arm/kernel/head.S
--- linux-2.6.14-uc0/arch/arm/kernel/head.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/head.S	2005-11-09 17:35:53.000000000 +0900
@@ -393,165 +393,4 @@
 	mov	pc, lr
 	.ltorg
 
-
-
-/*
- * Exception handling.  Something went wrong and we can't proceed.  We
- * ought to tell the user, but since we don't have any guarantee that
- * we're even running on the right architecture, we do virtually nothing.
- *
- * If CONFIG_DEBUG_LL is set we try to print out something about the error
- * and hope for the best (useful if bootloader fails to pass a proper
- * machine ID for example).
- */
-
-	.type	__error_p, %function
-__error_p:
-#ifdef CONFIG_DEBUG_LL
-	adr	r0, str_p1
-	bl	printascii
-	b	__error
-str_p1:	.asciz	"\nError: unrecognized/unsupported processor variant.\n"
-	.align
-#endif
-
-	.type	__error_a, %function
-__error_a:
-#ifdef CONFIG_DEBUG_LL
-	mov	r4, r1				@ preserve machine ID
-	adr	r0, str_a1
-	bl	printascii
-	mov	r0, r4
-	bl	printhex8
-	adr	r0, str_a2
-	bl	printascii
-	adr	r3, 3f
-	ldmia	r3, {r4, r5, r6}		@ get machine desc list
-	sub	r4, r3, r4			@ get offset between virt&phys
-	add	r5, r5, r4			@ convert virt addresses to
-	add	r6, r6, r4			@ physical address space
-1:	ldr	r0, [r5, #MACHINFO_TYPE]	@ get machine type
-	bl	printhex8
-	mov	r0, #'\t'
-	bl	printch
-	ldr     r0, [r5, #MACHINFO_NAME]	@ get machine name
-	add	r0, r0, r4
-	bl	printascii
-	mov	r0, #'\n'
-	bl	printch
-	add	r5, r5, #SIZEOF_MACHINE_DESC	@ next machine_desc
-	cmp	r5, r6
-	blo	1b
-	adr	r0, str_a3
-	bl	printascii
-	b	__error
-str_a1:	.asciz	"\nError: unrecognized/unsupported machine ID (r1 = 0x"
-str_a2:	.asciz	").\n\nAvailable machine support:\n\nID (hex)\tNAME\n"
-str_a3:	.asciz	"\nPlease check your kernel config and/or bootloader.\n"
-	.align
-#endif
-
-	.type	__error, %function
-__error:
-#ifdef CONFIG_ARCH_RPC
-/*
- * Turn the screen red on a error - RiscPC only.
- */
-	mov	r0, #0x02000000
-	mov	r3, #0x11
-	orr	r3, r3, r3, lsl #8
-	orr	r3, r3, r3, lsl #16
-	str	r3, [r0], #4
-	str	r3, [r0], #4
-	str	r3, [r0], #4
-	str	r3, [r0], #4
-#endif
-1:	mov	r0, r0
-	b	1b
-
-
-/*
- * Read processor ID register (CP#15, CR0), and look up in the linker-built
- * supported processor list.  Note that we can't use the absolute addresses
- * for the __proc_info lists since we aren't running with the MMU on
- * (and therefore, we are not in the correct address space).  We have to
- * calculate the offset.
- *
- * Returns:
- *	r3, r4, r6 corrupted
- *	r5 = proc_info pointer in physical address space
- *	r9 = cpuid
- */
-	.type	__lookup_processor_type, %function
-__lookup_processor_type:
-	adr	r3, 3f
-	ldmda	r3, {r5, r6, r9}
-	sub	r3, r3, r9			@ get offset between virt&phys
-	add	r5, r5, r3			@ convert virt addresses to
-	add	r6, r6, r3			@ physical address space
-	mrc	p15, 0, r9, c0, c0		@ get processor id
-1:	ldmia	r5, {r3, r4}			@ value, mask
-	and	r4, r4, r9			@ mask wanted bits
-	teq	r3, r4
-	beq	2f
-	add	r5, r5, #PROC_INFO_SZ		@ sizeof(proc_info_list)
-	cmp	r5, r6
-	blo	1b
-	mov	r5, #0				@ unknown processor
-2:	mov	pc, lr
-
-/*
- * This provides a C-API version of the above function.
- */
-ENTRY(lookup_processor_type)
-	stmfd	sp!, {r4 - r6, r9, lr}
-	bl	__lookup_processor_type
-	mov	r0, r5
-	ldmfd	sp!, {r4 - r6, r9, pc}
-
-/*
- * Look in include/asm-arm/procinfo.h and arch/arm/kernel/arch.[ch] for
- * more information about the __proc_info and __arch_info structures.
- */
-	.long	__proc_info_begin
-	.long	__proc_info_end
-3:	.long	.
-	.long	__arch_info_begin
-	.long	__arch_info_end
-
-/*
- * Lookup machine architecture in the linker-build list of architectures.
- * Note that we can't use the absolute addresses for the __arch_info
- * lists since we aren't running with the MMU on (and therefore, we are
- * not in the correct address space).  We have to calculate the offset.
- *
- *  r1 = machine architecture number
- * Returns:
- *  r3, r4, r6 corrupted
- *  r5 = mach_info pointer in physical address space
- */
-	.type	__lookup_machine_type, %function
-__lookup_machine_type:
-	adr	r3, 3b
-	ldmia	r3, {r4, r5, r6}
-	sub	r3, r3, r4			@ get offset between virt&phys
-	add	r5, r5, r3			@ convert virt addresses to
-	add	r6, r6, r3			@ physical address space
-1:	ldr	r3, [r5, #MACHINFO_TYPE]	@ get machine type
-	teq	r3, r1				@ matches loader number?
-	beq	2f				@ found
-	add	r5, r5, #SIZEOF_MACHINE_DESC	@ next machine_desc
-	cmp	r5, r6
-	blo	1b
-	mov	r5, #0				@ unknown machine
-2:	mov	pc, lr
-
-/*
- * This provides a C-API version of the above function.
- */
-ENTRY(lookup_machine_type)
-	stmfd	sp!, {r4 - r6, lr}
-	mov	r1, r0
-	bl	__lookup_machine_type
-	mov	r0, r5
-	ldmfd	sp!, {r4 - r6, pc}
+#include "head-common.S"
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/Makefile linux-2.6.14-uc0-hsc0/arch/arm/kernel/Makefile
--- linux-2.6.14-uc0/arch/arm/kernel/Makefile	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/Makefile	2005-11-09 17:37:24.000000000 +0900
@@ -1,5 +1,6 @@
 #
 # Makefile for the linux kernel.
+# modified for uClinux by Hyok S. Choi, 2004
 #
 
 AFLAGS_head.o := -DTEXTADDR=$(TEXTADDR) -DDATAADDR=$(DATAADDR)
@@ -27,7 +28,6 @@
   obj-y		+= io.o
 endif
 
-head-y			:= head.o
 obj-$(CONFIG_DEBUG_LL)	+= debug.o
 
-extra-y := $(head-y) init_task.o vmlinux.lds
+extra-y := $(HEAD) init_task.o vmlinux.lds
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/module.c linux-2.6.14-uc0-hsc0/arch/arm/kernel/module.c
--- linux-2.6.14-uc0/arch/arm/kernel/module.c	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/module.c	2005-11-09 17:40:24.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/arch/arm/kernel/module.c
  *
  *  Copyright (C) 2002 Russell King.
+ *  Copyright (C) 2004 Hyok S. Choi, for nommu.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -32,6 +33,7 @@
 #define MODULE_START	(((unsigned long)&_etext + ~PGDIR_MASK) & PGDIR_MASK)
 #endif
 
+#ifdef CONFIG_MMU
 void *module_alloc(unsigned long size)
 {
 	struct vm_struct *area;
@@ -46,6 +48,12 @@
 
 	return __vmalloc_area(area, GFP_KERNEL, PAGE_KERNEL);
 }
+#else /* CONFIG_MMU */
+void *module_alloc(unsigned long size)
+{
+	return size == 0 ? NULL : vmalloc(size);
+}
+#endif /* !CONFIG_MMU */
 
 void module_free(struct module *module, void *region)
 {
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/process.c linux-2.6.14-uc0-hsc0/arch/arm/kernel/process.c
--- linux-2.6.14-uc0/arch/arm/kernel/process.c	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/process.c	2005-11-09 13:29:51.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/arch/arm/kernel/process.c
  *
  *  Copyright (C) 1996-2000 Russell King - Converted to ARM.
+ *  Copyright (C) 2003 Hyok S. Choi - uClinux changes
  *  Original Copyright (C) 1995  Linus Torvalds
  *
  * This program is free software; you can redistribute it and/or modify
@@ -199,6 +200,7 @@
 		processor_modes[processor_mode(regs)],
 		thumb_mode(regs) ? " (T)" : "",
 		get_fs() == get_ds() ? "kernel" : "user");
+#ifndef CONFIG_CPU_HAS_NO_CP15
 	{
 		unsigned int ctrl, transbase, dac;
 		  __asm__ (
@@ -209,6 +211,7 @@
 		printk("Control: %04X  Table: %08X  DAC: %08X\n",
 		  	ctrl, transbase, dac);
 	}
+#endif
 }
 
 void show_regs(struct pt_regs * regs)
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/setup.c linux-2.6.14-uc0-hsc0/arch/arm/kernel/setup.c
--- linux-2.6.14-uc0/arch/arm/kernel/setup.c	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/setup.c	2005-11-09 17:44:36.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/arch/arm/kernel/setup.c
  *
  *  Copyright (C) 1995-2001 Russell King
+ *  Copyright (C) 2003, 2004 Hyok S. Choi - uClinux support
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -140,6 +141,7 @@
 #define lp1 io_res[1]
 #define lp2 io_res[2]
 
+#ifndef CONFIG_CPU_HAS_NO_CP15
 static const char *cache_types[16] = {
 	"write-through",
 	"write-back",
@@ -196,6 +198,7 @@
 	"format C",
 	"undefined 15",
 };
+#endif
 
 static const char *proc_arch[] = {
 	"undefined/unknown",
@@ -227,6 +230,7 @@
 #define CACHE_M(y)	((y) & (1 << 2))
 #define CACHE_LINE(y)	((y) & 3)
 
+#ifndef CONFIG_CPU_HAS_NO_CP15
 static inline void dump_cache(const char *prefix, int cpu, unsigned int cache)
 {
 	unsigned int mult = 2 + (CACHE_M(cache) ? 1 : 0);
@@ -255,6 +259,7 @@
 		}
 	}
 }
+#endif
 
 int cpu_architecture(void)
 {
@@ -284,6 +289,7 @@
 {
 	struct proc_info_list *list;
 
+#ifndef CONFIG_CPU_HAS_NO_CP15
 	/*
 	 * locate processor in the list of supported processor
 	 * types.  The linker builds this table for us from the
@@ -295,6 +301,12 @@
 		       "to continue.\n", processor_id);
 		while (1);
 	}
+#else
+	extern struct proc_info_list __proc_info_begin, __proc_info_end;
+	for (list = &__proc_info_begin; list < &__proc_info_end ; list++)
+		if ((processor_id & list->cpu_mask) == list->cpu_val)
+			break;
+#endif
 
 	cpu_name = list->cpu_name;
 
@@ -311,9 +323,13 @@
 	cpu_cache = *list->cache;
 #endif
 
+#ifndef CONFIG_CPU_HAS_NO_CP15
 	printk("CPU: %s [%08x] revision %d (ARMv%s)\n",
 	       cpu_name, processor_id, (int)processor_id & 15,
 	       proc_arch[cpu_architecture()]);
+#else
+	printk("CPU: %s [%08x]\n", cpu_name, processor_id);
+#endif
 
 	sprintf(system_utsname.machine, "%s%c", list->arch_name, ENDIANNESS);
 	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);
@@ -382,6 +398,19 @@
 	return list;
 }
 
+static void __init show_memory_management_type(void)
+{
+	printk("Memory management: ");
+#ifdef CONFIG_MMU
+	printk("Paged(MMU)\n");
+#elifdef CONFIG_MPU
+	printk("Non-Paged(MPU)\n");
+#else
+	printk("Non-Paged(unused/noMMU)\n");
+#endif
+}
+
+
 static void __init early_initrd(char **p)
 {
 	unsigned long start, size;
@@ -734,6 +763,8 @@
 	mdesc = setup_machine(machine_arch_type);
 	machine_name = mdesc->name;
 
+	show_memory_management_type();
+
 	if (mdesc->soft_reboot)
 		reboot_setup("s");
 
@@ -813,6 +844,7 @@
 	NULL
 };
 
+#ifndef CONFIG_CPU_HAS_NO_CP15
 static void
 c_show_cache(struct seq_file *m, const char *type, unsigned int cache)
 {
@@ -828,6 +860,7 @@
 		type, 1 << (6 + CACHE_SIZE(cache) - CACHE_ASSOC(cache) -
 			    CACHE_LINE(cache)));
 }
+#endif
 
 static int c_show(struct seq_file *m, void *v)
 {
@@ -877,6 +910,7 @@
 	}
 	seq_printf(m, "CPU revision\t: %d\n", processor_id & 15);
 
+#ifndef CONFIG_CPU_HAS_NO_CP15
 	{
 		unsigned int cache_info = read_cpuid(CPUID_CACHETYPE);
 		if (cache_info != processor_id) {
@@ -897,6 +931,7 @@
 			}
 		}
 	}
+#endif
 
 	seq_puts(m, "\n");
 
diff -Naur linux-2.6.14-uc0/arch/arm/kernel/traps.c linux-2.6.14-uc0-hsc0/arch/arm/kernel/traps.c
--- linux-2.6.14-uc0/arch/arm/kernel/traps.c	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/kernel/traps.c	2005-11-09 17:46:21.000000000 +0900
@@ -3,6 +3,7 @@
  *
  *  Copyright (C) 1995-2002 Russell King
  *  Fragments that appear the same as linux/arch/i386/kernel/traps.c (C) Linus Torvalds
+ *  Modified for uClinux 2005 Hyok S. Choi
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -605,7 +606,9 @@
 		printk(KERN_ERR "[%d] %s: bad data abort: code %d instr 0x%08lx\n",
 			current->pid, current->comm, code, instr);
 		dump_instr(regs);
+#ifdef CONFIG_MMU 
 		show_pte(current->mm, addr);
+#endif 
 	}
 #endif
 
@@ -668,6 +671,16 @@
 }
 EXPORT_SYMBOL(abort);
 
+#ifdef CONFIG_MMU
+ #define VECTORS_BASE (0xffff0000)
+#else
+ #ifndef CONFIG_REMAP_VECTORS_TO_RAM
+  #define VECTORS_BASE (0)
+ #else
+  #define VECTORS_BASE (CONFIG_DRAM_BASE)
+ #endif
+#endif	/* CONFIG_MMU */
+
 void __init trap_init(void)
 {
 	extern char __stubs_start[], __stubs_end[];
@@ -680,9 +693,9 @@
 	 * into the vector page, mapped at 0xffff0000, and ensure these
 	 * are visible to the instruction stream.
 	 */
-	memcpy((void *)0xffff0000, __vectors_start, __vectors_end - __vectors_start);
-	memcpy((void *)0xffff0200, __stubs_start, __stubs_end - __stubs_start);
-	memcpy((void *)0xffff1000 - kuser_sz, __kuser_helper_start, kuser_sz);
+	memcpy((void *)VECTORS_BASE, __vectors_start, __vectors_end - __vectors_start);
+	memcpy((void *)VECTORS_BASE+0x0200, __stubs_start, __stubs_end - __stubs_start);
+	memcpy((void *)VECTORS_BASE+0x1000 - kuser_sz, __kuser_helper_start, kuser_sz);
 
 	/*
 	 * Copy signal return handlers into the vector page, and
@@ -691,6 +704,6 @@
 	memcpy((void *)KERN_SIGRETURN_CODE, sigreturn_codes,
 	       sizeof(sigreturn_codes));
 
-	flush_icache_range(0xffff0000, 0xffff0000 + PAGE_SIZE);
+	flush_icache_range(VECTORS_BASE, VECTORS_BASE + PAGE_SIZE);
 	modify_domain(DOMAIN_USER, DOMAIN_CLIENT);
 }
diff -Naur linux-2.6.14-uc0/arch/arm/mach-atmel/arch.c linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/arch.c
--- linux-2.6.14-uc0/arch/arm/mach-atmel/arch.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/arch.c	2005-11-08 08:49:00.000000000 +0900
@@ -0,0 +1,37 @@
+/*
+ *  linux/arch/arm/mach-atmel/arch.c
+ *
+ *  Copyright (C) 2004 SAMSUNG ELECTRONICS Co.,Ltd.
+ *			      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+
+#include <asm/mach/time.h>
+#include <asm/mach/arch.h>
+
+extern void atmel_time_init(void);
+extern unsigned long atmel_gettimeoffset(void);
+
+extern void __init atmel_init_irq(void);
+
+extern struct sys_timer atmel_timer;
+
+MACHINE_START(ATMEL, "ATMEL EB01")
+	/* Maintainer: Hyok S. Choi <hyok.choi@samsung.com> */
+	.init_irq	= atmel_init_irq,
+	.timer		= &atmel_timer,
+MACHINE_END
diff -Naur linux-2.6.14-uc0/arch/arm/mach-atmel/head.S linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/head.S
--- linux-2.6.14-uc0/arch/arm/mach-atmel/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/head.S	2005-11-08 08:49:00.000000000 +0900
@@ -0,0 +1,83 @@
+/*
+ *  linux/arch/arm/mach-atmel/head.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *  <hyok.choi@samsung.com>
+ *
+ *  uClinux kernel startup code for atmel
+ *  which has no bootloader
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+#define MACHINFO_TYPE		0
+#define MACHINFO_PHYSRAM	4
+#define MACHINFO_PHYSIO		8
+#define MACHINFO_PGOFFIO	12
+#define MACHINFO_NAME		16
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0				@ and all irqs disabled
+
+	adr	r5, LC0
+	ldmia	r5, {r5, r6, r8, r9, sp}		@ Setup stack
+
+	/*  Copy data sections to their new home.  */
+
+
+	/*  Clear BSS */
+	mov	r4, #0
+1:	cmp	r5, r8
+	strcc	r4, [r5],#4
+	bcc	1b
+
+	/*  Pretend we know what our processor code is (for arm_id)   */
+
+	ldr	r2, L_AT91_SF_CIDR
+	ldr	r2, [r2]		@ read processor id
+
+	str     r2, [r6]
+	mov     r2, #MACH_TYPE_ATMEL
+	str     r2, [r9]
+
+	mov fp, #0
+	b	start_kernel
+
+LC0:	.long	__bss_start
+	.long	processor_id
+	.long	_end
+	.long   __machine_arch_type
+	.long	init_thread_union+8192
+
+L_AT91_SF_CIDR:
+	.long	0xfff00000
+
+#include "../kernel/head-common.S"
diff -Naur linux-2.6.14-uc0/arch/arm/mach-atmel/irq.c linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/irq.c
--- linux-2.6.14-uc0/arch/arm/mach-atmel/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/irq.c	2005-11-08 08:49:00.000000000 +0900
@@ -0,0 +1,212 @@
+/*
+ *  linux/arch/armnommu/mach-atmel/irq.c
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+ /* Internal Sources */
+#define LevelSensitive	(0<<5)
+#define EdgeTriggered	(1<<5)
+
+ /* External Sources */
+#define LowLevel	(0<<5)
+#define NegativeEdge	(1<<5)
+#define HighLevel	(2<<5)
+#define PositiveEdge	(3<<5)
+
+static unsigned char eb01_irq_prtable[32] = {
+	7, /* FIQ */
+	0, /* SWIRQ */
+	0, /* US0IRQ */
+	0, /* US1IRQ */
+	2, /* TC0IRQ */
+	2, /* TC1IRQ */
+	2, /* TC2IRQ */
+	0, /* WDIRQ */
+	0, /* PIOAIRQ */
+	0, /* reserved */
+	0, /* reserved */
+	0, /* reserved */
+	0, /* reserved */
+	0, /* reserved */
+	0, /* reserved */
+	0, /* reserved */
+	1, /* IRQ0 */
+	0, /* IRQ1 */
+	0, /* IRQ2 */
+};
+
+static unsigned char eb01_irq_type[32] = {
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+
+	EdgeTriggered,	/* IRQ0 = neg. edge */
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+	EdgeTriggered,
+};
+
+void __inline__ at91_mask_irq(unsigned int irq)
+{
+	unsigned long mask = 1 << (irq);
+	__raw_writel(mask, AIC_IDCR);
+}	
+
+void __inline__ at91_unmask_irq(unsigned int irq)
+{
+	unsigned long mask = 1 << (irq);
+	__raw_writel(mask, AIC_IECR);
+}
+
+void __inline__ at91_mask_ack_irq(unsigned int irq)
+{
+	at91_mask_irq(irq);
+}
+
+void __inline__ at91_end_of_isr(void)
+{
+	/* Indicates end of ISR to AIC */
+	__raw_writel(0x1L, AIC_EOICR); /* AIC don't care the value */
+}
+
+void __inline__ at91_unmask_and_eoi(unsigned int irq)
+{
+	at91_unmask_irq(irq);
+	at91_end_of_isr();
+}
+
+static struct irqchip at91_chip = {
+	.ack	= at91_mask_ack_irq,
+	.mask	= at91_mask_irq,
+	.unmask = at91_unmask_and_eoi,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init atmel_init_irq(void)
+{
+	int irq;
+
+	/* Disable all interrupts */
+	__raw_writel(0xFFFFFFFF, AIC_IDCR);
+
+	/* Clear all interrupts	*/
+	__raw_writel(0xFFFFFFFF, AIC_ICCR);
+
+	for ( irq = 0 ; irq < 32 ; irq++ ) {
+		__raw_writel(irq, AIC_EOICR);
+	}
+
+	for ( irq = 0 ; irq < 32 ; irq++ ) {
+		__raw_writel(eb01_irq_prtable[irq] | eb01_irq_type[irq],
+			AIC_SMR(irq));
+	}
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		if (!VALID_IRQ(irq)) continue;
+		set_irq_chip(irq, &at91_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-atmel/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/Kconfig
--- linux-2.6.14-uc0/arch/arm/mach-atmel/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/Kconfig	2005-11-08 08:49:00.000000000 +0900
@@ -0,0 +1,61 @@
+menu "ATMEL Options"
+	depends on ARCH_ATMEL
+
+config ARCH_SUPPORTS_BIG_ENDIAN
+	bool "big endian mode"
+	default n
+	help
+	AT91 core supports both of little and big endian.
+
+config ARM_CLK
+	int 'Arm Core Clock'
+	default 40000000
+	help
+	the default host clock of EB01 is 40MHz.
+	otherwise, change the value in clock.
+
+config SKIP_DUMP_CPU_INFO
+	bool
+	default y
+	help
+	AT91(ARM7TDMI) core does not support cache size
+	recognition instructions which uses MMU features.
+
+config MEM16_BASE
+	hex 'Memory mapped 16-bit io base'
+	default 0x03000000
+
+config MEM8_BASE
+	hex 'Memory mapped 8-bit io base'
+	default 0x03000000
+
+config IO16_BASE
+	hex '16-bit io base'
+	default 0x02000000
+
+config IO8_BASE
+	hex '8-bit io base'
+	default 0x02000000
+
+choice
+	prompt " Atmel CPU"
+	default CPU_AT91X40
+
+config CPU_AT91X40
+	bool "AT91x40"
+
+config CPU_AT91X63
+	bool "AT91X63"
+
+endchoice
+
+config ATMEL_DEBUG
+	bool "Atmel Kernel-Debug hack"
+	default n
+
+config AT91_DEBUG_BASE
+	depends on ATMEL_DEBUG
+	hex 'Debug buffer address'
+	default 0x01400000
+
+endmenu
diff -Naur linux-2.6.14-uc0/arch/arm/mach-atmel/Makefile linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/Makefile
--- linux-2.6.14-uc0/arch/arm/mach-atmel/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/Makefile	2005-11-08 08:49:00.000000000 +0900
@@ -0,0 +1 @@
+obj-y		+= arch.o irq.o time.o
diff -Naur linux-2.6.14-uc0/arch/arm/mach-atmel/Makefile.boot linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/Makefile.boot
--- linux-2.6.14-uc0/arch/arm/mach-atmel/Makefile.boot	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/Makefile.boot	2005-11-08 08:49:00.000000000 +0900
@@ -0,0 +1,2 @@
+   zreladdr-y	:= 0x01000000
+initrd_phys-y	:= 0x01300000
diff -Naur linux-2.6.14-uc0/arch/arm/mach-atmel/time.c linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/time.c
--- linux-2.6.14-uc0/arch/arm/mach-atmel/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-atmel/time.c	2005-11-08 08:49:00.000000000 +0900
@@ -0,0 +1,100 @@
+/*
+ *  linux/arch/armnommu/mach-atmel/time.c
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *		      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+#include <asm/arch/time.h>
+
+unsigned long atmel_gettimeoffset (void)
+{
+	volatile struct at91_timers* tt = (struct at91_timers*) (AT91_TC_BASE);
+	volatile struct at91_timer_channel* tc = &tt->chans[KERNEL_TIMER].ch;
+	return tc->cv * (1000*1000)/(ARM_CLK/128);
+}
+
+static irqreturn_t
+atmel_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	timer_tick(regs);
+	return IRQ_HANDLED;
+}
+
+static struct irqaction atmel_timer_irq = {
+	.name		= "ATMEL Timer Tick",
+	.flags		= SA_INTERRUPT | SA_TIMER,
+	.handler	= atmel_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+
+void __init  atmel_time_init (void)
+{
+	register volatile struct at91_timers* tt = (struct at91_timers*) (AT91_TC_BASE);
+	register volatile struct at91_timer_channel* tc = &tt->chans[KERNEL_TIMER].ch;
+	unsigned long v;
+
+	/* enable Kernel timer */
+	HW_AT91_TIMER_INIT(KERNEL_TIMER)
+
+	/* No SYNC */
+	tt->bcr = 0;
+	/* program NO signal on XC1 */
+	v = tt->bmr;
+	v &= ~TCNXCNS(KERNEL_TIMER,3);
+	v |= TCNXCNS(KERNEL_TIMER,1);
+	tt->bmr = v;
+
+	tc->ccr = 2;  /* disable the channel */
+
+	/* select ACLK/128 as inupt frequency for TC1 and enable CPCTRG */
+	tc->cmr = 3 | (1 << 14);
+
+	tc->idr = ~0ul;  /* disable all interrupt */
+	tc->rc = ((ARM_CLK/128)/HZ - 1);   /* load the count limit into the CR register */
+	tc->ier = TC_CPCS;  /* enable CPCS interrupt */
+
+	/*
+	 * @todo do those really need to be function pointers ?
+	 */
+	atmel_timer_irq.handler = atmel_timer_interrupt;
+
+	/* set up the interrupt */
+	setup_irq(KERNEL_TIMER_IRQ_NUM, &atmel_timer_irq);
+
+	/* enable the channel */
+	tc->ccr = TC_SWTRG|TC_CLKEN;
+}
+
+struct sys_timer atmel_timer = {
+	.init		= atmel_time_init,
+	.offset		= atmel_gettimeoffset,
+};
diff -Naur linux-2.6.14-uc0/arch/arm/mach-espd_4510b/arch.c linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/arch.c
--- linux-2.6.14-uc0/arch/arm/mach-espd_4510b/arch.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/arch.c	2005-11-08 08:48:41.000000000 +0900
@@ -0,0 +1,44 @@
+/*
+ *  linux/arch/arm/mach-espd_4510b/arch.c
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *			      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  Architecture specific fixups.  This is where any
+ *  parameters in the params struct are fixed up, or
+ *  any additional architecture specific information
+ *  is pulled from the params struct.
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+extern void __init s3c4510b_init_irq(void);
+extern struct sys_timer s3c4510b_timer;
+
+void __init s3c4510b_init_machine(void) {
+	/* enable LED 0 */
+	outl( 0xFE, REG_IOPDATA);
+}
+
+MACHINE_START(ESPD_4510B, "ESPD 4510B(S3C4510B)")
+	/* Maintainer: Curt Brune <curt@cucy.com> */
+	.init_irq	= s3c4510b_init_irq,
+	.init_machine = s3c4510b_init_machine,
+	.boot_params	= 0x00000800,
+	.timer = &s3c4510b_timer,
+MACHINE_END
diff -Naur linux-2.6.14-uc0/arch/arm/mach-espd_4510b/dma.c linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/dma.c
--- linux-2.6.14-uc0/arch/arm/mach-espd_4510b/dma.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/dma.c	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/arch-espd_4510b/dma.c
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS Co., Ltd. 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *     
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+
+void arch_dma_init(dma_t *dma)
+{
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-espd_4510b/head.S linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/head.S
--- linux-2.6.14-uc0/arch/arm/mach-espd_4510b/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/head.S	2005-11-08 08:48:41.000000000 +0900
@@ -0,0 +1,97 @@
+/*
+ *  linux/arch/armnommu/mach-espd_4510b/head.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *  <hyok.choi@samsung.com>
+ *
+ *  uClinux kernel startup code for s3c4510b
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+#define MACHINFO_TYPE           0
+#define MACHINFO_PHYSRAM        4
+#define MACHINFO_PHYSIO         8
+#define MACHINFO_PGOFFIO        12
+#define MACHINFO_NAME           16
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r8, r9, sp}			@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+        /* cache clean and flush
+/*
+ * cf. Ch-5 of S3C4510 user's manual for
+ *     "Cache flush operation"
+ * To clear Tag RAM area.
+ */
+        ldr     r4, =0x11000000
+        mov     r5, #0
+        mov     r0, #256
+cache_flush_loop:
+        str     r5, [r4], #4
+        subs    r0, r0, #1
+        bne     cache_flush_loop
+
+        /* cache/write buffer on */
+        ldr     r0, =0x3FF0000          @ SYSCFG
+        ldr     r2, [r0]
+        bic     r2, r2, #0x30
+        orr     r2, r2, #0x10           @ 0-Kbyte SRAM, 8-Kbyte cache
+        orr     r2, r2, #6              @ Cache and write buffer
+        str     r2, [r0]
+
+	ldr	r5, =REG_IOPDATA
+        /* P0: LED, P2: ETH_MDDIS */
+	ldr     r4, =0xFA
+	str     r4, [r5]
+	
+	ldr	r2, S3C4510B_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, ESPD_4510B_MACH_TYPE
+	str     r2, [r9]
+
+        mov fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start
+        .long	processor_id
+        .long	_end
+	.long   __machine_arch_type
+        .long	init_thread_union+8192
+	
+S3C4510B_PROCESSOR_TYPE:
+	.long	0x36807001
+ESPD_4510B_MACH_TYPE:
+	.long	MACH_TYPE_ESPD_4510B
+
+#include "../kernel/head-common.S"
diff -Naur linux-2.6.14-uc0/arch/arm/mach-espd_4510b/irq.c linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/irq.c
--- linux-2.6.14-uc0/arch/arm/mach-espd_4510b/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/irq.c	2005-11-08 08:48:41.000000000 +0900
@@ -0,0 +1,123 @@
+/*
+ *  linux/arch/armnommu/mach-espd_4510b/irq.c
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ * based the codes by
+ *     2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ *
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+static void __s3c4510b_mask_irq(unsigned int irq)
+{
+	INT_DISABLE( irq);
+}
+
+static void __s3c4510b_unmask_irq(unsigned int irq)
+{
+	INT_ENABLE( irq);
+}
+
+static void __s3c4510b_ack_irq(unsigned int irq)
+{
+	/* Acknowledge, clear _AND_ disable the interrupt. */
+	INT_DISABLE( irq);
+	CLEAR_PEND_INT( irq);
+}
+
+static struct irqchip s3c4510b_chip = {
+	.ack	= __s3c4510b_ack_irq,
+	.mask	= __s3c4510b_mask_irq,
+	.unmask = __s3c4510b_unmask_irq,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init s3c4510b_init_irq(void)
+{
+        int irq;
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &s3c4510b_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	/* mask and disable all further interrupts */
+	outl(INT_MASK_DIS, REG_INTMASK);
+
+	/* set all to IRQ mode, not FIQ */
+	outl(INT_MODE_IRQ, REG_INTMODE);
+
+	/* Clear Intrerrupt pending register	*/
+	outl( 0x1FFFFF, REG_INTPEND);
+
+	/*
+	 * enable the gloabal interrupt flag, this should be
+	 * safe now, all sources are masked out and acknowledged
+	 */
+	INT_ENABLE( INT_GLOBAL);
+}
+
diff -Naur linux-2.6.14-uc0/arch/arm/mach-espd_4510b/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/Kconfig
--- linux-2.6.14-uc0/arch/arm/mach-espd_4510b/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/Kconfig	2005-11-08 08:48:41.000000000 +0900
@@ -0,0 +1,26 @@
+menu "ESPD_4510B Options"
+	depends on ARCH_ESPD_4510B
+
+config ARM_CLK
+	int 'Arm Core Clock'
+	default 50000000
+	help
+	the default host clock of S3C4510B is 50MHz.
+	otherwise, change the value in clock.
+
+config SKIP_DUMP_CPU_INFO
+	bool
+	default y
+	help
+	S3C4510B(ARM7TDMI) core does not support cache size
+	recognition instructions which uses MMU features.
+
+config REMAP_VECTORS_TO_RAM
+	bool
+	default y
+	help
+	S3C4510B core does not support ROM and RAM remap
+	function. we set the trap_init to be initialized
+	at the begining of DRAM_BASE.
+
+endmenu
diff -Naur linux-2.6.14-uc0/arch/arm/mach-espd_4510b/Makefile linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/Makefile
--- linux-2.6.14-uc0/arch/arm/mach-espd_4510b/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/Makefile	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		+= arch.o irq.o mm.o dma.o time.o
diff -Naur linux-2.6.14-uc0/arch/arm/mach-espd_4510b/Makefile.boot linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/Makefile.boot
--- linux-2.6.14-uc0/arch/arm/mach-espd_4510b/Makefile.boot	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/Makefile.boot	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,4 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
+
diff -Naur linux-2.6.14-uc0/arch/arm/mach-espd_4510b/mm.c linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/mm.c
--- linux-2.6.14-uc0/arch/arm/mach-espd_4510b/mm.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/mm.c	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,17 @@
+/*
+ *  linux/arch/armnommu/mach-espd_4510b/mm.c
+ *
+ *  Copyright(C)2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+ 
+#include <asm/mach/map.h>
diff -Naur linux-2.6.14-uc0/arch/arm/mach-espd_4510b/time.c linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/time.c
--- linux-2.6.14-uc0/arch/arm/mach-espd_4510b/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-espd_4510b/time.c	2005-11-08 08:48:41.000000000 +0900
@@ -0,0 +1,119 @@
+/*
+ *  linux/arch/armnommu/mach-espd_4510b/time.c
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *                      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+                                                                                                                                           
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/arch/timex.h>
+#include <asm/mach/irq.h>
+                                                                                                                                           
+#define CLOCKS_PER_USEC (CONFIG_ARM_CLK/1000000)
+                                                                                                                                           
+static volatile unsigned long timer_cnt;
+                                                                                                                                           
+unsigned long s3c4510b_gettimeoffset (void)
+{
+        unsigned long usec;
+                                                                                                                                           
+        /* returns microseconds -- timer 1 is free running in countdown mode */
+        usec = 0xFFFFFFFF - inl( REG_TCNT1);
+        usec /= CLOCKS_PER_USEC;
+                                                                                                                                           
+        return usec;
+}
+                                                                                                                                           
+static irqreturn_t
+s3c4510b_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+                                                                                                                                           
+        timer_cnt++;
+                                                                                                                                           
+#ifdef CONFIG_ARCH_ESPD_4510B
+        if ( ! (timer_cnt % (HZ/4))) {
+                LED_TOGGLE(0);
+        }
+#endif
+        timer_tick(regs);
+                                                                                                                                           
+        return IRQ_HANDLED;
+}
+
+static struct irqaction s3c4510b_timer_irq = {
+        .name           = "S3C4510b Timer Tick",
+        .flags          = SA_INTERRUPT | SA_TIMER,
+        .handler        = s3c4510b_timer_interrupt
+};
+
+                                                                                                                                           
+/*
+ * Set up timer interrupt
+ */
+                                                                                                                                           
+void __init  s3c4510b_time_init (void)
+{
+        u_int32_t period;
+                                                                                                                                           
+        /*
+         * disable and clear timers 0 and 1.  set both timers to
+         * interval mode.
+         */
+        outl( 0x0, REG_TMOD);
+        /* clear any pending interrupts */
+        outl( 0x1FFFFF, REG_INTPEND);
+                                                                                                                                           
+        timer_cnt = 0;
+                                                                                                                                           
+        /* initialize the timer period */
+        period = (CLOCK_TICK_RATE / HZ);
+        outl( period, REG_TDATA0);
+                                                                                                                                           
+        /* set timer1 to continually count down from FFFFFFFF */
+        outl( 0xFFFFFFFF, REG_TDATA1);
+                                                                                                                                           
+//      printk(KERN_INFO "time_init():  TICK_RATE: %u, HZ: %u, period: %u\n", CLOCK_TICK_RATE, HZ, period);
+                                                                                                                                           
+        s3c4510b_timer_irq.handler = s3c4510b_timer_interrupt;
+                                                                                                                                           
+        /* set up the interrupt vevtor for timer 0 match */
+        setup_irq( INT_TIMER0, &s3c4510b_timer_irq);
+                                                                                                                                           
+        /* enable the timer IRQ */
+        INT_ENABLE( INT_TIMER0);
+                                                                                                                                           
+        /* let timer 0 run... */
+        outl( TM0_RUN | TM1_RUN, REG_TMOD);
+}
+                                                                                                                                           
+struct sys_timer s3c4510b_timer = {
+        .init           = s3c4510b_time_init,
+        .offset         = s3c4510b_gettimeoffset,
+};
+
diff -Naur linux-2.6.14-uc0/arch/arm/mach-p2001/arch.c linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/arch.c
--- linux-2.6.14-uc0/arch/arm/mach-p2001/arch.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/arch.c	2005-11-08 08:49:04.000000000 +0900
@@ -0,0 +1,95 @@
+/*
+ *  linux/arch/arm/mach-p2001/arch.c
+ *
+ *  Copyright (C) 2004-2005 Tobias Lorenz
+ *
+ *  uClinux kernel startup code for p2001
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/sizes.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+
+extern void __init p2001_init_irq(void);
+extern struct sys_timer p2001_timer;
+
+#ifdef CONFIG_P2001_AUTO_DETECT_SDRAM
+/* automatic memory detection (by write tests at each memory banks) */
+static void __init p2001_fixup(struct machine_desc *desc, struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+	volatile char *mem_start;	// bank 0
+	volatile char *mem_end;		// bank n
+	char mem_wrap;			// value of bank 0
+	char mem_err;			// value of bank n
+
+	/* save memstart */
+	mem_start = (char *) CONFIG_DRAM_BASE;
+	mem_wrap = *mem_start;
+
+	/* search wrap or error position */
+	for(mem_end = mem_start + SZ_1M; mem_end < (char *) (CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE); mem_end += SZ_1M) {
+		mem_err = *mem_end;
+		(*mem_end)++;
+		if (mem_err+1 != *mem_end)
+			break;
+		if (mem_wrap != *mem_start)
+			break;
+		*mem_end = mem_err;
+	}
+	*mem_end = mem_err;
+
+	/* print message */
+	printk("Auto detected SDRAM: 0x%08x - 0x%08x (size: %dMB)\n",
+		(unsigned int) mem_start, (unsigned int) mem_end, 
+		 ((unsigned int) mem_end - (unsigned int) mem_start) / SZ_1M);
+
+	/* give values to mm */
+	mi->nr_banks      = 1;
+	mi->bank[0].start = (unsigned int) mem_start;
+	mi->bank[0].size  = (unsigned int) mem_end - (unsigned int) mem_start;
+	mi->bank[0].node  = 0;
+}
+#endif
+
+MACHINE_START(P2001, "P2001")
+	/* Maintainer: Tobias Lorenz <tobias.lorenz@gmx.net> */
+#ifdef CONFIG_P2001_AUTO_DETECT_SDRAM
+	.fixup = p2001_fixup,
+#endif
+	.init_irq = p2001_init_irq,
+	.timer = &p2001_timer,
+MACHINE_END
diff -Naur linux-2.6.14-uc0/arch/arm/mach-p2001/entry-macro.S linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/entry-macro.S
--- linux-2.6.14-uc0/arch/arm/mach-p2001/entry-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/entry-macro.S	2005-11-08 08:49:04.000000000 +0900
@@ -0,0 +1,168 @@
+/*
+ *  linux/arch/armnommu/mach-p2001/entry-macro.S
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/arch/irqs.h>
+
+#define Adr_INT_CTRL_BASE		0x00130000
+#define REL_Adr_Main_NFIQ_Int_Ctrl	0x00
+#define REL_Adr_Main_NIRQ_Int_Ctrl	0x04
+#define REL_Adr_Status_NFIQ		0x08
+#define REL_Adr_Status_NIRQ		0x0c
+
+#define NR_IRQS				27	/* 27 Interrupts: INT 0..26 */
+
+
+		/* disable FIQ */
+                .macro  disable_fiq
+                .endm
+
+
+		/*
+		 * get the irq number(at least), and others.
+		 * irqnr  :  The number of the IRQ that you want to raise.
+		 * irqstat: ???
+		 * base   :  The comments suggest this is a prioritization mechanism, but it doesn't appear
+		 *           to be actually used anywhere.  That's why many of the irq_prio_table macros are empty.
+		 * flags  :  This is non-obvious, but you'll notice that every get_irqnr_and_base macro
+		 *           does a test at the end of the macro.  If you don't have a flag (I think it's the Z) set,
+		 *           then you'll never call do_IRQ.  It's basically a check to avoid calling do_IRQ if you had
+		 *           a spurious interrupt (or one that was masked).
+		 */
+		/* irqnr=r0 irqstat=r6 base=r5 tmp=lr */
+                .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	\irqstat, #Adr_INT_CTRL_BASE
+		ldr	\irqstat, [\irqstat, #REL_Adr_Status_NIRQ]
+
+                mov	\irqnr, #IRQ_EU0_DATA
+		tst	\irqstat, #(1<<IRQ_EU0_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU1_DATA
+		tst	\irqstat, #(1<<IRQ_EU1_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_TIMER1
+		tst	\irqstat, #(1<<IRQ_TIMER1)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU0_ERROR
+		tst	\irqstat, #(1<<IRQ_EU0_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU1_ERROR
+		tst	\irqstat, #(1<<IRQ_EU1_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_UART
+		tst	\irqstat, #(1<<IRQ_UART)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_USB
+		tst	\irqstat, #(1<<IRQ_USB)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PWM
+		tst	\irqstat, #(1<<IRQ_PWM)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_FSC
+		tst	\irqstat, #(1<<IRQ_FSC)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_GPIO
+		tst	\irqstat, #(1<<IRQ_GPIO)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PFS0
+		tst	\irqstat, #(1<<IRQ_PFS0)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PFS1
+		tst	\irqstat, #(1<<IRQ_PFS1)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PFS2
+		tst	\irqstat, #(1<<IRQ_PFS2)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PFS3
+		tst	\irqstat, #(1<<IRQ_PFS3)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_SO0
+		tst	\irqstat, #(1<<IRQ_SO0)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_SO1
+		tst	\irqstat, #(1<<IRQ_SO1)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_DTMF
+		tst	\irqstat, #(1<<IRQ_DTMF)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_WATCHDOG
+		tst	\irqstat, #(1<<IRQ_WATCHDOG)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PCMHW
+		tst	\irqstat, #(1<<IRQ_PCMHW)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_HDLC_MTS
+		tst	\irqstat, #(1<<IRQ_HDLC_MTS)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_HDLC_ERROR
+		tst	\irqstat, #(1<<IRQ_HDLC_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_HDLC_DATA
+		tst	\irqstat, #(1<<IRQ_HDLC_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU2_DATA
+		tst	\irqstat, #(1<<IRQ_EU2_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU2_ERROR
+		tst	\irqstat, #(1<<IRQ_EU2_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU3_DATA
+		tst	\irqstat, #(1<<IRQ_EU3_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU3_ERROR
+		tst	\irqstat, #(1<<IRQ_EU3_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_TIMER2
+		tst	\irqstat, #(1<<IRQ_TIMER2)
+1001:
+                .endm
+
+
+		/* irq priority table */
+                .macro  irq_prio_table
+                .endm
diff -Naur linux-2.6.14-uc0/arch/arm/mach-p2001/head.S linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/head.S
--- linux-2.6.14-uc0/arch/arm/mach-p2001/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/head.S	2005-11-08 08:49:04.000000000 +0900
@@ -0,0 +1,95 @@
+/*
+ *  linux/arch/arm/mach-p2001/head.S
+ *
+ *  Copyright (C) 2004-2005 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Kernel startup code for P2001
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/constants.h>
+
+#define MACHINFO_TYPE           0
+#define MACHINFO_PHYSRAM        4
+#define MACHINFO_PHYSIO         8
+#define MACHINFO_PGOFFIO        12
+#define MACHINFO_NAME           16
+
+/*
+ * Kernel startup entry point.
+ * ---------------------------
+ *
+ * This is normally called from the decompressor code.  The requirements
+ * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
+ * r1 = machine nr.
+ *
+ * See linux/arch/arm/tools/mach-types for the complete list of machine
+ * numbers for r1.
+ *
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r0, #0
+	ldr	r1, P2001_MACH_TYPE
+
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+	ldr	r9, P2001_PROCESSOR_TYPE
+
+/*
+ * Set the Control Register and Read the process ID.
+ */
+ 	mov	r0, #0
+
+/*
+ *  r0  = processor control register
+ *  r1  = machine ID
+ *  r9  = processor ID
+ *  r12 = value of r0 when kernel was called (currently always zero)
+ */
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r7, r8, sp}			@ Setup stack
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r7					
+        strcc	r4, [r5],#4
+	bcc	1b
+
+	str	r9, [r6]			@ Save processor ID
+	str	r1, [r8]			@ Save machine type
+
+	b	start_kernel
+
+LC0:	.long	__bss_start			@ r5
+        .long	processor_id			@ r6
+        .long	_end				@ r7
+	.long   __machine_arch_type		@ r8
+        .long	init_thread_union+8192		@ sp
+
+/*
+ *	arm_id/PROCESSOR_TYPE:
+ *	31:24:	Implementer		(ARM Ltd)
+ *	23:20:	Variant			(0)
+ *	19:16:	Architecture		(4T)
+ *	15:4:	Primary Part Number	(0)
+ *	3:0	Revision		(0)
+ */
+P2001_PROCESSOR_TYPE:
+	.long	0x41029000
+P2001_MACH_TYPE:
+	.long	MACH_TYPE_P2001
+
+#include "../kernel/head-common.S"
diff -Naur linux-2.6.14-uc0/arch/arm/mach-p2001/irq.c linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/irq.c
--- linux-2.6.14-uc0/arch/arm/mach-p2001/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/irq.c	2005-11-08 08:49:03.000000000 +0900
@@ -0,0 +1,165 @@
+/*
+ *  linux/arch/arm/mach-p2001/irq.c
+ *
+ *  Copyright (C) 2004-2005 Tobias Lorenz
+ *
+ *  IRQ handling code
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+
+/**************************************************************************
+ * IRQ Chip
+ **************************************************************************/
+
+void __inline__ p2001_irqchip_mask(unsigned int irq)
+{
+	unsigned long mask = 1 << (irq);
+	P2001_INT_CTRL->Main_NIRQ_Int_Ctrl &= ~mask;
+}	
+
+void __inline__ p2001_irqchip_unmask(unsigned int irq)
+{
+	unsigned long mask = 1 << (irq);
+	P2001_INT_CTRL->Main_NIRQ_Int_Ctrl |= mask;
+}
+
+void __inline__ p2001_irqchip_ack(unsigned int irq)
+{
+	p2001_irqchip_mask(irq);
+}
+
+#if 0
+int __inline__ p2001_irqchip_retrigger(unsigned int irq)
+{
+	/* not implemented */
+	return 0;
+}
+#endif
+
+#if 0
+int __inline__ p2001_irqchip_type(unsigned int irq, unsigned int flags)
+{
+	/* not implemented */
+	return 0;
+}
+#endif
+
+#if 0
+int __inline__ p2001_irqchip_wake(unsigned int irq, unsigned int on)
+{
+	/* not implemented */
+	return 0;
+}
+#endif
+
+static struct irqchip p2001_irqchip = {
+	.ack		= p2001_irqchip_ack,		/* Acknowledge the IRQ. */
+	.mask		= p2001_irqchip_mask,		/* Mask the IRQ in hardware. */
+	.unmask		= p2001_irqchip_unmask,		/* Unmask the IRQ in hardware. */
+//	.retrigger	= p2001_irqchip_retrigger,	/* Ask the hardware to re-trigger the IRQ. */
+//	.type		= p2001_irqchip_type,		/* Set the type of the IRQ. */
+//	.wake		= p2001_irqchip_wake,		/* Set wakeup-enable on the selected IRQ */
+};
+
+
+
+/**************************************************************************
+ * System IRQ Device/Class
+ **************************************************************************/
+
+#if 0
+static int irq_shutdown(struct sys_device *dev)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#endif
+
+static struct sysdev_class irq_class = {
+//	.shutdown	= irq_shutdown,
+#ifdef CONFIG_PM
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+#endif
+	set_kset_name("irq"),
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+
+
+/**************************************************************************
+ * Module functions
+ **************************************************************************/
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init p2001_init_irq(void)
+{
+	int irq;
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &p2001_irqchip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-p2001/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/Kconfig
--- linux-2.6.14-uc0/arch/arm/mach-p2001/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/Kconfig	2005-11-08 08:49:04.000000000 +0900
@@ -0,0 +1,61 @@
+if ARCH_P2001
+
+menu "P2001 Options"
+	depends on ARCH_P2001
+
+config SYSCLK
+	int 'SysClk'
+	default 73728000
+	help
+	  The default sysclk is 73.728 MHz. For the ethernet unit to
+	  work more than 25 MHz are needed. Overclocking starts at
+	  75 MHz. The following system clock frequencies are allowed:
+	   12288000:  12.288 MHz
+	   24576000:  24.576 MHz
+	   36864000:  36.864 MHz
+	   49152000:  49.152 MHz
+	   61440000:  61.440 MHz
+	   73728000:  73.728 MHz
+	   86016000:  86.016 MHz
+	   98304000:  98.304 MHz
+	  110592000: 110.592 MHz
+
+config P2001_AUTO_DETECT_SDRAM
+	bool 'Automatic SDRAM detection'
+	default y
+	help
+	  The automatic SDRAM detection is done by writing at each
+	  memory bank. The memory is over, when a read/write error
+	  occured or a wrap to the first memory bank is detected.
+
+	  The search area is specified by CONFIG_DRAM_BASE and
+	  CONFIG_DRAM_SIZE !
+
+	  The P2001 can have up to 64 MB SDRAM. So just keep the
+	  default values:
+	  CONFIG_DRAM_BASE = 0x40000000
+	  CONFIG_DRAM_SIZE = 0x04000000 = SZ_64M
+
+config SKIP_DUMP_CPU_INFO
+	bool
+	default y
+	help
+	  ARM9TDMI cores do not support cache size
+	  recognition instructions which use MMU features.
+
+config P2001_WATCHDOG
+	bool 'P2001 watchdog timer support'
+	default y
+	help
+	  Activate P2001 watchdog timer with reset in idle function.
+
+config P2001_TIMER2_LED_FREQ_INDICATOR
+	bool 'P2001 timer2 led frequency indicator'
+	default y
+	help
+	  Use timer2 interrupt to blink leds with 10 Hz at 73.728 MHz.
+	  Lower SYSCLK scales down blinking as well.
+
+endmenu
+
+endif
diff -Naur linux-2.6.14-uc0/arch/arm/mach-p2001/Makefile linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/Makefile
--- linux-2.6.14-uc0/arch/arm/mach-p2001/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/Makefile	2005-11-08 08:49:03.000000000 +0900
@@ -0,0 +1,9 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y			+= arch.o irq.o time.o
+
+obj-$(CONFIG_CPU_FREQ_P2001)	+= p2001_cpufreq.o
diff -Naur linux-2.6.14-uc0/arch/arm/mach-p2001/Makefile.boot linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/Makefile.boot
--- linux-2.6.14-uc0/arch/arm/mach-p2001/Makefile.boot	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/Makefile.boot	2005-11-08 08:49:03.000000000 +0900
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x40100000
+params_phys-y	:= 0x40500000
+initrd_phys-y	:= 0x40600000
diff -Naur linux-2.6.14-uc0/arch/arm/mach-p2001/p2001_cpufreq.c linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/p2001_cpufreq.c
--- linux-2.6.14-uc0/arch/arm/mach-p2001/p2001_cpufreq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/p2001_cpufreq.c	2005-11-08 08:49:04.000000000 +0900
@@ -0,0 +1,286 @@
+/*
+ *  linux/arch/arm/mach-p2001/p2001_cpufreq.c
+ *
+ *  Copyright (C) 2004-2005 Tobias Lorenz
+ *
+ *  CPU frequency scaling support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/cpufreq.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+static struct cpufreq_driver p2001_cpufreq_driver;
+
+static int p2001_cpufreq_driver_init(struct cpufreq_policy *policy);
+static int p2001_cpufreq_driver_verify(struct cpufreq_policy *policy);
+//static int p2001_cpufreq_driver_setpolicy(struct cpufreq_policy *policy);
+static int p2001_cpufreq_driver_target(struct cpufreq_policy *policy,
+				 unsigned int target_freq,
+				 unsigned int relation);
+static unsigned int p2001_cpufreq_driver_get(unsigned int cpu);
+
+static struct cpufreq_frequency_table p2001_cpufreq_frequency_table[] =
+{
+	/* index is also the scaling factor */
+						//       6 kHz (minimum)
+	{ .index = 1, .frequency =   12288 },	//  12.288 MHz (no network)
+	{ .index = 2, .frequency =   24576 },	//  24.576 MHz (no network)
+	{ .index = 3, .frequency =   36864 },	//  36.864 MHz
+	{ .index = 4, .frequency =   49152 },	//  49.152 MHz
+	{ .index = 5, .frequency =   61440 },	//  61.440 MHz
+	{ .index = 6, .frequency =   73728 },	//  73.728 MHz
+	{ .index = 7, .frequency =   86016 },	//  86.016 MHz (overclocked)
+	{ .index = 8, .frequency =   98304 },	//  98.304 MHz (overclocked)
+	{ .index = 9, .frequency =  110592 },	// 110.592 MHz (not working)
+	{ .frequency = CPUFREQ_TABLE_END   },
+};
+
+static int p2001_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+//	printk("p2001_cpufreq_driver_init\n");
+
+	/* set default policy and cpuinfo */
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->cur = policy->min = policy->max = p2001_cpufreq_driver_get(policy->cpu);
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+	policy->cpuinfo.max_freq = 73728;	// kHz
+	policy->cpuinfo.min_freq = 36864;	// kHz
+	policy->cpuinfo.transition_latency = 1000000; /* 1 ms, assumed */
+
+	return 0;
+}
+
+/**
+ * p2001_cpufreq_driver_verify - verifies a new CPUFreq policy
+ * @policy: new policy
+ *
+ * Limit must be within this model's frequency range at least one
+ * border included.
+ */
+static int p2001_cpufreq_driver_verify(struct cpufreq_policy *policy)
+{
+//	printk("p2001_cpufreq_driver_verify\n");
+	return cpufreq_frequency_table_verify(policy, p2001_cpufreq_frequency_table);
+}
+
+/**
+ * p2001_cpufreq_driver_verify - set a new CPUFreq policy
+ * @policy: new policy
+ *
+ * Sets a new CPUFreq policy.
+ */
+/*
+static int p2001_cpufreq_driver_setpolicy(struct cpufreq_policy *policy)
+{
+//	printk("p2001_cpufreq_driver_setpolicy\n");
+	// what to do here ?
+	return 0;
+}
+*/
+
+/**
+ * p2001_cpufreq_driver_target - set a new CPUFreq policy
+ * @policy: new policy
+ * @target_freq: the target frequency
+ * @relation: how that frequency relates to achieved frequency (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)
+ *
+ * Sets a new CPUFreq policy.
+ */
+static int p2001_cpufreq_driver_target(struct cpufreq_policy *policy,
+				       unsigned int target_freq,
+				       unsigned int relation)
+{
+	unsigned int newstate = 0;
+	struct cpufreq_freqs freqs;
+	unsigned int M, P, S, N, PWRDN;			// PLL_12288_config
+	unsigned int M_DIV, N_DIV, SEL_PLL, SEL_DIV;	// DIV_12288_config
+	unsigned int config;
+
+//	printk("p2001_cpufreq_driver_target(target_freq=%d)\n", target_freq);
+        if (cpufreq_frequency_table_target(policy, &p2001_cpufreq_frequency_table[0], target_freq, relation, &newstate))
+                return -EINVAL;
+
+	freqs.old = p2001_cpufreq_driver_get(policy->cpu);
+        freqs.new = p2001_cpufreq_frequency_table[newstate].frequency;
+	freqs.cpu = 0; /* p2001_cpufreq.c is UP only driver */
+
+	if (freqs.new == freqs.old)
+		return 0;
+//	printk("System clock change from %d kHz to %d kHz\n", freqs.old, freqs.new);
+
+	M = 0;
+	S = 0;
+	P = 0;
+	N = 0;
+	PWRDN = 0;
+	M_DIV = 1;
+	N_DIV = newstate;
+	SEL_PLL = 1;
+	SEL_DIV = 0;
+	switch (p2001_cpufreq_frequency_table[newstate].index) {
+		case 1:	// 12288 kHz
+			PWRDN = 1;
+			SEL_PLL = 0;
+			break;
+		case 2:	// 24576 kHz
+			P = 2;
+			break;
+		case 3:	// 36864 kHz
+			M = 1;
+			P = 1;
+			break;
+		case 4:	// 49152 kHz
+			M = 0;
+			break;
+		case 5:	// 61440 kHz
+			M = 2;
+			break;
+		case 6:	// 73728 kHz
+			M = 4;
+			break;
+		case 7:	// 86016 kHz
+			M = 6;
+			break;
+		case 8:	// 98304 kHz
+			M = 8;
+			break;
+		case 9:	// 110592 kHz
+			M = 10;
+			break;
+	}
+
+	/* notifier */
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	/* change DIV first to bypass PLL before PWRDN */
+	config = (M_DIV<<0) | (N_DIV<<8) | (SEL_PLL<<16) | (SEL_DIV<<17);
+	P2001_TIMER->DIV_12288_config = config;
+	config = (M<<0) | (P<<8) | (S<<14) | (N<<16) | (PWRDN<<26);
+	P2001_TIMER->PLL_12288_config = config;
+
+	/* notifier */
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	return 0;
+}
+
+/*
+ * returns current frequency in kHz
+ */
+static unsigned int p2001_cpufreq_driver_get(unsigned int cpu)
+{
+	cpumask_t cpus_allowed;
+	unsigned int current_freq;
+	unsigned int M, P, S, N, PWRDN;			// PLL_12288_config
+	unsigned int M_DIV, N_DIV, SEL_PLL, SEL_DIV;	// DIV_12288_config
+
+//	printk("p2001_cpufreq_driver_get\n");
+	/*
+	 * Save this threads cpus_allowed mask.
+	 */
+	cpus_allowed = current->cpus_allowed;
+
+	/*
+	 * Bind to the specified CPU.  When this call returns,
+	 * we should be running on the right CPU.
+	 */
+	set_cpus_allowed(current, cpumask_of_cpu(cpu));
+	BUG_ON(cpu != smp_processor_id());
+
+	/* get current setting */
+	M	= (P2001_TIMER->PLL_12288_config >>  0) & 0x00ff;
+	P	= (P2001_TIMER->PLL_12288_config >>  8) & 0x003f;
+	S	= (P2001_TIMER->PLL_12288_config >> 14) & 0x0003;
+	N	= (P2001_TIMER->PLL_12288_config >> 16) & 0x03ff;
+	PWRDN	= (P2001_TIMER->PLL_12288_config >> 26) & 0x0001;
+	M_DIV	= (P2001_TIMER->DIV_12288_config >>  0) & 0x00ff;
+	N_DIV	= (P2001_TIMER->DIV_12288_config >>  8) & 0x00ff;
+	SEL_PLL	= (P2001_TIMER->DIV_12288_config >> 16) & 0x0001;
+	SEL_DIV	= (P2001_TIMER->DIV_12288_config >> 17) & 0x0001;
+//	printk("M=%d P=%d S=%d N=%d PWRDN=%d\n", M, P, S, N, PWRDN);
+//	printk("M_DIV=%d N_DIV=%d SEL_PLL=%d SEL_DIV=%d\n", M_DIV, N_DIV, SEL_PLL, SEL_DIV);
+
+	current_freq = 12288; // External 12.288 MHz oscillator
+//	printk("cpufreq after OSC: %d\n", current_freq);
+
+	switch (SEL_PLL) {
+		case 0: // shortcut
+			break;
+		case 1: // PLL
+			/* WARNING: 2^S=2 for S=0 (CodeSourcery ARM Q1A 2004) */
+//			current_freq *= PWRDN ? 0 : ((M+8) / ( (2^S) * (P+2) )); // correct
+			current_freq *= PWRDN ? 0 : ((M+8) / (P+2)); // working
+			break;
+		case 2: // 0
+			current_freq = 0;
+			break;
+	}
+//	printk("cpufreq after PLL: %d\n", current_freq);
+
+	switch (SEL_DIV) {
+		case 0: // shortcut
+			break;
+		case 1:
+			current_freq /= (2*(N+1));
+			break;
+	}
+//	printk("cpufreq after DIV: %d\n", current_freq);
+
+	/*
+	 * Restore the CPUs allowed mask.
+	 */
+	set_cpus_allowed(current, cpus_allowed);
+
+	return current_freq;
+}
+
+static struct cpufreq_driver p2001_cpufreq_driver = {
+	.name		= "P2001 cpufreq",
+	.init		= p2001_cpufreq_driver_init,
+	.verify		= p2001_cpufreq_driver_verify,
+//	.setpolicy	= p2001_cpufreq_driver_setpolicy,
+	.target		= p2001_cpufreq_driver_target,
+	.get		= p2001_cpufreq_driver_get,
+};
+
+static int __init p2001_cpufreq_module_init(void)
+{
+//	printk("p2001_cpufreq_module_init\n");
+	return cpufreq_register_driver(&p2001_cpufreq_driver);
+}
+
+static void __exit p2001_cpufreq_module_exit(void)
+{
+//	printk("p2001_cpufreq_module_exit\n");
+	cpufreq_unregister_driver(&p2001_cpufreq_driver);
+}
+
+module_init(p2001_cpufreq_module_init);
+module_exit(p2001_cpufreq_module_exit);
+
+MODULE_AUTHOR("Tobias Lorenz");
+MODULE_DESCRIPTION("P2001 cpu frequency scaling driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14-uc0/arch/arm/mach-p2001/time.c linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/time.c
--- linux-2.6.14-uc0/arch/arm/mach-p2001/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-p2001/time.c	2005-11-08 08:49:04.000000000 +0900
@@ -0,0 +1,273 @@
+/*
+ *  linux/arch/arm/mach-p2001/time.c
+ *
+ *  Copyright (C) 2004-2005 Tobias Lorenz
+ *
+ *  Timer handling code
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/timex.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+
+#ifdef CONFIG_CPU_FREQ
+#include <linux/notifier.h>
+#include <linux/cpufreq.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/io.h>
+
+#include <asm/mach/time.h>
+
+#define P2001_TIMER_VALUE(reg, mask, shift, value) { \
+	unsigned int i = (P2001_TIMER->reg); \
+	i &= ~((mask) << (shift)); \
+	i |= (((value) & (mask)) << (shift)); \
+	(P2001_TIMER->reg) = i; \
+}
+
+/*
+ * short calculation
+ * ---------------------------------------------------------------
+ * prescaler = factor * (SYSCLK / 12288000)		max: 255
+ * period = SYSCLK/prescaler/HZ				max: 65535
+ * clocks_per_usec = SYSCLK/prescaler / 1000000		min: 1
+ *                 = 12288000 / factor / 1000000
+ * ---------------------------------------------------------------
+ * IMPORTANT: recalculate factor when HZ changes, so that limits
+ * are kept within SYSCLK range (12288000-73728000)
+ */
+
+/**************************************************************************
+ * Timer 1: Scheduler
+ **************************************************************************/
+#define TIMER1_HZ	HZ	/* 100-1000 HZ */
+#define TIMER1_FACTOR	2
+
+static irqreturn_t p2001_timer1_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	write_seqlock(&xtime_lock);
+
+	timer_tick(regs);
+
+	/* clear interrupt pending bit */
+	P2001_TIMER->TIMER_INT &= ~(1<<0);		// Timer1_Int
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction p2001_timer1_irq = {
+	.name		= "P2001 timer1",
+	.flags		= SA_INTERRUPT | SA_TIMER,
+	.handler	= p2001_timer1_interrupt,
+};
+
+/* Return number of microseconds since last interrupt */
+#define TIMER1_CLOCKS_PER_USEC (12288000/TIMER1_FACTOR/1000000)
+static unsigned long p2001_gettimeoffset(void)
+{
+	return ((0xffff - P2001_TIMER->Timer1) & 0xffff) / TIMER1_CLOCKS_PER_USEC;
+}
+
+#ifdef CONFIG_CPU_FREQ
+/*
+ * Transistion notifier
+ */
+static int p2001_timer1_notifier(struct notifier_block *self, unsigned long phase, void *data)
+{
+	struct cpufreq_freqs *cf = data;
+	unsigned int prescaler, period;
+
+	if ((phase == CPUFREQ_POSTCHANGE) ||
+	    (phase == CPUFREQ_RESUMECHANGE)) {
+	    	prescaler = TIMER1_FACTOR*cf->new/12288;
+		period = (1000*cf->new/prescaler)/TIMER1_HZ;
+		P2001_TIMER_VALUE(TIMER_PRELOAD, 0xffff, 0, period);
+		P2001_TIMER_VALUE(Timer12_PreDiv, 0xff, 0, prescaler - 1);
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block p2001_timer1_nb = { &p2001_timer1_notifier, NULL, 0 };
+#endif /* CONFIG_CPU_FREQ */
+
+static void p2001_timer1_init(void)
+{
+	unsigned int prescaler, period;
+
+	/* initialize the timer period and prescaler */
+	prescaler = TIMER1_FACTOR*(CONFIG_SYSCLK/12288000);
+	period = (CONFIG_SYSCLK/prescaler)/TIMER1_HZ;
+	P2001_TIMER_VALUE(TIMER_PRELOAD, 0xffff, 0, period);
+	P2001_TIMER_VALUE(Timer12_PreDiv, 0xff, 0, prescaler - 1);
+
+	/* set up the interrupt vector for timer 1 match */
+	setup_irq(IRQ_TIMER1, &p2001_timer1_irq);
+	
+	/* enable the timer IRQ */
+	P2001_TIMER->TIMER_INT |= (1<<4);		// Timer1_Int_En
+
+	/* let timer 1 run... */
+	P2001_TIMER->Timer12_PreDiv &= ~(1<<28);	// Timer_1_Disable
+
+#ifdef CONFIG_CPU_FREQ
+	cpufreq_register_notifier(&p2001_timer1_nb, CPUFREQ_TRANSITION_NOTIFIER);
+#endif
+}
+
+
+/**************************************************************************
+ * Timer 2: LED Frequency Indicator
+ **************************************************************************/
+#ifdef CONFIG_P2001_TIMER2_LED_FREQ_INDICATOR
+#define TIMER2_HZ	10
+#define TIMER2_FACTOR	20
+
+static irqreturn_t p2001_timer2_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned int gpio2;
+
+	/* switch leds */
+	gpio2 = P2001_GPIO->GPIO2_Out;
+	if (gpio2 & 0x0040) {
+		/* gpio23_v4 on */
+		gpio2 &= ~0x00c0;
+		gpio2 |= 0x0080;
+	} else {
+		/* gpio22_v5 on */
+		gpio2 &= ~0x00c0;
+		gpio2 |= 0x0040;
+	}
+	P2001_GPIO->GPIO2_Out = gpio2;
+
+	/* clear interrupt pending bit */
+	P2001_TIMER->TIMER_INT &= ~(1<<1);		// Timer2_Int
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction p2001_timer2_irq = {
+	.name		= "P2001 timer2",
+	.flags		= SA_INTERRUPT,
+	.handler	= p2001_timer2_interrupt,
+};
+
+static void p2001_timer2_init(void)
+{
+	unsigned int prescaler, period;
+
+	/* initialize the timer period and prescaler */
+	prescaler = TIMER2_FACTOR*(CONFIG_SYSCLK/12288000);
+	period = (CONFIG_SYSCLK/prescaler)/TIMER2_HZ;
+	P2001_TIMER_VALUE(TIMER_PRELOAD, 0xffff, 16, period);
+	P2001_TIMER_VALUE(Timer12_PreDiv, 0xff, 8, prescaler - 1);
+
+	/* Activate Leds Frequency Indicator */
+	/* Schematics say that: SDO_2/GPIO_22=V5, SDI_2/GPIO_23=V4 */
+	P2001_GPIO->PIN_MUX |= (1<<2);			// set MUX to GPIOs
+	P2001_GPIO->GPIO2_En |= 0xC0;			// Enable GPIO driver
+	P2001_GPIO->GPIO2_Out |= 0x00C00000; 		// Mask bits
+
+	/* set up the interrupt vector for timer 2 match */
+	setup_irq(IRQ_TIMER2, &p2001_timer2_irq);
+
+	/* enable the timer IRQ */
+	P2001_TIMER->TIMER_INT |= (1<<5);		// Timer2_Int_En
+
+	/* let timer 2 run... */
+	P2001_TIMER->Timer12_PreDiv &= ~(1<<29);	// Timer_2_Disable
+}
+#endif
+
+
+/**************************************************************************
+ * Watchdog
+ **************************************************************************/
+#ifdef CONFIG_P2001_WATCHDOG
+static irqreturn_t p2001_wdt_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	// printk(KERN_CRIT "Critical watchdog value reached: %d!\n", P2001_TIMER->WatchDog_Timer);
+
+	/* Reset watchdog */
+	P2001_TIMER->Timer12_PreDiv |= (1<<31);		// WatchDog_Reset
+
+	/* clear interrupt pending bit */
+	P2001_TIMER->TIMER_INT &= ~(1<<2);		// WatchDog_Int
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction p2001_wdt_irq = {
+	.name		= "P2001 watchdog",
+	.flags		= SA_INTERRUPT,
+	.handler	= p2001_wdt_interrupt,
+};
+
+static void p2001_wdt_init(void)
+{
+	/* Set predivider, so that watchdog runs at 3000 Hz */
+	/* Reset after 65536/3000 = 21.85 secs (75 MHz) */
+	P2001_TIMER->Timer12_PreDiv |= (0xfff << 16);	// PreDiv_WatchDog
+
+	/* Reset watchdog */
+	P2001_TIMER->Timer12_PreDiv |= (1<<31);		// WatchDog_Reset
+
+	/* Warning after 30000/3000 = 10 secs passed */
+	P2001_TIMER->TIMER_INT |= (1<<6);		// WatchDog_Int_En
+	P2001_TIMER->TIMER_INT &= 0xff;			// WatchDog_Int_Level
+	P2001_TIMER->TIMER_INT |= (30000 << 8);		// WatchDog_Int_Level
+
+	/* Activate watchdog warning interrupt */
+	setup_irq(IRQ_WATCHDOG, &p2001_wdt_irq);
+
+	/* Activate watchdog */
+	P2001_TIMER->Timer12_PreDiv &= ~(1<<30);	// WatchDog_Disable
+}
+#endif
+
+
+/**************************************************************************
+ * Main init
+ **************************************************************************/
+static void __init p2001_init_time(void)
+{
+	/*
+	 * disable and clear timer 0, set to
+	 * internal clock and interval mode
+	 */
+	P2001_TIMER->Timer12_PreDiv = 0x70bb0000;
+	P2001_TIMER->Timer1 = 0;
+	P2001_TIMER->Timer2 = 0;
+
+	p2001_timer1_init();
+#ifdef CONFIG_P2001_TIMER2_LED_FREQ_INDICATOR
+	p2001_timer2_init();
+#endif
+#ifdef CONFIG_P2001_WATCHDOG
+	p2001_wdt_init();
+#endif
+}
+
+struct sys_timer p2001_timer = {
+	.init	= p2001_init_time,
+	.offset	= p2001_gettimeoffset,
+};
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/clocks.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/clocks.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/clocks.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/clocks.c	2005-11-08 08:48:36.000000000 +0900
@@ -0,0 +1,118 @@
+/*
+ *  arch/arm/mach-s3c24a0/clocks.c
+ *
+ *  $Id: clocks.c,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <asm/errno.h>
+#include <asm/arch/clocks.h>
+
+
+
+static unsigned long get_usb_clk_freq(int who)
+{
+        unsigned long val = UPLLCON;
+
+        if (CLKSRC & (1<<7)) return 0;  /* UPLL OFF */
+        val = ((GET_MDIV(val) + 8) * FIN)/((GET_PDIV(val) + 2) * (1 << GET_SDIV(val)));
+        return val;
+}
+
+/* 
+ * CLKDIVN  differs from S3C24A0X to S3C24A0A 
+ * --SW.LEE
+ */
+
+static inline unsigned long
+cal_bus_clk(unsigned long cpu_clk, unsigned long ratio, int who)
+{
+	unsigned long hclk = 0;
+	unsigned long pclk = 0;
+
+	if (who == GET_UPLL)
+		return get_usb_clk_freq(GET_UPLL); 
+
+	switch (ratio & 0x6) {
+		case 0:
+			hclk = cpu_clk;
+			break;
+		case 2:
+			hclk = cpu_clk/2;
+			break; 
+		case 4:
+			hclk = cpu_clk/4;
+			break; 
+		default:
+			panic("Wrong Value in CLKDIVN");
+	}
+	switch (ratio & 0x1) {
+		case 0:
+			pclk = hclk;
+			break;
+		case 1:
+			pclk = hclk/2;
+			break;
+	}
+
+	if (who == GET_HCLK) 
+			return hclk;
+	else {
+		if (who == GET_PCLK) 
+			return pclk;
+		else 
+			panic("Wrong Clock requested ");
+	}
+}
+
+
+/*
+ * cpu clock = (((mdiv + 8) * FIN) / ((pdiv + 2) * (1 << sdiv)))
+ *  FIN = Input Frequency (to CPU)
+ */
+unsigned long
+elfin_get_cpu_clk(void)
+{
+	unsigned long val = MPLLCON;
+	
+	return (((GET_MDIV(val) + 8) * FIN) / ((GET_PDIV(val) + 2) * (1 << GET_SDIV(val))));
+}
+EXPORT_SYMBOL(elfin_get_cpu_clk);
+
+unsigned long
+elfin_get_bus_clk(int who)
+{
+	unsigned long cpu_clk = elfin_get_cpu_clk();
+	unsigned long ratio = CLKDIVN_BUS;
+
+	return (cal_bus_clk(cpu_clk, ratio, who));
+}
+EXPORT_SYMBOL(elfin_get_bus_clk);
+
+#define MEGA	(1000 * 1000)
+static int __init elfin_cpu_init(void)
+{
+	unsigned long freq, hclk, pclk;
+
+	freq = elfin_get_cpu_clk();
+	hclk = elfin_get_bus_clk(GET_HCLK);
+	pclk = elfin_get_bus_clk(GET_PCLK);
+
+	printk(KERN_INFO "CPU clock = %ld.%03ld Mhz,", freq / MEGA, freq % MEGA);
+	
+	printk(" HCLK = %ld.%03ld Mhz, PCLK = %ld.%03ld Mhz\n",
+		 hclk / MEGA, hclk % MEGA, pclk / MEGA, pclk % MEGA);
+
+	return 0;
+}
+
+__initcall(elfin_cpu_init);
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/generic.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/generic.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/generic.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/generic.c	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,42 @@
+/*
+ *  /arch/arm/mach-s3c24a0/generic.c
+ *
+ *      $Id: generic.c,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/serial_core.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+/*
+ * Common I/O mapping:
+ *
+ * 0x4000.0000 ~ 0x4Aff.fffff
+  (0xe000.0000 ~ 0xeAff.fffff)  GPIO
+ */
+static struct map_desc standard_io_desc[] __initdata = {
+        /* virtual    physical    length */
+        { 0xe0000000, 0x40000000, 0x10000000, MT_DEVICE},
+};
+
+void __init elfin_map_io(void)
+{
+        iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/generic.h linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/generic.h
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/generic.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/generic.h	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,14 @@
+/*
+ *  /arch/arm/mach-s3c24a0/generic.h
+ *
+ * 	$Id: generic.h,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ * 	
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+extern void __init elfin_map_io(void);
+extern void __init elfin_init_irq(void);
+
+/* drivers/serial/serial_s3c24a0.c */
+extern void __init elfin_register_uart(int idx, int port);
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/head.S linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/head.S
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/head.S	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,173 @@
+/*
+ *  linux/arch/armnommu/mach-s3c24a0/head.S
+ *
+ *  Taken from mach-s5c7375/head.S
+ *         
+ *  modified by heechul.yun@samsung.com 
+ */
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+#define MACHINFO_TYPE           0
+#define MACHINFO_PHYSRAM        4
+#define MACHINFO_PHYSIO         8
+#define MACHINFO_PGOFFIO        12
+#define MACHINFO_NAME           16
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+/*
+ * ARM920T need MMU enable for D-cache.
+ * we just make the identical table before the MMU enabling.
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	/* Write domain id (cp15_r3) */
+	mvn	r0, #0			/* Domains 0, 1 = client */
+	mcr	p15, 0, r0, c3, c0, 0	/* load domain access register */
+	/* Set control register v4 */
+
+	mov	r0, #0
+	mcr	p15, 0, r0, c13, c0, 0	/* zero PID */
+	mcr	p15, 0, r0, c7, c7, 0	/* invalidate I,D caches */
+	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
+	mcr	p15, 0, r0, c8, c7, 0	/* invalidate I,D TLBs */
+	mrc	p15, 0, r0, c1, c0, 0	/* get control register */
+	bic	r0, r0, #0x0001		/* disable MMU */
+	mcr	p15, 0, r0, c1, c0, 0	/* write control register */
+
+                
+init_ttb:
+        /*
+         * We must reserve DRAM_BASE ~ DRAM_BASE+0x8000. 
+         * And Kernel TEXTADDR must be after DRAM_BASE + 0x8000
+         */ 
+#if !defined(CONFIG_DRAM_BASE) || !defined(CONFIG_DRAM_SIZE) 
+        #define CONFIG_DRAM_BASE 0x10000000
+        #define CONFIG_DRAM_SIZE 0x04000000 
+#endif 
+        ldr     r0,=(CONFIG_DRAM_BASE + 0x4000) /* set TTB (Must be on 16KB boundary) */ 
+        mcr     p15, 0, r0, c2, c0, 0   /* write to TTB(CP15,c2) */
+        
+	/* 
+	 *
+	 * Create translation table for flat mapping
+	 * Top 12 bits of VA is pointer into table
+	 * Create 4096 entries from 000xxxxx to fffxxxxx
+         * 
+	 * Set Section descriptor. 4K entry totla and 
+         * each entry describe 1MB. 
+	 */
+	mov	r1, #0x1000                 @ 4K counter 
+	subs 	r1,r1,#1
+        mov     r2,#0b110000000000          @ set access permissions (AP) for full access SVC/USR (11:10)
+        orr     r2,r2,#0b000111100000       @ set for domain 15 (8:5)
+        orr     r2,r2,#0b000000010000       @ must be 1 (4)
+        orr     r2,r2,#0b000000000000       @ set non cachable non bufferable (CB) (3:2)
+        orr     r2,r2,#0b000000000010       @ set for 1Mb section (1:0)
+init_ttb_1: /* create 4K entry */ 
+        orr     r3,r2,r1,lsl#20             @ use loop counter to create individual table entries
+        str     r3,[r0,r1,lsl#2]            @ str r3 at TTB base + loopcount*4
+        subs    r1,r1,#1                    @ decrement loop counter
+        bpl     init_ttb_1
+
+	/* resetting the SDRAM area to cacheable*/
+        /* DRAM_BASE ~ DRAM_BASE+DRAM_SIZE */
+        /* 64MB -> 64 entry -> 0x40 */ 
+	mov	r1, #(CONFIG_DRAM_SIZE >> 20 ) @ 64 entry =ase addr
+        subs    r1, r1, #1
+        
+	mov     r2,#0b110000000000          @ set access permissions (AP) for full access SVC/USR (11:10)
+	orr     r2,r2,#0b000111100000       @ set for domain 15 (8:5)
+	orr     r2,r2,#0b000000010000       @ must be 1 (4)
+	orr     r2,r2,#0b000000001100       @ set cachable but unbufferable (CB) (3:2)
+	orr     r2,r2,#0b000000000010       @ set for 1Mb section (1:0)
+
+init_ttb_2: /* create 64 entry (for 64MB SDRAM) */
+        add     r4, r1, #(CONFIG_DRAM_BASE >> 20 )  @ drambase >> 20 bit .
+        orr     r3,r2,r4,lsl#20             @ use loop counter to create individual table entries
+	str     r3,[r0,r4,lsl#2]            @ str r3 at TTB base + loopcount*4
+	subs    r1,r1,#1                    @ decrement loop counter
+	bpl     init_ttb_2
+	@init_domains : we define all domains are manager. so no access permission check is occured.
+	mvn     r0, #0				@ trick. 0 -1 == 0xFFFFFFFF
+	mcr     p15, 0, r0, c3, c0, 0       @ write to CP15 register 5
+/*
+ * set global core configurations
+ */
+        mrc     p15, 0, r0, c1, c0, 0       @ read CP15 register 1 into r0
+       
+#ifndef CONFIG_CPU_ICACHE_DISABLE         
+        orr     r0, r0, #(0x1 <<12)         @ enable I Cache
+#endif         
+#ifndef CONFIG_CPU_DCACHE_DISABLE        
+        orr     r0, r0, #(0x1 <<2)          @ enable D Cache
+#endif
+#ifdef  CONFIG_ALIGNMENT_TRAP
+        orr     r0, r0, #2                  @ ...........A. 
+#endif                 
+        orr     r0, r0, #(0b11 <<30)        @ enable asynchronous clocking mode
+        orr     r0, r0, #0x1                @ enable MMU
+
+        mcr     p15, 0, r0, c1, c0, 0       @ write cp15 register 1
+
+#endif
+
+/*
+ * stuffs for cache are done.
+ * Now we setup the stack and machine id, and start the kernel!
+ */
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r7, r8, r9, sp}			@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+	ldr	r2, S3C24A0_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, S3C24A0_MACH_TYPE
+	str     r2, [r9]
+
+        str     r0, [r7]        /* save c1 to cr_alignment */ 
+
+        mov fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start                     @ r5
+        .long	processor_id                    @ r6
+        .long   cr_alignment                    @ r7 
+        .long	_end                            @ r8 
+	.long   __machine_arch_type             @ r9 
+        .long	init_thread_union+8192          @ sp 
+	
+S3C24A0_PROCESSOR_TYPE:
+	.long	0x41069264
+S3C24A0_MACH_TYPE:
+	.long	MACH_TYPE_S3C24A0 
+
+#include "../kernel/head-common.S"
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/irq.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/irq.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/irq.c	2005-11-08 08:48:36.000000000 +0900
@@ -0,0 +1,314 @@
+/*$)C
+ *  arch/arm/mach-s3c24a0/irq.c
+ *
+ *  Generic S3C24A0 IRQ handling.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <linux/sysdev.h>
+
+/* Pendng registers
+ *
+ * INTPND               0x40200010
+ * SUBINTPND    0x40200018
+ * EINTPND              0x44800038
+ */
+static const unsigned long p_regs[3] = { 0x40200010, 0x40200018, 0x44800038 };
+
+/* Mask registers
+ *
+ * INTMSK               0x40200008
+ * SUBINTMSK    0x4020001c
+ * EINTMSK              0x44800034
+ */
+
+static const unsigned long m_regs[3] = { 0x40200008, 0x4020001c, 0x44800034 };
+
+/*
+ * Interrupt table
+ */
+static const int r_irqs[NR_IRQS] = {
+        96, 96, 96, 96, 96,  5,  6,  7,  8,  9, 10, 11, 12, 96, 96, 15,
+        96, 96, 18, 19, 96, 21, 22, 96, 96, 25, 26, 27, 96, 29, 30, 96,
+        17, 17, 17, 23, 23, 23, 28, 28, 96, 96, 96, 13, 13, 16, 16, 14,
+        14, 31, 31, 31, 14, 24, 24, 29, 29, 20, 20, 20, 20, 96, 96, 96,
+         0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  4,
+         4,  4,  4, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96
+};
+
+static inline void clear_pending(int irq)
+{
+        int i = r_irqs[irq];
+        if (i == NR_IRQS)
+                return;
+
+        *(volatile unsigned long *)(io_p2v(p_regs[irq >> 5])) = (1 << (irq % 32));
+        SRCPND = (1 << i);
+        INTPND = INTPND;
+        INTPND;
+}
+
+static inline int read_pending(int irq)
+{
+        return ((*(volatile unsigned long *)(io_p2v(p_regs[irq >> 5]))) & (1 << (irq % 32)));
+}
+
+static inline void mask_irq(int irq)
+{
+        *(volatile unsigned long *)(io_p2v(m_regs[irq >> 5])) |= (1 << (irq % 32));
+}
+
+static inline void unmask_irq(int irq)
+{
+        *(volatile unsigned long *)(io_p2v(m_regs[irq >> 5])) &= ~(1 << (irq % 32));
+}
+
+//#define DEBUG // hcyun
+#undef DEBUG
+
+static inline int find_irq(int irq)
+{
+        int i;
+
+#ifdef DEBUG
+        if ( irq == 4 || irq == 3 ) printk("find_irq: irq=%d\n", irq);
+#endif
+
+        for (i = IRQ_GRP1_START; i < NR_IRQS; i++) {
+                if (r_irqs[i] == irq) {
+#ifdef DEBUG
+                        if ( i >= 64 ) printk("Externel IRQ %d\n", i);
+                        else if ( i >= 32 ) printk("Sub IRQ %d\n", i);
+#endif
+
+                        if (read_pending(i)) {
+#ifdef DEBUG
+                                if ( i >= 64 ) printk("OK there's external pending IRQ %d\n", i);
+                                else if ( i >= 32 ) printk("OK there's sub pending IRQ %d\n", i);
+#endif
+                                return i;
+                        }
+                }
+        }
+        return NR_IRQS;
+}
+
+int fixup_irq(int irq)
+{
+        int retval = NR_IRQS;
+
+        if (irq >= IRQ_GRP1_START)
+                return retval;
+
+        if ((r_irqs[irq]) == NR_IRQS) {
+                retval = find_irq(irq);
+        } else {
+                retval = irq;
+        }
+
+        return retval;
+}
+
+static void elfin_mask_ack_irq(unsigned int irq)
+{
+        mask_irq(irq);
+        clear_pending(irq);
+}
+
+static void elfin_ack_irq(unsigned int irq)
+{
+        clear_pending(irq);
+}
+
+static void elfin_mask_irq(unsigned int irq)
+{
+        mask_irq(irq);
+}
+
+static void elfin_unmask_irq(unsigned int irq)
+{
+        unmask_irq(irq);
+}
+
+static struct irqchip s3c24a0_irq_chip = {
+        .ack    = elfin_ack_irq,  // irq_ack
+        .mask   = elfin_mask_irq,  // irq_mask
+        .unmask = elfin_unmask_irq   // irq_unmak
+};
+
+
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+        return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+        /* disable all irq sources */
+        return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+        set_kset_name("irq"),
+        .suspend        = irq_suspend,
+        .resume         = irq_resume,
+};
+
+static struct sys_device irq_device = {
+        .id     = 0,
+        .cls    = &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+        int ret = sysdev_class_register(&irq_class);
+        if (ret == 0)
+                ret = sysdev_register(&irq_device);
+        return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init elfin_init_irq(void)
+{
+        int irq;
+
+        unsigned int flags;
+
+        /* disable all interrupts */
+        INTSUBMSK = 0xffffffff;
+        EINTMASK = 0xffffffff;
+        INTMSK = 0xffffffff;
+
+        /* clear status registers */
+        EINTPEND = EINTPEND;
+        SUBSRCPND = SUBSRCPND;
+        SRCPND = SRCPND;
+        INTPND = INTPND;
+
+        /* all interrupts set as IRQ */
+        INTMOD = 0x00000000;
+
+        /* we have three groups */
+        for (irq = 0; irq < NR_IRQS; irq++) {
+                flags = IRQF_PROBE;
+
+                /* external IRQ */
+                if ((r_irqs[irq]) == NR_IRQS) {
+                        if (irq < IRQ_GRP1_START)
+                                INTMSK &= ~(1 << irq);
+                }
+                /* main IRQ */
+                else if ( irq < IRQ_GRP2_START )
+                        flags |= IRQF_VALID;
+
+                set_irq_chip(irq, &s3c24a0_irq_chip);
+                set_irq_handler(irq, do_edge_IRQ);
+                set_irq_flags(irq, flags);
+        }
+}
+
+/*
+ * S3C24A0 , External Interrupt setting interface
+ *
+ *  1) GPIO-A8: external irq$)C
+ *  2) Edge setting
+ *                         |<--ECTRL-->|<--GPIO--->|
+ *                           bit   reg   bit   reg
+ *                           ofs   ofs   ofs   ofs
+ * +-----+-----+-----+-----+-----+-----+-----+-----+
+ * |4-bit|4-bit|4-bit|4-bit|4-bit|4-bit|4-bit|4-bit|
+ * +-----+-----+-----+-----+-----+-----+-----+-----+
+ */
+
+static const unsigned long garbage[] = {
+        0xffff0000,     /* EINT 0 */
+        0xffff1010,     /* EINT 1 */
+        0xffff2020,     /* EINT 2 */
+        0xffff0130,     /* EINT 3 */
+        0xffff1140,     /* EINT 4 */
+        0xffff2150,     /* EINT 5 */
+        0xffff3160,     /* EINT 6 */
+        0xffff4170,     /* EINT 7 */
+        0xffff5180,     /* EINT 8 */
+        0xffff6190,     /* EINT 9 */
+        0xffff71a0,     /* EINT 10 */
+        0xffff0201,     /* EINT 11 */
+        0xffff1211,     /* EINT 12 */
+        0xffff2221,     /* EINT 13 */
+        0xffff3231,     /* EINT 14 */
+        0xffff4241,     /* EINT 15 */
+        0xffff5251,     /* EINT 16 */
+        0xffff6261,     /* EINT 17 */
+        0xffff7271,     /* EINT 18 */
+};
+
+int set_external_irq(int irq, int edge, int pullup)
+{
+        int phy_irq = EINTIRQ_DEC(irq); /* physical irq number */
+        unsigned long g;
+        struct irqdesc *desc;
+
+
+        if (phy_irq > 18)
+                return -EINVAL;
+
+        g = garbage[phy_irq];
+
+        /* GPIO setting */
+        *(volatile unsigned long *)(io_p2v(0x44800008 - (0x4 * (g & 0x0000000f)))) &= ~(0x3 << (((g & 0x000000f0) >> 0x4) * 0x2));
+        *(volatile unsigned long *)(io_p2v(0x44800008 - (0x4 * (g & 0x0000000f)))) |= (0x2 << (((g & 0x000000f0) >> 0x4) * 0x2));
+
+#if 0
+        printk("GPIO(0x%x) = 0x%x\n", io_p2v(0x44800008), *(volatile unsigned long *)io_p2v(0x44800008));
+        printk("GPIO(0x%x) = 0x%x\n", io_p2v(0x44800004), *(volatile unsigned long *)io_p2v(0x44800004));
+#endif
+
+        /* edge setting */
+        *(volatile unsigned long *)(io_p2v(0x44800018 + (0x4 * ((g & 0x00000f00) >> 0x8)))) &= ~(0x7 << (((g & 0x0000f000) >> 0xc) * 0x4));
+        *(volatile unsigned long *)(io_p2v(0x44800018 + (0x4 * ((g & 0x00000f00) >> 0x8)))) |= (edge << (((g & 0x0000f000) >> 0xc) * 0x4));
+
+        /* Set pullup */
+        GPUP &= ~(1 << phy_irq);
+        GPUP |= pullup;
+
+        desc = irq_desc + irq;
+        desc->valid = 1;
+
+        switch ( edge ) {
+        case EINT_FALLING_EDGE:
+        case EINT_RISING_EDGE:
+        case EINT_BOTH_EDGES:
+                set_irq_handler(irq, do_edge_IRQ);
+                break;
+        case EINT_LOW_LEVEL:
+        case EINT_HIGH_LEVEL:
+                set_irq_handler(irq, do_level_IRQ);
+                break;
+        }
+        clear_pending(irq);
+        return 0;
+}
+
+EXPORT_SYMBOL(set_external_irq);
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/Kconfig
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/Kconfig	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,13 @@
+if ARCH_S3C24A0
+
+menu "S3C24A0 Implementations" 
+
+config ARCH_SMDK24A0 
+        bool "Meritek SMDK24A0" 
+     
+config ARCH_SPJ
+        depends on ARCH_SMDK24A0 
+        bool "Bluetek SPJ Daughter Board for SMDK24A0" 
+endmenu 
+
+endif 
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/leds.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/leds.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/leds.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/leds.c	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,30 @@
+/*
+ *  /arch/arm/mach-s3c24a0/leds.c
+ *
+ * 	$Id: leds.c,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ * 	
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include "leds.h"
+
+static int __init
+s3c24a0_leds_init(void)
+{
+#ifdef CONFIG_BOARD_SMDK24A0
+	if (machine_is_s3c24a0())
+		leds_event = smdk_leds_event;
+#endif
+
+	leds_event(led_start);
+	return 0;
+}
+
+__initcall(s3c24a0_leds_init);
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/leds.h linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/leds.h
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/leds.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/leds.h	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,7 @@
+/*
+ * arch/arm/mach-s3c24a0/leds.h
+ *
+ * $Id: leds.h,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ *
+ */
+extern void smdk_leds_event(led_event_t evt);
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/leds-smdk.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/leds-smdk.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/leds-smdk.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/leds-smdk.c	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,122 @@
+/*
+ *  arch/arm/mach-s3c24a0/leds-smdk.c
+ *
+ *  $Id: leds-smdk.c,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/leds.h>
+#include <asm/system.h>
+#include <asm/arch/smdk.h>
+
+#include "leds.h"
+
+#define LED_STATE_ENABLED	1
+#define LED_STATE_CLAIMED	2
+
+#define LED0		(1 << 0)
+#define LED1		(1 << 1)
+#define LED2		(1 << 2)
+#define LED3		(1 << 3)	
+
+static unsigned int led_state;
+static unsigned int hw_led_state;
+
+static inline void
+led_update(unsigned int state)
+{
+	write_gpio_bit(SMDK_LED4, (state & LED0));
+	write_gpio_bit(SMDK_LED5, ((state & LED1) >> 1));
+	write_gpio_bit(SMDK_LED6, ((state & LED2) >> 2));
+	write_gpio_bit(SMDK_LED7, ((state & LED3) >> 3));
+}
+
+void
+smdk_leds_event(led_event_t evt)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch (evt) {
+	case led_start:
+		hw_led_state = (LED1 | LED2 | LED3);
+		led_state = LED_STATE_ENABLED;
+		break;
+
+	case led_stop:
+		led_state &= ~LED_STATE_ENABLED;
+		hw_led_state = (LED0 | LED1 | LED2 | LED3);
+		led_update(hw_led_state);
+		break;
+
+	case led_claim:
+		led_state |= LED_STATE_CLAIMED;
+		hw_led_state = (LED0 | LED1 | LED2 | LED3);
+		break;
+
+	case led_release:
+		led_state &= ~LED_STATE_CLAIMED;
+		hw_led_state = (LED1 | LED2 | LED3);
+		break;
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:
+		if (!(led_state & LED_STATE_CLAIMED))
+			hw_led_state ^= LED3;
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_CPU
+	case led_idle_start:
+		if (!(led_state & LED_STATE_CLAIMED))
+			hw_led_state |= LED2;
+		break;
+
+	case led_idle_end:
+		if (!(led_state & LED_STATE_CLAIMED))
+			hw_led_state &= ~LED2;
+		break;
+#endif
+
+	case led_halted:
+		break;
+
+	case led_green_on:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state &= ~LED2;
+		break;
+
+	case led_green_off:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state |= LED2;
+		break;
+
+	case led_amber_on:
+		break;
+
+	case led_amber_off:
+		break;
+
+	case led_red_on:
+		break;
+
+	case led_red_off:
+		break;
+
+	default:
+		break;
+	}
+
+	if (led_state & LED_STATE_ENABLED)
+		led_update(hw_led_state);
+
+	local_irq_restore(flags);
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/Makefile linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/Makefile
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/Makefile	2005-11-08 08:48:36.000000000 +0900
@@ -0,0 +1,30 @@
+#
+# Makefile for the linux kernel.
+# Copyright (C) 2005, Hyok S. Choi
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+USE_STANDARD_AS_RULE := true
+
+
+obj-y :=
+obj-m := registers.o
+obj-n :=
+obj-  :=
+
+# for MMU enabled kernel, needs mapping codes
+obj-$(CONFIG_MMU) += generic.o
+
+# Common support (must be linked before board specific support)
+obj-y += irq.o clocks.o time.o
+
+# Specific board support
+obj-$(CONFIG_ARCH_SMDK24A0) += smdk.o
+
+# LEDs support
+leds-y := leds.o
+leds-$(CONFIG_ARCH_SMDK24A0) += leds-smdk.o
+obj-$(CONFIG_LEDS) += $(leds-y)
+ 
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/Makefile.boot linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/Makefile.boot
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/Makefile.boot	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/Makefile.boot	2005-11-08 08:48:36.000000000 +0900
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x10008000
+params_phys-y	:= 0x10000100
+initrd_phys-y	:= 0x10800000
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/registers.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/registers.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/registers.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/registers.c	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,262 @@
+/*
+ * arch/arm/mach-s3c24a0/register.c
+ *
+ * S3C24A0 register monitor & controller
+ *
+ * $Id: registers.c,v 1.1 2004/06/03 01:35:10 hcyun Exp $
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+ 	
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>               /* because we are a module */
+#include <linux/init.h>                 /* for the __init macros */
+#include <linux/proc_fs.h>              /* all the /proc functions */
+#include <linux/ioport.h>
+#include <asm/uaccess.h>                /* to copy to/from userspace */
+#include <asm/arch/hardware.h>
+
+#define MODULE_NAME "regmon"
+#define CPU_DIRNAME "cpu"
+#define REG_DIRNAME "registers"
+
+static ssize_t proc_read_reg(struct file * file, char * buf,
+		size_t nbytes, loff_t *ppos);
+static ssize_t proc_write_reg(struct file * file, const char * buffer,
+		size_t count, loff_t *ppos);
+
+static struct file_operations proc_reg_operations = {
+	read:	proc_read_reg,
+	write:	proc_write_reg
+};
+
+typedef struct elfin_reg_entry {
+	u32 phyaddr;
+	char* name;
+	unsigned short low_ino;
+} elfin_reg_entry_t;
+
+static elfin_reg_entry_t elfin_regs[] =
+{
+/*	{ phyaddr,    name } */
+
+	/* PLL clock */	
+	{0x40000000, "LOCKTIME"},
+	{0x40000004, "OSCWEST"},
+	{0x40000010, "MPLLCON"},
+	{0x40000014, "UPLLCON"},
+	{0x40000020, "CLKCON"},
+	{0x40000024, "CLKSRC"},
+	{0x40000028, "CLKDIV"},
+	{0x40000030, "PWRMAN"},
+	{0x40000038, "SOFTRESET"},
+
+	/* INT */
+	{0x40200000, "SRCPND"},
+	{0x40200004, "INTMOD"},
+	{0x40200008, "INTMSK"},
+	{0x4020000c, "PRIORITY"},
+	{0x40200010, "INTPND"},
+	{0x40200014, "INTOFFSET"},
+	{0x40200018, "SUBSRCPND"},
+	{0x4020001c, "INTSUBMSK"},
+	{0x40200020, "VECINTMOD"},
+	{0x40200024, "VECADDR"},
+	{0x40200028, "NVECADDR"},
+	{0x4020002c, "VAR"},
+
+	/* SROM */
+	{0x40c20000, "SROM_BW"},
+	{0x40c20004, "SROM_BC0"},
+	{0x40c20008, "SROM_BC1"},
+	{0x40c2000c, "SROM_BC2"},
+
+	/* PWM timer */
+	{0x44000000, "TCFG0"},
+	{0x44000004, "TCFG1"},
+	{0x44000008, "TCON"},
+	{0x4400000c, "TCNTB0"},
+	{0x44000010, "TCMPB0"},
+	{0x44000014, "TCNTO0"},
+	{0x44000018, "TCNTB1"},
+	{0x4400001c, "TCMPB1"},
+	{0x44000020, "TCNTO1"},
+	{0x44000024, "TCNTB2"},
+	{0x44000028, "TCMPB2"},
+	{0x4400002c, "TCNTO2"},
+	{0x44000030, "TCNTB3"},
+	{0x44000034, "TCMPB3"},
+	{0x44000038, "TCNTO3"},
+	{0x4400003c, "TCNTB4"},
+	{0x44000040, "TCNTO4"},
+
+	/* CamIF */
+	{0x48000004, "CAM_STAY1"},
+	{0x48000008, "CAM_STAY2"},
+	{0x4800000c, "CAM_STAY3"},
+	{0x48000010, "CAM_STAY4"},
+	{0x48000000, "CAM_RDSTAT"},
+
+	/* Post Processor */
+	{0x4a100000, "VP_MODE"},
+	{0x4a100004, "VP_RATIO_Y"},
+	{0x4a100008, "VP_RATIO_CB"},
+	{0x4a10000c, "VP_RATIO_CR"},
+	{0x4a100010, "VP_SRC_WIDTH"},
+	{0x4a100014, "VP_SRC_HEIGHT"},
+	{0x4a100018, "VP_DST_WIDTH"},
+	{0x4a10001c, "VP_DST_HEIGHT"},
+	{0x4a100020, "VP_START_Y1"},
+	{0x4a100024, "VP_START_Y2"},
+	{0x4a100028, "VP_START_Y3"},
+	{0x4a10002c, "VP_START_Y4"},
+	{0x4a100030, "VP_START_CB1"},
+	{0x4a100034, "VP_START_CB2"},
+	{0x4a100038, "VP_START_CB3"},
+	{0x4a10003c, "VP_START_CB4"},
+	{0x4a100040, "VP_START_CR1"},
+	{0x4a100044, "VP_START_CR2"},
+	{0x4a100048, "VP_START_CR3"},
+	{0x4a10004c, "VP_START_CR4"},
+	{0x4a100050, "VP_START_RGB1"},
+	{0x4a100054, "VP_START_RGB2"},
+	{0x4a100058, "VP_START_RGB3"},
+	{0x4a10005c, "VP_START_RGB4"},
+	{0x4a100060, "VP_END_Y1"},
+	{0x4a100064, "VP_END_Y2"},
+	{0x4a100068, "VP_END_Y3"},
+	{0x4a10006c, "VP_END_Y4"},
+	{0x4a100070, "VP_END_CB1"},
+	{0x4a100074, "VP_END_CB2"},
+	{0x4a100078, "VP_END_CB3"},
+	{0x4a10007c, "VP_END_CB4"},
+	{0x4a100080, "VP_END_CR1"},
+	{0x4a100084, "VP_END_CR2"},
+	{0x4a100088, "VP_END_CR3"},
+	{0x4a10008c, "VP_END_CR4"},
+	{0x4a100090, "VP_END_RGB1"},
+	{0x4a100094, "VP_END_RGB2"},
+	{0x4a100098, "VP_END_RGB3"},
+	{0x4a10009c, "VP_END_RGB4"},
+	{0x4a1000f0, "VP_BYPASS"},
+	{0x4a1000f4, "VP_OFS_Y"},
+	{0x4a1000f8, "VP_OFS_CB"},
+	{0x4a1000fc, "VP_OFS_CR"},
+	{0x4a100100, "VP_OFS_RGB"},
+
+	/* BUS matrix */
+	{0x40ce0000, "BUS_PRIORITY0"},
+	{0x40ce0004, "BUS_PRIORITY1"},
+};
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
+#endif
+
+static int proc_read_reg(struct file * file, char * buf,
+		size_t nbytes, loff_t *ppos)
+{
+	int i_ino = (file->f_dentry->d_inode)->i_ino;
+	char outputbuf[15];
+	int count;
+	int i;
+	elfin_reg_entry_t* current_reg=NULL;
+	if (*ppos>0) /* Assume reading completed in previous read*/
+		return 0;
+	for (i=0;i<ARRAY_SIZE(elfin_regs);i++) {
+		if (elfin_regs[i].low_ino==i_ino) {
+			current_reg = &elfin_regs[i];
+			break;
+		}
+	}
+	if (current_reg==NULL)
+		return -EINVAL;
+
+	count = sprintf(outputbuf, "0x%08lx\n",
+			*((volatile unsigned long *) io_p2v(current_reg->phyaddr)));
+	*ppos+=count;
+	if (count>nbytes)  /* Assume output can be read at one time */
+		return -EINVAL;
+	if (copy_to_user(buf, outputbuf, count))
+		return -EFAULT;
+	return count;
+}
+
+static ssize_t proc_write_reg(struct file * file, const char * buffer,
+		size_t count, loff_t *ppos)
+{
+	int i_ino = (file->f_dentry->d_inode)->i_ino;
+	elfin_reg_entry_t* current_reg=NULL;
+	int i;
+	unsigned long newRegValue;
+	char *endp;
+
+	for (i=0;i<ARRAY_SIZE(elfin_regs);i++) {
+		if (elfin_regs[i].low_ino==i_ino) {
+			current_reg = &elfin_regs[i];
+			break;
+		}
+	}
+	if (current_reg==NULL)
+		return -EINVAL;
+
+	newRegValue = simple_strtoul(buffer,&endp,0);
+	*((volatile unsigned long *) io_p2v(current_reg->phyaddr))=newRegValue;
+	return (count+endp-buffer);
+}
+
+static struct proc_dir_entry *regdir;
+static struct proc_dir_entry *cpudir;
+
+static int __init init_reg_monitor(void)
+{
+	struct proc_dir_entry *entry;
+	int i;
+
+	cpudir = proc_mkdir(CPU_DIRNAME, &proc_root);
+	if (cpudir == NULL) {
+		printk(KERN_ERR MODULE_NAME": can't create /proc/" CPU_DIRNAME "\n");
+		return(-ENOMEM);
+	}
+
+	regdir = proc_mkdir(REG_DIRNAME, cpudir);
+	if (regdir == NULL) {
+		printk(KERN_ERR MODULE_NAME": can't create /proc/" CPU_DIRNAME "/" REG_DIRNAME "\n");
+		return(-ENOMEM);
+	}
+
+	for(i=0;i<ARRAY_SIZE(elfin_regs);i++) {
+		entry = create_proc_entry(elfin_regs[i].name,
+				S_IWUSR |S_IRUSR | S_IRGRP | S_IROTH,
+				regdir);
+		if(entry) {
+			elfin_regs[i].low_ino = entry->low_ino;
+			entry->proc_fops = &proc_reg_operations;
+		} else {
+			printk( KERN_ERR MODULE_NAME
+				": can't create /proc/" REG_DIRNAME
+				"/%s\n", elfin_regs[i].name);
+			return(-ENOMEM);
+		}
+	}
+	return (0);
+}
+
+static void __exit cleanup_reg_monitor(void)
+{
+	int i;
+	for(i=0;i<ARRAY_SIZE(elfin_regs);i++)
+		remove_proc_entry(elfin_regs[i].name,regdir);
+	remove_proc_entry(REG_DIRNAME, cpudir);
+	remove_proc_entry(CPU_DIRNAME, &proc_root);
+}
+
+module_init(init_reg_monitor);
+module_exit(cleanup_reg_monitor);
+
+MODULE_LICENSE("GPL");
+
+EXPORT_NO_SYMBOLS;
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/smdk.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/smdk.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/smdk.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/smdk.c	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,218 @@
+/*
+ *  /arch/arm/mach-s3c24a0/smdk.c
+ *
+ *  This file contains all SMDK24A0 specific tweaks.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  Changes
+ *
+ *  2005/03/24 <hyok.choi@samsung.com>   update for 2.6.10
+ *  2004/06/10 <heechul.yun@samsung.com>   Initial CPLD IDE support for SPJ
+ *  2004/06/13 <heechul.yun@samsung.com>   CPLD IDE and USB csupport for SPJ
+ *  2004/06/23 <heechul.yun@samsung.com>   Added bank1 access functions and now
+ *     IDE works with cs8900.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/serial_core.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include "generic.h"
+
+// #define DEBUG;
+#ifdef DEBUG
+#  define PDEBUG(fmt, args...) \
+printk(KERN_DEBUG "[%s:%d] " fmt, __PRETTY_FUNCTION__, __LINE__ , ## args)
+#else
+#  define PDEBUG(fmt, args...) do {} while(0)
+#endif
+
+/* global lock to protect bank1 register settings */
+spinlock_t bank1_lock = SPIN_LOCK_UNLOCKED;
+
+bank_param_t bank1_params[] =
+{
+        { 0x08, 0x3740 }, /* B1_IDE_PIO0 */
+        { 0x08, 0x2340 }, /* B1_IDE_PIO4 */
+        { 0x38, 0x3740 }, /* B1_CS89x0 */
+        { 0x00, 0x2200 }, /* B1_USB2 */
+};
+
+/* bank1 state of interrupt context */
+static int b1_int_state = B1_STATE_NONE;
+
+/**
+ * real_bank1_set_param: blah blah
+ */
+static __inline__ void real_bank1_set_param(int bw_val, int bc1_val)
+{
+        SROM_BW &= ~0x38;
+        SROM_BW |= bw_val;
+        SROM_BC1 = bc1_val;
+}
+
+/**
+ * bank1_set_state - set bank1 timing
+ * @state - state
+ *
+ * long description
+ */
+void bank1_set_state(int state)
+{
+#if 0
+        unsigned long flags;
+
+        if ( state == B1_STATE_NONE)
+                return;
+
+        if ( state > B1_STATE_LIMIT || state < B1_STATE_NONE )
+                panic("bank1: Inavlid state");
+
+
+        spin_lock_irqsave( &bank1_lock, flags);
+
+        if ( !in_interrupt())
+             current->bank1_state = state;
+
+        real_bank1_set_param( bank1_params[state].bw, bank1_params[state].bc);
+
+        spin_unlock_irqrestore( &bank1_lock, flags);
+#endif
+
+}
+
+
+void bank1_set_int_state(int state)
+{
+#if 0
+        unsigned long flags;
+
+        if ( !in_interrupt() )
+                panic("bank1_set_int_state is called fron interrupt context\n");
+
+        spin_lock_irqsave( &bank1_lock, flags);
+
+        b1_int_state = state; /* set */
+
+        if ( state == B1_STATE_NONE) /* 1st level interrupt */
+                state = current->bank1_state;
+
+        if ( state != B1_STATE_NONE )
+                real_bank1_set_param( bank1_params[state].bw, bank1_params[state].bc);
+
+        spin_unlock_irqrestore( &bank1_lock, flags);
+#endif
+}
+
+/*
+ * bank1_get_int_state - bank1 state of interrupt context
+ */
+int bank1_get_int_state(void)
+{
+        return b1_int_state;
+}
+
+EXPORT_SYMBOL(bank1_set_state);
+EXPORT_SYMBOL(bank1_set_int_state);
+EXPORT_SYMBOL(bank1_get_int_state);
+
+static int __init smdk_init(void)
+{
+        printk("%s: initialize smdk24a0 board\n", __func__);
+
+        set_gpio_ctrl(SMDK_LED4 | GPIO_PULLUP_DIS | GPIO_MODE_OUT);
+        set_gpio_ctrl(SMDK_LED5 | GPIO_PULLUP_DIS | GPIO_MODE_OUT);
+        set_gpio_ctrl(SMDK_LED6 | GPIO_PULLUP_DIS | GPIO_MODE_OUT);
+        set_gpio_ctrl(SMDK_LED7 | GPIO_PULLUP_DIS | GPIO_MODE_OUT);
+
+/*
+        // real_bank1_set_param(0x38, 0x3740);
+        real_bank1_set_param(0x38, 0x2340);
+*/
+        real_bank1_set_param( bank1_params[B1_CS89x0].bw, bank1_params[B1_CS89x0].bc);
+        printk("Set BANK1 register (0x%x, 0x%x)\n", SROM_BW, SROM_BC1);
+
+        return 0;
+}
+
+__initcall(smdk_init);
+
+#ifdef CONFIG_MMU
+/*
+ * I/O mapping:
+ */
+static struct map_desc smdk_io_desc[] __initdata = {
+        /* virtual         physical         length      domain     r  w  c  b */
+        { SMDK_CS8900_VIO, SMDK_CS8900_PIO, SZ_1M, MT_DEVICE},
+        { SMDK_CPLD_IDE_VIO, SMDK_CPLD_IDE_PIO, 0x00900000, MT_DEVICE}, // hcyun
+        { SMDK_CPLD_USB_VIO, SMDK_CPLD_USB_PIO, 0x00900000, MT_DEVICE},  // hcyun
+};
+
+static void __init smdk_map_io(void)
+{
+        elfin_map_io();                                 // 0x4000.0000 -> 0xe000.0000
+}
+#endif /* CONFIG_MMU */
+
+static void __init fixup_smdk(struct machine_desc *desc,
+                struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+#ifdef CONFIG_MMU
+        iotable_init(smdk_io_desc, ARRAY_SIZE(smdk_io_desc));
+#endif
+#ifdef CONFIG_SERIAL_S3C24A0
+        elfin_register_uart(0, 0);
+#endif
+#ifdef CONFIG_PM
+        register_wakeup_src(0, EINT_RISING_EDGE, 0);
+#endif
+
+}
+
+
+#include <asm/mach/time.h>
+
+extern void elfin_time_init(void);
+extern unsigned long elfin_gettimeoffset(void);
+
+extern void __init elfin_init_irq(void);
+
+extern struct sys_timer elfin_timer;
+
+
+
+MACHINE_START(S3C24A0, "Samsung-SMDK24A0")
+        /* Maintainer: Hyok S. Choi */
+#ifdef CONFIG_MMU
+	.phys_ram	= 0x10000000,
+	.phys_io	= 0x40000000,
+	.io_pg_offst	= ((io_p2v (0xe0000000))>>18) & 0xfffc,
+	.boot_params	= 0x10000100,
+        .map_io = smdk_map_io,
+#else
+	.phys_ram	= 0x10000000,
+	.phys_io	= 0x40000000,
+#endif
+        .fixup = fixup_smdk,
+        .init_irq = elfin_init_irq,
+	.timer		= &elfin_timer,
+MACHINE_END
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c24a0/time.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/time.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c24a0/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c24a0/time.c	2005-11-08 08:48:37.000000000 +0900
@@ -0,0 +1,249 @@
+/*
+ * time.c for smdk24a0
+ * by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on linux/include/asm-arm/arch-s3c2410/time.h
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+#include <asm/arch/time.h>
+
+/* copy from linux/arch/arm/kernel/time.c */
+#ifndef BCD_TO_BIN
+#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+#ifndef RTC_LEAP_YEAR
+#define RTC_LEAP_YEAR        2000
+#endif
+
+extern spinlock_t rtc_lock;
+
+unsigned long elfin_get_rtc_time(void)
+{
+        unsigned int year, mon, day, hour, min, sec;
+
+        spin_lock_irq(&rtc_lock);
+read_rtc_bcd_time:
+        year = BCDYEAR & Msk_RTCYEAR;
+        mon  = BCDMON  & Msk_RTCMON;
+        day  = BCDDAY  & Msk_RTCDAY;
+        hour = BCDHOUR & Msk_RTCHOUR;
+        min  = BCDMIN  & Msk_RTCMIN;
+        sec  = BCDSEC  & Msk_RTCSEC;
+        if (sec == 0) {
+                /* If BCDSEC is zero, reread all bcd registers.
+                   See Section 17.2 READ/WRITE REGISTERS for more info. */
+                goto read_rtc_bcd_time;
+        }
+        spin_unlock_irq(&rtc_lock);
+
+        BCD_TO_BIN(year);
+        BCD_TO_BIN(mon);
+        BCD_TO_BIN(day);
+        BCD_TO_BIN(hour);
+        BCD_TO_BIN(min);
+        BCD_TO_BIN(sec);
+
+        year += RTC_LEAP_YEAR;
+
+        return (mktime(year, mon, day, hour, min, sec));
+}
+
+/*
+ * Copyed from drivers/char/sa1100-rtc.c.
+ */
+#define epoch                   1970
+
+static const unsigned char days_in_mo[] =
+        {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+#ifndef is_leap
+#define is_leap(year) \
+        ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+#endif
+
+/*
+ * Converts seconds since 1970-01-01 00:00:00 to Gregorian date.
+ */
+static void decodetime (unsigned long t, struct rtc_time *tval)
+{
+        unsigned long days, month, year, rem;
+
+        days = t / 86400;
+        rem = t % 86400;
+        tval->tm_hour = rem / 3600;
+        rem %= 3600;
+        tval->tm_min = rem / 60;
+        tval->tm_sec = rem % 60;
+        tval->tm_wday = (4 + days) % 7;
+
+#define LEAPS_THRU_END_OF(y) ((y)/4 - (y)/100 + (y)/400)
+
+        year = epoch;
+        while (days >= (365 + is_leap(year))) {
+                unsigned long yg = year + days / 365;
+                days -= ((yg - year) * 365
+                                + LEAPS_THRU_END_OF (yg - 1)
+                                - LEAPS_THRU_END_OF (year - 1));
+                year = yg;
+        }
+        tval->tm_year = year - 1900;
+        tval->tm_yday = days + 1;
+
+        month = 0;
+        if (days >= 31) {
+                days -= 31;
+                month++;
+                if (days >= (28 + is_leap(year))) {
+                        days -= (28 + is_leap(year));
+                        month++;
+                        while (days >= days_in_mo[month]) {
+                                days -= days_in_mo[month];
+                                month++;
+                        }
+                }
+        }
+        tval->tm_mon = month;
+        tval->tm_mday = days + 1;
+}
+
+int elfin_set_rtc(void)
+{
+        unsigned long current_time = xtime.tv_sec;
+        unsigned char year, mon, day, hour, min, sec;
+        signed int yeardiff;
+        struct rtc_time rtc_tm;
+
+        decodetime(current_time, &rtc_tm);
+
+        yeardiff = (rtc_tm.tm_year + 1900) - RTC_LEAP_YEAR;
+        if (yeardiff < 0) {
+                /* S3C2410 RTC forces that the year must be higher or
+                   equal than 2000, so initailize it. */
+                yeardiff = 0;
+        }
+
+        year = (unsigned char) yeardiff;
+        mon = rtc_tm.tm_mon + 1; /* tm_mon starts at zero */
+        day = rtc_tm.tm_mday;
+        hour = rtc_tm.tm_hour;
+        min = rtc_tm.tm_min;
+        sec = rtc_tm.tm_sec;
+
+        BIN_TO_BCD(sec);
+        BIN_TO_BCD(min);
+        BIN_TO_BCD(hour);
+        BIN_TO_BCD(day);
+        BIN_TO_BCD(mon);
+        BIN_TO_BCD(year);
+
+        spin_lock_irq(&rtc_lock);
+        RTCCON |= RTCCON_EN;
+        BCDSEC  = sec  & Msk_RTCSEC;
+        BCDMIN  = min  & Msk_RTCMIN;
+        BCDHOUR = hour & Msk_RTCHOUR;
+        BCDDAY  = day  & Msk_RTCDAY;
+        BCDMON  = mon  & Msk_RTCMON;
+        BCDYEAR = year & Msk_RTCYEAR;
+        RTCCON &= ~RTCCON_EN;
+        spin_unlock_irq(&rtc_lock);
+
+        return 0;
+}
+
+static unsigned long elfin_gettimeoffset(void)
+{
+        unsigned long elapsed, usec;
+        unsigned long latch;
+
+        /* Use TCNTB4 as LATCH */
+        latch = TCNTB4;
+
+        elapsed = latch - TCNTO4;
+        usec = (elapsed * (tick_nsec / 1000)) / latch; // hcyun
+
+        return usec;
+}
+
+static irqreturn_t elfin_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+
+//      do_set_rtc();
+	timer_tick(regs);
+
+        return IRQ_HANDLED;
+
+}
+
+static struct irqaction elfin_timer_irq = {
+	.name		= "S3C24A0 Timer Tick",
+	.flags		= SA_INTERRUPT | SA_TIMER,
+	.handler	= elfin_timer_interrupt
+};
+
+#define TCON4_PRESCALER_VALUE   15
+#define TCON4_DIVIDER_VALUE     2
+#define TCON4_PERIOD            10      /* miliseconds */
+void __init elfin_time_init(void)
+{
+        set_rtc = elfin_set_rtc;
+        xtime.tv_sec = elfin_get_rtc_time();
+
+        /* set timer interrupt */
+        TCFG0 = (TCFG0_DZONE(0) | TCFG0_PRE1(TCON4_PRESCALER_VALUE) | TCFG0_PRE0(TCON4_PRESCALER_VALUE));
+
+        /*
+         * period = (prescaler value + 1) * (divider value) * buffer count / PCLK
+         * buffer count = period * PCLK / divider value / (prescaler value + 1)
+         *
+         * e.g.)
+         *
+         * PCLK = 50700000 Hz, divider value = 2, prescaler value = 15
+         * period = 10ms
+         *
+         * buffer count = ((10 / 1000) * 50700000) / 2 / (15+1)
+         *              = 15843.75
+         */
+
+        printk("DEBUG: PCLK=%d, Prescaler=%d, Divider=%d\n", elfin_get_bus_clk(GET_PCLK), TCON4_PRESCALER_VALUE+1, TCON4_DIVIDER_VALUE );
+        TCNTB4 = ((TCON4_PERIOD * ((elfin_get_bus_clk(GET_PCLK))/1000)) / TCON4_DIVIDER_VALUE) / (TCON4_PRESCALER_VALUE + 1);
+        printk("DEBUG: timer count %d\n", TCNTB4);
+
+        TCON = (TCON_4_AUTO | TCON_4_UPDATE | (0 << 20));
+
+	elfin_timer_irq.handler = elfin_timer_interrupt;
+
+        printk("Timer Initialized.. IRQ=%d\n", IRQ_TIMER4);
+
+        setup_irq(IRQ_TIMER4, &elfin_timer_irq);
+
+        TCON = (TCON_4_AUTO | (0 << 21) | TCON_4_ONOFF);
+}
+
+struct sys_timer elfin_timer = {
+	.init		= elfin_time_init,
+	.offset		= elfin_gettimeoffset,
+};
+
+EXPORT_SYMBOL(elfin_get_rtc_time);
+EXPORT_SYMBOL(elfin_set_rtc);
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c3410/arch.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/arch.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c3410/arch.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/arch.c	2005-11-08 08:48:38.000000000 +0900
@@ -0,0 +1,55 @@
+/*
+ *  linux/arch/arm/mach-s5c7375/arch.c
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *			      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  Architecture specific fixups.  This is where any
+ *  parameters in the params struct are fixed up, or
+ *  any additional architecture specific information
+ *  is pulled from the params struct.
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+#include <linux/tty.h>
+#include <asm/elf.h>
+#include <linux/root_dev.h>
+#include <linux/initrd.h>
+
+
+extern void __init s3c3410_init_irq(void);
+extern void s3c3410_time_init(void);
+                                                                                                                                           
+static void __init
+fixup_s3c3410(struct machine_desc *desc, struct param_struct *params,
+        char **cmdline, struct meminfo *mi)
+{
+}
+
+MACHINE_START(S3C3410, "S3C3410, SAMSUNG ELECTRONICS Co., Ltd.")
+	MAINTAINER("Hyok S. Choi <hyok.choi@samsung.com>")
+	FIXUP(fixup_s3c3410)
+	INITIRQ(s3c3410_init_irq)
+	INITTIME(s3c3410_time_init)
+MACHINE_END
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c3410/dma.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/dma.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c3410/dma.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/dma.c	2005-11-08 08:48:38.000000000 +0900
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/arch-s3c3410/dma.c
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS Co., Ltd. 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *     
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+
+void arch_dma_init(dma_t *dma)
+{
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c3410/head.S linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/head.S
--- linux-2.6.14-uc0/arch/arm/mach-s3c3410/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/head.S	2005-11-08 08:48:38.000000000 +0900
@@ -0,0 +1,70 @@
+/*
+ *  linux/arch/arm/mach-s3c3410/head.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *  <hyok.choi@samsung.com>
+ *
+ *  uClinux kernel startup code for s3c3410
+ *  which has no proper bootloader for linux startup
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+#define MACHINFO_TYPE           0
+#define MACHINFO_PHYSRAM        4
+#define MACHINFO_PHYSIO         8
+#define MACHINFO_PGOFFIO        12
+#define MACHINFO_NAME           16
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r8, r9, sp}			@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+	ldr	r2, S3C3410_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, S3C3410_MACH_TYPE
+	str     r2, [r9]
+
+        mov fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start
+        .long	processor_id
+        .long	_end
+	.long   __machine_arch_type
+        .long	init_thread_union+8192
+	
+S3C3410_PROCESSOR_TYPE:
+	.long	0x34107700
+S3C3410_MACH_TYPE:
+	.long	MACH_TYPE_S3C3410
+
+#include "../kernel/head-common.S"
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c3410/irq.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/irq.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c3410/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/irq.c	2005-11-08 08:48:38.000000000 +0900
@@ -0,0 +1,131 @@
+/*
+ *  linux/arch/arm/mach-s5c7375/irq.c
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ * based the codes by
+ *     2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ *
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+void __inline__ s3c3410_mask_irq(unsigned int irq)
+{
+	outl( inl(S3C3410X_INTMSK) & ~( 1 << irq ), S3C3410X_INTMSK);
+}
+
+void __inline__ s3c3410_unmask_irq(unsigned int irq)
+{
+	outl( inl(S3C3410X_INTMSK) | ( 1 << irq ), S3C3410X_INTMSK);
+}
+
+void __inline__ s3c3410_mask_ack_irq(unsigned int irq)
+{
+	s3c3410_mask_irq(irq);
+}
+
+/* Clear pending bit */
+void __inline__ s3c3410_clear_pb(unsigned int irq)
+{
+     outl( ~(1 << irq), S3C3410X_INTPND);}
+
+
+/* YOU CAN CHANGE THIS ROUTINE FOR SPEED UP */
+__inline__ unsigned int fixup_irq (int irq )
+{
+	s3c3410_clear_pb(irq);
+	return(irq);
+}
+
+static struct irqchip s3c3410_chip = {
+	.ack	= s3c3410_clear_pb,
+	.mask	= s3c3410_mask_irq,
+	.unmask = s3c3410_unmask_irq,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init s3c3410_init_irq(void)
+{
+        int irq;
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &s3c3410_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	/* mask and disable all further interrupts */
+	outl(0x00000000, S3C3410X_INTMSK);
+
+	/* set all to IRQ mode, not FIQ */
+	outl(0x00000000, S3C3410X_INTMOD);
+
+	/* Clear Intrerrupt pending register	*/
+	outl(0x00000000, S3C3410X_INTPND);
+
+	/*
+	 * enable the gloabal interrupt flag, this should be
+	 * safe now, all sources are masked out and acknowledged
+	 */
+	outb(inb(S3C3410X_SYSCON) | S3C3410X_SYSCON_GIE, S3C3410X_SYSCON);
+}
+
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c3410/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/Kconfig
--- linux-2.6.14-uc0/arch/arm/mach-s3c3410/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/Kconfig	2005-11-08 08:48:38.000000000 +0900
@@ -0,0 +1,33 @@
+menu "S3C3410 Options"
+	depends on ARCH_S3C3410
+
+config ARCH_SUPPORTS_BIG_ENDIAN
+        bool
+        default y
+	help
+	S3C3410 core supports BIG-ENDIAN only,
+	both for CPU core and the external memory access.
+
+config ARM_CLK
+	int 'Arm Core Clock'
+	default 40000000
+	help
+	the default host clock of SMDK40100 is 40MHz.
+	otherwise, change the value in clock.
+
+config SKIP_DUMP_CPU_INFO
+	bool
+	default y
+	help
+	S3C3410(ARM7TDMI) core does not support cache size
+	recognition instructions which uses MMU features.
+
+config REMAP_VECTORS_TO_RAM
+	bool
+	default y
+	help
+	S3C3410 core does not support ROM and RAM remap
+	function. we set the trap_init to be initialized
+	at the begining of DRAM_BASE.
+
+endmenu
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c3410/Makefile linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/Makefile
--- linux-2.6.14-uc0/arch/arm/mach-s3c3410/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/Makefile	2005-11-08 08:48:38.000000000 +0900
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		+= arch.o irq.o mm.o dma.o time.o
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c3410/mm.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/mm.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c3410/mm.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/mm.c	2005-11-08 08:48:38.000000000 +0900
@@ -0,0 +1,21 @@
+/*
+ *  linux/arch/armnommu/mach-s3c3410/mm.c
+ *
+ *  Copyright(C)2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+ 
+#include <asm/mach/map.h>
+
+static void __init s3c3410_map_io(void)
+{
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c3410/time.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/time.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c3410/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c3410/time.c	2005-11-08 08:48:38.000000000 +0900
@@ -0,0 +1,96 @@
+/*
+ *  linux/arch/armnommu/mach-s3c3410/time.c
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *                      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+                                                                                                                                           
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/mach/time.h>
+#include <asm/arch/time.h>
+
+
+extern void s3c3410_unmask_irq(unsigned int irq);
+                                                                                                                                           
+unsigned long s3c3410_gettimeoffset (void)
+{
+        return (inw(S3C3410X_TCNT0) / CLOCKS_PER_USEC);
+}
+                                                                                                                                           
+static irqreturn_t
+s3c3410_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+    timer_tick(regs);
+                                                                                                                                           
+    return IRQ_HANDLED;
+}
+
+static struct irqaction s3c3410_timer_irq = {
+        .name           = "S3C3410 Timer Tick",
+        .flags          = SA_INTERRUPT,
+        .handler        = s3c3410_timer_interrupt
+};
+                                                                                                                                           
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+                                                                                                                                           
+void __init  s3c3410_time_init (void)
+{
+        u_int8_t tmod;
+        u_int16_t period;
+                                                                                                                                           
+        /*
+         * disable and clear timer 0, set to
+         * internal clock and interval mode
+         */
+        tmod = S3C3410X_T16_OMS_INTRV | S3C3410X_T16_CL;
+        outb(tmod, S3C3410X_TCON0);
+                                                                                                                                           
+        /* initialize the timer period and prescaler */
+        period = (CONFIG_ARM_CLK/S3C3410X_TIMER0_PRESCALER)/HZ;
+        outw(period, S3C3410X_TDAT0);
+        outb(S3C3410X_TIMER0_PRESCALER-1, S3C3410X_TPRE0);
+                                                                                                                                           
+        /*
+         * @todo do those really need to be function pointers ?
+         */
+        gettimeoffset     = s3c3410_gettimeoffset;
+        s3c3410_timer_irq.handler = s3c3410_timer_interrupt;
+                                                                                                                                           
+        /* set up the interrupt vevtor for timer 0 match */
+        setup_irq(S3C3410X_INTERRUPT_TMC0, &s3c3410_timer_irq);
+                                                                                                                                           
+        /* enable the timer IRQ */
+        s3c3410_unmask_irq(S3C3410X_INTERRUPT_TMC0);
+                                                                                                                                           
+        /* let timer 0 run... */
+        tmod |= S3C3410X_T16_TEN;
+        tmod &= ~S3C3410X_T16_CL;
+        outb(tmod, S3C3410X_TCON0);
+}
+                                                                                                                                           
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/arch.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/arch.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/arch.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/arch.c	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,107 @@
+/*
+ *  linux/arch/arm/mach-s3c44b0x/arch.c
+ *  	nickmit_zheng@eastday.com
+ *  		based on
+ *	Hyok S. Choi (hyok.choi@samsung.com)
+ * 	linux 2.6 armnommu porting
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+#include <linux/tty.h>
+#include <asm/elf.h>
+#include <linux/root_dev.h>
+#include <linux/initrd.h>
+
+// used by sysctl
+//#define DEFAULT_MAX_MAP_COUNT	65536
+//int sysctl_max_map_count = DEFAULT_MAX_MAP_COUNT;
+
+int s3c44b0x_fMHZ 	= CONFIG_ARM_CLK / 1000000;
+int s3c44b0x_finMHZ	= CONFIG_ARM_CLK_FIN / 1000000;
+
+extern void __init s3c44b0x_init_irq(void);
+extern void s3c44b0x_time_init(void);
+
+void __init s3c44b0x_init_machine(void)
+{
+}
+
+#if CONFIG_DEBUG_NICKMIT
+// char my_cmdline[] = "root=/dev/ram rw initrd=0x0c700000,512K";
+char my_cmdline[1024] = "root=/dev/nfs "
+	"nfsroot=192.168.1.24:/armboot "
+	"ip=192.168.1.8:192.168.1.24:192.168.1.1:255.255.255.0:arm:eth0:off";
+	
+void __init change_cmdline(char **cmdline)
+{
+	int magic_addr[] = {0xcf00000, 0xce000000, 0x1e0000};
+	char magic_head[] = "Kernel cmdline:";
+	int i;
+	int cnt = sizeof (magic_addr) / sizeof (int);
+	char *p, *d;
+	for(i=0;i<cnt;i++) {
+		p = (char *) magic_addr[i];
+		if (strncmp(p, magic_head, (sizeof magic_head) - 1) != 0)
+			continue;
+		p += sizeof magic_head - 1;
+		d = my_cmdline;
+		while (*p != '\r' && *p != '\n' && (d - my_cmdline - sizeof my_cmdline))
+			*d++ = *p++;
+
+		*d = 0;
+		*cmdline = my_cmdline;
+		return;
+	}
+	*cmdline = my_cmdline;
+}
+
+void __init load_initrd(void *src, void *dst, size_t count)
+{
+	int verify = 1;
+	printk("Load initrd image from flash(%08x) to SDRAM(%08x), Length = %d ...", src, dst, count);
+	memmove(dst, src, count);
+	if (verify) {
+		printk("Verify ...");
+		printk("%s\n", memcmp(src, dst, count) == 0 ? "Done" : "Failed");
+	} else {
+		printk("Done\n");
+	}
+}
+#endif
+
+void __init s3c44b0x_fixup(struct machine_desc *desc, struct param_struct *params, char **cmdline, struct meminfo *mi)
+{
+#if CONFIG_NICKMIT_DEBUG
+	change_cmdline(cmdline);
+//	load_initrd(0x1000, 0x0c700000, 0x100000);
+#endif
+}
+
+MACHINE_START(S3C44B0, "S3C44B0X Development Board")
+	MAINTAINER("nickmit <nickmit_zheng@eastday.com>")
+	FIXUP(s3c44b0x_fixup)
+	INITIRQ(s3c44b0x_init_irq)
+	INIT_MACHINE(s3c44b0x_init_machine)
+	INITTIME(s3c44b0x_time_init)
+MACHINE_END
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/cache.S linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/cache.S
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/cache.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/cache.S	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ *  linux/arch/arm/mm/cache-s3c44b0.S
+ *
+ *  caution: s3c44b0x DONT have a coprocessor!
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/page.h>
+
+ENTRY(v3_flush_user_cache_all)
+ENTRY(v3_flush_kern_cache_all)
+ENTRY(v3_flush_user_cache_range)
+
+ENTRY(v3_coherent_kern_range)
+
+ENTRY(v3_flush_kern_dcache_page)
+ENTRY(v3_dma_inv_range)
+ENTRY(v3_dma_flush_range)
+ENTRY(v3_dma_clean_range)
+	mov	pc, lr
+
+	__INITDATA
+
+	.type	v3_cache_fns, #object
+ENTRY(v3_cache_fns)
+	.long	v3_flush_kern_cache_all
+	.long	v3_flush_user_cache_all
+	.long	v3_flush_user_cache_range
+	.long	v3_coherent_kern_range
+	.long	v3_flush_kern_dcache_page
+	.long	v3_dma_inv_range
+	.long	v3_dma_clean_range
+	.long	v3_dma_flush_range
+	.size	v3_cache_fns, . - v3_cache_fns
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/dma.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/dma.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/dma.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/dma.c	2005-11-08 08:48:54.000000000 +0900
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/arch-s3c44b0x/dma.c
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+
+void arch_dma_init(dma_t *dma)
+{
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/console.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/console.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/console.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/console.c	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,41 @@
+#include <linux/init.h>
+#include <linux/console.h>
+#include <asm/arch/hardware.h>
+
+void s3c44b0x_uart_putc(const char c)
+{
+	while(!(SYSREG_GET(S3C44B0X_UTRSTAT0) & 0x2));
+	SYSREG_SETB(S3C44B0X_UTXH0, c);
+}
+
+void s3c44b0x_console_write(struct console *co, const char *b, unsigned count)
+{
+	while(count) {
+		s3c44b0x_uart_putc(*b);
+		if (*b == '\n')
+			s3c44b0x_uart_putc('\r');
+		++b;
+		--count;
+	}
+}
+
+static int __init s3c44b0x_console_setup(struct console *co, char *options)
+{       
+	return 0;
+}
+
+struct console s3c44b0x_con_driver = {
+	.name           = "S3C44B0X",
+	.write          = s3c44b0x_console_write,
+	.setup          = s3c44b0x_console_setup,
+	.flags          = CON_PRINTBUFFER,
+	.index          = -1,
+};      
+
+static int __init s3c44b0x_console_init(void) 
+{                               
+	register_console(&s3c44b0x_con_driver);
+	return 0;       
+}                               
+
+console_initcall(s3c44b0x_console_init);
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/Kconfig
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/Kconfig	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,23 @@
+menu "S3C44B0X Board Driver Options" 
+
+config SERIAL_S3C44B0X
+	bool 'S3C44B0X Serial Support'
+	default y
+	help
+	Samsung S3C44B0X Chips has built-in serial controler
+
+config SERIAL_S3C44B0X_CONSOLE
+	bool 'S3C44B0X Serial Console Support'
+	depends on SERIAL_S3C44B0X
+	help
+	use serial port 0 as console
+	
+config ETH_RTL8019AS
+	bool 'Realtek 8019AS NIC support'
+	default n
+
+config S3C44B0X_GPIO_LED
+	bool 'Use onboard led'
+	default n
+
+endmenu
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/led.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/led.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/led.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/led.c	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,28 @@
+#include <asm/arch/hardware.h>
+
+void s3c44b0x_led_off(int bit)
+{
+	SYSREG_OR_SET(S3C44B0X_PDATE, 1<<(4+bit));
+}
+
+void s3c44b0x_led_on(int bit)
+{	
+	SYSREG_CLR(S3C44B0X_PDATE, 1<<(4+bit));
+}
+
+void s3c44b0x_led_disp(int data)
+{
+	data = (data << 12) >> 8;
+	data = (~data) & 0x1ff;
+	SYSREG_AND_SET(S3C44B0X_PDATE, ~data);
+}
+
+void s3c44b0x_led_init(void)
+{
+	SYSREG_AND_SET(S3C44B0X_PCONE, 0xffff556b);
+	SYSREG_SET(S3C44B0X_PUPE, 0x6);
+	SYSREG_SET(S3C44B0X_PDATE, 0x3f7);
+	s3c44b0x_led_disp(15);
+}
+
+
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/Makefile linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/Makefile
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/Makefile	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+# obj-$(CONFIG_SERIAL_S3C44B0X)	+= serial_core_44b0x.o s3c44b0.o
+obj-$(CONFIG_SERIAL_S3C44B0X)	+= console.o
+obj-$(CONFIG_ETH_RTL8019AS)	+= rtl8019.o
+obj-$(CONFIG_S3C44B0X_GPIO_LED)	+= led.o
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/rtl8019.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/rtl8019.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/rtl8019.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/rtl8019.c	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,419 @@
+/*
+ * port to 16bit/8bit remote dma mode lq@cdgwbn.com.cn 
+ * linux/deriver/net/Rtl8019as.c
+ * Ethernet driver for Samsung 44B0
+ * Copyright (C) 2003 antiscle <hzh12@163.net>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>		// kmalloc()
+#include <linux/errno.h>	// error codes
+#include <linux/types.h>	// size_t
+#include <linux/interrupt.h>	// mark_bh
+#include <linux/in.h>
+#include <linux/netdevice.h>    // net_device
+#include <linux/etherdevice.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <asm/irq.h>
+#include "rtl8019.h"
+
+#define RTL8019_OP_16   1
+
+#undef  DEBUG
+#define DEBUG	1
+#ifdef	DEBUG
+#define TRACE(str, args...)	printk(str, ## args)
+#else
+#define TRACE(str, args...)
+#endif
+
+
+#define	outportb(port, data)	*((volatile u8 *)(port)) = (u8)(data)
+#define	inportb(port)		*((volatile u8 *)(port))
+
+
+#define	outportw(port, data)	*((volatile u16 *)(port)) = (u16)(data)
+#define	inportw(port)		*((volatile u16 *)(port))
+
+#define	ETH_FRAME_LEN		1514
+
+#define	RPSTART			0x4c
+#define	RPSTOP			0x80
+#define	SPSTART			0x40
+
+static int timeout = 100;	// tx watchdog ticks 100 = 1s
+static char *version = "Samsung S3C44B0 Rtl8019as driver version 0.1 (2002-02-20) <hzh12@163.net>\n";
+
+/*
+ * This structure is private to each device. It is used to pass
+ * packets in and out, so there is place for a packet
+ */
+struct nic_8019_priv {
+	struct net_device_stats stats;	
+	spinlock_t lock;
+	struct sk_buff *skb;
+};
+
+/*****************************************************************************/
+static u8 rBNRY;
+static u8 SrcMacID[ETH_ALEN] = {0x12,0x34,0x56,0x78,0x90,0xAB,};
+
+static void SetRegPage( u8 PageIdx)
+{
+	u8 temp;
+
+	temp = inportb(BaseAddr);	
+	temp = (temp&0x3b)|(PageIdx<<6);						
+	outportb(BaseAddr, temp);
+}
+
+
+irqreturn_t nic_8019_rx(int irq, void *dev_id, struct pt_regs *regs)
+{
+	u8 RxPageBeg, RxPageEnd;
+	u8 RxNextPage;
+	u8 RxStatus;
+	u16 *data,temp;
+	u16 i, RxLength,RxLen;
+
+	struct sk_buff *skb;	
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct nic_8019_priv *priv = (struct nic_8019_priv *) dev->priv;
+
+	TRACE("TX/RX Interupt!\n");
+	spin_lock(&priv->lock);
+	SetRegPage(0);
+	outportb(BNRY, rBNRY);		//???
+	RxStatus = inportb(ISR);
+	if (RxStatus & 2) {
+		outportb(ISR, 0x2);		//clr TX interupt
+		priv->stats.tx_packets++;	
+		TRACE("transmit one packet complete!\n");
+	}
+	
+	if (RxStatus & 1) {
+		TRACE("Receivex packet....\n");		
+		outportb(ISR, 0x1);	         //clr Rx interupt	
+		SetRegPage(1);
+		RxPageEnd = inportb(CURR);
+
+		SetRegPage(0);	
+		RxPageBeg = rBNRY+1;
+		if(RxPageBeg>=RPSTOP)
+			RxPageBeg = RPSTART;		
+		outportb(BaseAddr, 0x22);	// stop	remote dma
+
+		//outport(RSAR0, RxPageBeg<<8);
+		//outport(RBCR0, 256);		
+		outportb(RSAR0, 0);
+		outportb(RSAR1, RxPageBeg);
+		outportb(RBCR0, 4);
+		outportb(RBCR1, 0);	
+		outportb(BaseAddr, 0xa);
+
+#ifdef RTL8019_OP_16
+		temp       = inportw(RWPORT);
+		RxNextPage = temp>>8;
+		RxStatus   = temp&0xff;
+		RxLength   = inportw(RWPORT);
+#else
+		RxStatus   = inportb(RWPORT);
+		RxNextPage = inportb(RWPORT);	
+		RxLength   = inportb(RWPORT);
+		RxLength  |= inportb(RWPORT)<<8;
+#endif		
+		TRACE("\nRxBeg = %x, RxEnd = %x,  nextpage = %x,  size = %i\n", RxPageBeg, RxPageEnd, RxNextPage, RxLength);		
+		RxLength -= 4;
+		if (RxLength>ETH_FRAME_LEN) {
+			if (RxPageEnd==RPSTART)
+				rBNRY = RPSTOP-1;
+			else
+				rBNRY = RxPageEnd-1;
+				
+			outportb(BNRY, rBNRY);
+			TRACE("RxLength more long than %x\n", ETH_FRAME_LEN);
+			return IRQ_HANDLED;
+		}
+
+		skb = dev_alloc_skb(RxLength+2);
+		if (!skb) {
+			TRACE("Rtl8019as eth: low on mem - packet dropped\n");
+			priv->stats.rx_dropped++;
+			return IRQ_HANDLED;
+		}
+
+		skb->dev = dev;		
+		skb_reserve(skb, 2);
+		skb_put(skb, RxLength);
+		data = ( u16 *)skb->data;
+
+		//		eth_copy_and_sum(skb, data, len, 0);
+		outportb(RSAR0, 4);
+		outportb(RSAR1, RxPageBeg);
+		outportb(RBCR0, RxLength);
+		outportb(RBCR1, RxLength>>8);	
+		outportb(BaseAddr, 0xa);
+#ifdef RTL8019_OP_16
+		i = 2;
+		data -= 2;
+		RxLen=(RxLength+1)/2;	
+#else 
+		i = 4;
+		data -= 4;
+		RxLen=RxLength;
+#endif
+		for(; RxLen--;) {
+#ifdef RTL8019_OP_16
+			static const int cmp_val = 0x7f;
+#else
+			static const int cmp_val = 0xff;
+#endif
+			if (!(i & cmp_val)) {
+				outportb(BNRY, RxPageBeg);				
+				RxPageBeg++;
+				if(RxPageBeg>=RPSTOP)
+					RxPageBeg = RPSTART;					
+			}
+#ifdef RTL8019_OP_16
+			data[i++] = inportw(RWPORT);		
+			TRACE("%2X,%2X,", data[i-1]&0xff,data[i-1]>>8);
+#else
+			data[i++] = inportb(RWPORT);		
+			TRACE("%2X,", data[i-1]);
+#endif
+		}
+
+		TRACE("\n");
+		outportb(BNRY, RxPageBeg);	
+		rBNRY = RxPageBeg;
+
+		skb->protocol = eth_type_trans(skb, dev);
+		TRACE("\nprotocol=%x\n", skb->protocol);
+		priv->stats.rx_packets++;
+		priv->stats.rx_bytes +=RxLength;
+		netif_rx(skb);
+	} else {
+		outportb(ISR, 0xfe);	
+	}
+
+	spin_unlock(&priv->lock);
+	return IRQ_HANDLED;
+}
+
+
+/*
+ * Open and Close
+ */
+static int nic_8019_open(struct net_device *dev)
+{
+	int i,j;
+
+	MOD_INC_USE_COUNT;
+	TRACE("open\n");
+	// Disable irqs
+	disable_irq(dev->irq);
+	// register rx isr
+	if (request_irq(dev->irq, &nic_8019_rx, SA_INTERRUPT, "eth rx isr", dev)) {
+		printk(KERN_ERR "Rtl8019: Can't get irq %d\n", dev->irq);
+		return -EAGAIN;
+	}
+
+	// wake up Rtl8019as
+	SetRegPage(3);	
+	outportb(CR9346, 0xcf);		//set eem1-0, 11 ,enable write config register
+	outportb(CONFIG3, 0x60);	//clear pwrdn, sleep mode, set led0 as led_col, led1 as led_crs	
+	outportb(CR9346, 0x3f); 	//disable write config register
+	
+	// initialize
+	outportb(RstAddr, 0x5a);
+	i = 20000;
+	while(i--);
+
+
+	SetRegPage(0);
+	inportb(ISR);				
+	outportb(BaseAddr, 0x21);	/* set page 0 and stop */
+	outportb(Pstart, RPSTART);	/* set Pstart 0x4c */
+	outportb(Pstop, RPSTOP);	/* set Pstop 0x80 */
+	outportb(BNRY, RPSTART);	/* BNRY-> the last page has been read */	
+	outportb(TPSR, SPSTART);	/* SPSTART page start register, 0x40 */
+	outportb(RCR, 0xcc);		/* set RCR 0xcc */	
+	outportb(TCR, 0xe0);		/* set TCR 0xe0 */
+	outportb(DCR, 0xc9);		/* set DCR 0xc9, 16bit DMA */	
+
+	outportb(IMR, 0x03);		/* set IMR 0x03, enable tx rx int */
+	outportb(ISR, 0xff);		/* clear ISR */
+
+	SetRegPage(1);
+	for(i=0; i<6; i++)
+		outportb(BaseAddr+(1+i)*2, dev->dev_addr[i]);	// set mac id
+		
+	outportb(CURR, RPSTART+1);	
+	outportb(MAR0, 0x00);
+	outportb(MAR1, 0x41);
+	outportb(MAR2, 0x00);
+	outportb(MAR3, 0x80);
+	outportb(MAR4, 0x00);
+	outportb(MAR5, 0x00);
+	outportb(MAR6, 0x00);
+	outportb(MAR7, 0x00);
+	outportb(BaseAddr, 0x22);		/* set page 0 and start */	
+	rBNRY = RPSTART;
+	enable_irq(dev->irq);		
+	// Start the transmit queue
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int nic_8019_stop(struct net_device *dev)
+{
+	TRACE("stop\n");
+	SetRegPage(3);	
+	outportb(CR9346, 0xcf);		// set eem1-0, 11 ,enable write config register
+	outportb(CONFIG3, 0x66);	// enter pwrdn, sleep mode, set led0 as led_col, led1 as led_crs	
+	outportb(CR9346, 0x3f); 	// disable write config register
+
+	free_irq(dev->irq, dev);	
+	netif_stop_queue(dev);
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static int nic_8019_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int i;
+	u16 len,TxLen;
+	u16 *data;
+	struct nic_8019_priv *priv = (struct nic_8019_priv *) dev->priv;
+
+	TRACE("start_xmit\n");
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	TRACE("\nTx Length = %i,%x,%x\n", len, skb->data[12], skb->data[13]);
+	data =(u16*) skb->data;
+
+	outportb(BaseAddr,0x22);  	//switch to page 0 and stop remote dma
+	if (inportb(BaseAddr)&4)	// last remote dma not complete,return 1 echo busy(error),retransmit next
+		return 1;
+#ifdef bug_fix_for_write
+	//read page 42,0,42,0 before write if you have problem
+#endif
+	outportb(RSAR0, 0);
+	outportb(RSAR1, SPSTART);
+	outportb(RBCR0, len&0xff);	
+	outportb(RBCR1, len>>8);			
+	outportb(BaseAddr, 0x12);	//begin remote write
+	dev->trans_start = jiffies;	
+#ifdef RTL8019_OP_16
+	TxLen=(len+1)/2;
+#else
+	TxLen=len;
+#endif
+	for(i=0; i<TxLen; i++) {				
+#ifdef RTL8019_OP_16		
+		outportw(RWPORT, data[i]);		// copy data to nic ram
+		TRACE("%2X,%2X,",data[i]&0xff,data[i]>>8);
+#else
+		outportb(RWPORT, data[i]);		// copy data to nic ram
+		TRACE("%2X,",skb->data[i]);
+#endif
+	}	
+
+	TRACE("\n");
+	outportb(TPSR,  SPSTART);       // transmit begin page 0x40
+	outportb(TBCR0, len&0xff);	
+	outportb(TBCR1, len>>8);				
+	outportb(BaseAddr, 0x1e);	// begin to send packet	
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+static struct net_device_stats *nic_8019_get_stats(struct net_device *dev)
+{
+	struct nic_8019_priv *priv = (struct nic_8019_priv *) dev->priv;
+	TRACE("get_stats\n");
+	return &priv->stats;
+}
+
+/******************************************************************************/
+static int nic_8019_init(struct net_device *dev)
+{
+	int i;
+	TRACE("init\n");
+	ether_setup(dev);	// Assign some of the fields
+
+	// set net_device methods
+	dev->open = nic_8019_open;
+	dev->stop = nic_8019_stop;
+	dev->get_stats = nic_8019_get_stats;
+	dev->hard_start_xmit = nic_8019_start_xmit;
+
+	// set net_device data members
+	dev->watchdog_timeo = timeout;
+	dev->irq = 22;
+	dev->dma = 0;
+
+	// set MAC address manually
+	printk(KERN_INFO "%s: ", dev->name);
+	for(i=0; i<6; i++) {
+		dev->dev_addr[i] = SrcMacID[i];		
+		printk("%2.2x%c", dev->dev_addr[i], (i==5) ? ' ' : ':');
+	}
+	printk("\n");
+
+	SET_MODULE_OWNER(dev);
+
+	dev->priv = kmalloc(sizeof(struct nic_8019_priv), GFP_KERNEL);
+	if(dev->priv == NULL)
+		return -ENOMEM;
+
+	memset(dev->priv, 0, sizeof(struct nic_8019_priv));
+	spin_lock_init(&((struct nic_8019_priv *) dev->priv)->lock);
+	return 0;
+}
+
+static struct net_device nic_8019_netdevs = {
+	init: nic_8019_init,
+};
+
+/*
+ * Finally, the module stuff
+ */
+int __init nic_8019_init_module(void)
+{
+	int result;
+	TRACE("init_module\n");
+
+	//Print version information
+	printk(KERN_INFO "%s", version);
+
+	//register_netdev will call nic_8019_init()
+	if((result = register_netdev(&nic_8019_netdevs)))
+		printk("Rtl8019as eth: Error %i registering device \"%s\"\n", result, nic_8019_netdevs.name);
+		
+	return result ? 0 : -ENODEV;
+}
+
+void __exit nic_8019_cleanup(void)
+{
+	TRACE("cleanup\n");
+	kfree(nic_8019_netdevs.priv);
+	unregister_netdev(&nic_8019_netdevs);
+	return;
+}
+
+module_init(nic_8019_init_module);
+module_exit(nic_8019_cleanup);
+
+MODULE_DESCRIPTION("Rtl8019as ethernet driver");
+MODULE_AUTHOR("antiscle <hzh12@163.net>");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/rtl8019.h linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/rtl8019.h
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/driver/rtl8019.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/driver/rtl8019.h	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,55 @@
+
+#define SHIFT(x)	(x<<1)
+
+#define	BaseAddr	0x6000000
+#define	RWPORT	(BaseAddr+SHIFT(0x10))	/* dma read write address, form 0x10 - 0x17 */
+#define	RstAddr (BaseAddr+SHIFT(0x18))	/* reset register, 0x18, 0x1a, 0x1c, 0x1e even address is recommanded */
+
+/* page 0 */
+#define	Pstart	(BaseAddr+SHIFT(1))	/* page start */
+#define	Pstop	(BaseAddr+SHIFT(2))	/* page stop */
+#define	BNRY	(BaseAddr+SHIFT(3))	
+#define	TPSR	(BaseAddr+SHIFT(4))	/* transmit page start */
+#define	TBCR0	(BaseAddr+SHIFT(5))
+#define	TBCR1	(BaseAddr+SHIFT(6))
+#define	ISR	(BaseAddr+SHIFT(7))	/* interrupt status register */
+
+#define	RSAR0	(BaseAddr+SHIFT(8))	/* dma read address */
+#define	RSAR1	(BaseAddr+SHIFT(9))
+#define	RBCR0	(BaseAddr+SHIFT(10))	/* dma read byte count */
+#define	RBCR1	(BaseAddr+SHIFT(11))
+
+#define	RCR	(BaseAddr+SHIFT(12))	/* receive config */
+#define	TCR	(BaseAddr+SHIFT(13))	/* transmit config */
+#define	DCR	(BaseAddr+SHIFT(14))	/* data config */
+#define	IMR	(BaseAddr+SHIFT(15))	/* interrupt mask */
+
+#define	ID8019L	(BaseAddr+SHIFT(10))
+#define	ID8019H	(BaseAddr+SHIFT(11))
+
+/* page 1 */
+#define	PAR0	(BaseAddr+SHIFT(1))
+#define	PAR1	(BaseAddr+SHIFT(2))
+#define	PAR2	(BaseAddr+SHIFT(3))
+#define	PAR3	(BaseAddr+SHIFT(4))
+#define	PAR4	(BaseAddr+SHIFT(5))
+#define	PAR6	(BaseAddr+SHIFT(6))
+
+#define	CURR	(BaseAddr+SHIFT(7))		
+#define	MAR0	(BaseAddr+SHIFT(8))
+#define	MAR1	(BaseAddr+SHIFT(9))
+#define	MAR2	(BaseAddr+SHIFT(10))
+#define	MAR3	(BaseAddr+SHIFT(11))
+#define	MAR4	(BaseAddr+SHIFT(12))
+#define	MAR5	(BaseAddr+SHIFT(13))
+#define	MAR6	(BaseAddr+SHIFT(14))
+#define	MAR7	(BaseAddr+SHIFT(15))
+
+/* page 2 */
+
+/* page 3 */
+#define	CR9346	(BaseAddr+SHIFT(1))
+#define	CONFIG0	(BaseAddr+SHIFT(3))
+#define	CONFIG1	(BaseAddr+SHIFT(4))
+#define	CONFIG2	(BaseAddr+SHIFT(5))
+#define	CONFIG3	(BaseAddr+SHIFT(6))
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/head.S linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/head.S
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/head.S	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,74 @@
+/*
+ *  linux/arch/armnommu/mach-s3c44b0x/head.S
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+#include <asm/arch/hardware.h>
+
+#define MACHINFO_TYPE           0
+#define MACHINFO_PHYSRAM        4
+#define MACHINFO_PHYSIO         8
+#define MACHINFO_PGOFFIO        12
+#define MACHINFO_NAME           16
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	/*
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	*/
+	mov	r0, #PSR_I_BIT | MODE_SVC		@ make sure svc mode
+	msr	cpsr_c, r0				@ and all irqs disabled
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r8, r9, sp}		@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+	/* handle CPU Cache */
+	ldr	r4, =S3C44B0X_SYSCFG
+	mov	r5, #0x0e
+	str	r5, [r4]
+	
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+
+	ldr	r2, S3C44B0_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, S3C44B0_MACH_TYPE
+	str     r2, [r9]
+
+        mov 	fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start
+        .long	processor_id
+        .long	_end
+	.long   __machine_arch_type
+        .long	init_thread_union+8192
+	
+S3C44B0_PROCESSOR_TYPE:
+	.long	0x44b07700
+S3C44B0_MACH_TYPE:
+	.long	MACH_TYPE_S3C44B0
+
+#include "../kernel/head-common.S"
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/irq.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/irq.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/irq.c	2005-11-08 08:48:54.000000000 +0900
@@ -0,0 +1,143 @@
+/*
+ *  linux/arch/arm/mach-s3c44b0x/irq.c
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+void __inline__ s3c44b0x_mask_irq(unsigned int irq)
+{
+	SYSREG_OR_SET(S3C44B0X_INTMSK, 1<<irq);
+}
+
+void __inline__ s3c44b0x_unmask_irq(unsigned int irq)
+{
+	SYSREG_CLR(S3C44B0X_INTMSK, 1<<irq);
+}
+
+void __inline__ s3c44b0x_mask_ack_irq(unsigned int irq)
+{
+	s3c44b0x_mask_irq(irq);
+}
+
+/* Clear pending bit */
+void __inline__ s3c44b0x_clear_pb(unsigned int irq)
+{
+	SYSREG_OR_SET(S3C44B0X_I_ISPC, 1<<irq);
+}
+
+
+/* YOU CAN CHANGE THIS ROUTINE FOR SPEED UP */
+__inline__ unsigned int fixup_irq (int irq )
+{
+	s3c44b0x_clear_pb(irq);
+	return(irq);
+}
+
+static struct irqchip s3c44b0x_chip = {
+	.ack	= s3c44b0x_clear_pb,
+	.mask	= s3c44b0x_mask_irq,
+	.unmask = s3c44b0x_unmask_irq,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+
+void __init s3c44b0x_init_irq(void)
+{
+        int irq;
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &s3c44b0x_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	/* Note: in Samsung s3c44b0x um
+	
+	"1. INTMSK register can be masked only when it is sure that the corresponding interrupt does not be
+	requested. If your application should mask any interrupt mask bit(INTMSK) just when the
+	corresponding interrupt is issued, please contact our FAE (field application engineer).
+	
+	2. If you need that all interrupt is masked, we recommend that I/F bits in CPSR are set using MRS, MSR
+	instructions. The I, F bit in CPSR can be masked even when any interrupt is issued."
+	
+	*/
+	/* at this moment, the I/F bits should has been set, so it's safe to use rINTMAK */
+	
+	/* mask and disable all further interrupts */
+	SYSREG_SET(S3C44B0X_INTMSK, 0x07ffffff);
+
+	/* set all to IRQ mode, not FIQ */
+
+	SYSREG_SET(S3C44B0X_INTCON, 0x5);	 // Vectored & IRQ & !FIQ
+	SYSREG_SET(S3C44B0X_INTMOD, 0x00000000); // All IRQ mode
+
+	/* Clear Intrerrupt pending register */
+
+	SYSREG_OR_SET(S3C44B0X_I_ISPC, 0x7fffffff);
+
+	/*
+	 * enable the gloabal interrupt flag, this should be
+	 * safe now, all sources are masked out and acknowledged
+	 */
+	SYSREG_CLR(S3C44B0X_INTMSK, 1<<26);
+}
+
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/Kconfig
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/Kconfig	2005-11-08 08:48:54.000000000 +0900
@@ -0,0 +1,45 @@
+menu "S3C44B0X Board Options" 
+	depends on ARCH_S3C44B0
+
+config DEBUG_NICKMIT
+	bool 'DEBUG_NICKMIT'
+	default n
+
+config SKIP_DUMP_CPU_INFO
+	bool 'Skip Dump CPU Info'
+	default y
+	help
+	S3C44B0X(ARM7TDMI) core does not support cache size
+	recognition instructions which uses MMU features.
+
+config REMAP_VECTORS_TO_RAM
+	bool 'Remap Vectors To Ram'
+	default y
+	help
+	S3C44B0X core does not support ROM and RAM remap
+	function. we set the trap_init to be initialized
+	at the begining of DRAM_BASE.
+
+config ARM_CLK
+	int 'Arm Core Clock'
+	default 60000000
+	help
+	the default host clock of 51EDA-S3C44B0X Board is 60MHz.
+	otherwise, change the value in clock.
+	
+config ARM_CLK_ADJUST
+	bool "Arm Core Clock Adjust(EXPERIMENTAL)"
+	default n && EXPERIMENTAL
+	help
+	use this option to adjust the CPU frequence
+
+config ARM_CLK_FIN
+	int 'External OSC Clock Frequence' 
+	default 8000000
+	depends on ARM_CLK_ADJUST && EXPERIMENTAL
+	help
+	this is the input frequence of system clock
+
+source "arch/arm/mach-s3c44b0x/driver/Kconfig"
+
+endmenu
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/Makefile linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/Makefile
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/Makefile	2005-11-08 08:48:54.000000000 +0900
@@ -0,0 +1,8 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		+= arch.o irq.o mm.o dma.o time.o cache.o
+obj-y		+= driver/
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/Makefile.boot linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/Makefile.boot
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/Makefile.boot	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/Makefile.boot	2005-11-08 08:48:54.000000000 +0900
@@ -0,0 +1,2 @@
+   zreladdr-y	:= 0x0c008000
+initrd_phys-y	:= 0x0c300000
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/mm.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/mm.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/mm.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/mm.c	2005-11-08 08:48:54.000000000 +0900
@@ -0,0 +1,18 @@
+/*
+ *  linux/arch/armnommu/mach-s3c44b0x/mm.c
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+ 
+#include <asm/mach/map.h>
+
+static void __init s3c44b0x_map_io(void)
+{
+	return;
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/time.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/time.c
--- linux-2.6.14-uc0/arch/arm/mach-s3c44b0x/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s3c44b0x/time.c	2005-11-08 08:48:55.000000000 +0900
@@ -0,0 +1,104 @@
+/*
+ * for 2.6.8.1 port by 
+ *    Hyok S. Choi <hyok.choi@samsung.com>
+ * linux/arch/armnommu/mach-s3c44b0x/time.c
+ */
+
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/mach/time.h>
+#include <asm/arch/timex.h>
+
+#define S3C44B0X_SYSTIMER_DIVIDER	2
+extern int s3c44b0x_fMHZ;
+extern int s3c44b0x_finMHZ;
+
+/* the system clock is in MHz unit, here I use the prescale value for 1 us resolution */
+
+#if	CONFIG_ARM_CLK_ADJUST
+void s3c44b0x_systimer_setup(void)
+#else
+void __init s3c44b0x_systimer_setup(void)
+#endif
+{
+	int prescale = s3c44b0x_fMHZ / S3C44B0X_SYSTIMER_DIVIDER;
+	int cnt = s3c44b0x_fMHZ * 1000000 / prescale / S3C44B0X_SYSTIMER_DIVIDER / HZ;
+	
+	SYSREG_CLR	(S3C44B0X_TCON,0x7<<24);			// stop timer 5			
+	SYSREG_SET	(S3C44B0X_TCNTB5, cnt);
+	SYSREG_OR_SET	(S3C44B0X_TCON, 2<<24);				// update timer5 counter
+	
+	SYSREG_OR_SET	(S3C44B0X_TCFG0, (prescale - 1) << 16);		// set prescale, bit 16-23
+	SYSREG_AND_SET	(S3C44B0X_TCFG1, 0xff0fffff);			// set timer5 divider, bit 20-23.  0 for 1/2 
+}
+
+void __inline__ s3c44b0x_systimer_start(void)
+{
+	SYSREG_CLR	(S3C44B0X_TCON, 0x02<<24);
+	SYSREG_OR_SET	(S3C44B0X_TCON, 0x05<<24);
+}
+
+/*
+ * Set up timer interrupt.
+ */
+#if     CONFIG_ARM_CLK_ADJUST
+void s3c44b0x_led_off(int);
+void s3c44b0x_led_on(int);
+#endif
+                                                                                                                                           
+unsigned long s3c44b0x_gettimeoffset (void)
+{
+        return SYSREG_GETW(S3C44B0X_TCNTB5);
+}
+                                                                                                                                           
+static irqreturn_t s3c44b0x_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+#if     CONFIG_DEBUG_NICKMIT
+        static int cnt = 0;
+        ++cnt;
+        if (cnt == HZ) {
+                static int stat = 0;
+                cnt = 0;
+                if (stat)
+                        s3c44b0x_led_on(0);
+                else
+                        s3c44b0x_led_off(0);
+                stat = 1 - stat;
+        }
+#endif
+        timer_tick(regs);
+
+        return IRQ_HANDLED;
+}
+
+static struct irqaction s3c44b0x_timer_irq = {
+        .name           = "S3C44B0X Timer Tick",
+        .flags          = SA_INTERRUPT,
+        .handler        = s3c44b0x_timer_interrupt
+};
+
+                                                                                                                                           
+void __init s3c44b0x_time_init(void)
+{
+        s3c44b0x_systimer_setup();
+        /*
+         * @todo do those really need to be function pointers ?
+         */
+        gettimeoffset     = s3c44b0x_gettimeoffset;
+        s3c44b0x_timer_irq.handler = s3c44b0x_timer_interrupt;
+                                                                                                                                           
+        setup_irq(S3C44B0X_INTERRUPT_TIMER5, &s3c44b0x_timer_irq);
+        s3c44b0x_clear_pb(S3C44B0X_INTERRUPT_TIMER5);
+        s3c44b0x_unmask_irq(S3C44B0X_INTERRUPT_TIMER5);
+                                                                                                                                           
+        s3c44b0x_systimer_start();
+}
+
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s5c7375/arch.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/arch.c
--- linux-2.6.14-uc0/arch/arm/mach-s5c7375/arch.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/arch.c	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,56 @@
+/*
+ *  linux/arch/arm/mach-s5c7375/arch.c
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *			      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/time.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+extern void s5c7375_time_init(void);
+extern unsigned long s5c7375_gettimeoffset(void);
+
+extern void __init s5c7375_init_irq(void);
+
+extern struct sys_timer s5c7375_timer;
+
+MACHINE_START(S5C7375, "S5C7375, SAMSUNG ELECTRONICS Co., Ltd.")
+	MAINTAINER("Hyok S. Choi <hyok.choi@samsung.com>")
+	INITIRQ(s5c7375_init_irq)
+	.timer = &s5c7375_timer,
+MACHINE_END
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s5c7375/dma.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/dma.c
--- linux-2.6.14-uc0/arch/arm/mach-s5c7375/dma.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/dma.c	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,39 @@
+/*
+ * arch/arm/arch-s5c7375/dma-s5c7375.c
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS Co., Ltd. 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *     
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+
+void arch_dma_init(dma_t *dma)
+{
+}
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s5c7375/head.S linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/head.S
--- linux-2.6.14-uc0/arch/arm/mach-s5c7375/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/head.S	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,163 @@
+/*
+ *  linux/arch/armnommu/mach-s5c7375/head.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *  <hyok.choi@samsung.com>
+ *
+ *  uClinux kernel startup code for s5c7375
+ *  which has no proper bootloader for linux startup
+ *  because of XIP.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+#define MACHINFO_TYPE           0
+#define MACHINFO_PHYSRAM        4
+#define MACHINFO_PHYSIO         8
+#define MACHINFO_PGOFFIO        12
+#define MACHINFO_NAME           16
+
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+/*
+ * ARM920T need MMU enable for D-cache.
+ * we just make the identical table before the MMU enabling.
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	/* Write domain id (cp15_r3) */
+	mvn	r0, #0			/* Domains 0, 1 = client */
+	mcr	p15, 0, r0, c3, c0, 0	/* load domain access register */
+	/* Set control register v4 */
+
+	mov	r0, #0
+	mcr	p15, 0, r0, c13, c0, 0	/* zero PID */
+	mcr	p15, 0, r0, c7, c7, 0	/* invalidate I,D caches */
+	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
+	mcr	p15, 0, r0, c8, c7, 0	/* invalidate I,D TLBs */
+	mrc	p15, 0, r0, c1, c0, 0	/* get control register */
+	bic	r0, r0, #0x0001		/* disable MMU */
+	mcr	p15, 0, r0, c1, c0, 0	/* write control register */
+init_ttb:
+        ldr     r0,=0x00004000         @ set start of Translation Table base (16k Boundary)
+        mcr     p15, 0, r0, c2, c0, 0      @ write to CP15 register 2
+	/* 
+	 *
+	 * Create translation table for flat mapping
+	 * Top 12 bits of VA is pointer into table
+	 * Create 4096 entries from 000xxxxx to fffxxxxx
+	 *
+	 */
+	mov		r1, #0x1000
+	subs 	r1,r1,#1
+        mov     r2,#0b110000000000           @ set access permissions (AP) for full access SVC/USR (11:10)
+        orr     r2,r2,#0b000111100000       @ set for domain 15 (8:5)
+        orr     r2,r2,#0b000000010000       @ must be 1 (4)
+        orr     r2,r2,#0b000000000000       @ set non cachable non bufferable (CB) (3:2)
+        orr     r2,r2,#0b000000000010       @ set for 1Mb section (1:0)
+init_ttb_1:
+        orr     r3,r2,r1,lsl#20             @ use loop counter to create individual table entries
+        str     r3,[r0,r1,lsl#2]            @ str r3 at TTB base + loopcount*4
+        subs    r1,r1,#1                    @ decrement loop counter
+        bpl     init_ttb_1
+
+	/* resetting the SDRAM area to cacheable*/
+	mov	r1, #0x003				@ loop counter
+
+	mov     r2,#0b110000000000           @ set access permissions (AP) for full access SVC/USR (11:10)
+	orr     r2,r2,#0b000111100000       @ set for domain 15 (8:5)
+	orr     r2,r2,#0b000000010000       @ must be 1 (4)
+	orr     r2,r2,#0b000000001100       @ set cachable but unbufferable (CB) (3:2)
+	orr     r2,r2,#0b000000000010       @ set for 1Mb section (1:0)
+
+init_ttb_2:
+        orr     r3,r2,r1,lsl#20             @ use loop counter to create individual table entries
+	str     r3,[r0,r1,lsl#2]            @ str r3 at TTB base + loopcount*4
+	subs    r1,r1,#1                    @ decrement loop counter
+	bpl     init_ttb_2
+	@init_domains : we define all domains are manager. so no access permission check is occured.
+	mvn     r0, #0				@ trick. 0 -1 == 0xFFFFFFFF
+	mcr     p15, 0, r0, c3, c0, 0       @ write to CP15 register 5
+/*
+ * set global core configurations
+ */
+        mrc     p15, 0, r0, c1, c0, 0       @ read CP15 register 1 into r0
+        
+        orr     r0, r0, #(0x1 <<12)         @ enable I Cache
+        orr     r0, r0, #(0x1 <<2)          @ enable D Cache
+        orr     r0, r0, #(0b11 <<30)        @ enable asynchronous clocking mode
+        orr     r0, r0, #0x1                @ enable MMU
+
+        mcr     p15, 0, r0, c1, c0, 0       @ write cp15 register 1
+
+#endif
+
+/*
+ * stuffs for cache are done.
+ * Now we setup the stack and machine id, and start the kernel!
+ */
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r8, r9, sp}			@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+	ldr	r2, S5C7375_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, S5C7375_MACH_TYPE
+	str     r2, [r9]
+
+        mov fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start
+        .long	processor_id
+        .long	_end
+	.long   __machine_arch_type
+        .long	init_thread_union+8192
+	
+S5C7375_PROCESSOR_TYPE:
+	.long	0x41129200
+S5C7375_MACH_TYPE:
+	.long	MACH_TYPE_S5C7375
+
+#include "../kernel/head-common.S"
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s5c7375/irq.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/irq.c
--- linux-2.6.14-uc0/arch/arm/mach-s5c7375/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/irq.c	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,148 @@
+/*
+ *  linux/arch/armnommu/mach-s5c7375/irq.c
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+void __inline__ s5c7375_mask_irq(unsigned int irq)
+{
+        rINTMSK |= ((unsigned long) 1 << irq);
+}
+
+void __inline__ s5c7375_unmask_irq(unsigned int irq)
+{
+        rINTMSK &= ~((unsigned long)1 << irq);
+}
+
+void __inline__ s5c7375_mask_ack_irq(unsigned int irq)
+{
+	s5c7375_mask_irq(irq);
+}
+
+void __inline__ s5c7375_clear_pb(unsigned int irq)
+{
+     rIRQISPC = (0x00000001<<irq);	/* Clear pending bit */
+     rIRQISPC;  /* WriteBack */
+}
+
+
+/* YOU CAN CHANGE THIS ROUTINE FOR SPEED UP */
+__inline__ unsigned int fixup_irq (int irq )
+{
+	s5c7375_clear_pb(irq);
+	return(irq);
+}
+
+static struct irqchip s5c7375_chip = {
+	.ack	= s5c7375_clear_pb,
+	.mask	= s5c7375_mask_irq,
+	.unmask = s5c7375_unmask_irq,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init s5c7375_init_irq(void)
+{
+        int irq;
+
+        /* Disable all IRQs */
+
+        rINTMSK = 0xffffffff; /* all masked */
+        /****************
+         * All IRQs are IRQ, not FIQ 
+         * Write only one register,
+         * 0 : IRQ mode
+         * 1 : FIQ mode
+         *******************************************/
+        rINTMOD = 0x00000000; 
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &s5c7375_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+	rINTCON = 0x0; // all interrupt is disabled
+//	rINTCON = 0xD; // vectored mode
+	DisableFIQ();	// fiq is disabled
+#ifndef CONFIG_S5C7375VM
+	EnableIRQ();		// irq is enabled
+#else
+	DisableIRQ();
+#endif
+	DisableGMask();	// global mask is disabled
+}
+
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s5c7375/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/Kconfig
--- linux-2.6.14-uc0/arch/arm/mach-s5c7375/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/Kconfig	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,3 @@
+menu "S5C7375 Options"
+	depends on ARCH_S5C7375
+endmenu
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s5c7375/Makefile linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/Makefile
--- linux-2.6.14-uc0/arch/arm/mach-s5c7375/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/Makefile	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		+= arch.o irq.o dma.o time.o
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s5c7375/Makefile.boot linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/Makefile.boot
--- linux-2.6.14-uc0/arch/arm/mach-s5c7375/Makefile.boot	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/Makefile.boot	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,2 @@
+   zreladdr-y	:= 0x00008000
+initrd_phys-y	:= 0x00300000
diff -Naur linux-2.6.14-uc0/arch/arm/mach-s5c7375/time.c linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/time.c
--- linux-2.6.14-uc0/arch/arm/mach-s5c7375/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mach-s5c7375/time.c	2005-11-08 08:48:40.000000000 +0900
@@ -0,0 +1,104 @@
+/*
+ *  linux/arch/armnommu/mach-s5c7375/time.c
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *                      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+                                                                                                                                           
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/arch/s5c7375.h>
+#include <asm/mach/time.h>
+#include <asm/arch/time.h>
+
+unsigned long s5c7375_gettimeoffset (void)
+{
+	return (((RESCHED_PERIOD  * CLOCKS_PER_USEC) /1000) - rT3LDR)  / CLOCKS_PER_USEC;
+}
+
+static irqreturn_t
+s5c7375_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+    /* clear interrupt pending bit */
+    rT3ISR = 0;
+    timer_tick(regs);
+
+    return IRQ_HANDLED;
+}
+
+static struct irqaction s5c7375_timer_irq = {
+        .name           = "S5C7375 Timer Tick",
+        .flags          = SA_INTERRUPT,
+        .handler        = s5c7375_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+
+void __init  s5c7375_time_init (void)
+{
+	//- APB bus speed setting
+	/*
+	 * Number of AHB clock cycles allocated in the ENABLE or
+	 * SETUP state of the 2-nd APB peripheral minus one.
+	 */
+	rAPBCON2=(unsigned long)0x00010000; 
+
+	s5c7375_timer_irq.handler = s5c7375_timer_interrupt;
+
+	/*
+	 * Timer 3 is used for OS_timer by external clock.
+	 */
+	rT3CTR = TMR_TE_DISABLE | TMR_IE_PULSE | TMR_OE_ENABLE | TMR_UD_DOWN \
+			| TMR_UDS_TxCTR | TMR_OM_PULSE | TMR_ES_POS | TMR_M_PERIODIC_TIMER;
+
+	/*
+	 * prescaler to 0x6B 'cause : 
+	 * 	27M / (0x6B +1) = 4usec
+	 */
+	rT3PSR = SYS_TIMER03_PRESCALER; // 0x6B
+	/* rT3LDR  =  X second * (frequency/second ) */
+	rT3LDR = RESCHED_PERIOD  * CLOCKS_PER_USEC /1000;
+			/* is equal to 
+			 *	RESCHED_PERIOD * 1000    // for msec to usec
+			 * 	   * (ECLK/ (SYS_TIMER03_PRESCALER +1)) /1000000;
+			 *	= 2500
+			 */
+   	/* clear interrupt pending bit */
+	rT3ISR = 0;
+
+	setup_irq(INT_N_TIMER3, &s5c7375_timer_irq);
+
+	/* timer 3 enable it! */
+	rT3CTR |= TMR_TE_ENABLE;
+
+}
+
+
+struct sys_timer s5c7375_timer = {
+	.init		= s5c7375_time_init,
+	.offset		= s5c7375_gettimeoffset,
+};
diff -Naur linux-2.6.14-uc0/arch/arm/Makefile linux-2.6.14-uc0-hsc0/arch/arm/Makefile
--- linux-2.6.14-uc0/arch/arm/Makefile	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/Makefile	2005-11-09 18:48:48.000000000 +0900
@@ -6,6 +6,7 @@
 # for more details.
 #
 # Copyright (C) 1995-2001 by Russell King
+# Copyright (C) 2004 by Hyok S. Choi (for uClinux/ARM 2.6)
 
 LDFLAGS_vmlinux	:=-p --no-undefined -X
 CPPFLAGS_vmlinux.lds = -DTEXTADDR=$(TEXTADDR) -DDATAADDR=$(DATAADDR)
@@ -17,6 +18,11 @@
 # Select a platform tht is kept up-to-date
 KBUILD_DEFCONFIG := versatile_defconfig
 
+# defines filename extension for mmu type, if any.
+ifeq ($(CONFIG_MMU),)
+MMUEXT		:= -nommu
+endif
+
 ifeq ($(CONFIG_FRAME_POINTER),y)
 CFLAGS		+=-fno-omit-frame-pointer -mapcs -mno-sched-prolog
 endif
@@ -45,11 +51,17 @@
 # This selects how we optimise for the processor.
 tune-$(CONFIG_CPU_ARM610)	:=-mtune=arm610
 tune-$(CONFIG_CPU_ARM710)	:=-mtune=arm710
+tune-$(CONFIG_CPU_ARM7TDMI)	:=-mtune=arm7tdmi
+tune-$(CONFIG_CPU_S3C4510B)	:=-mtune=arm7tdmi
 tune-$(CONFIG_CPU_ARM720T)	:=-mtune=arm7tdmi
+tune-$(CONFIG_CPU_ARM740T)	:=-mtune=arm7tdmi
+tune-$(CONFIG_CPU_ARM9TDMI)	:=-mtune=arm9tdmi
 tune-$(CONFIG_CPU_ARM920T)	:=-mtune=arm9tdmi
 tune-$(CONFIG_CPU_ARM922T)	:=-mtune=arm9tdmi
 tune-$(CONFIG_CPU_ARM925T)	:=-mtune=arm9tdmi
 tune-$(CONFIG_CPU_ARM926T)	:=-mtune=arm9tdmi
+tune-$(CONFIG_CPU_ARM940T)	:=-mtune=arm9tdmi
+tune-$(CONFIG_CPU_ARM946T)	:=-mtune=arm9tdmi
 tune-$(CONFIG_CPU_SA110)	:=-mtune=strongarm110
 tune-$(CONFIG_CPU_SA1100)	:=-mtune=strongarm1100
 tune-$(CONFIG_CPU_XSCALE)	:=$(call cc-option,-mtune=xscale,-mtune=strongarm110) -Wa,-mcpu=xscale
@@ -63,8 +75,12 @@
 CHECKFLAGS	+= -D__arm__
 
 #Default value
-head-y		:= arch/arm/kernel/head.o arch/arm/kernel/init_task.o
+head-y		:= arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o
+ifeq ($(CONFIG_MMU),y)
 textaddr-y	:= 0xC0008000
+else
+textaddr-y	:= 0x00008000
+endif
 
  machine-$(CONFIG_ARCH_RPC)	   := rpc
  machine-$(CONFIG_ARCH_EBSA110)	   := ebsa110
@@ -99,6 +115,22 @@
  machine-$(CONFIG_ARCH_IMX)	   := imx
  machine-$(CONFIG_ARCH_H720X)	   := h720x
  machine-$(CONFIG_ARCH_AAEC2000)   := aaec2000
+ machine-$(CONFIG_ARCH_ATMEL)	   := atmel
+textaddr-$(CONFIG_ARCH_ATMEL)	   := 0x01000000
+ machine-$(CONFIG_ARCH_ESPD_4510B) := espd_4510b
+textaddr-$(CONFIG_ARCH_ESPD_4510B) := 0x00008000
+ machine-$(CONFIG_ARCH_S3C3410)	   := s3c3410
+textaddr-$(CONFIG_ARCH_S3C3410)	   := 0x01020000
+ machine-$(CONFIG_ARCH_S3C44B0)	   := s3c44b0x
+textaddr-$(CONFIG_ARCH_S3C44B0)	   := 0x0c008000
+ machine-$(CONFIG_ARCH_S5C7375)	   := s5c7375
+textaddr-$(CONFIG_ARCH_S5C7375)	   := 0x00008000
+ machine-$(CONFIG_ARCH_S3C24A0)	   := s3c24a0
+ifeq ($(CONFIG_MMU),)
+textaddr-$(CONFIG_ARCH_S3C24A0)	   := 0x10008000
+endif
+ machine-$(CONFIG_ARCH_P2001)	   := p2001
+textaddr-$(CONFIG_ARCH_P2001)	   := 0x40100000
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
@@ -127,8 +159,18 @@
 else
 MACHINE  :=
 endif
-  
-export	TEXTADDR DATAADDR GZFLAGS
+
+# set HEAD as default (kernel/head.o)
+HEAD		:= head$(MMUEXT).o
+# Check if an overriding head.S exist for non-paged kernel
+ifeq ($(CONFIG_MMU),)
+ifeq ($(MACHINE)head.S, $(wildcard $(MACHINE)head.S))
+head-y		:= $(MACHINE)head.o arch/arm/kernel/init_task.o
+HEAD		:= ../mach-$(machine-y)/head.o
+endif
+endif
+
+export	MACHINE HEAD MMUEXT TEXTADDR GZFLAGS
 
 # Do we have FASTFPE?
 FASTFPE		:=arch/arm/fastfpe
@@ -153,11 +195,15 @@
 libs-y				+= arch/arm/lib/
 
 # Default target when executing plain make
+ifeq ($(CONFIG_MMU),y)
 ifeq ($(CONFIG_XIP_KERNEL),y)
 all: xipImage
 else
 all: zImage
 endif
+else
+all: Image
+endif
 
 boot := arch/arm/boot
 
diff -Naur linux-2.6.14-uc0/arch/arm/mm/cache-v4.S linux-2.6.14-uc0-hsc0/arch/arm/mm/cache-v4.S
--- linux-2.6.14-uc0/arch/arm/mm/cache-v4.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/cache-v4.S	2005-11-09 17:53:53.000000000 +0900
@@ -29,9 +29,13 @@
  *	Clean and invalidate the entire cache.
  */
 ENTRY(v4_flush_kern_cache_all)
+#ifndef CPU_HAS_NO_CP15
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7, 0		@ flush ID cache
 	mov	pc, lr
+#else
+	/* FALLTHROUGH */
+#endif
 
 /*
  *	flush_user_cache_range(start, end, flags)
@@ -44,9 +48,13 @@
  *	- flags	- vma_area_struct flags describing address space
  */
 ENTRY(v4_flush_user_cache_range)
+#ifndef CPU_HAS_NO_CP15
 	mov	ip, #0
 	mcreq	p15, 0, ip, c7, c7, 0		@ flush ID cache
 	mov	pc, lr
+#else
+	/* FALLTHROUGH */
+#endif
 
 /*
  *	coherent_kern_range(start, end)
@@ -108,8 +116,10 @@
  *	- end	 - virtual end address
  */
 ENTRY(v4_dma_flush_range)
+#ifndef CPU_HAS_NO_CP15
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7, 0		@ flush ID cache
+#endif
 	/* FALLTHROUGH */
 
 /*
diff -Naur linux-2.6.14-uc0/arch/arm/mm/consistent-nommu.c linux-2.6.14-uc0-hsc0/arch/arm/mm/consistent-nommu.c
--- linux-2.6.14-uc0/arch/arm/mm/consistent-nommu.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/consistent-nommu.c	2005-11-09 13:29:47.000000000 +0900
@@ -0,0 +1,207 @@
+/*
+ *  arch/arm/mm/consistent-nommu.c
+ *  Based on arch/arm/mm/consistent.c
+ *
+ *  Copyright (C) 2000-2004 Russell King
+ *  Modified by Catalin Marinas for noMMU support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  DMA uncached mapping support.
+ */
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+
+static void *
+__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, int gfp,
+	    pgprot_t prot)
+{
+	struct page *page;
+	unsigned long order;
+	u64 mask = ISA_DMA_THRESHOLD, limit;
+
+	if (dev) {
+		mask = dev->coherent_dma_mask;
+
+		/*
+		 * Sanity check the DMA mask - it must be non-zero, and
+		 * must be able to be satisfied by a DMA allocation.
+		 */
+		if (mask == 0) {
+			dev_warn(dev, "coherent DMA mask is unset\n");
+			goto no_page;
+		}
+
+		if ((~mask) & ISA_DMA_THRESHOLD) {
+			dev_warn(dev, "coherent DMA mask %#llx is smaller "
+				 "than system GFP_DMA mask %#llx\n",
+				 mask, (unsigned long long)ISA_DMA_THRESHOLD);
+			goto no_page;
+		}
+	}
+
+	/*
+	 * Sanity check the allocation size.
+	 */
+	size = PAGE_ALIGN(size);
+	limit = (mask + 1) & ~mask;
+	if (limit && size >= limit) {
+		printk(KERN_WARNING "coherent allocation too big "
+		       "(requested %#x mask %#llx)\n", size, mask);
+		goto no_page;
+	}
+
+	order = get_order(size);
+
+	if (mask != 0xffffffff)
+		gfp |= GFP_DMA;
+
+	page = alloc_pages(gfp, order);
+	if (!page)
+		goto no_page;
+
+	/*
+	 * Invalidate any data that might be lurking in the
+	 * kernel direct-mapped region for device DMA.
+	 */
+	{
+		unsigned long kaddr = (unsigned long)page_address(page);
+		memset(page_address(page), 0, size);
+		dmac_flush_range(kaddr, kaddr + size);
+	}
+
+	/*
+	 * Set the "dma handle"
+	 */
+	*handle = page_to_dma(dev, page);
+
+	do {
+		set_page_count(page, 1);
+		/*
+		 * x86 does not mark the pages reserved...
+		 */
+		SetPageReserved(page);
+		page++;
+	} while (size -= PAGE_SIZE);
+
+	return page_address(page);
+
+ no_page:
+	*handle = ~0;
+	return NULL;
+}
+
+/*
+ * Allocate DMA-coherent memory space and return both the kernel remapped
+ * virtual and bus address for that space.
+ */
+void *
+dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, int gfp)
+{
+	return __dma_alloc(dev, size, handle, gfp,
+			   pgprot_noncached(pgprot_kernel));
+}
+EXPORT_SYMBOL(dma_alloc_coherent);
+
+/*
+ * Allocate a writecombining region, in much the same way as
+ * dma_alloc_coherent above.
+ */
+void *
+dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *handle, int gfp)
+{
+	return __dma_alloc(dev, size, handle, gfp,
+			   pgprot_writecombine(pgprot_kernel));
+}
+EXPORT_SYMBOL(dma_alloc_writecombine);
+
+static int dma_mmap(struct device *dev, struct vm_area_struct *vma,
+		    void *cpu_addr, dma_addr_t dma_addr, size_t size)
+{
+	unsigned long user_size;
+	int ret = -ENXIO;
+
+	user_size = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+
+	vma->vm_flags |= VM_RESERVED;
+
+	/* Equivalent to: vma->vm_start = vma->vm_pgoff << PAGE_SHIFT; */
+	ret = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			      user_size << PAGE_SHIFT, vma->vm_page_prot);
+
+	return ret;
+}
+
+int dma_mmap_coherent(struct device *dev, struct vm_area_struct *vma,
+		      void *cpu_addr, dma_addr_t dma_addr, size_t size)
+{
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	return dma_mmap(dev, vma, cpu_addr, dma_addr, size);
+}
+EXPORT_SYMBOL(dma_mmap_coherent);
+
+int dma_mmap_writecombine(struct device *dev, struct vm_area_struct *vma,
+			  void *cpu_addr, dma_addr_t dma_addr, size_t size)
+{
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	return dma_mmap(dev, vma, cpu_addr, dma_addr, size);
+}
+EXPORT_SYMBOL(dma_mmap_writecombine);
+
+/*
+ * free a page as defined by the above mapping.
+ */
+void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t handle)
+{
+	struct page *page;
+
+	size = PAGE_ALIGN(size);
+
+	page = virt_to_page(cpu_addr);
+	do {
+		
+		/*
+		 * x86 does not mark the pages reserved...
+		 */
+		ClearPageReserved(page);
+
+		__free_page(page);
+		page++;
+	} while (size -= PAGE_SIZE);
+}
+EXPORT_SYMBOL(dma_free_coherent);
+
+/*
+ * Make an area consistent for devices.
+ */
+void consistent_sync(void *vaddr, size_t size, int direction)
+{
+	unsigned long start = (unsigned long)vaddr;
+	unsigned long end   = start + size;
+
+	switch (direction) {
+	case DMA_FROM_DEVICE:		/* invalidate only */
+		dmac_inv_range(start, end);
+		break;
+	case DMA_TO_DEVICE:		/* writeback only */
+		dmac_clean_range(start, end);
+		break;
+	case DMA_BIDIRECTIONAL:		/* writeback and invalidate */
+		dmac_flush_range(start, end);
+		break;
+	default:
+		BUG();
+	}
+}
+EXPORT_SYMBOL(consistent_sync);
diff -Naur linux-2.6.14-uc0/arch/arm/mm/fault.c linux-2.6.14-uc0-hsc0/arch/arm/mm/fault.c
--- linux-2.6.14-uc0/arch/arm/mm/fault.c	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/fault.c	2005-11-09 13:29:38.000000000 +0900
@@ -3,6 +3,7 @@
  *
  *  Copyright (C) 1995  Linus Torvalds
  *  Modifications for ARM processor (c) 1995-2004 Russell King
+ *  Modifications for nommu or non-paged, Hyok S. Choi, 2003
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -22,6 +23,7 @@
 
 #include "fault.h"
 
+#ifdef CONFIG_MMU
 /*
  * This is useful to dump out the page tables associated with
  * 'addr' in mm 'mm'.
@@ -74,6 +76,7 @@
 	printk("\n");
 }
 
+#endif /* CONFIG_MMU */
 /*
  * Oops.  The kernel tried to access some page that wasn't present.
  */
@@ -96,7 +99,9 @@
 		(addr < PAGE_SIZE) ? "NULL pointer dereference" :
 		"paging request", addr);
 
+#ifdef CONFIG_MMU
 	show_pte(mm, addr);
+#endif
 	die("Oops", regs, fsr);
 	bust_spinlocks(0);
 	do_exit(SIGKILL);
@@ -117,7 +122,9 @@
 	if (user_debug & UDBG_SEGV) {
 		printk(KERN_DEBUG "%s: unhandled page fault (%d) at 0x%08lx, code 0x%03x\n",
 		       tsk->comm, sig, addr, fsr);
+#ifdef CONFIG_MMU
 		show_pte(tsk->mm, addr);
+#endif
 		show_regs(regs);
 	}
 #endif
@@ -146,6 +153,7 @@
 		__do_kernel_fault(mm, addr, fsr, regs);
 }
 
+#ifdef CONFIG_MMU
 #define VM_FAULT_BADMAP		(-20)
 #define VM_FAULT_BADACCESS	(-21)
 
@@ -215,10 +223,12 @@
 out:
 	return fault;
 }
+#endif /* CONFIG_MMU */
 
 static int
 do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 {
+#ifdef CONFIG_MMU
 	struct task_struct *tsk;
 	struct mm_struct *mm;
 	int fault, sig, code;
@@ -296,6 +306,10 @@
 
 no_context:
 	__do_kernel_fault(mm, addr, fsr, regs);
+#else /* CONFIG_MMU */
+	printk("do_page_fault? : %s %d\n",__FILE__,__LINE__);
+
+#endif /* !CONFIG_MMU */
 	return 0;
 }
 
@@ -320,6 +334,7 @@
 do_translation_fault(unsigned long addr, unsigned int fsr,
 		     struct pt_regs *regs)
 {
+#ifdef CONFIG_MMU
 	struct task_struct *tsk;
 	unsigned int index;
 	pgd_t *pgd, *pgd_k;
@@ -355,6 +370,9 @@
 	tsk = current;
 
 	do_bad_area(tsk, tsk->active_mm, addr, fsr, regs);
+#else /* CONFIG_MMU */
+	printk("do_translation_fault? : %s %d\n",__FILE__,__LINE__);
+#endif /* !CONFIG_MMU */
 	return 0;
 }
 
diff -Naur linux-2.6.14-uc0/arch/arm/mm/fault.h linux-2.6.14-uc0-hsc0/arch/arm/mm/fault.h
--- linux-2.6.14-uc0/arch/arm/mm/fault.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/fault.h	2005-11-09 13:29:38.000000000 +0900
@@ -1,6 +1,7 @@
 void do_bad_area(struct task_struct *tsk, struct mm_struct *mm,
 		 unsigned long addr, unsigned int fsr, struct pt_regs *regs);
-
+#ifdef CONFIG_MMU
 void show_pte(struct mm_struct *mm, unsigned long addr);
+#endif
 
 unsigned long search_exception_table(unsigned long addr);
diff -Naur linux-2.6.14-uc0/arch/arm/mm/init.c linux-2.6.14-uc0-hsc0/arch/arm/mm/init.c
--- linux-2.6.14-uc0/arch/arm/mm/init.c	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/init.c	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,9 @@
  *  linux/arch/arm/mm/init.c
  *
  *  Copyright (C) 1995-2002 Russell King
+ *  for uClinux, 2003,  Hyok S. Choi <hyok.choi@samsung.com>
+ *    machine dependent bootmem and initmem reserve/free
+ *    codes are gone to hardware.h
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -26,11 +29,14 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 
+#ifdef CONFIG_MMU
 #define TABLE_SIZE	(2 * PTRS_PER_PTE * sizeof(pte_t))
 
 DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
 
 extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+#endif
+
 extern void _stext, _text, _etext, __data_start, _end, __init_begin, __init_end;
 extern unsigned long phys_initrd_start;
 extern unsigned long phys_initrd_size;
@@ -269,7 +275,9 @@
 static __init void reserve_node_zero(unsigned int bootmap_pfn, unsigned int bootmap_pages)
 {
 	pg_data_t *pgdat = NODE_DATA(0);
+#ifdef CONFIG_MMU
 	unsigned long res_size = 0;
+#endif
 
 	/*
 	 * Register the kernel text and data with bootmem.
@@ -281,12 +289,23 @@
 	reserve_bootmem_node(pgdat, __pa(&_stext), &_end - &_stext);
 #endif
 
+#ifdef CONFIG_MMU
 	/*
 	 * Reserve the page tables.  These are already in use,
 	 * and can only be in node 0.
 	 */
 	reserve_bootmem_node(pgdat, __pa(swapper_pg_dir),
 			     PTRS_PER_PGD * sizeof(pgd_t));
+#else /* CONFIG_MMU */
+  #ifdef PA_SDRAM_BASE
+	/*
+	 * Register the exception vector page.
+	 * some architectures which the DRAM is the exception vector to trap,
+	 * alloc_page breaks with error, although it is not NULL, but "0."
+	 */
+	reserve_bootmem_node(pgdat, PA_SDRAM_BASE, PAGE_SIZE);
+  #endif
+#endif /* ! CONFIG_MMU */
 
 	/*
 	 * And don't forget to reserve the allocator bitmap,
@@ -295,6 +314,7 @@
 	reserve_bootmem_node(pgdat, bootmap_pfn << PAGE_SHIFT,
 			     bootmap_pages << PAGE_SHIFT);
 
+#ifdef CONFIG_MMU
 	/*
 	 * Hmm... This should go elsewhere, but we really really need to
 	 * stop things allocating the low memory; ideally we need a better
@@ -322,6 +342,13 @@
 #endif
 	if (res_size)
 		reserve_bootmem_node(pgdat, PHYS_OFFSET, res_size);
+#else /* CONFIG_MMU */
+	/*
+	 * the machine/platform dependent bootmem reserve codes
+	 * define it in include/asm-armnommu/arch/hardware.h
+	 */
+	MACH_RESERVE_BOOTMEM();
+#endif /* !CONFIG_MMU */
 }
 
 /*
@@ -429,8 +456,18 @@
 	/*
 	 * allocate the zero page.  Note that we count on this going ok.
 	 */
+#if defined (PA_SDRAM_BASE) && !defined(CONFIG_MMU)
+	/*
+	 * hyok: some architecture has 0 based SDRAM memory map.
+	 *       we should check if the ptr was not "NULL" but the exact address "0".
+	 *       for that, we do that in reserve_node_zero.
+	 */
+	zero_page = (void *)PA_SDRAM_BASE;
+#else
 	zero_page = alloc_bootmem_low_pages(PAGE_SIZE);
+#endif
 
+#ifdef CONFIG_MMU
 	/*
 	 * initialise the page tables.
 	 */
@@ -438,6 +475,7 @@
 	if (mdesc->map_io)
 		mdesc->map_io();
 	local_flush_tlb_all();
+#endif
 
 	/*
 	 * initialise the zones within each node
@@ -497,6 +535,7 @@
 				bdata->node_boot_start >> PAGE_SHIFT, zhole_size);
 	}
 
+#ifdef CONFIG_MMU
 	/*
 	 * finish off the bad pages once
 	 * the mem_map is initialised
@@ -504,6 +543,7 @@
 	memzero(zero_page, PAGE_SIZE);
 	empty_zero_page = virt_to_page(zero_page);
 	flush_dcache_page(empty_zero_page);
+#endif /* CONFIG_MMU */
 }
 
 static inline void free_area(unsigned long addr, unsigned long end, char *s)
@@ -613,10 +653,18 @@
 			totalram_pages += free_all_bootmem_node(pgdat);
 	}
 
+#ifdef CONFIG_MMU
 #ifdef CONFIG_SA1111
 	/* now that our DMA memory is actually so designated, we can free it */
 	free_area(PAGE_OFFSET, (unsigned long)swapper_pg_dir, NULL);
 #endif
+#else
+	/*
+	 * the machine/platform dependent bootmem free code.
+	 * define it in include/asm-armnommu/arch/hardware.h
+	 */
+	MACH_FREE_BOOTMEM();
+#endif
 
 	/*
 	 * Since our memory may not be contiguous, calculate the
@@ -649,7 +697,15 @@
 
 void free_initmem(void)
 {
+#ifdef CONFIG_MMU
 	if (!machine_is_integrator() && !machine_is_cintegrator()) {
+#else
+	/*
+	 * machine depend decision, if initmem is safe to free.
+	 * it is defiened in hardware.h by default, true.
+	 */
+	if (DO_FREE_INITMEM()) {
+#endif
 		free_area((unsigned long)(&__init_begin),
 			  (unsigned long)(&__init_end),
 			  "init");
diff -Naur linux-2.6.14-uc0/arch/arm/mm/ioremap.c linux-2.6.14-uc0-hsc0/arch/arm/mm/ioremap.c
--- linux-2.6.14-uc0/arch/arm/mm/ioremap.c	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/ioremap.c	2005-11-09 13:29:38.000000000 +0900
@@ -8,6 +8,7 @@
  * Hacked for ARM by Phil Blundell <philb@gnu.org>
  * Hacked to allow all architectures to build, and various cleanups
  * by Russell King
+ * Modified for uClinux/ARM by Hyok S. Choi <hyok.choi@samsung.com>
  *
  * This allows a driver to remap an arbitrary region of bus memory into
  * virtual space.  One should *only* use readl, writel, memcpy_toio and
@@ -29,6 +30,8 @@
 #include <asm/io.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_MMU
+
 static inline void
 remap_area_pte(pte_t * pte, unsigned long address, unsigned long size,
 	       unsigned long phys_addr, pgprot_t pgprot)
@@ -163,11 +166,25 @@
 	}
 	return (void __iomem *) (offset + (char *)addr);
 }
+
+#else	/* CONFIG_MMU */
+
+void *
+__ioremap(unsigned long phys_addr, size_t size, unsigned long flags,
+	  unsigned long align)
+{
+	return (void *) (phys_addr);
+}
+
+#endif /* !CONFIG_MMU */
+
 EXPORT_SYMBOL(__ioremap);
 
 void __iounmap(void __iomem *addr)
 {
+#ifdef CONFIG_MMU
 	vfree((void *) (PAGE_MASK & (unsigned long) addr));
+#endif
 }
 EXPORT_SYMBOL(__iounmap);
 
diff -Naur linux-2.6.14-uc0/arch/arm/mm/Kconfig linux-2.6.14-uc0-hsc0/arch/arm/mm/Kconfig
--- linux-2.6.14-uc0/arch/arm/mm/Kconfig	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/Kconfig	2005-11-09 18:05:14.000000000 +0900
@@ -15,8 +15,8 @@
 	select CPU_32v3
 	select CPU_CACHE_V3
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V3
-	select CPU_TLB_V3
+	select CPU_COPY_V3 if MMU
+	select CPU_TLB_V3 if MMU
 	help
 	  The ARM610 is the successor to the ARM3 processor
 	  and was produced by VLSI Technology Inc.
@@ -24,6 +24,36 @@
 	  Say Y if you want support for the ARM610 processor.
 	  Otherwise, say N.
 
+# ARM7TDMI
+config CPU_ARM7TDMI
+	bool "Support ARM7TDMI processor"
+        depends on ARCH_S3C3410 || ARCH_ATMEL || ARCH_S3C44B0
+	default y if ARCH_S3C3410 || ARCH_ATMEL || ARCH_S3C44B0
+	select CPU_32v4
+	select CPU_CACHE_V4
+	select CPU_HAS_NO_CP15
+	help
+	  A 32-bit RISC microprocessor based on the ARM7 processor core
+	  designed by Advanced RISC Machines Ltd.
+
+	  Say Y if you want support for the ARM7TDMI processor.
+	  Otherwise, say N.
+
+# S3C4510B
+config CPU_S3C4510B
+	bool "Support S3C4510B/ARM7TDMI processor"
+        depends on ARCH_ESPD_4510B
+	default y if ARCH_ESPD_4510B
+	select CPU_32v4
+	select CPU_HAS_NO_CP15
+	help
+	  A Samsung 32-bit RISC microprocessor based on the ARM7TDMI processor 
+	  core designed by Advanced RISC Machines Ltd and a custom cache unit
+	  of Samsung.
+
+	  Say Y if you want support for the S3C4510B/ARM7TDMI processor.
+	  Otherwise, say N.
+
 # ARM710
 config CPU_ARM710
 	bool "Support ARM710 processor" if !ARCH_CLPS7500 && ARCH_RPC
@@ -31,8 +61,8 @@
 	select CPU_32v3
 	select CPU_CACHE_V3
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V3
-	select CPU_TLB_V3
+	select CPU_COPY_V3 if MMU
+	select CPU_TLB_V3 if MMU
 	help
 	  A 32-bit RISC microprocessor based on the ARM7 processor core
 	  designed by Advanced RISC Machines Ltd. The ARM710 is the
@@ -50,8 +80,8 @@
 	select CPU_ABRT_LV4T
 	select CPU_CACHE_V4
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WT
-	select CPU_TLB_V4WT
+	select CPU_COPY_V4WT if MMU
+	select CPU_TLB_V4WT if MMU
 	help
 	  A 32-bit RISC processor with 8kByte Cache, Write Buffer and
 	  MMU built around an ARM7TDMI core.
@@ -59,17 +89,44 @@
 	  Say Y if you want support for the ARM720T processor.
 	  Otherwise, say N.
 
+# ARM740
+config CPU_ARM740
+	bool "Support ARM740 processor" if ARCH_INTEGRATOR
+	select CPU_32v4
+	select CPU_CACHE_V4
+	help
+	  A 32-bit RISC processor with 8KB cache or 4KB variants,
+	  write buffer and MPU(Protection Unit) built around
+	  an ARM7TDMI core.
+
+	  Say Y if you want support for the ARM740T process.
+	  Otherwise, say N.
+
+# ARM9TDMI
+config CPU_ARM9TDMI
+	bool "Support ARM9TDMI processor"
+	depends on ARCH_P2001
+	default y if ARCH_P2001
+	select CPU_32v4
+	select CPU_CACHE_V4
+	select CPU_HAS_NO_CP15
+	help
+	  This is ARM9TDMI based RISC processor without MMU. 
+
+	  Say Y if you want support for the ARM9TDMI processor.
+	  Otherwise, say N.
+
 # ARM920T
 config CPU_ARM920T
 	bool "Support ARM920T processor" if !ARCH_S3C2410
-	depends on ARCH_INTEGRATOR || ARCH_S3C2410 || ARCH_IMX || ARCH_AAEC2000
+	depends on ARCH_INTEGRATOR || ARCH_S3C2410 || ARCH_IMX || ARCH_AAEC2000 || ARCH_S5C7375
 	default y if ARCH_S3C2410
 	select CPU_32v4
 	select CPU_ABRT_EV4T
 	select CPU_CACHE_V4WT
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WB
-	select CPU_TLB_V4WBI
+	select CPU_COPY_V4WB if MMU
+	select CPU_TLB_V4WBI if MMU
 	help
 	  The ARM920T is licensed to be produced by numerous vendors,
 	  and is used in the Maverick EP9312 and the Samsung S3C2410.
@@ -89,8 +146,8 @@
 	select CPU_ABRT_EV4T
 	select CPU_CACHE_V4WT
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WB
-	select CPU_TLB_V4WBI
+	select CPU_COPY_V4WB if MMU
+	select CPU_TLB_V4WBI if MMU
 	help
 	  The ARM922T is a version of the ARM920T, but with smaller
 	  instruction and data caches. It is used in Altera's
@@ -108,8 +165,8 @@
 	select CPU_ABRT_EV4T
 	select CPU_CACHE_V4WT
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WB
-	select CPU_TLB_V4WBI
+	select CPU_COPY_V4WB if MMU
+	select CPU_TLB_V4WBI if MMU
  	help
  	  The ARM925T is a mix between the ARM920T and ARM926T, but with
 	  different instruction and data caches. It is used in TI's OMAP
@@ -120,14 +177,14 @@
 
 # ARM926T
 config CPU_ARM926T
-	bool "Support ARM926T processor" if ARCH_INTEGRATOR
-	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX
-	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX
+	bool "Support ARM926T processor"
+	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || ARCH_S3C24A0
+	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || ARCH_S3C24A0
 	select CPU_32v5
 	select CPU_ABRT_EV5TJ
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WB
-	select CPU_TLB_V4WBI
+	select CPU_COPY_V4WB if MMU
+	select CPU_TLB_V4WBI if MMU
 	help
 	  This is a variant of the ARM920.  It has slightly different
 	  instruction sequences for cache and TLB operations.  Curiously,
@@ -144,8 +201,8 @@
 	select CPU_ABRT_EV4T
 	select CPU_CACHE_V4WT
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WB
-	select CPU_TLB_V4WBI
+	select CPU_COPY_V4WB if MMU
+	select CPU_TLB_V4WBI if MMU
 	help
 	  The ARM1020 is the 32K cached version of the ARM10 processor,
 	  with an addition of a floating-point unit.
@@ -161,8 +218,8 @@
 	select CPU_ABRT_EV4T
 	select CPU_CACHE_V4WT
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WB
-	select CPU_TLB_V4WBI
+	select CPU_COPY_V4WB if MMU
+	select CPU_TLB_V4WBI if MMU
 	depends on n
 
 # ARM1022E
@@ -172,8 +229,8 @@
 	select CPU_32v5
 	select CPU_ABRT_EV4T
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WB # can probably do better
-	select CPU_TLB_V4WBI
+	select CPU_COPY_V4WB if MMU # can probably do better
+	select CPU_TLB_V4WBI if MMU
 	help
 	  The ARM1022E is an implementation of the ARMv5TE architecture
 	  based upon the ARM10 integer core with a 16KiB L1 Harvard cache,
@@ -189,8 +246,8 @@
 	select CPU_32v5
 	select CPU_ABRT_EV5T # But need Jazelle, but EV5TJ ignores bit 10
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WB # can probably do better
-	select CPU_TLB_V4WBI
+	select CPU_COPY_V4WB if MMU # can probably do better
+	select CPU_TLB_V4WBI if MMU
 	help
 	  The ARM1026EJ-S is an implementation of the ARMv5TEJ architecture
 	  based upon the ARM10 integer core.
@@ -207,8 +264,8 @@
 	select CPU_ABRT_EV4
 	select CPU_CACHE_V4WB
 	select CPU_CACHE_VIVT
-	select CPU_COPY_V4WB
-	select CPU_TLB_V4WB
+	select CPU_COPY_V4WB if MMU
+	select CPU_TLB_V4WB if MMU
 	help
 	  The Intel StrongARM(R) SA-110 is a 32-bit microprocessor and
 	  is available at five speeds ranging from 100 MHz to 233 MHz.
@@ -227,7 +284,7 @@
 	select CPU_ABRT_EV4
 	select CPU_CACHE_V4WB
 	select CPU_CACHE_VIVT
-	select CPU_TLB_V4WB
+select CPU_TLB_V4WB if MMU
 
 # XScale
 config CPU_XSCALE
@@ -237,7 +294,7 @@
 	select CPU_32v5
 	select CPU_ABRT_EV5T
 	select CPU_CACHE_VIVT
-	select CPU_TLB_V4WBI
+	select CPU_TLB_V4WBI if MMU
 
 # ARMv6
 config CPU_V6
@@ -247,8 +304,8 @@
 	select CPU_ABRT_EV6
 	select CPU_CACHE_V6
 	select CPU_CACHE_VIPT
-	select CPU_COPY_V6
-	select CPU_TLB_V6
+	select CPU_COPY_V6 if MMU
+	select CPU_TLB_V6 if MMU
 
 # Figure out what processor architecture version we should be using.
 # This defines the compiler instruction set which depends on the machine type.
@@ -305,6 +362,7 @@
 config CPU_CACHE_VIPT
 	bool
 
+if MMU
 # The copy-page model
 config CPU_COPY_V3
 	bool
@@ -343,11 +401,18 @@
 config CPU_TLB_V6
 	bool
 
+endif
+
+config CPU_HAS_NO_CP15
+	bool
+	help
+	  Processor has not the CP15 register.
+
 comment "Processor Features"
 
 config ARM_THUMB
 	bool "Support Thumb user binaries"
-	depends on CPU_ARM720T || CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM1020 || CPU_ARM1020E || CPU_ARM1022 || CPU_ARM1026 || CPU_XSCALE || CPU_V6
+	depends on CPU_ARM720T || CPU_ARM740T || CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM940T || CPU_ARM946E || CPU_ARM1020 || CPU_ARM1020E || CPU_ARM1022 || CPU_ARM1026 || CPU_XSCALE || CPU_V6
 	default y
 	help
 	  Say Y if you want to include kernel support for running user space
@@ -362,12 +427,21 @@
 config CPU_BIG_ENDIAN
 	bool "Build big-endian kernel"
 	depends on ARCH_SUPPORTS_BIG_ENDIAN
+	default y if ARCH_S3C3410
 	help
 	  Say Y if you plan on running a kernel in big-endian mode.
 	  Note that your board must be properly built and your board
 	  port must properly enable any big-endian related features
 	  of your chipset/board/processor.
 
+config CPU_MXU_ENABLE
+	depends !MMU
+	bool "Enable the MMU/MPU on non-paged memory management mode"
+	depends on CPU_ARM720T ||CPU_ARM740T || CPU_ARM920T || CPU_ARM922T ||  CPU_ARM925T || CPU_ARM926T || CPU_ARM940T || CPU_ARM946E || CPU_ARM1020
+	help
+	  Say Y here to enable the memory control unit like: MMU/MPU,
+	  on non-paged memory management mode.
+
 config CPU_ICACHE_DISABLE
 	bool "Disable I-Cache"
 	depends on CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM1020 || CPU_V6
@@ -405,7 +479,7 @@
 
 config TLS_REG_EMUL
 	bool
-	default y if SMP && (CPU_32v5 || CPU_32v4 || CPU_32v3)
+	default y if (SMP || !MMU) && (CPU_32v5 || CPU_32v4 || CPU_32v3)
 	help
 	  An SMP system using a pre-ARMv6 processor (there are apparently
 	  a few prototypes like that in existence) and therefore access to
diff -Naur linux-2.6.14-uc0/arch/arm/mm/Makefile linux-2.6.14-uc0-hsc0/arch/arm/mm/Makefile
--- linux-2.6.14-uc0/arch/arm/mm/Makefile	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/Makefile	2005-11-09 18:18:37.000000000 +0900
@@ -1,10 +1,12 @@
 #
 # Makefile for the linux arm-specific parts of the memory manager.
+# modified by Hyok S. Choi for nommu support
 #
 
-obj-y				:= consistent.o extable.o fault-armv.o \
-				   fault.o flush.o init.o ioremap.o mmap.o \
+obj-y				:= consistent$(MMUEXT).o extable.o \
+				   fault.o init.o ioremap.o \
 				   mm-armv.o
+obj-$(CONFIG_MMU)		+= fault-armv.o flush.o mmap.o
 
 obj-$(CONFIG_MODULES)		+= proc-syms.o
 
@@ -37,13 +39,19 @@
 obj-$(CONFIG_CPU_TLB_V4WBI)	+= tlb-v4wbi.o
 obj-$(CONFIG_CPU_TLB_V6)	+= tlb-v6.o
 
+obj-$(CONFIG_CPU_S3C4510B)	+= proc-s3c4510b.o
 obj-$(CONFIG_CPU_ARM610)	+= proc-arm6_7.o
 obj-$(CONFIG_CPU_ARM710)	+= proc-arm6_7.o
+obj-$(CONFIG_CPU_ARM7TDMI)	+= proc-arm7tdmi.o
 obj-$(CONFIG_CPU_ARM720T)	+= proc-arm720.o
+obj-$(CONFIG_CPU_ARM740T)	+= proc-arm740.o
+obj-$(CONFIG_CPU_ARM9TDMI)	+= proc-arm9tdmi.o
 obj-$(CONFIG_CPU_ARM920T)	+= proc-arm920.o
 obj-$(CONFIG_CPU_ARM922T)	+= proc-arm922.o
 obj-$(CONFIG_CPU_ARM925T)	+= proc-arm925.o
 obj-$(CONFIG_CPU_ARM926T)	+= proc-arm926.o
+obj-$(CONFIG_CPU_ARM940T)	+= proc-arm940.o
+obj-$(CONFIG_CPU_ARM946E)	+= proc-arm946.o
 obj-$(CONFIG_CPU_ARM1020)	+= proc-arm1020.o
 obj-$(CONFIG_CPU_ARM1020E)	+= proc-arm1020e.o
 obj-$(CONFIG_CPU_ARM1022)	+= proc-arm1022.o
diff -Naur linux-2.6.14-uc0/arch/arm/mm/mm-armv.c linux-2.6.14-uc0-hsc0/arch/arm/mm/mm-armv.c
--- linux-2.6.14-uc0/arch/arm/mm/mm-armv.c	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/mm-armv.c	2005-11-09 18:22:44.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/arch/arm/mm/mm-armv.c
  *
  *  Copyright (C) 1998-2002 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi for nommu
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -25,6 +26,8 @@
 
 #include <asm/mach/map.h>
 
+#ifdef CONFIG_MMU
+
 #define CPOLICY_UNCACHED	0
 #define CPOLICY_BUFFERED	1
 #define CPOLICY_WRITETHROUGH	2
@@ -569,6 +572,7 @@
 		length -= PAGE_SIZE;
 	}
 }
+#endif /* CONFIG_MMU */
 
 /*
  * In order to soft-boot, we need to insert a 1:1 mapping in place of
@@ -577,6 +581,7 @@
  */
 void setup_mm_for_reboot(char mode)
 {
+#ifdef CONFIG_MMU
 	unsigned long base_pmdval;
 	pgd_t *pgd;
 	int i;
@@ -599,8 +604,12 @@
 		pmd[1] = __pmd(pmdval + (1 << (PGDIR_SHIFT - 1)));
 		flush_pmd_entry(pmd);
 	}
+#else /* !CONFIG_MMU */
+	printk("FIXME: setup_mm_for_reboot %s %i\n",__FILE__,__LINE__);
+#endif /* CONFIG_MMU */
 }
 
+#ifdef CONFIG_MMU
 extern void _stext, _etext;
 
 /*
@@ -705,3 +714,13 @@
 	for (i = 0; i < nr; i++)
 		create_mapping(io_desc + i);
 }
+#endif /* CONFIG_MMU */
+
+#if !defined(CONFIG_MMU) && defined(CONFIG_MAGIC_ROM_PTR)
+int is_in_rom(unsigned long addr)
+{
+        /* Anything not in operational RAM is returned as in rom! */
+        return (addr < CONFIG_DRAM_BASE 
+		|| addr >= (CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)) ? 1 : 0;
+}
+#endif /* !CONFIG_MMU && CONFIG_MAGIC_ROM_PTR */
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm1020e.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm1020e.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm1020e.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm1020e.S	2005-11-09 18:25:52.000000000 +0900
@@ -3,6 +3,8 @@
  *
  *  Copyright (C) 2000 ARM Limited
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -101,7 +103,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f 		@ ............wcam
 	bic	ip, ip, #0x1100 		@ ...i...s........
@@ -344,6 +348,7 @@
  */
 	.align	5
 ENTRY(cpu_arm1020e_switch_mm)
+#ifdef CONFIG_MMU
 #ifndef CONFIG_CPU_DCACHE_DISABLE
 	mcr	p15, 0, r3, c7, c10, 4
 	mov	r1, #0xF			@ 16 segments
@@ -367,8 +372,10 @@
 	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, r1, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mov	pc, lr
         
+#ifdef CONFIG_MMU
 /*
  * cpu_arm1020e_set_pte(ptep, pte)
  *
@@ -404,6 +411,7 @@
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 #endif
 	mov	pc, lr
+#endif /* CONFIG_MMU */
 
 	__INIT
 
@@ -412,7 +420,9 @@
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
+#endif
 	mrc	p15, 0, r0, c1, c0		@ get control register v4
 	ldr	r5, arm1020e_cr1_clear
 	bic	r0, r0, r5
@@ -434,7 +444,11 @@
 arm1020e_cr1_clear:
 	.word	0x5f3f
 arm1020e_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x3935
+#else
+	.word	0x3934
+#endif
 
 	__INITDATA
 
@@ -451,7 +465,9 @@
 	.word	cpu_arm1020e_do_idle
 	.word	cpu_arm1020e_dcache_clean_area
 	.word	cpu_arm1020e_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_arm1020e_set_pte
+#endif
 	.size	arm1020e_processor_functions, . - arm1020e_processor_functions
 
 	.section ".rodata"
@@ -497,17 +513,21 @@
 __arm1020e_proc_info:
 	.long	0x4105a200			@ ARM 1020TE (Architecture v5TE)
 	.long	0xff0ffff0
+#ifdef CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__arm1020e_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB | HWCAP_EDSP
 	.long	cpu_arm1020e_name
 	.long	arm1020e_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wbi_tlb_fns
 	.long	v4wb_user_fns
+#endif
 	.long	arm1020e_cache_fns
 	.size	__arm1020e_proc_info, . - __arm1020e_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm1020.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm1020.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm1020.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm1020.S	2005-11-09 18:24:59.000000000 +0900
@@ -3,6 +3,8 @@
  *
  *  Copyright (C) 2000 ARM Limited
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -101,7 +103,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f 		@ ............wcam
 	bic	ip, ip, #0x1100 		@ ...i...s........
@@ -359,6 +363,7 @@
  */
 	.align	5
 ENTRY(cpu_arm1020_switch_mm)
+#ifdef CONFIG_MMU
 #ifndef CONFIG_CPU_DCACHE_DISABLE
 	mcr	p15, 0, r3, c7, c10, 4
 	mov	r1, #0xF			@ 16 segments
@@ -383,8 +388,10 @@
 	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, r1, c8, c7, 0		@ invalidate I & D TLBs
+#endif /* CONFIG_MMU */
 	mov	pc, lr
         
+#ifdef CONFIG_MMU
 /*
  * cpu_arm1020_set_pte(ptep, pte)
  *
@@ -423,6 +430,7 @@
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
 
+#endif /* CONFIG_MMU */
 	__INIT
 
 	.type	__arm1020_setup, #function
@@ -430,7 +438,9 @@
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
+#endif
 	mrc	p15, 0, r0, c1, c0		@ get control register v4
 	ldr	r5, arm1020_cr1_clear
 	bic	r0, r0, r5
@@ -452,7 +462,11 @@
 arm1020_cr1_clear:
 	.word	0x593f
 arm1020_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x3935
+#else
+	.word	0x3934
+#endif
 
 	__INITDATA
 
@@ -469,7 +483,9 @@
 	.word	cpu_arm1020_do_idle
 	.word	cpu_arm1020_dcache_clean_area
 	.word	cpu_arm1020_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_arm1020_set_pte
+#endif
 	.size	arm1020_processor_functions, . - arm1020_processor_functions
 
 	.section ".rodata"
@@ -515,16 +531,20 @@
 __arm1020_proc_info:
 	.long	0x4104a200			@ ARM 1020T (Architecture v5T)
 	.long	0xff0ffff0
+#ifdef CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__arm1020_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
 	.long	cpu_arm1020_name
 	.long	arm1020_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wbi_tlb_fns
 	.long	v4wb_user_fns
+#endif
 	.long	arm1020_cache_fns
 	.size	__arm1020_proc_info, . - __arm1020_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm1022.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm1022.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm1022.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm1022.S	2005-11-09 18:26:49.000000000 +0900
@@ -3,6 +3,8 @@
  *
  *  Copyright (C) 2000 ARM Limited
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -89,7 +91,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f 		@ ............wcam
 	bic	ip, ip, #0x1100 		@ ...i...s........
@@ -332,6 +336,7 @@
  */
 	.align	5
 ENTRY(cpu_arm1022_switch_mm)
+#ifdef CONFIG_MMU
 #ifndef CONFIG_CPU_DCACHE_DISABLE
 	mov	r1, #(CACHE_DSEGMENTS - 1) << 5	@ 16 segments
 1:	orr	r3, r1, #(CACHE_DENTRIES - 1) << 26 @ 64 entries
@@ -348,8 +353,10 @@
 	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, r1, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mov	pc, lr
         
+#ifdef CONFIG_MMU
 /*
  * cpu_arm1022_set_pte(ptep, pte)
  *
@@ -385,6 +392,7 @@
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 #endif
 	mov	pc, lr
+#endif /* CONFIG_MMU */
 
 	__INIT
 
@@ -393,7 +401,9 @@
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
+#endif
 	mrc	p15, 0, r0, c1, c0		@ get control register v4
 	ldr	r5, arm1022_cr1_clear
 	bic	r0, r0, r5
@@ -416,7 +426,11 @@
 arm1022_cr1_clear:
 	.word	0x7f3f
 arm1022_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x3935
+#else
+	.word	0x3934
+#endif
 
 	__INITDATA
 
@@ -433,7 +447,9 @@
 	.word	cpu_arm1022_do_idle
 	.word	cpu_arm1022_dcache_clean_area
 	.word	cpu_arm1022_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_arm1022_set_pte
+#endif
 	.size	arm1022_processor_functions, . - arm1022_processor_functions
 
 	.section ".rodata"
@@ -479,17 +495,21 @@
 __arm1022_proc_info:
 	.long	0x4105a220			@ ARM 1022E (v5TE)
 	.long	0xff0ffff0
+#ifdef CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__arm1022_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB | HWCAP_EDSP
 	.long	cpu_arm1022_name
 	.long	arm1022_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wbi_tlb_fns
 	.long	v4wb_user_fns
+#endif
 	.long	arm1022_cache_fns
 	.size	__arm1022_proc_info, . - __arm1022_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm1026.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm1026.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm1026.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm1026.S	2005-11-09 18:27:37.000000000 +0900
@@ -3,6 +3,8 @@
  *
  *  Copyright (C) 2000 ARM Limited
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -89,7 +91,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f 		@ ............wcam
 	bic	ip, ip, #0x1100 		@ ...i...s........
@@ -326,6 +330,7 @@
  */
 	.align	5
 ENTRY(cpu_arm1026_switch_mm)
+#ifdef CONFIG_MMU
 	mov	r1, #0
 #ifndef CONFIG_CPU_DCACHE_DISABLE
 1:	mrc	p15, 0, r15, c7, c14, 3		@ test, clean, invalidate
@@ -337,8 +342,10 @@
 	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, r1, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mov	pc, lr
         
+#ifdef CONFIG_MMU
 /*
  * cpu_arm1026_set_pte(ptep, pte)
  *
@@ -374,7 +381,7 @@
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 #endif
 	mov	pc, lr
-
+#endif /* CONFIG_MMU */
 
 	__INIT
 
@@ -383,8 +390,10 @@
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
 	mcr	p15, 0, r4, c2, c0		@ load page table pointer
+#endif
 #ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
 	mov	r0, #4				@ explicitly disable writeback
 	mcr	p15, 7, r0, c15, c0, 0
@@ -411,7 +420,11 @@
 arm1026_cr1_clear:
 	.word	0x7f3f
 arm1026_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x3935
+#else
+	.word	0x3934
+#endif
 
 	__INITDATA
 
@@ -428,7 +441,9 @@
 	.word	cpu_arm1026_do_idle
 	.word	cpu_arm1026_dcache_clean_area
 	.word	cpu_arm1026_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_arm1026_set_pte
+#endif
 	.size	arm1026_processor_functions, . - arm1026_processor_functions
 
 	.section .rodata
@@ -475,17 +490,21 @@
 __arm1026_proc_info:
 	.long	0x4106a260			@ ARM 1026EJ-S (v5TEJ)
 	.long	0xff0ffff0
+#ifdef CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__arm1026_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP|HWCAP_HALF|HWCAP_THUMB|HWCAP_FAST_MULT|HWCAP_EDSP|HWCAP_JAVA
 	.long	cpu_arm1026_name
 	.long	arm1026_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wbi_tlb_fns
 	.long	v4wb_user_fns
+#endif
 	.long	arm1026_cache_fns
 	.size	__arm1026_proc_info, . - __arm1026_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm6_7.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm6_7.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm6_7.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm6_7.S	2005-11-09 18:28:50.000000000 +0900
@@ -2,6 +2,8 @@
  *  linux/arch/arm/mm/proc-arm6,7.S
  *
  *  Copyright (C) 1997-2000 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for nommu version
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -198,12 +200,15 @@
  */
 ENTRY(cpu_arm6_switch_mm)
 ENTRY(cpu_arm7_switch_mm)
+#ifdef CONFIG_MMU
 		mov	r1, #0
 		mcr	p15, 0, r1, c7, c0, 0		@ flush cache
 		mcr	p15, 0, r0, c2, c0, 0		@ update page table ptr
 		mcr	p15, 0, r1, c5, c0, 0		@ flush TLBs
+#endif
 		mov	pc, lr
 
+#ifdef CONFIG_MMU
 /*
  * Function: arm6_7_set_pte(pte_t *ptep, pte_t pte)
  * Params  : r0 = Address to set
@@ -232,6 +237,7 @@
 
 		str	r2, [r0]			@ hardware version
 		mov	pc, lr
+#endif /* CONFIG_MMU */
 
 /*
  * Function: _arm6_7_reset
@@ -242,7 +248,9 @@
 ENTRY(cpu_arm7_reset)
 		mov	r1, #0
 		mcr	p15, 0, r1, c7, c0, 0		@ flush cache
+#ifdef CONFIG_MMU
 		mcr	p15, 0, r1, c5, c0, 0		@ flush TLB
+#endif
 		mov	r1, #0x30
 		mcr	p15, 0, r1, c1, c0, 0		@ turn off MMU etc
 		mov	pc, r0
@@ -252,19 +260,27 @@
 		.type	__arm6_setup, #function
 __arm6_setup:	mov	r0, #0
 		mcr	p15, 0, r0, c7, c0		@ flush caches on v3
+#ifdef CONFIG_MMU
 		mcr	p15, 0, r0, c5, c0		@ flush TLBs on v3
 		mov	r0, #0x3d			@ . ..RS BLDP WCAM
 		orr	r0, r0, #0x100			@ . ..01 0011 1101
+#else
+		mov	r0, #0x3c			@ . ..RS BLDP WCA.
+#endif
 		mov	pc, lr
 		.size	__arm6_setup, . - __arm6_setup
 
 		.type	__arm7_setup, #function
 __arm7_setup:	mov	r0, #0
 		mcr	p15, 0, r0, c7, c0		@ flush caches on v3
+#ifdef CONFIG_MMU
 		mcr	p15, 0, r0, c5, c0		@ flush TLBs on v3
 		mcr	p15, 0, r0, c3, c0		@ load domain access register
 		mov	r0, #0x7d			@ . ..RS BLDP WCAM
 		orr	r0, r0, #0x100			@ . ..01 0111 1101
+#else
+		mov	r0, #0x7c			@ . ..RS BLDP WCA.
+#endif
 		mov	pc, lr
 		.size	__arm7_setup, . - __arm7_setup
 
@@ -283,7 +299,9 @@
 		.word	cpu_arm6_do_idle
 		.word	cpu_arm6_dcache_clean_area
 		.word	cpu_arm6_switch_mm
+#ifdef CONFIG_MMU
 		.word	cpu_arm6_set_pte
+#endif
 		.size	arm6_processor_functions, . - arm6_processor_functions
 
 /*
@@ -299,7 +317,9 @@
 		.word	cpu_arm7_do_idle
 		.word	cpu_arm7_dcache_clean_area
 		.word	cpu_arm7_switch_mm
+#ifdef CONFIG_MMU
 		.word	cpu_arm7_set_pte
+#endif
 		.size	arm7_processor_functions, . - arm7_processor_functions
 
 		.section ".rodata"
@@ -338,15 +358,19 @@
 __arm6_proc_info:
 		.long	0x41560600
 		.long	0xfffffff0
+#ifdef CONFIG_MMU
 		.long	0x00000c1e
+#endif
 		b	__arm6_setup
 		.long	cpu_arch_name
 		.long	cpu_elf_name
 		.long	HWCAP_SWP | HWCAP_26BIT
 		.long	cpu_arm6_name
 		.long	arm6_processor_functions
+#ifdef CONFIG_MMU
 		.long	v3_tlb_fns
 		.long	v3_user_fns
+#endif
 		.long	v3_cache_fns
 		.size	__arm6_proc_info, . - __arm6_proc_info
 
@@ -354,15 +378,19 @@
 __arm610_proc_info:
 		.long	0x41560610
 		.long	0xfffffff0
+#ifdef CONFIG_MMU
 		.long	0x00000c1e
+#endif
 		b	__arm6_setup
 		.long	cpu_arch_name
 		.long	cpu_elf_name
 		.long	HWCAP_SWP | HWCAP_26BIT
 		.long	cpu_arm610_name
 		.long	arm6_processor_functions
+#ifdef CONFIG_MMU
 		.long	v3_tlb_fns
 		.long	v3_user_fns
+#endif
 		.long	v3_cache_fns
 		.size	__arm610_proc_info, . - __arm610_proc_info
 
@@ -370,15 +398,19 @@
 __arm7_proc_info:
 		.long	0x41007000
 		.long	0xffffff00
+#ifdef CONFIG_MMU
 		.long	0x00000c1e
+#endif
 		b	__arm7_setup
 		.long	cpu_arch_name
 		.long	cpu_elf_name
 		.long	HWCAP_SWP | HWCAP_26BIT
 		.long	cpu_arm7_name
 		.long	arm7_processor_functions
+#ifdef CONFIG_MMU
 		.long	v3_tlb_fns
 		.long	v3_user_fns
+#endif
 		.long	v3_cache_fns
 		.size	__arm7_proc_info, . - __arm7_proc_info
 
@@ -386,19 +418,23 @@
 __arm710_proc_info:
 		.long	0x41007100
 		.long	0xfff8ff00
+#ifdef CONFIG_MMU
 		.long   PMD_TYPE_SECT | \
 			PMD_SECT_BUFFERABLE | \
 			PMD_SECT_CACHEABLE | \
 			PMD_BIT4 | \
 			PMD_SECT_AP_WRITE | \
 			PMD_SECT_AP_READ
+#endif
 		b	__arm7_setup
 		.long	cpu_arch_name
 		.long	cpu_elf_name
 		.long	HWCAP_SWP | HWCAP_26BIT
 		.long	cpu_arm710_name
 		.long	arm7_processor_functions
+#ifdef CONFIG_MMU
 		.long	v3_tlb_fns
 		.long	v3_user_fns
+#endif
 		.long	v3_cache_fns
 		.size	__arm710_proc_info, . - __arm710_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm720.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm720.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm720.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm720.S	2005-11-09 18:30:21.000000000 +0900
@@ -4,6 +4,8 @@
  *  Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
  *                     Rob Scott (rscott@mtrob.fdns.net)
  *  Copyright (C) 2000 ARM Limited, Deep Blue Solutions Ltd.
+ *  Copyright (C) 2004 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -29,6 +31,7 @@
  *			out of 'proc-arm6,7.S' per RMK discussion
  *   07-25-2000 SJH	Added idle function.
  *   08-25-2000	DBS	Updated for integration of ARM Ltd version.
+ *   04-20-2004 HSC     copied and modified for non-paged mmu version.
  */
 #include <linux/linkage.h>
 #include <linux/init.h>
@@ -75,12 +78,15 @@
  *	     the new.
  */
 ENTRY(cpu_arm720_switch_mm)
+#ifdef CONFIG_MMU
 		mov	r1, #0
 		mcr	p15, 0, r1, c7, c7, 0		@ invalidate cache
 		mcr	p15, 0, r0, c2, c0, 0		@ update page table ptr
 		mcr	p15, 0, r1, c8, c7, 0		@ flush TLB (v4)
+#endif
 		mov	pc, lr
 
+#ifdef CONFIG_MMU
 /*
  * Function: arm720_set_pte(pte_t *ptep, pte_t pte)
  * Params  : r0 = Address to set
@@ -108,6 +114,7 @@
 
 		str	r2, [r0]			@ hardware version
 		mov	pc, lr
+#endif
 
 /*
  * Function: arm720_reset
@@ -117,7 +124,9 @@
 ENTRY(cpu_arm720_reset)
 		mov	ip, #0
 		mcr	p15, 0, ip, c7, c7, 0		@ invalidate cache
+#ifdef CONFIG_MMU
 		mcr	p15, 0, ip, c8, c7, 0		@ flush TLB (v4)
+#endif
 		mrc	p15, 0, ip, c1, c0, 0		@ get ctrl register
 		bic	ip, ip, #0x000f			@ ............wcam
 		bic	ip, ip, #0x2100			@ ..v....s........
@@ -130,7 +139,9 @@
 __arm710_setup:
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7, 0		@ invalidate caches
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7, 0		@ flush TLB (v4)
+#endif
 	mrc	p15, 0, r0, c1, c0		@ get control register
 	ldr	r5, arm710_cr1_clear
 	bic	r0, r0, r5
@@ -150,13 +161,19 @@
 arm710_cr1_clear:
 	.word	0x0f3f
 arm710_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x013d
+#else
+	.word	0x013c
+#endif
 
 	.type	__arm720_setup, #function
 __arm720_setup:
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7, 0		@ invalidate caches
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7, 0		@ flush TLB (v4)
+#endif
 	mrc	p15, 0, r0, c1, c0		@ get control register
 	ldr	r5, arm720_cr1_clear
 	bic	r0, r0, r5
@@ -176,7 +193,11 @@
 arm720_cr1_clear:
 	.word	0x2f3f
 arm720_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x213d
+#else
+	.word	0x213c
+#endif
 
 		__INITDATA
 
@@ -193,7 +214,9 @@
 		.word	cpu_arm720_do_idle
 		.word	cpu_arm720_dcache_clean_area
 		.word	cpu_arm720_switch_mm
+#ifdef CONFIG_MMU
 		.word	cpu_arm720_set_pte
+#endif
 		.size	arm720_processor_functions, . - arm720_processor_functions
 
 		.section ".rodata"
@@ -240,8 +263,10 @@
 		.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB	@ elf_hwcap
 		.long	cpu_arm710_name				@ name
 		.long	arm720_processor_functions
+#ifdef CONFIG_MMU
 		.long	v4_tlb_fns
 		.long	v4wt_user_fns
+#endif
 		.long	v4_cache_fns
 		.size	__arm710_proc_info, . - __arm710_proc_info
 
@@ -249,19 +274,23 @@
 __arm720_proc_info:
 		.long	0x41807200				@ cpu_val
 		.long	0xffffff00				@ cpu_mask
+#ifdef CONFIG_MMU
 		.long   PMD_TYPE_SECT | \
 			PMD_SECT_BUFFERABLE | \
 			PMD_SECT_CACHEABLE | \
 			PMD_BIT4 | \
 			PMD_SECT_AP_WRITE | \
 			PMD_SECT_AP_READ
+#endif
 		b	__arm720_setup				@ cpu_flush
 		.long	cpu_arch_name				@ arch_name
 		.long	cpu_elf_name				@ elf_name
 		.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB	@ elf_hwcap
 		.long	cpu_arm720_name				@ name
 		.long	arm720_processor_functions
+#ifdef CONFIG_MMU
 		.long	v4_tlb_fns
 		.long	v4wt_user_fns
+#endif
 		.long	v4_cache_fns
 		.size	__arm720_proc_info, . - __arm720_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm740.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm740.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm740.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm740.S	2005-11-08 08:48:12.000000000 +0900
@@ -0,0 +1,333 @@
+/*
+ *  linux/arch/armnommu/mm/arm740.S: MPU functions for ARM740
+ * 
+ *  Copyright (C) 1997-2000 Russell King
+ *  Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *                     Rob Scott (rscott@mtrob.fdns.net)
+ *  Copyright (C) 2000 ARM Limited, Deep Blue Solutions Ltd.
+ *  Copyright (C) 2004 Hyok S. Choi (hyok.choi@samsung.com)
+ */
+	
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>	
+#include <asm/assembler.h>
+#include <asm/pgtable.h>	
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>	
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+
+/*
+ * cpu_arm740_data_abort()
+ *
+ * obtain information about current aborted instruction
+ *
+ * r0 = address of aborted instruction
+ *
+ * Returns:
+ *  r0 = address of abort
+ *  r1 != 0 if writing
+ *  r3 = FSR
+ */
+	.align	5
+Ldata_ldmstm:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+	mov	r7, #0x11
+	orr	r7, r7, r7, lsl #8
+	and	r0, r4, r7
+	and	r2, r4, r7, lsl #1
+	add	r0, r0, r2, lsr #1
+	and	r2, r4, r7, lsl #2
+	add	r0, r0, r2, lsr #2
+	and	r2, r4, r7, lsl #3
+	add	r0, r0, r2, lsr #3
+	add	r0, r0, r0, lsr #8
+	add	r0, r0, r0, lsr #4
+	and	r7, r0, #15			@ r7 = no. of registers to transfer.
+	and	r5, r4, #15 << 16		@ Get Rn
+	ldr	r0, [sp, r5, lsr #14]		@ Get register
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r7, lsl #2
+	addeq	r7, r0, r7, lsl #2		@ Do correction (signed)
+Ldata_saver7:
+	str	r7, [sp, r5, lsr #14]		@ Put register
+Ldata_simple:
+	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
+	mrc	p15, 0, r3, c5, c0, 0		@ get FSR
+	and	r3, r3, #255
+	mov	pc, lr
+
+ENTRY(cpu_arm740_data_abort)
+	ldr	r4, [r0]			@ read instruction causing problem
+	tst	r4, r4, lsr #21			@ C = bit 20
+	sbc	r1, r1, r1			@ r1 = C - 1
+	and	r2, r4, #15 << 24
+	add	pc, pc, r2, lsr #22		@ Now branch to the relevent processing routine
+	movs	pc, lr
+
+	b	Ldata_lateldrhpost		@ ldrh	rd, [rn], #m/rm
+	b	Ldata_lateldrhpre		@ ldrh	rd, [rn, #m/rm]
+	b	Ldata_unknown
+	b	Ldata_unknown
+	b	Ldata_lateldrpostconst		@ ldr	rd, [rn], #m
+	b	Ldata_lateldrpreconst		@ ldr	rd, [rn, #m] 
+	b	Ldata_lateldrpostreg		@ ldr	rd, [rn], rm
+	b	Ldata_lateldrprereg		@ ldr	rd, [rn, rm]
+	b	Ldata_ldmstm			@ ldm*a	rn, <rlist>
+	b	Ldata_ldmstm			@ ldm*b	rn, <rlist>
+	b	Ldata_unknown
+	b	Ldata_unknown
+	b	Ldata_simple			@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
+	b	Ldata_simple			@ ldc	rd, [rn, #m]
+	b	Ldata_unknown
+
+Ldata_unknown:	@ Part of jumptable
+	mov	r0, r2
+	mov	r1, r4
+	mov	r2, r3
+	bl	baddataabort
+	b	ret_from_exception
+
+Ldata_lateldrhpre:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+Ldata_lateldrhpost:
+	and	r5, r4, #0x00f			@ get Rm / low nibble of immediate value
+	tst	r4, #1 << 22			@ if (immediate offset)
+	andne	r2, r4, #0xf00			@ { immediate high nibble
+	orrne	r2, r5, r2, lsr #4		@   combine nibbles } else
+	ldreq	r2, [sp, r5, lsl #2]		@ { load Rm value }
+	and	r5, r4, #15 << 16		@ get Rn
+	ldr	r0, [sp, r5, lsr #14]		@ load Rn value
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r2
+	addeq	r7, r0, r2
+	b	Ldata_saver7
+
+Ldata_lateldrpreconst:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+Ldata_lateldrpostconst:
+	movs	r2, r4, lsl #20			@ Get offset
+	beq	Ldata_simple
+	and	r5, r4, #15 << 16		@ Get Rn
+	ldr	r0, [sp, r5, lsr #14]
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r2, lsr #20
+	addeq	r7, r0, r2, lsr #20
+	b	Ldata_saver7
+
+Ldata_lateldrprereg:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+Ldata_lateldrpostreg:
+	and	r5, r4, #15
+	ldr	r2, [sp, r5, lsl #2]		@ Get Rm
+	mov	r3, r4, lsr #7
+	ands	r3, r3, #31
+	and	r6, r4, #0x70
+	orreq	r6, r6, #8
+	add	pc, pc, r6
+	mov	r0, r0
+
+	mov	r2, r2, lsl r3			@ 0: LSL #!0
+	b	1f
+	b	1f				@ 1: LSL #0
+	mov	r0, r0
+	b	1f				@ 2: MUL?
+	mov	r0, r0
+	b	1f				@ 3: MUL?
+	mov	r0, r0
+	mov	r2, r2, lsr r3			@ 4: LSR #!0
+	b	1f
+	mov	r2, r2, lsr #32			@ 5: LSR #32
+	b	1f
+	b	1f				@ 6: MUL?
+	mov	r0, r0
+	b	1f				@ 7: MUL?
+	mov	r0, r0
+	mov	r2, r2, asr r3			@ 8: ASR #!0
+	b	1f
+	mov	r2, r2, asr #32			@ 9: ASR #32
+	b	1f
+	b	1f				@ A: MUL?
+	mov	r0, r0
+	b	1f				@ B: MUL?
+	mov	r0, r0
+	mov	r2, r2, ror r3			@ C: ROR #!0
+	b	1f
+	mov	r2, r2, rrx			@ D: RRX
+	b	1f
+	mov	r0, r0				@ E: MUL?
+	mov	r0, r0
+	mov	r0, r0				@ F: MUL?
+
+
+1:	and	r5, r4, #15 << 16		@ Get Rn
+	ldr	r0, [sp, r5, lsr #14]
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r2
+	addeq	r7, r0, r2
+	b	Ldata_saver7
+
+
+/*
+ * cpu_arm740_check_bugs()
+ */
+ENTRY(cpu_arm740_check_bugs)
+	mrs	ip, cpsr
+	bic	ip, ip, #PSR_F_BIT
+	msr	cpsr, ip
+	mov	pc, lr
+
+/*
+ * cpu_arm740_proc_init()
+ */
+ENTRY(cpu_arm740_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm740_proc_fin()
+ */
+ENTRY(cpu_arm740_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	mcr	p15, 0, r1, c7, c7, 0		@ invalidate cache
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm740_reset(loc)
+ * Params  : r0 = address to jump to
+ * Notes   : This sets up everything for a reset
+ */
+ENTRY(cpu_arm740_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate cache
+	mrc	p15, 0, ip, c1, c0, 0		@ get ctrl register
+	bic	ip, ip, #0x000e				@ ............wcam
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * idle mode processing 
+ */
+ENTRY(cpu_arm740_do_idle)  
+	mov	pc, lr
+
+/* 
+ * *FIXME* 
+ */ 	
+ENTRY(cpu_arm740_dcache_clean_area)
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7, 0		@ flush cache
+	mov	pc, lr
+	
+/*
+ * Function: arm740_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, 
+ */	
+ENTRY(cpu_arm740_switch_mm)
+	mov	pc, lr	
+
+	
+	/* .section ".text.init", #alloc, #execinstr */ 
+	__INIT
+	
+__arm740_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7, 0		@ invalidate caches
+
+	mov r0, #0x0					@disable region 3-7
+	mcr p15, 0, r0, c6, c3
+	mcr p15, 0, r0, c6, c4
+	mcr p15, 0, r0, c6, c5
+	mcr p15, 0, r0, c6, c6
+	mcr p15, 0, r0, c6, c7
+
+	mov r0, #0x0000003F			@ (base = 0, size = 4GB, non cacheable, no write buffer)
+	mcr p15, 0, r0, c6,	c0		@ enable region 0, default
+	mov r0, #0x00000037			@ (base = 0, size = 256MB, cacheable, write buffered)
+	mcr p15, 0, r0, c6,	c1		@enable region 1, RAM
+	mov r0, #0x20000000
+	add r0, r0, #0x37			@ (base = 512MB, size = 256MB, cacheable, write buffered)
+	mcr p15, 0, r0, c6,	c2		@enable region 2, ROM/Flash
+
+	mov r0, #0x06				
+	mcr p15, 0, r0, c2, c0		@ Region 1&2 cacheable
+	mov r0, #0x02			
+	mcr p15, 0, r0, c3, c0		@ Region 1 write buferred
+
+	mov r0, #0xff00
+	add r0, r0, #0x00ff
+	mcr p15, 0, r0, c5, c0		@ all read/write access
+
+	mrc	p15, 0, r0, c1, c0		@ get control register
+	orr r0, r0, #0x00030000		@ Split cache mode
+	orr	r0, r0, #0x0000000d		@ MPU, Cache, Write Buffer on
+	
+	mov	pc, lr				@ __ret (head-armv.S)
+		
+	.size	__arm740_setup, . - __arm740_setup	
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm740_processor_functions, #object
+ENTRY(arm740_processor_functions)
+	.word	cpu_arm740_data_abort
+	.word	cpu_arm740_proc_init
+	.word	cpu_arm740_proc_fin
+	.word	cpu_arm740_reset
+	.word   cpu_arm740_do_idle
+
+	.word	cpu_arm740_dcache_clean_area
+	.word	cpu_arm740_switch_mm
+	.size	arm740_processor_functions, . - arm740_processor_functions
+
+	.section ".rodata"	
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv4"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v4"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm740_name, #object
+cpu_arm740_name:
+	.ascii	"ARM740T"
+	.size	cpu_arm740_name, . - cpu_arm740_name
+
+	.align
+
+
+	.section ".proc.info", #alloc, #execinstr
+	.type	__arm740_proc_info,#object
+__arm740_proc_info:
+	.long	0x41807400
+	.long	0xfffffff0
+	b	__arm740_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT
+	.long	cpu_arm740_name  
+	.long	arm740_processor_functions 
+	.long	v4_cache_fns			@ cache model
+	.size	__arm740_proc_info, . - __arm740_proc_info
+
+
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm7tdmi.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm7tdmi.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm7tdmi.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm7tdmi.S	2005-11-08 08:48:11.000000000 +0900
@@ -0,0 +1,384 @@
+/*
+ *  linux/arch/arm/mm/proc-arm7tdmi.S
+ *
+ *  Copyright (C) 1997-2000 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  for ARM7TDMI and the compatibles.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/errno.h>
+
+ENTRY(cpu_arm7tdmi_dcache_clean_area)
+		mov	pc, lr
+
+/*
+ * Function: arm7tdmi_data_abort ()
+ *
+ * Params  : r2 = address of aborted instruction
+ *	   : sp = pointer to registers
+ *
+ * Purpose : obtain information about current aborted instruction
+ *
+ * Returns : r0 = address of abort
+ *	   : r1 = FSR
+ */
+
+ENTRY(cpu_arm7tdmi_data_abort)
+#ifndef CONFIG_CPU_HAS_NO_CP15
+	mrc	p15, 0, r1, c5, c0, 0		@ get FSR
+	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
+#endif
+	ldr	r8, [r0]			@ read arm instruction
+	tst	r8, #1 << 20			@ L = 1 -> write?
+	orreq	r1, r1, #1 << 8			@ yes.
+	and	r7, r8, #15 << 24
+	add	pc, pc, r7, lsr #22		@ Now branch to the relevant processing routine
+	nop
+
+/* 0 */	b	.data_unknown
+/* 1 */	mov	pc, lr				@ swp
+/* 2 */	b	.data_unknown
+/* 3 */	b	.data_unknown
+/* 4 */	b	.data_arm_lateldrpostconst	@ ldr	rd, [rn], #m
+/* 5 */	b	.data_arm_lateldrpreconst	@ ldr	rd, [rn, #m]
+/* 6 */	b	.data_arm_lateldrpostreg	@ ldr	rd, [rn], rm
+/* 7 */	b	.data_arm_lateldrprereg		@ ldr	rd, [rn, rm]
+/* 8 */	b	.data_arm_ldmstm		@ ldm*a	rn, <rlist>
+/* 9 */	b	.data_arm_ldmstm		@ ldm*b	rn, <rlist>
+/* a */	b	.data_unknown
+/* b */	b	.data_unknown
+/* c */	mov	pc, lr				@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
+/* d */	mov	pc, lr				@ ldc	rd, [rn, #m]
+/* e */	b	.data_unknown
+/* f */
+.data_unknown:	@ Part of jumptable
+	mov	r0, r2
+	mov	r1, r8
+	mov	r2, sp
+	bl	baddataabort
+	b	ret_from_exception
+
+
+.data_arm_ldmstm:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+	mov	r7, #0x11
+	orr	r7, r7, #0x1100
+	and	r6, r8, r7
+	and	r2, r8, r7, lsl #1
+	add	r6, r6, r2, lsr #1
+	and	r2, r8, r7, lsl #2
+	add	r6, r6, r2, lsr #2
+	and	r2, r8, r7, lsl #3
+	add	r6, r6, r2, lsr #3
+	add	r6, r6, r6, lsr #8
+	add	r6, r6, r6, lsr #4
+	and	r6, r6, #15			@ r6 = no. of registers to transfer.
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6, lsl #2		@ Undo increment
+	addeq	r7, r7, r6, lsl #2		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_apply_r6_and_rn:
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6			@ Undo incrmenet
+	addeq	r7, r7, r6			@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrpreconst:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostconst:
+	movs	r2, r8, lsl #20			@ Get offset
+	moveq	pc, lr				@ zero -> no fixup
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r2, lsr #20		@ Undo increment
+	addeq	r7, r7, r2, lsr #20		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrprereg:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostreg:
+	and	r7, r8, #15			@ Extract 'm' from instruction
+	ldr	r6, [sp, r7, lsl #2]		@ Get register 'Rm'
+	mov	r5, r8, lsr #7			@ get shift count
+	ands	r5, r5, #31
+	and	r7, r8, #0x70			@ get shift type
+	orreq	r7, r7, #8			@ shift count = 0
+	add	pc, pc, r7
+	nop
+
+	mov	r6, r6, lsl r5			@ 0: LSL #!0
+	b	.data_arm_apply_r6_and_rn
+	b	.data_arm_apply_r6_and_rn	@ 1: LSL #0
+	nop
+	b	.data_unknown			@ 2: MUL?
+	nop
+	b	.data_unknown			@ 3: MUL?
+	nop
+	mov	r6, r6, lsr r5			@ 4: LSR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, lsr #32			@ 5: LSR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ 6: MUL?
+	nop
+	b	.data_unknown			@ 7: MUL?
+	nop
+	mov	r6, r6, asr r5			@ 8: ASR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, asr #32			@ 9: ASR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ A: MUL?
+	nop
+	b	.data_unknown			@ B: MUL?
+	nop
+	mov	r6, r6, ror r5			@ C: ROR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, rrx			@ D: RRX
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ E: MUL?
+	nop
+	b	.data_unknown			@ F: MUL?
+
+/*
+ * Function: arm7tdmi_proc_init (void)
+ *	   : arm7tdmi_proc_fin (void)
+ *
+ * Notes   : This processor does not require these
+ */
+ENTRY(cpu_arm7tdmi_proc_init)
+		mov	pc, lr
+
+ENTRY(cpu_arm7tdmi_proc_fin)
+		mov	r0, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+		msr	cpsr_c, r0
+#ifndef CONFIG_CPU_HAS_NO_CP15
+		mov	r0, #0x31			@ ....S..DP...M
+		mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+#endif
+		mov	pc, lr
+
+ENTRY(cpu_arm7tdmi_do_idle)
+		mov	pc, lr
+
+/*
+ * Function: arm7tdmi_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, saving the old processes state, and restoring
+ *	     the new.
+ */
+ENTRY(cpu_arm7tdmi_switch_mm)
+		mov	pc, lr
+
+/*
+ * Function: _arm7tdmi_reset
+ * Params  : r0 = address to jump to
+ * Notes   : This sets up everything for a reset
+ */
+ENTRY(cpu_arm7tdmi_reset)
+#ifndef CPU_HAS_NO_CP15
+		mov	r1, #0
+		mcr	p15, 0, r1, c7, c0, 0		@ flush cache
+		mov	r1, #0x30
+		mcr	p15, 0, r1, c1, c0, 0		@ turn off MMU etc
+#endif
+		mov	pc, r0
+
+		__INIT
+
+		.type	__arm7tdmi_setup, #function
+__arm7tdmi_setup:
+#ifndef CPU_HAS_NO_CP15
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c0		@ flush caches on v3
+#endif
+		mov	r0, #0x7c			@ . .... .LDP WC..
+		mov	pc, lr
+		.size	__arm7tdmi_setup, . - __arm7tdmi_setup
+
+		__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+		.type	arm7tdmi_processor_functions, #object
+ENTRY(arm7tdmi_processor_functions)
+		.word	cpu_arm7tdmi_data_abort
+		.word	cpu_arm7tdmi_proc_init
+		.word	cpu_arm7tdmi_proc_fin
+		.word	cpu_arm7tdmi_reset
+		.word	cpu_arm7tdmi_do_idle
+		.word	cpu_arm7tdmi_dcache_clean_area
+		.word	cpu_arm7tdmi_switch_mm
+		.size	arm7tdmi_processor_functions, . - arm7tdmi_processor_functions
+
+		.section ".rodata"
+
+		.type	cpu_arch_name, #object
+cpu_arch_name:	.asciz	"armv4t"
+		.size	cpu_arch_name, . - cpu_arch_name
+
+		.type	cpu_elf_name, #object
+cpu_elf_name:	.asciz	"v4"
+		.size	cpu_elf_name, . - cpu_elf_name
+
+		.type	cpu_arm7tdmi_name, #object
+cpu_arm7tdmi_name:
+		.asciz	"ARM7TDMI"
+		.size	cpu_arm7tdmi_name, . - cpu_arm7tdmi_name
+
+		.type	cpu_triscenda7_name, #object
+cpu_triscenda7_name:
+#if defined(CONFIG_ARCH_TA7S)
+		.asciz	"Triscend-A7S"
+#elif defined(CONFIG_ARCH_TA7V)
+		.asciz	"Triscend-A7V"
+#endif
+		.size	cpu_triscenda7_name, . - cpu_triscenda7_name
+
+		.type	cpu_at91_name, #object
+cpu_at91_name:
+		.asciz	"Atmel-AT91M40xxx"
+		.size	cpu_at91_name, . - cpu_at91_name
+
+		.type	cpu_s3c3410_name, #object
+cpu_s3c3410_name:
+		.asciz	"Samsung-S3C3410"
+		.size	cpu_s3c3410_name, . - cpu_s3c3410_name
+
+		.type	cpu_s3c44b0x_name, #object
+cpu_s3c44b0x_name:
+		.asciz	"Samsung-S3C44B0x"
+		.size	cpu_s3c44b0x_name, . - cpu_s3c44b0x_name
+
+		.type	cpu_s3c4510b, #object
+cpu_s3c4510b_name:
+		.asciz	"Samsung-S3C4510B"
+		.size	cpu_s3c4510b_name, . - cpu_s3c4510b_name
+
+		.type	cpu_s3c4530_name, #object
+cpu_s3c4530_name:
+		.asciz	"Samsung-S3C4530"
+		.size	cpu_s3c4530_name, . - cpu_s3c4530_name
+
+		.type	cpu_netarm_name, #object
+cpu_netarm_name:
+		.asciz	"NETARM"
+		.size	cpu_netarm_name, . - cpu_netarm_name
+
+		.align
+
+		.section ".proc.info", #alloc, #execinstr
+
+		.type	__arm7tdmi_proc_info, #object
+__arm7tdmi_proc_info:
+		.long	0x41007700
+		.long	0xfff8ff00
+		b	__arm7tdmi_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_arm7tdmi_name
+		.long	arm7tdmi_processor_functions
+		.long	v4_cache_fns
+		.size	__arm7tdmi_proc_info, . - __arm7dmi_proc_info
+
+		.type	__triscenda7_proc_info, #object
+__triscenda7_proc_info:
+		.long	0x0001d2ff
+		.long	0x0001ffff
+		b	__arm7tdmi_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_THUMB | HWCAP_26BIT
+		.long	cpu_triscenda7_name
+		.long	arm7tdmi_processor_functions
+		.long	v4_cache_fns
+		.size	__triscenda7_proc_info, . - __triscenda7_proc_info
+
+		.type	__at91_proc_info, #object
+__at91_proc_info:
+		.long	0x14000040
+		.long	0xfff000e0
+		b	__arm7tdmi_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_THUMB | HWCAP_26BIT
+		.long	cpu_at91_name
+		.long	arm7tdmi_processor_functions
+		.long	v4_cache_fns
+		.size	__at91_proc_info, . - __at91_proc_info
+
+		.type	__s3c4510b_proc_info, #object
+__s3c4510b_proc_info:
+		.long	0x36365000
+		.long	0xfffff000
+		b	__arm7tdmi_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_THUMB | HWCAP_26BIT
+		.long	cpu_s3c4510b_name
+		.long	arm7tdmi_processor_functions
+		.long	v4_cache_fns
+		.size	__s3c4510b_proc_info, . - __s3c4510b_proc_info
+
+		.type	__s3c4530_proc_info, #object
+__s3c4530_proc_info:
+		.long	0x4c000000
+		.long	0xfff000e0
+		b	__arm7tdmi_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_THUMB | HWCAP_26BIT
+		.long	cpu_s3c4530_name
+		.long	arm7tdmi_processor_functions
+		.long	v4_cache_fns
+		.size	__s3c4530_proc_info, . - __s3c4530_proc_info
+
+		.type	__s3c3410_proc_info, #object
+__s3c3410_proc_info:
+		.long	0x34100000
+		.long	0xffff0000
+		b	__arm7tdmi_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_THUMB | HWCAP_26BIT
+		.long	cpu_s3c3410_name
+		.long	arm7tdmi_processor_functions
+		.long	v4_cache_fns
+		.size	__s3c3410_proc_info, . - __s3c3410_proc_info
+
+		.type	__s3c44b0x_proc_info, #object
+__s3c44b0x_proc_info:
+		.long	0x44b00000
+		.long	0xffff0000
+		b	__arm7tdmi_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_THUMB | HWCAP_26BIT
+		.long	cpu_s3c44b0x_name
+		.long	arm7tdmi_processor_functions
+		.long	v4_cache_fns
+		.size	__s3c44b0x_proc_info, . - __s3c44b0x_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm920.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm920.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm920.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm920.S	2005-11-09 18:32:07.000000000 +0900
@@ -3,6 +3,8 @@
  *
  *  Copyright (C) 1999,2000 ARM Limited
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -97,7 +99,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f			@ ............wcam
 	bic	ip, ip, #0x1100			@ ...i...s........
@@ -317,6 +321,7 @@
  */
 	.align	5
 ENTRY(cpu_arm920_switch_mm)
+#ifdef CONFIG_MMU
 	mov	ip, #0
 #ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
 	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
@@ -337,8 +342,10 @@
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mov	pc, lr
 
+#ifdef CONFIG_MMU
 /*
  * cpu_arm920_set_pte(ptep, pte)
  *
@@ -373,7 +380,7 @@
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
-
+#endif /* CONFIG_MMU */
 	__INIT
 
 	.type	__arm920_setup, #function
@@ -381,7 +388,9 @@
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
+#endif
 	mrc	p15, 0, r0, c1, c0		@ get control register v4
 	ldr	r5, arm920_cr1_clear
 	bic	r0, r0, r5
@@ -401,7 +410,11 @@
 arm920_cr1_clear:
 	.word	0x3f3f
 arm920_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x3135
+#else
+	.word	0x3134
+#endif
 
 	__INITDATA
 
@@ -418,7 +431,9 @@
 	.word   cpu_arm920_do_idle
 	.word	cpu_arm920_dcache_clean_area
 	.word	cpu_arm920_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_arm920_set_pte
+#endif
 	.size	arm920_processor_functions, . - arm920_processor_functions
 
 	.section ".rodata"
@@ -458,20 +473,24 @@
 __arm920_proc_info:
 	.long	0x41009200
 	.long	0xff00fff0
+#ifdef CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__arm920_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
 	.long	cpu_arm920_name
 	.long	arm920_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wbi_tlb_fns
 	.long	v4wb_user_fns
+#endif
 #ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
 	.long	arm920_cache_fns
 #else
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm922.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm922.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm922.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm922.S	2005-11-09 18:33:06.000000000 +0900
@@ -4,6 +4,8 @@
  *  Copyright (C) 1999,2000 ARM Limited
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
  *  Copyright (C) 2001 Altera Corporation
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -99,7 +101,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f			@ ............wcam
 	bic	ip, ip, #0x1100			@ ...i...s........
@@ -321,6 +325,7 @@
  */
 	.align	5
 ENTRY(cpu_arm922_switch_mm)
+#ifdef CONFIG_MMU
 	mov	ip, #0
 #ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
 	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
@@ -341,8 +346,10 @@
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mov	pc, lr
 
+#ifdef CONFIG_MMU
 /*
  * cpu_arm922_set_pte(ptep, pte)
  *
@@ -377,7 +384,7 @@
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
-
+#endif /* CONFIG_MMU */
 	__INIT
 
 	.type	__arm922_setup, #function
@@ -385,7 +392,9 @@
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
+#endif
 	mrc	p15, 0, r0, c1, c0		@ get control register v4
 	ldr	r5, arm922_cr1_clear
 	bic	r0, r0, r5
@@ -405,8 +414,11 @@
 arm922_cr1_clear:
 	.word	0x3f3f
 arm922_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x3135
-
+#else
+	.word	0x3134
+#endif
 	__INITDATA
 
 /*
@@ -422,7 +434,9 @@
 	.word   cpu_arm922_do_idle
 	.word	cpu_arm922_dcache_clean_area
 	.word	cpu_arm922_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_arm922_set_pte
+#endif
 	.size	arm922_processor_functions, . - arm922_processor_functions
 
 	.section ".rodata"
@@ -462,20 +476,24 @@
 __arm922_proc_info:
 	.long	0x41009220
 	.long	0xff00fff0
+#if CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__arm922_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
 	.long	cpu_arm922_name
 	.long	arm922_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wbi_tlb_fns
 	.long	v4wb_user_fns
+#endif
 #ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
 	.long	arm922_cache_fns
 #else
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm925.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm925.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm925.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm925.S	2005-11-09 18:36:18.000000000 +0900
@@ -5,6 +5,8 @@
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
  *  Copyright (C) 2002 RidgeRun, Inc.
  *  Copyright (C) 2002-2003 MontaVista Software, Inc.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  *  Update for Linux-2.6 and cache flush improvements
  *  Copyright (C) 2004 Nokia Corporation by Tony Lindgren <tony@atomide.com>
@@ -122,7 +124,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f			@ ............wcam
 	bic	ip, ip, #0x1100			@ ...i...s........
@@ -369,6 +373,7 @@
  */
 	.align	5
 ENTRY(cpu_arm925_switch_mm)
+#ifdef CONFIG_MMU
 	mov	ip, #0
 #ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
 	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
@@ -383,8 +388,10 @@
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mov	pc, lr
 
+#ifdef CONFIG_MMU
 /*
  * cpu_arm925_set_pte(ptep, pte)
  *
@@ -421,7 +428,7 @@
 #endif
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
-
+#endif /* CONFIG_MMU */
 	__INIT
 
 	.type	__arm925_setup, #function
@@ -438,7 +445,9 @@
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
+#endif
 
 #ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
 	mov	r0, #4				@ disable write-back on caches explicitly
@@ -467,7 +476,11 @@
 arm925_cr1_clear:
 	.word	0x7f3f
 arm925_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x313d
+#else
+	.word	0x313c
+#endif
 
 	__INITDATA
 
@@ -484,7 +497,9 @@
 	.word   cpu_arm925_do_idle
 	.word	cpu_arm925_dcache_clean_area
 	.word	cpu_arm925_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_arm925_set_pte
+#endif
 	.size	arm925_processor_functions, . - arm925_processor_functions
 
 	.section ".rodata"
@@ -527,18 +542,22 @@
 __arm925_proc_info:
 	.long	0x54029250
 	.long	0xfffffff0
+#if CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__arm925_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
 	.long	cpu_arm925_name
 	.long	arm925_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wbi_tlb_fns
 	.long	v4wb_user_fns
+#endif
 	.long	arm925_cache_fns
 	.size	__arm925_proc_info, . - __arm925_proc_info
 
@@ -546,17 +565,21 @@
 __arm915_proc_info:
 	.long	0x54029150
 	.long	0xfffffff0
+#if CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__arm925_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
 	.long	cpu_arm925_name
 	.long	arm925_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wbi_tlb_fns
 	.long	v4wb_user_fns
+#endif
 	.long	arm925_cache_fns
 	.size	__arm925_proc_info, . - __arm925_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm926.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm926.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm926.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm926.S	2005-11-09 16:07:03.000000000 +0900
@@ -3,6 +3,8 @@
  *
  *  Copyright (C) 1999-2001 ARM Limited
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -85,7 +87,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f			@ ............wcam
 	bic	ip, ip, #0x1100			@ ...i...s........
@@ -329,6 +333,7 @@
  */
 	.align	5
 ENTRY(cpu_arm926_switch_mm)
+#ifdef CONFIG_MMU
 	mov	ip, #0
 #ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
 	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
@@ -341,8 +346,10 @@
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mov	pc, lr
 
+#ifdef CONFIG_MMU
 /*
  * cpu_arm926_set_pte(ptep, pte)
  *
@@ -379,7 +386,7 @@
 #endif
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
-
+#endif
 	__INIT
 
 	.type	__arm926_setup, #function
@@ -387,7 +394,9 @@
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
+#endif
 
 
 #ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
@@ -417,7 +426,11 @@
 arm926_cr1_clear:
 	.word	0x7f3f
 arm926_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x3135
+#else
+	.word	0x3134
+#endif
 
 	__INITDATA
 
@@ -434,7 +447,9 @@
 	.word	cpu_arm926_do_idle
 	.word	cpu_arm926_dcache_clean_area
 	.word	cpu_arm926_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_arm926_set_pte
+#endif
 	.size	arm926_processor_functions, . - arm926_processor_functions
 
 	.section ".rodata"
@@ -477,19 +492,23 @@
 __arm926_proc_info:
 	.long	0x41069260			@ ARM926EJ-S (v5TEJ)
 	.long	0xff0ffff0
+#if CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__arm926_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP|HWCAP_HALF|HWCAP_THUMB|HWCAP_FAST_MULT|HWCAP_EDSP|HWCAP_JAVA
 	.long	cpu_arm926_name
 	.long	arm926_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wbi_tlb_fns
 	.long	v4wb_user_fns
+#endif
 	.long	arm926_cache_fns
 	.size	__arm926_proc_info, . - __arm926_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm940.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm940.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm940.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm940.S	2005-11-08 08:48:12.000000000 +0900
@@ -0,0 +1,215 @@
+/*
+ *  linux/arch/armnommu/mm/arm940.S: MPU functions for ARM940
+ *  2001 Minspeed
+ * 
+ *  2004/03/22  modified for 2.6 kernel by heechul.yun@samsung.com 
+ *  2004/04/20  clean-up by Hyok S. Choi
+ */
+	
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>	
+#include <asm/assembler.h>
+#include <asm/pgtable.h>	
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>	
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+	/* FIXME - this is also defined in cache-v4wb.S */ 
+#define CACHE_DSIZE	4096	/* 4K */
+#define CACHE_DLINESIZE	16	/* 4word */
+#define CACHE_DLIMIT	(CACHE_DSIZE * 4)
+
+/*
+ * cpu_arm940_data_abort()
+ *
+ * obtain information about current aborted instruction
+ *
+ * r0 = address of aborted instruction
+ *
+ * Returns:
+ *  r0 = address of abort
+ *  r1 != 0 if writing
+ *  r3 = FSR
+ */
+	.align	5
+ENTRY(cpu_arm940_data_abort)
+	mrc	p15, 0, r3, c5, c0, 0		@ get FSR
+	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
+	ldr	r1, [r0]			@ read aborted instruction
+	tst	r1, r1, lsr #21			@ C = bit 20
+	sbc	r1, r1, r1			@ r1 = C - 1
+	and	r3, r3, #255
+	mov	pc, lr
+
+/*
+ * cpu_arm940_check_bugs()
+ */
+ENTRY(cpu_arm940_check_bugs)
+	mrs	ip, cpsr
+	bic	ip, ip, #PSR_F_BIT
+	msr	cpsr, ip
+	mov	pc, lr
+
+/*
+ * cpu_arm940_proc_init()
+ *	
+ *  setup_processor()  - setup.c
+ *  +-> cpu_proc_init() - cpu-multi32.h --> proc-arm940.S
+ *	
+ *  TODO: cp15 initialization code can be placed here - hcyun 
+ */
+ENTRY(cpu_arm940_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm940_proc_fin()
+ */
+ENTRY(cpu_arm940_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+#if defined(CONFIG_CPU_CACHE_V4WT)
+	bl	v4wt_flush_kern_cache_all	@ write-through
+#elif defined(CONFIG_CPU_CACHE_V4WB)
+	bl	v4wb_flush_kern_cache_all	@ write-back
+#endif /* CONFIG_CPU_CACHE_V4WT */
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm940_reset(loc)
+ *
+ * Perform a soft reset of the system.  Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+ENTRY(cpu_arm940_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f			@ ............wcam
+	bic	ip, ip, #0x1100			@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * idle mode processing 
+ */
+ENTRY(cpu_arm940_do_idle)  
+#if defined(CONFIG_CPU_ARM940_CPU_IDLE)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+#endif
+	mov	pc, lr
+
+/* 
+ * *FIXME* 
+ */ 	
+ENTRY(cpu_arm940_dcache_clean_area)
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+	mov	pc, lr
+/*
+ * Function: arm940_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, 
+ */	
+ENTRY(cpu_arm940_switch_mm)
+	mov	pc, lr	
+
+	
+	/* .section ".text.init", #alloc, #execinstr */ 
+	__INIT
+	
+__arm940_setup:
+	MRC     p15, 0, R0, c1, c0, 0		@ get control register
+		
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+	bic	r0, r0, #0x0e00			@ ....??r.........
+	bic	r0, r0, #0x0002			@ ..............a.
+	bic	r0, r0, #0x000c			@ W,D
+	bic	r0, r0, #0x1000			@ I
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	orr	r0, r0, #0x0001			@ Enable PU
+#else
+	bic	r0, r0, #0x0001			@ Disable PU
+#endif
+
+#ifdef CONFIG_CPU_ARM940_D_CACHE_ON
+	orr	r0, r0, #0x0004			@ Enable D cache
+#endif
+#ifdef CONFIG_CPU_ARM940_I_CACHE_ON
+	orr	r0, r0, #0x1000                 @ I Cache on
+#endif
+	mov	pc, lr
+	.size	__arm940_setup, . - __arm940_setup	
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm940_processor_functions, #object
+ENTRY(arm940_processor_functions)
+	.word	cpu_arm940_data_abort
+	.word	cpu_arm940_proc_init
+	.word	cpu_arm940_proc_fin
+	.word	cpu_arm940_reset
+	.word   cpu_arm940_do_idle
+
+	.word	cpu_arm940_dcache_clean_area
+	.word	cpu_arm940_switch_mm
+	.size	arm940_processor_functions, . - arm940_processor_functions
+
+	.section ".rodata"	
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv4t"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v4"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm940_name, #object
+cpu_arm940_name:
+	.ascii	"ARM940T"
+	.size	cpu_arm940_name, . - cpu_arm940_name
+
+	.align
+
+
+	.section ".proc.info", #alloc, #execinstr
+	.type	__arm940_proc_info,#object
+__arm940_proc_info:
+	.long	0x41009400
+	.long	0xff00fff0
+	b	__arm940_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT
+	.long	cpu_arm940_name  
+	.long	arm940_processor_functions 
+#if defined(CONFIG_CPU_CACHE_V4WT)
+	.long	v4wt_cache_fns			@ cache model
+#elif defined(CONFIG_CPU_CACHE_V4WB)
+	.long	v4wb_cache_fns			@ cache model
+#endif /* CONFIG_CPU_CACHE_V4WT */
+	.size	__arm940_proc_info, . - __arm940_proc_info
+
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm946.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm946.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm946.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm946.S	2005-11-08 08:48:12.000000000 +0900
@@ -0,0 +1,212 @@
+/*
+ *  linux/arch/armnommu/mm/arm946.S: MPU functions for ARM946E-S
+ * 
+ *  Copyright 2003, STMicroelectronics
+ *  Copyright 2004, Hyok S. Choi, for 2.6.
+ *
+ */
+	
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>	
+#include <asm/assembler.h>
+#include <asm/pgtable.h>	
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>	
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+
+	/* FIXME - this is also defined in cache-v4wb.S */ 
+#define CACHE_DSIZE	4096	/* 4K */
+#define CACHE_DLINESIZE	32	/* 8word */
+#define CACHE_DLIMIT	(CACHE_DSIZE * 4)
+
+/*
+ * cpu_arm946_data_abort()
+ *
+ * obtain information about current aborted instruction
+ *
+ * r0 = address of aborted instruction
+ *
+ * Returns:
+ *  r0 = address of abort
+ *  r1 != 0 if writing
+ *  r3 = FSR
+ */
+	.align	5
+ENTRY(cpu_arm946_data_abort)
+	mrc	p15, 0, r3, c5, c0, 0		@ get FSR
+	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
+	ldr	r1, [r0]			@ read aborted instruction
+	tst	r1, r1, lsr #21			@ C = bit 20
+	sbc	r1, r1, r1			@ r1 = C - 1
+	and	r3, r3, #255
+	mov	pc, lr
+
+/*
+ * cpu_arm946_check_bugs()
+ */
+ENTRY(cpu_arm946_check_bugs)
+	mrs	ip, cpsr
+	bic	ip, ip, #PSR_F_BIT
+	msr	cpsr, ip
+	mov	pc, lr
+
+/*
+ * cpu_arm946_proc_init()
+ */
+ENTRY(cpu_arm946_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm946_proc_fin()
+ */
+ENTRY(cpu_arm946_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+#if defined(CONFIG_CPU_CACHE_V4WT)
+	bl	v4wt_flush_kern_cache_all	@ write-through
+#elif defined(CONFIG_CPU_CACHE_V4WB)
+	bl	v4wb_flush_kern_cache_all	@ write-back
+#endif /* CONFIG_CPU_CACHE_V4WT */
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm946_reset(loc)
+ *
+ * Perform a soft reset of the system.  Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+ENTRY(cpu_arm946_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f			@ ............wcam
+	bic	ip, ip, #0x1100			@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * idle mode processing 
+ */
+ENTRY(cpu_arm946_do_idle)  
+#if defined(CONFIG_CPU_ARM946_CPU_IDLE)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+#endif
+	mov	pc, lr
+
+/* 
+ * *FIXME* 
+ */ 	
+ENTRY(cpu_arm946_dcache_clean_area)
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+	mov	pc, lr
+/*
+ * Function: arm946_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, 
+ */	
+ENTRY(cpu_arm946_switch_mm)
+	mov	pc, lr	
+
+	
+	/* .section ".text.init", #alloc, #execinstr */ 
+	__INIT
+	
+__arm946_setup:
+	MRC     p15, 0, R0, c1, c0, 0		@ get control register
+		
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+	bic	r0, r0, #0x0e00			@ ....??r.........
+	bic	r0, r0, #0x0002			@ ..............a.
+	bic	r0, r0, #0x000c			@ W,D
+	bic	r0, r0, #0x1000			@ I
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	orr	r0, r0, #0x0001			@ Enable PU
+#else
+	bic	r0, r0, #0x0001			@ Disable PU
+#endif
+
+#ifdef CONFIG_CPU_ARM940_D_CACHE_ON
+	orr	r0, r0, #0x0004			@ Enable D cache
+#endif
+#ifdef CONFIG_CPU_ARM940_I_CACHE_ON
+	orr	r0, r0, #0x1000                 @ I Cache on
+#endif
+	mov	pc, lr
+	.size	__arm946_setup, . - __arm946_setup	
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm946_processor_functions, #object
+ENTRY(arm946_processor_functions)
+	.word	cpu_arm946_data_abort
+	.word	cpu_arm946_proc_init
+	.word	cpu_arm946_proc_fin
+	.word	cpu_arm946_reset
+	.word   cpu_arm946_do_idle
+
+	.word	cpu_arm946_dcache_clean_area
+	.word	cpu_arm946_switch_mm
+	.size	arm946_processor_functions, . - arm946_processor_functions
+
+	.section ".rodata"	
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv5"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v5"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm946_name, #object
+cpu_arm946_name:
+	.ascii	"ARM946E"
+	.size	cpu_arm946_name, . - cpu_arm946_name
+
+	.align
+
+
+	.section ".proc.info", #alloc, #execinstr
+	.type	__arm946_proc_info,#object
+__arm946_proc_info:
+	.long	0x41009460
+	.long	0xff00fff0
+	b	__arm946_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT
+	.long	cpu_arm946_name  
+	.long	arm946_processor_functions 
+#if defined(CONFIG_CPU_CACHE_V4WT)
+	.long	v4wt_cache_fns			@ cache model
+#elif defined(CONFIG_CPU_CACHE_V4WB)
+	.long	v4wb_cache_fns			@ cache model
+#endif /* CONFIG_CPU_CACHE_V4WT */
+	.size	__arm946_proc_info, . - __arm946_proc_info
+
+
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-arm9tdmi.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm9tdmi.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-arm9tdmi.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-arm9tdmi.S	2005-11-08 08:48:13.000000000 +0900
@@ -0,0 +1,255 @@
+/*
+ *  linux/arch/arm/mm/proc-arm9tdmi.S
+ *
+ *  Copyright (C) 1997-2000 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  Copyright (C) 2004-2005 Tobias Lorenz <tobias.lorenz@gmx.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  for ARM9TDMI and the compatibles.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/errno.h>
+
+ENTRY(cpu_arm9tdmi_dcache_clean_area)
+		mov	pc, lr
+
+/*
+ * Function: arm9tdmi_data_abort ()
+ *
+ * Params  : r2 = address of aborted instruction
+ *	   : sp = pointer to registers
+ *
+ * Purpose : obtain information about current aborted instruction
+ *
+ * Returns : r0 = address of abort
+ *	   : r1 = FSR
+ */
+
+ENTRY(cpu_arm9tdmi_data_abort)
+	ldr	r8, [r0]			@ read arm instruction
+	tst	r8, #1 << 20			@ L = 1 -> write?
+	orreq	r1, r1, #1 << 8			@ yes.
+	and	r7, r8, #15 << 24
+	add	pc, pc, r7, lsr #22		@ Now branch to the relevant processing routine
+	nop
+
+/* 0 */	b	.data_unknown
+/* 1 */	mov	pc, lr				@ swp
+/* 2 */	b	.data_unknown
+/* 3 */	b	.data_unknown
+/* 4 */	b	.data_arm_lateldrpostconst	@ ldr	rd, [rn], #m
+/* 5 */	b	.data_arm_lateldrpreconst	@ ldr	rd, [rn, #m]
+/* 6 */	b	.data_arm_lateldrpostreg	@ ldr	rd, [rn], rm
+/* 7 */	b	.data_arm_lateldrprereg		@ ldr	rd, [rn, rm]
+/* 8 */	b	.data_arm_ldmstm		@ ldm*a	rn, <rlist>
+/* 9 */	b	.data_arm_ldmstm		@ ldm*b	rn, <rlist>
+/* a */	b	.data_unknown
+/* b */	b	.data_unknown
+/* c */	mov	pc, lr				@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
+/* d */	mov	pc, lr				@ ldc	rd, [rn, #m]
+/* e */	b	.data_unknown
+/* f */
+.data_unknown:	@ Part of jumptable
+	mov	r0, r2
+	mov	r1, r8
+	mov	r2, sp
+	bl	baddataabort
+	b	ret_from_exception
+
+.data_arm_ldmstm:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+	mov	r7, #0x11
+	orr	r7, r7, #0x1100
+	and	r6, r8, r7
+	and	r2, r8, r7, lsl #1
+	add	r6, r6, r2, lsr #1
+	and	r2, r8, r7, lsl #2
+	add	r6, r6, r2, lsr #2
+	and	r2, r8, r7, lsl #3
+	add	r6, r6, r2, lsr #3
+	add	r6, r6, r6, lsr #8
+	add	r6, r6, r6, lsr #4
+	and	r6, r6, #15			@ r6 = no. of registers to transfer.
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6, lsl #2		@ Undo increment
+	addeq	r7, r7, r6, lsl #2		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_apply_r6_and_rn:
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6			@ Undo incrmenet
+	addeq	r7, r7, r6			@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrpreconst:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostconst:
+	movs	r2, r8, lsl #20			@ Get offset
+	moveq	pc, lr				@ zero -> no fixup
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r2, lsr #20		@ Undo increment
+	addeq	r7, r7, r2, lsr #20		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrprereg:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostreg:
+	and	r7, r8, #15			@ Extract 'm' from instruction
+	ldr	r6, [sp, r7, lsl #2]		@ Get register 'Rm'
+	mov	r5, r8, lsr #7			@ get shift count
+	ands	r5, r5, #31
+	and	r7, r8, #0x70			@ get shift type
+	orreq	r7, r7, #8			@ shift count = 0
+	add	pc, pc, r7
+	nop
+
+	mov	r6, r6, lsl r5			@ 0: LSL #!0
+	b	.data_arm_apply_r6_and_rn
+	b	.data_arm_apply_r6_and_rn	@ 1: LSL #0
+	nop
+	b	.data_unknown			@ 2: MUL?
+	nop
+	b	.data_unknown			@ 3: MUL?
+	nop
+	mov	r6, r6, lsr r5			@ 4: LSR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, lsr #32			@ 5: LSR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ 6: MUL?
+	nop
+	b	.data_unknown			@ 7: MUL?
+	nop
+	mov	r6, r6, asr r5			@ 8: ASR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, asr #32			@ 9: ASR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ A: MUL?
+	nop
+	b	.data_unknown			@ B: MUL?
+	nop
+	mov	r6, r6, ror r5			@ C: ROR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, rrx			@ D: RRX
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ E: MUL?
+	nop
+	b	.data_unknown			@ F: MUL?
+
+/*
+ * Function: arm9tdmi_proc_init (void)
+ *	   : arm9tdmi_proc_fin (void)
+ *
+ * Notes   : This processor does not require these
+ */
+ENTRY(cpu_arm9tdmi_proc_init)
+		mov	pc, lr
+
+ENTRY(cpu_arm9tdmi_proc_fin)
+		mov	r0, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+		msr	cpsr_c, r0
+		mov	pc, lr
+
+ENTRY(cpu_arm9tdmi_do_idle)
+		mov	pc, lr
+
+/*
+ * Function: arm9tdmi_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, saving the old processes state, and restoring
+ *	     the new.
+ */
+ENTRY(cpu_arm9tdmi_switch_mm)
+		mov	pc, lr
+
+/*
+ * Function: _arm9tdmi_reset
+ * Params  : r0 = address to jump to
+ * Notes   : This sets up everything for a reset
+ */
+ENTRY(cpu_arm9tdmi_reset)
+		mov	pc, r0
+
+		__INIT
+
+		.type	__arm9tdmi_setup, #function
+__arm9tdmi_setup:
+		mov	r0, #0x7c			@ . .... .LDP WC..
+		mov	pc, lr
+		.size	__arm9tdmi_setup, . - __arm9tdmi_setup
+
+		__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+		.type	arm9tdmi_processor_functions, #object
+ENTRY(arm9tdmi_processor_functions)
+		.word	cpu_arm9tdmi_data_abort
+		.word	cpu_arm9tdmi_proc_init
+		.word	cpu_arm9tdmi_proc_fin
+		.word	cpu_arm9tdmi_reset
+		.word	cpu_arm9tdmi_do_idle
+		.word	cpu_arm9tdmi_dcache_clean_area
+		.word	cpu_arm9tdmi_switch_mm
+		.size	arm9tdmi_processor_functions, . - arm9tdmi_processor_functions
+
+		.section ".rodata"
+
+		.type	cpu_arch_name, #object
+cpu_arch_name:	.asciz	"armv4t"
+		.size	cpu_arch_name, . - cpu_arch_name
+
+		.type	cpu_elf_name, #object
+cpu_elf_name:	.asciz	"v4"
+		.size	cpu_elf_name, . - cpu_elf_name
+
+		.type	cpu_arm9tdmi_name, #object
+cpu_arm9tdmi_name:
+		.asciz	"ARM9TDMI"
+		.size	cpu_arm9tdmi_name, . - cpu_arm9tdmi_name
+
+		.type	cpu_p2001_name, #object
+cpu_p2001_name:
+		.asciz	"P2001"
+		.size	cpu_p2001_name, . - cpu_p2001_name
+
+		.align
+
+		.section ".proc.info", #alloc, #execinstr
+
+		.type	__p2001_proc_info, #object
+__p2001_proc_info:
+		.long	0x41029000
+		.long	0xffffffff
+		.long	0x00000c1e
+		b	__arm9tdmi_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_THUMB | HWCAP_26BIT
+		.long	cpu_p2001_name
+		.long	arm9tdmi_processor_functions
+		.long	v4_cache_fns
+		.size	__p2001_proc_info, . - __p2001_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-s3c4510b.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-s3c4510b.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-s3c4510b.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-s3c4510b.S	2005-11-08 08:48:12.000000000 +0900
@@ -0,0 +1,383 @@
+/*
+ *  linux/arch/armnommu/mm/proc-s3c4510b.S
+ *
+ *  Copyright (C) 1997-2000 Russell King
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *  Modified for s3c4510b cache
+ *  Copyright (c) 2005 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/errno.h>
+#include <asm/hardware.h>
+	
+/*
+ *	flush_user_cache_all()
+ *
+ *	Invalidate all cache entries in a particular address
+ *	space.
+ *
+ *	- mm	- mm_struct describing address space
+ */
+ENTRY(s3c4510b_flush_user_cache_all)
+	/* FALLTHROUGH */
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(s3c4510b_flush_kern_cache_all)
+	/* FALLTHROUGH */
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Invalidate a range of cache entries in the specified
+ *	address space.
+ *
+ *	- start - start address (may not be aligned)
+ *	- end	- end address (exclusive, may not be aligned)
+ *	- flags	- vma_area_struct flags describing address space
+ */
+ENTRY(s3c4510b_flush_user_cache_range)
+	stmfd	sp!, {r5-r8, lr}
+	/* save current cache state */
+	ldr	r7, =REG_SYSCFG
+	ldr     r8, [r7]
+	/* disable cache */
+        ldr	r6, =0x83ffffa0
+	str	r6, [r7]
+	/* zero out the 1KB TAG RAM area starting @ 0x11000000 */
+	ldr	r7, =0x11000000
+	ldr     r6, =(0x11000000 + 1024)
+	ldr	r5, =0x0
+tag_zero:		
+	str     r5, [r7]
+	add     r7, r7, #4
+	cmp	r6, r7
+	bne     tag_zero
+	
+	/* restore previoux cache state */
+	ldr	r7, =REG_SYSCFG
+	str	r8, [r7]
+
+	ldmfd	sp!, {r5-r8, pc}
+	
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(s3c4510b_coherent_kern_range)
+	/* FALLTHROUGH */
+
+                                                                                                                                           
+/*
+ *      coherent_user_range(start, end)
+ *
+ *      Ensure coherency between the Icache and the Dcache in the
+ *      region described by start, end.  If you have non-snooping
+ *      Harvard caches, you need to implement this function.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ */
+ENTRY(s3c4510b_coherent_user_range)
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- addr	- page aligned address
+ */
+ENTRY(s3c4510b_flush_kern_dcache_page)
+	/* FALLTHROUGH */
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(s3c4510b_dma_inv_range)
+	/* FALLTHROUGH */
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(s3c4510b_dma_flush_range)
+	/* FALLTHROUGH */
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean (write back) the specified virtual address range.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(s3c4510b_dma_clean_range)
+	/* FALLTHROUGH */
+
+ENTRY(cpu_s3c4510b_dcache_clean_area)
+	mov	pc, lr  
+
+/*
+ * Function: cpu_s3c4510b_data_abort ()
+ *
+ * Params  : r2 = address of aborted instruction
+ *	   : sp = pointer to registers
+ *
+ * Purpose : obtain information about current aborted instruction
+ *
+ * Returns : r0 = address of abort
+ *	   : r1 = FSR
+ */
+
+ENTRY(cpu_s3c4510b_data_abort)
+@FIXME
+	ldr     r8, [r2]                        @ read arm instruction
+	tst     r8, #1 << 20                    @ L = 1 -> write?
+	and	r7, r8, #15 << 24
+	orr	r1, r7, #1
+	orreq   r1, r1, #1 << 8                 @ yes.
+	add	pc, pc, r7, lsr #22		@ Now branch to the relevant processing routine
+	nop
+
+/* 0 */	b	.data_unknown
+/* 1 */	mov	pc, lr				@ swp
+/* 2 */	b	.data_unknown
+/* 3 */	b	.data_unknown
+/* 4 */	b	.data_arm_lateldrpostconst	@ ldr	rd, [rn], #m
+/* 5 */	b	.data_arm_lateldrpreconst	@ ldr	rd, [rn, #m]
+/* 6 */	b	.data_arm_lateldrpostreg	@ ldr	rd, [rn], rm
+/* 7 */	b	.data_arm_lateldrprereg		@ ldr	rd, [rn, rm]
+/* 8 */	b	.data_arm_ldmstm		@ ldm*a	rn, <rlist>
+/* 9 */	b	.data_arm_ldmstm		@ ldm*b	rn, <rlist>
+/* a */	b	.data_unknown
+/* b */	b	.data_unknown
+/* c */	mov	pc, lr				@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
+/* d */	mov	pc, lr				@ ldc	rd, [rn, #m]
+/* e */	b	.data_unknown
+/* f */
+.data_unknown:	@ Part of jumptable
+	mov	r0, r2
+	mov	r1, r8
+	mov	r2, sp
+	bl	baddataabort
+	b	ret_from_exception
+
+.data_arm_ldmstm:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+	mov	r7, #0x11
+	orr	r7, r7, #0x1100
+	and	r6, r8, r7
+	and	r2, r8, r7, lsl #1
+	add	r6, r6, r2, lsr #1
+	and	r2, r8, r7, lsl #2
+	add	r6, r6, r2, lsr #2
+	and	r2, r8, r7, lsl #3
+	add	r6, r6, r2, lsr #3
+	add	r6, r6, r6, lsr #8
+	add	r6, r6, r6, lsr #4
+	and	r6, r6, #15			@ r6 = no. of registers to transfer.
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6, lsl #2		@ Undo increment
+	addeq	r7, r7, r6, lsl #2		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_apply_r6_and_rn:
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6			@ Undo incrmenet
+	addeq	r7, r7, r6			@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrpreconst:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostconst:
+	movs	r2, r8, lsl #20			@ Get offset
+	moveq	pc, lr				@ zero -> no fixup
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r2, lsr #20		@ Undo increment
+	addeq	r7, r7, r2, lsr #20		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrprereg:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostreg:
+	and	r7, r8, #15			@ Extract 'm' from instruction
+	ldr	r6, [sp, r7, lsl #2]		@ Get register 'Rm'
+	mov	r5, r8, lsr #7			@ get shift count
+	ands	r5, r5, #31
+	and	r7, r8, #0x70			@ get shift type
+	orreq	r7, r7, #8			@ shift count = 0
+	add	pc, pc, r7
+	nop
+
+	mov	r6, r6, lsl r5			@ 0: LSL #!0
+	b	.data_arm_apply_r6_and_rn
+	b	.data_arm_apply_r6_and_rn	@ 1: LSL #0
+	nop
+	b	.data_unknown			@ 2: MUL?
+	nop
+	b	.data_unknown			@ 3: MUL?
+	nop
+	mov	r6, r6, lsr r5			@ 4: LSR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, lsr #32			@ 5: LSR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ 6: MUL?
+	nop
+	b	.data_unknown			@ 7: MUL?
+	nop
+	mov	r6, r6, asr r5			@ 8: ASR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, asr #32			@ 9: ASR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ A: MUL?
+	nop
+	b	.data_unknown			@ B: MUL?
+	nop
+	mov	r6, r6, ror r5			@ C: ROR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, rrx			@ D: RRX
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ E: MUL?
+	nop
+	b	.data_unknown			@ F: MUL?
+
+
+ENTRY(cpu_s3c4510b_proc_init)
+		mov	pc, lr
+
+ENTRY(cpu_s3c4510b_proc_fin)
+		mov	r0, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+		msr	cpsr_c, r0
+		mov     r0, #0
+		mov	pc, lr
+
+ENTRY(cpu_s3c4510b_do_idle)
+		mov	r0, #-EINVAL
+		mov	pc, lr
+
+ENTRY(cpu_s3c4510b_switch_mm)
+		mov	pc, lr
+
+ENTRY(cpu_s3c4510b_reset)
+		mov	r1, #0
+		mov	pc, r0
+
+
+		__INIT
+
+		.type	__s3c4510b_setup, #function
+__s3c4510b_setup:
+		mov	r0, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+		msr	cpsr_c, r0
+		mov	r0, #0
+		mov	pc, lr
+		.size	__s3c4510b_setup, . - __s3c4510b_setup
+	
+		__INITDATA
+
+		.type	s3c4510b_cache_fns, #object
+ENTRY(s3c4510b_cache_fns)
+		.long	s3c4510b_flush_kern_cache_all
+		.long	s3c4510b_flush_user_cache_all
+		.long	s3c4510b_flush_user_cache_range
+		.long	s3c4510b_coherent_kern_range
+		.long	s3c4510b_coherent_user_range
+		.long	s3c4510b_flush_kern_dcache_page
+		.long	s3c4510b_dma_inv_range
+		.long	s3c4510b_dma_clean_range
+		.long	s3c4510b_dma_flush_range
+		.size	s3c4510b_cache_fns, . - s3c4510b_cache_fns
+	
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+		.type	s3c4510b_processor_functions, #object
+ENTRY(s3c4510b_processor_functions)
+		.word	cpu_s3c4510b_data_abort
+		.word	cpu_s3c4510b_proc_init
+		.word	cpu_s3c4510b_proc_fin
+		.word	cpu_s3c4510b_reset
+		.word	cpu_s3c4510b_do_idle
+		.word	cpu_s3c4510b_dcache_clean_area
+		.word	cpu_s3c4510b_switch_mm
+		.size	s3c4510b_processor_functions, . - s3c4510b_processor_functions
+
+		.section ".rodata"
+
+		.type	cpu_arch_name, #object
+cpu_arch_name:	.asciz	"armv4t"
+		.size	cpu_arch_name, . - cpu_arch_name
+
+		.type	cpu_elf_name, #object
+cpu_elf_name:	.asciz	"v4"
+		.size	cpu_elf_name, . - cpu_elf_name
+
+		.type	cpu_s3c4510b, #object
+cpu_s3c4510b_name:
+		.asciz	"Samsung-S3C4510B"
+		.size	cpu_s3c4510b_name, . - cpu_s3c4510b_name
+
+		.align
+
+		.section ".proc.info", #alloc, #execinstr
+
+		.type	__s3c4510b_proc_info, #object
+__s3c4510b_proc_info:
+		.long	0x36807000
+		.long	0xfffff000
+		b	__s3c4510b_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_s3c4510b_name
+		.long	s3c4510b_processor_functions
+		.long	s3c4510b_cache_fns
+		.size	__s3c4510b_proc_info, . - __s3c4510b_proc_info
+
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-sa1100.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-sa1100.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-sa1100.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-sa1100.S	2005-11-09 18:38:24.000000000 +0900
@@ -2,6 +2,8 @@
  *  linux/arch/arm/mm/proc-sa1100.S
  *
  *  Copyright (C) 1997-2002 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -101,7 +103,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f			@ ............wcam
 	bic	ip, ip, #0x1100			@ ...i...s........
@@ -166,6 +170,7 @@
  */
 	.align	5
 ENTRY(cpu_sa1100_switch_mm)
+#ifdef CONFIG_MMU
 	flush_1100_dcache r3, ip, r1
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c5, 0		@ invalidate I cache
@@ -173,8 +178,10 @@
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mov	pc, lr
 
+#ifdef CONFIG_MMU
 /*
  * cpu_sa1100_set_pte(ptep, pte)
  *
@@ -204,6 +211,7 @@
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
+#endif
 
 	__INIT
 
@@ -212,7 +220,9 @@
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7		@ invalidate I,D TLBs on v4
+#endif
 	mrc	p15, 0, r0, c1, c0		@ get control register v4
 	ldr	r5, sa1100_cr1_clear
 	bic	r0, r0, r5
@@ -232,7 +242,11 @@
 sa1100_cr1_clear:
 	.word	0x3f3f
 sa1100_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x313d
+#else
+	.word	0x313c
+#endif
 
 	__INITDATA
 
@@ -253,7 +267,9 @@
 	.word	cpu_sa1100_do_idle
 	.word	cpu_sa1100_dcache_clean_area
 	.word	cpu_sa1100_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_sa1100_set_pte
+#endif
 	.size	sa1100_processor_functions, . - sa1100_processor_functions
 
 	.section ".rodata"
@@ -286,19 +302,23 @@
 __sa1100_proc_info:
 	.long	0x4401a110
 	.long	0xfffffff0
+#if CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__sa1100_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT | HWCAP_FAST_MULT
 	.long	cpu_sa1100_name
 	.long	sa1100_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wb_tlb_fns
 	.long	v4_mc_user_fns
+#endif
 	.long	v4wb_cache_fns
 	.size	__sa1100_proc_info, . - __sa1100_proc_info
 
@@ -306,18 +326,22 @@
 __sa1110_proc_info:
 	.long	0x6901b110
 	.long	0xfffffff0
+#if CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__sa1100_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT | HWCAP_FAST_MULT
 	.long	cpu_sa1110_name
 	.long	sa1100_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wb_tlb_fns
 	.long	v4_mc_user_fns
+#endif
 	.long	v4wb_cache_fns
 	.size	__sa1110_proc_info, . - __sa1110_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-sa110.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-sa110.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-sa110.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-sa110.S	2005-11-09 18:37:21.000000000 +0900
@@ -2,6 +2,8 @@
  *  linux/arch/arm/mm/proc-sa110.S
  *
  *  Copyright (C) 1997-2002 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -81,7 +83,9 @@
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#ifdef CONFIG_MMU
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
 	bic	ip, ip, #0x000f			@ ............wcam
 	bic	ip, ip, #0x1100			@ ...i...s........
@@ -144,14 +148,17 @@
  */
 	.align	5
 ENTRY(cpu_sa110_switch_mm)
+#ifdef CONFIG_MMU
 	flush_110_dcache	r3, ip, r1
 	mov	r1, #0
 	mcr	p15, 0, r1, c7, c5, 0		@ invalidate I cache
 	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, r1, c8, c7, 0		@ invalidate I & D TLBs
+#endif
 	mov	pc, lr
 
+#ifdef CONFIG_MMU
 /*
  * cpu_sa110_set_pte(ptep, pte)
  *
@@ -181,6 +188,7 @@
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
+#endif
 
 	__INIT
 
@@ -189,7 +197,9 @@
 	mov	r10, #0
 	mcr	p15, 0, r10, c7, c7		@ invalidate I,D caches on v4
 	mcr	p15, 0, r10, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r10, c8, c7		@ invalidate I,D TLBs on v4
+#endif
 	mrc	p15, 0, r0, c1, c0		@ get control register v4
 	ldr	r5, sa110_cr1_clear
 	bic	r0, r0, r5
@@ -209,7 +219,11 @@
 sa110_cr1_clear:
 	.word	0x3f3f
 sa110_cr1_set:
+#if defined(CONFIG_MMU) || defined(CONFIG_CPU_MXU_ENABLE)
 	.word	0x113d
+#else
+	.word	0x113c
+#endif
 
 	__INITDATA
 
@@ -227,7 +241,9 @@
 	.word	cpu_sa110_do_idle
 	.word	cpu_sa110_dcache_clean_area
 	.word	cpu_sa110_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_sa110_set_pte
+#endif
 	.size	sa110_processor_functions, . - sa110_processor_functions
 
 	.section ".rodata"
@@ -255,18 +271,22 @@
 __sa110_proc_info:
 	.long	0x4401a100
 	.long	0xfffffff0
+#if CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__sa110_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT | HWCAP_FAST_MULT
 	.long	cpu_sa110_name
 	.long	sa110_processor_functions
+#ifdef CONFIG_MMU
 	.long	v4wb_tlb_fns
 	.long	v4wb_user_fns
+#endif
 	.long	v4wb_cache_fns
 	.size	__sa110_proc_info, . - __sa110_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-syms.c linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-syms.c
--- linux-2.6.14-uc0/arch/arm/mm/proc-syms.c	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-syms.c	2005-11-09 18:40:34.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/arch/arm/mm/proc-syms.c
  *
  *  Copyright (C) 2000-2002 Russell King
+ *  Modified by Hyok S. Choi, 2004
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,7 +17,9 @@
 
 #ifndef MULTI_CPU
 EXPORT_SYMBOL(cpu_dcache_clean_area);
+#ifdef CONFIG_MMU
 EXPORT_SYMBOL(cpu_set_pte);
+#endif
 #else
 EXPORT_SYMBOL(processor);
 #endif
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-v6.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-v6.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-v6.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-v6.S	2005-11-09 18:42:34.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/arch/arm/mm/proc-v6.S
  *
  *  Copyright (C) 2001 Deep Blue Solutions Ltd.
+ *  Modified by Catalin Marinas for noMMU support
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -110,14 +111,17 @@
  *	- we are not using split page tables
  */
 ENTRY(cpu_v6_switch_mm)
+#ifdef CONFIG_MMU
 	mov	r2, #0
 	ldr	r1, [r1, #MM_CONTEXT_ID]	@ get mm->context.id
 	mcr	p15, 0, r2, c7, c5, 6		@ flush BTAC/BTB
 	mcr	p15, 0, r2, c7, c10, 4		@ drain write buffer
 	mcr	p15, 0, r0, c2, c0, 0		@ set TTB 0
 	mcr	p15, 0, r1, c13, c0, 1		@ set context ID
+#endif
 	mov	pc, lr
 
+#ifdef CONFIG_MMU
 /*
  *	cpu_v6_set_pte(ptep, pte)
  *
@@ -165,6 +169,7 @@
 	str	r2, [r0]
 	mcr	p15, 0, r0, c7, c10, 1 @ flush_pte
 	mov	pc, lr
+#endif
 
 
 
@@ -196,9 +201,11 @@
 	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
 	mcr	p15, 0, r0, c7, c15, 0		@ clean+invalidate cache
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r0, c8, c7, 0		@ invalidate I + D TLBs
 	mcr	p15, 0, r0, c2, c0, 2		@ TTB control register
 	mcr	p15, 0, r4, c2, c0, 1		@ load TTB1
+#endif
 #ifdef CONFIG_VFP
 	mrc	p15, 0, r0, c1, c0, 2
 	orr	r0, r0, #(0xf << 20)
@@ -220,9 +227,17 @@
 	.type	v6_cr1_clear, #object
 	.type	v6_cr1_set, #object
 v6_cr1_clear:
+#ifdef CONFIG_MMU
 	.word	0x01e0fb7f
+#else
+	.word	0x01bae703
+#endif
 v6_cr1_set:
+#ifdef CONFIG_MMU
 	.word	0x00c0387d
+#else
+	.word	0x0045187c
+#endif
 
 	.type	v6_processor_functions, #object
 ENTRY(v6_processor_functions)
@@ -233,7 +248,9 @@
 	.word	cpu_v6_do_idle
 	.word	cpu_v6_dcache_clean_area
 	.word	cpu_v6_switch_mm
+#ifdef CONFIG_MMU
 	.word	cpu_v6_set_pte
+#endif
 	.size	v6_processor_functions, . - v6_processor_functions
 
 	.type	cpu_arch_name, #object
@@ -256,18 +273,22 @@
 __v6_proc_info:
 	.long	0x0007b000
 	.long	0x0007f000
+#ifdef CONFIG_MMU
 	.long   PMD_TYPE_SECT | \
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
+#endif
 	b	__v6_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP|HWCAP_HALF|HWCAP_THUMB|HWCAP_FAST_MULT|HWCAP_VFP|HWCAP_EDSP|HWCAP_JAVA
 	.long	cpu_v6_name
 	.long	v6_processor_functions
+#ifdef CONFIG_MMU
 	.long	v6wbi_tlb_fns
 	.long	v6_user_fns
+#endif
 	.long	v6_cache_fns
 	.size	__v6_proc_info, . - __v6_proc_info
diff -Naur linux-2.6.14-uc0/arch/arm/mm/proc-xscale.S linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-xscale.S
--- linux-2.6.14-uc0/arch/arm/mm/proc-xscale.S	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/arch/arm/mm/proc-xscale.S	2005-11-09 18:42:45.000000000 +0900
@@ -30,6 +30,9 @@
 #include <asm/ptrace.h>
 #include "proc-macros.S"
 
+#ifndef CONFIG_MMU
+#error "need to be revisited"
+#endif
 /*
  * This is the maximum size of an area which will be flushed.  If the area
  * is larger than this, then we flush the whole cache
diff -Naur linux-2.6.14-uc0/CREDITS linux-2.6.14-uc0-hsc0/CREDITS
--- linux-2.6.14-uc0/CREDITS	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/CREDITS	2005-11-10 09:47:17.000000000 +0900
@@ -608,6 +608,15 @@
 S: Stanford, California 94305
 S: USA
 
+N: Hyok S. Choi
+W: http://opensrc.sec.samsung.com/
+E: hyok.choi@samsung.com
+D: Author and Maintainer of uClinux/ARM port (MPU/noMMU)
+D: Author of DCC(JTAG1) serial console emulation driver
+S: Samsung Electronics Co.,Ltd.
+S: Suwon, Gyeonggi, 443-742
+S: South Korea
+
 N: Randolph Chung
 E: tausq@debian.org
 D: Linux/PA-RISC hacker
diff -Naur linux-2.6.14-uc0/drivers/serial/dcc.c linux-2.6.14-uc0-hsc0/drivers/serial/dcc.c
--- linux-2.6.14-uc0/drivers/serial/dcc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/drivers/serial/dcc.c	2005-11-08 14:24:16.000000000 +0900
@@ -0,0 +1,551 @@
+/*
+ *  linux/drivers/serial/dcc.c
+ *
+ *  serial port emulation driver for the JTAG DCC Terminal.
+ *
+ * DCC(JTAG1) protocol version for JTAG ICE/ICD Debuggers:
+ * 	Copyright (C) 2003, 2004, 2005 Hyok S. Choi (hyok.choi@samsung.com)
+ * 	SAMSUNG ELECTRONICS Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   Oct-2003 Hyok S. Choi	Created
+ *   Feb-2004 Hyok S. Choi 	Updated for serial_core.c and 2.6 kernel
+ *   Apr-2004 Hyok S. Choi 	xmit_string_CR added
+ *   Mar-2005 Hyok S. Choi	renamed from T32 to DCC
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/major.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <linux/serial_core.h>
+
+#if 0
+	/* real irq interrupt used */
+	#define DCC_IRQ_USED
+#else
+	/* scheduled work used */
+	#undef DCC_IRQ_USED
+#endif
+
+#ifndef  DCC_IRQ_USED
+static struct work_struct dcc_poll_task;
+static void dcc_poll(void *data);
+#endif
+
+#define UART_NR			1	/* we have only one JTAG port */
+
+#define SERIAL_DCC_NAME	"ttyJ"
+#define SERIAL_DCC_MAJOR	4
+#define SERIAL_DCC_MINOR	64
+
+static int __inline__ __check_JTAG_RX_FLAG(void)
+{
+	int __ret=0;
+	__asm__ __volatile__(
+		"	mrc		p14, 0, %0, c0, c0 	@ read comms control reg\n"
+		"	and		%0, %0, #1		@ jtag read buffer status"
+		: "=r" (__ret)
+		);
+
+	/* if   __ret 	== 0 : no input yet
+				== 1 : a character pending */
+	return __ret;	
+}
+
+static void __inline__ __get_JTAG_RX(volatile char *p)
+{
+	__asm__ __volatile__(
+		"	mrc		p14, 0, r3, c1, c0 	@ read comms data reg to r5\n"
+		"	strb 		r3, 	[%0]		@ str a char"
+		: /* no output */
+		: "r" (p)
+		: "r3",  "memory");
+}
+
+
+static int __inline__ __check_JTAG_TX_FLAG(void)
+{
+	int __ret=0;
+	__asm__ __volatile__(
+		"	mrc		p14, 0, %0, c0, c0 	@ read comms control reg\n"
+		"	and 		%0, %0, #2		@ the read buffer status"
+		: "=r" (__ret)
+		);
+
+	/* if   __ret 	== 0 : tx is available
+				== 2 : tx busy */
+	return __ret;	
+}
+
+void xmit_string(char *p, int len)
+{
+#ifndef CONFIG_JTAG_DCC_OUTPUT_DISABLE
+	/*
+		r0 = string	; string address
+		r1 = 2		; state check bit (write)
+		r4 = *string	; character
+		r7 = 0		; count
+	*/
+		__asm__ __volatile__(
+			"	mov r7, #0\n"
+			"1: 	mrc	p14, 0, r3, c0, c0 	@ read comms control reg\n"
+			"	and r3, r3, #2			@ the write buffer status\n"
+			"	cmp r3, #2			@ is it available?\n"
+			"	beq 1b				@ is not, wait till then\n"
+			"	ldrb r4, [%0]			@ load a char\n"
+			"	mcr p14, 0, r4, c1, c0		@ write it\n"
+			"	add %0, %0, #1			@ str address increase one\n"
+			"	add r7, r7, #1			@ count increase\n"
+			"	cmp r7, %1			@ compare with str length\n"
+			"	bne 1b				@ if it is not yet, loop"
+			: /* no output register */
+			: "r" (p), "r" (len)
+			: "r7", "r3", "r4");
+#endif
+}
+
+void xmit_string_CR(char *p, int len)
+{
+#ifndef CONFIG_JTAG_DCC_OUTPUT_DISABLE
+	/*
+		r0 = string	; string address
+		r1 = 2		; state check bit (write)
+		r4 = *string	; character
+		r7 = 0		; count
+	*/
+		__asm__ __volatile__(
+			"	mov r7, #0\n"
+			"	ldrb r4, [%0]			@ load a char\n"
+			"1: 	mrc	p14, 0, r3, c0, c0 	@ read comms control reg\n"
+			"	and r3, r3, #2			@ the write buffer status\n"
+			"	cmp r3, #2			@ is it available?\n"
+			"	beq 1b				@ is not, wait till then\n"
+			"	mcr p14, 0, r4, c1, c0		@ write it\n"
+			"	cmp r4, #0x0a			@ is it LF?\n"
+			"	bne 2f				@ if it is not, continue\n"
+			"	mov r4, #0x0d			@ set the CR\n"
+			"	b   1b				@ loop for writing CR\n"			
+			"2:	ldrb r4, [%0, #1]!		@ load a char\n"
+			"	add r7, r7, #1			@ count increase\n"
+			"	cmp r7, %1			@ compare with str length\n"
+			"	bne 1b				@ if it is not yet, loop"
+			: /* no output register */
+			: "r" (p), "r" (len)
+			: "r7", "r3", "r4");
+#endif
+}
+
+
+static void
+dcc_stop_tx(struct uart_port *port)
+{
+}
+
+static inline void
+dcc_transmit_buffer(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+
+	int pendings = uart_circ_chars_pending(xmit);
+
+	if(pendings + xmit->tail > UART_XMIT_SIZE)
+	{
+		xmit_string(&(xmit->buf[xmit->tail]), UART_XMIT_SIZE - xmit->tail);
+		xmit_string(&(xmit->buf[0]), xmit->head);
+	} else
+		xmit_string(&(xmit->buf[xmit->tail]), pendings);
+	
+	xmit->tail = (xmit->tail + pendings) & (UART_XMIT_SIZE-1);
+        port->icount.tx += pendings;
+
+	if (uart_circ_empty(xmit))
+		dcc_stop_tx(port); 
+}
+
+static inline void
+dcc_transmit_x_char(struct uart_port *port)
+{
+	xmit_string(&port->x_char, 1);
+	port->icount.tx++;
+	port->x_char = 0;
+}
+
+static void
+dcc_start_tx(struct uart_port *port)
+{
+    dcc_transmit_buffer(port);
+}
+
+static void
+dcc_stop_rx(struct uart_port *port)
+{
+}
+
+static void
+dcc_enable_ms(struct uart_port *port)
+{
+}
+
+static inline void
+dcc_rx_chars(struct uart_port *port)
+{
+	unsigned char ch;
+	struct tty_struct *tty = port->info->tty;
+
+	/*
+	 * check input.
+	 * checking JTAG flag is better to resolve the status test.
+	 * incount is NOT used for JTAG1 protocol.
+	 */
+
+	if (__check_JTAG_RX_FLAG())
+		/* if   __ret 	== 0 : no input yet
+					== 1 : a character pending */
+	{
+		/* for JTAG 1 protocol, incount is always 1. */
+		__get_JTAG_RX(&ch);
+		if (tty->flip.count < TTY_FLIPBUF_SIZE) {
+			*tty->flip.char_buf_ptr++ = ch;
+			*tty->flip.flag_buf_ptr++ = TTY_NORMAL;
+			port->icount.rx++;
+			tty->flip.count++;
+		} 
+		tty_flip_buffer_push(tty);
+	}
+}
+
+static inline void
+dcc_overrun_chars(struct uart_port *port)
+{
+	port->icount.overrun++;
+}
+
+static inline void
+dcc_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+
+	if (port->x_char) {
+		dcc_transmit_x_char(port);
+		return; 
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		dcc_stop_tx(port);
+		return;
+	}
+
+	dcc_transmit_buffer(port);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+}
+
+#ifdef DCC_IRQ_USED /* real IRQ used */
+static irqreturn_t
+dcc_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_port *port = dev_id;
+	int handled = 0;
+
+	spin_lock(&port->lock);
+	
+	dcc_rx_chars(port);
+	dcc_tx_chars(port);
+
+	handled = 1;
+	spin_unlock(&port->lock);
+	
+	return IRQ_RETVAL(handled);
+}
+
+#else /* emulation by scheduled work */
+static void
+dcc_poll(void *data)
+{
+	struct uart_port *port = data;
+
+	spin_lock(&port->lock);
+	
+	dcc_rx_chars(port);
+	dcc_tx_chars(port);
+
+	schedule_delayed_work(&dcc_poll_task, 1);
+
+	spin_unlock(&port->lock);
+	
+}
+#endif /* end of DCC_IRQ_USED */
+
+static unsigned int
+dcc_tx_empty(struct uart_port *port)
+{
+	return TIOCSER_TEMT;
+}
+
+static unsigned int
+dcc_get_mctrl(struct uart_port *port)
+{
+	return 0;
+}
+
+static void
+dcc_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static void
+dcc_break_ctl(struct uart_port *port, int break_state)
+{
+}
+
+static int dcc_startup(struct uart_port *port)
+{
+#ifdef DCC_IRQ_USED /* real IRQ used */
+	int retval;
+
+	/* Allocate the IRQ */
+	retval = request_irq(port->irq, dcc_int, SA_INTERRUPT,
+			     "serial_dcc", port);
+	if (retval)
+		return retval;
+#else /* emulation */
+	/* Initialize the work, and shcedule it. */
+	INIT_WORK(&dcc_poll_task, dcc_poll, port);
+	schedule_delayed_work(&dcc_poll_task, 1);
+#endif
+
+	return 0;
+}
+
+static void dcc_shutdown(struct uart_port *port)
+{
+}
+
+static void
+dcc_set_termios(struct uart_port *port, struct termios *termios,
+		   struct termios *old)
+{
+#ifdef DCC_IRQ_USED
+	unsigned long flags;
+#endif
+	unsigned int baud, quot;
+
+	/*
+	 * We don't support parity, stop bits, or anything other
+	 * than 8 bits, so clear these termios flags.
+	 */
+	termios->c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD | CREAD);
+	termios->c_cflag |= CS8;
+
+	/*
+	 * We don't appear to support any error conditions either.
+	 */
+	termios->c_iflag &= ~(INPCK | IGNPAR | IGNBRK | BRKINT);
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); 
+	quot = uart_get_divisor(port, baud);
+
+#ifdef DCC_IRQ_USED
+	spin_lock_irqsave(&port->lock, flags);
+#endif
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+#ifdef DCC_IRQ_USED
+	spin_unlock_irqrestore(&port->lock, flags);
+#endif
+}
+
+static const char *dcc_type(struct uart_port *port)
+{
+	return port->type == PORT_DCC_JTAG1 ? "DCC" : NULL;
+}
+
+static void dcc_release_port(struct uart_port *port)
+{
+}
+
+static int dcc_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void dcc_config_port(struct uart_port *port, int flags)
+{
+        if (flags & UART_CONFIG_TYPE) {
+                port->type = PORT_DCC_JTAG1;
+                dcc_request_port(port);
+        }
+}
+        
+/*      
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */     
+static int dcc_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+        int ret = 0;
+        if (ser->type != PORT_UNKNOWN && ser->type != PORT_DCC_JTAG1)
+                ret = -EINVAL;
+        if (ser->irq < 0 || ser->irq >= NR_IRQS)
+                ret = -EINVAL;
+        if (ser->baud_base < 9600)
+                ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops dcc_pops = {
+	.tx_empty	= dcc_tx_empty,
+	.set_mctrl	= dcc_set_mctrl,
+	.get_mctrl	= dcc_get_mctrl,
+	.stop_tx	= dcc_stop_tx,
+	.start_tx	= dcc_start_tx,
+	.stop_rx	= dcc_stop_rx,
+	.enable_ms	= dcc_enable_ms,
+	.break_ctl	= dcc_break_ctl,
+	.startup	= dcc_startup,
+	.shutdown	= dcc_shutdown,
+	.set_termios	= dcc_set_termios,
+	.type		= dcc_type,
+	.release_port  = dcc_release_port,
+	.request_port = dcc_request_port,
+	.config_port = dcc_config_port,
+	.verify_port = dcc_verify_port,
+};
+
+static struct uart_port dcc_ports[UART_NR] = {
+	{
+		.membase	= (char*)0x12345678,	/* we need these garbages */
+		.mapbase	= 0x12345678,		/* for serial_core.c */
+		.iotype		= SERIAL_IO_MEM,	
+#ifdef DCC_IRQ_USED
+		.irq			= INT_N_EXT0,
+#else
+		.irq			= 0,
+#endif
+		.uartclk		= 14745600,			 
+		.fifosize		= 0,
+		.ops			= &dcc_pops,
+		.flags		= ASYNC_BOOT_AUTOCONF,
+		.line			= 0,
+	},
+};
+
+
+#ifdef CONFIG_SERIAL_DCC_CONSOLE
+
+static void
+dcc_console_write(struct console *co, const char *s, unsigned int count)
+{
+	xmit_string_CR((char*)s, count);
+}
+
+/*
+ * Read the current UART setup.
+ */
+static void __init
+dcc_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	*baud = 9600;
+	*parity = 'n';
+	*bits = 8;
+}
+
+static int __init
+dcc_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index >= UART_NR)
+		co->index = 0;
+	port = &dcc_ports[co->index];
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		dcc_console_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver dcc_reg;
+static struct console dcc_console = {
+	.name		= SERIAL_DCC_NAME,
+	.write		= dcc_console_write,
+	.device		= uart_console_device,
+	.setup		= dcc_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &dcc_reg,
+};
+
+static int __init dcc_console_init(void)
+{
+	register_console(&dcc_console);
+	return 0;
+}
+console_initcall(dcc_console_init);
+
+#define DCC_CONSOLE		&dcc_console
+#else
+#define DCC_CONSOLE		NULL
+#endif
+
+static struct uart_driver dcc_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= SERIAL_DCC_NAME,
+	.dev_name		= SERIAL_DCC_NAME,
+	.major			= SERIAL_DCC_MAJOR,
+	.minor			= SERIAL_DCC_MINOR,
+	.nr			= UART_NR,
+	.cons			= DCC_CONSOLE,
+};
+
+static int __init
+dcc_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "DCC: JTAG1 Serial emulation driver driver $Revision: 1.1 $\n");
+
+	ret = uart_register_driver(&dcc_reg);
+	if (ret == 0) {
+		int i;
+
+		for (i = 0; i < UART_NR; i++)
+			uart_add_one_port(&dcc_reg, &dcc_ports[i]);
+	}
+	return ret;
+}
+
+__initcall(dcc_init);
+
+MODULE_DESCRIPTION("DCC(JTAG1) JTAG debugger console emulation driver");
+MODULE_AUTHOR("Hyok S. Choi <hyok.choi@samsung.com>");
+MODULE_SUPPORTED_DEVICE("ttyJ");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14-uc0/drivers/serial/Kconfig linux-2.6.14-uc0-hsc0/drivers/serial/Kconfig
--- linux-2.6.14-uc0/drivers/serial/Kconfig	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/drivers/serial/Kconfig	2005-11-09 19:14:12.000000000 +0900
@@ -888,4 +888,140 @@
 		and wish to use the serial ports on this card, say Y.
 		Otherwise, say N.
 
+config SERIAL_ATMEL
+	bool "ATMEL uart support"
+	depends on ARCH_ATMEL
+	help
+	  This driver supports the uart ports of the ATMEL AT91 series.
+
+config SERIAL_ATMEL_CONSOLE
+	bool "Console on ATMEL uart"
+	depends on SERIAL_ATMEL
+	help
+	  If you would like to be able to use the ATMEL uart port
+	  as the console, say Y to this option.
+
+config SERIAL_DCC
+	bool "JTAG ICE/ICD DCC serial port emulation support"
+	depends on ARM
+	select SERIAL_CORE
+	help
+	  This selects serial port emulation driver for ICE/ICD JTAG debugger
+	  (e.g. Trace32) for ARM architecture. You should make an terminal with
+	  DCC(JTAG1) protocol.
+
+	  if unsure, say N.
+ 
+config SERIAL_DCC_CONSOLE
+	bool "Support for console on JTAG ICE/ICD DCC"
+	depends on SERIAL_DCC
+	select SERIAL_CORE_CONSOLE
+	help
+	  Say Y here if you wish to use ICE/ICD JTAG DCC serial port emulation
+	  as the system console. you can use command line option "console=ttyJ0"
+	  for manual console driver setup.
+
+	  if unsure, say N.
+
+config SERIAL_P2001_UART
+	tristate "P2001 uart driver"
+	depends on ARM && ARCH_P2001
+	default y
+	select SERIAL_CORE
+	help
+	  P2001 uart driver
+
+config SERIAL_P2001_UART_CONSOLE
+	bool "P2001 console on uart driver"
+	depends on SERIAL_P2001_UART=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  P2001 console on uart driver
+
+config SERIAL_S3C4510B
+	tristate "Samsung S3C4510B Serial port support"
+	depends on ARM && CPU_S3C4510B
+	select SERIAL_CORE
+	help
+	  Support for the on-chip UARTs on the Samsung S3C4510B CPU,
+	  providing /dev/ttyS0 and 1.
+
+config SERIAL_S3C4510B_CONSOLE
+	bool "Support for console on S3C4510B serial port"
+	depends on SERIAL_S3C4510B=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Allow selection of the S3C4510B on-board serial ports for use as
+	  an virtual console.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttySx". 
+
+config SERIAL_S3C24A0 
+	tristate "Samsung S3C24A0 Serial port support"
+	depends on ARM && ARCH_S3C24A0
+	select SERIAL_CORE
+	help
+	  Support for the on-chip UARTs on the Samsung S3C24A0 CPU,
+	  providing /dev/ttyS0 and 1.
+
+
+config SERIAL_S3C24A0_CONSOLE 
+	bool "Support for console on S3C24A0 serial port"
+	depends on SERIAL_S3C24A0=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Allow selection of the S3C24A0 on-board serial ports for use as
+	  an virtual console.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttySx". 
+
+config SERIAL_S3C4510B
+	tristate "Samsung S3C4510B Serial port support"
+	depends on ARM && CPU_S3C4510B
+	select SERIAL_CORE
+	help
+	  Support for the on-chip UARTs on the Samsung S3C4510B CPU,
+	  providing /dev/ttyS0 and 1.
+
+config SERIAL_S3C4510B_CONSOLE
+	bool "Support for console on S3C4510B serial port"
+	depends on SERIAL_S3C4510B=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Allow selection of the S3C4510B on-board serial ports for use as
+	  an virtual console.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttySx". 
+
+config SERIAL_S3C24A0 
+	tristate "Samsung S3C24A0 Serial port support"
+	depends on ARM && ARCH_S3C24A0
+	select SERIAL_CORE
+	help
+	  Support for the on-chip UARTs on the Samsung S3C24A0 CPU,
+	  providing /dev/ttyS0 and 1.
+
+
+config SERIAL_S3C24A0_CONSOLE 
+	bool "Support for console on S3C24A0 serial port"
+	depends on SERIAL_S3C24A0=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Allow selection of the S3C24A0 on-board serial ports for use as
+	  an virtual console.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttySx". 
+
 endmenu
diff -Naur linux-2.6.14-uc0/drivers/serial/Makefile linux-2.6.14-uc0-hsc0/drivers/serial/Makefile
--- linux-2.6.14-uc0/drivers/serial/Makefile	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/drivers/serial/Makefile	2005-11-09 19:14:42.000000000 +0900
@@ -56,3 +56,7 @@
 obj-$(CONFIG_SERIAL_TXX9) += serial_txx9.o
 obj-$(CONFIG_SERIAL_VR41XX) += vr41xx_siu.o
 obj-$(CONFIG_SERIAL_SGI_IOC4) += ioc4_serial.o
+obj-$(CONFIG_SERIAL_DCC) += dcc.o
+obj-$(CONFIG_SERIAL_ATMEL) += serial_atmel.o
+obj-$(CONFIG_SERIAL_S3C4510B) += serial_s3c4510b.o
+obj-$(CONFIG_SERIAL_P2001_UART) += p2001_uart.o
diff -Naur linux-2.6.14-uc0/drivers/serial/p2001_uart.c linux-2.6.14-uc0-hsc0/drivers/serial/p2001_uart.c
--- linux-2.6.14-uc0/drivers/serial/p2001_uart.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/drivers/serial/p2001_uart.c	2005-11-08 14:15:30.000000000 +0900
@@ -0,0 +1,721 @@
+/*
+ *  linux/drivers/char/p2001_uart.c
+ *
+ *  Driver for P2001 uart port
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Version 1.0: First working version
+ * Version 1.1: Removed all READ_REG/WRITE_REG
+ * Version 1.2: Break handling
+ * Version 1.3: Hardware handshake
+ *              Device naming, major/minor nr for setserial
+ *              ISR cleanups
+ * Version 1.4: cpu frequency scaling
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/device.h>
+#include <linux/serial_core.h>
+
+#ifdef CONFIG_CPU_FREQ
+#include <linux/notifier.h>
+#include <linux/cpufreq.h>
+#endif
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+
+#if defined(CONFIG_SERIAL_P2001_UART_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+
+/**************************************************************************
+ * Definitions
+ **************************************************************************/
+static const char *version =
+	"p2001_uart.c:v1.4 12/29/2004 Tobias Lorenz (tobias.lorenz@gmx.net)\n";
+
+static const char p2001_uart_name[] = "P2001 uart";
+
+#define TX_MIN_BUF	10
+
+#define tx_enabled(port)	((port)->unused[0])
+#define rx_enabled(port)	((port)->unused[1])
+
+extern struct uart_driver	p2001_uart_driver;	/* UART Driver     */
+extern struct uart_port		p2001_uart_port;	/* UART Port       */
+extern struct uart_ops		p2001_uart_ops;		/* UART Operations */
+extern struct console		p2001_console;		/* Console         */
+
+#define DEFAULT_BAUD 57600
+static unsigned int baud;	/* Current baudrate */
+
+
+
+/**************************************************************************
+ * UART Driver
+ **************************************************************************/
+
+static struct uart_driver p2001_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "serial",		/* name of tty/console device */
+	.dev_name	= "ttyS",		/* name of tty/console device */
+#ifdef CONFIG_DEVFS_FS
+	.devfs_name	= "tts/",		/* name of tty/console device */
+#endif
+	.major		= 4,			/* major number for the driver */
+	.minor		= 64,			/* starting minor number */
+	.nr		= 1,			/* maximum number of serial ports this driver supports */
+#ifdef CONFIG_SERIAL_P2001_UART_CONSOLE
+	.cons		= &p2001_console,
+#endif
+};
+
+
+
+/**************************************************************************
+ * UART Port
+ **************************************************************************/
+
+static struct uart_port p2001_uart_port = {
+	.membase	= (void*)P2001_UART,		/* read/write[bwl] */
+	.mapbase	= (unsigned int)P2001_UART,	/* for ioremap */
+	.iotype		= UPIO_MEM,			/* io access style */
+	.irq		= IRQ_UART,			/* irq number */
+	.uartclk	= CONFIG_SYSCLK/8,		/* base uart clock */
+	.fifosize	= 32,				/* tx fifo size */
+	.ops		= &p2001_uart_ops,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.line		= 0,				/* port index */
+};
+
+
+
+/**************************************************************************
+ * UART interrupt routine
+ **************************************************************************/
+
+/* uart interrupt send routine */
+static void p2001_uart_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	int count;
+
+	if (port->x_char) {
+		while ((P2001_UART->r.STATUS & 0x3f) > TX_MIN_BUF)
+			barrier();
+		P2001_UART->w.TX[0] = port->x_char;
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		tx_enabled(port) = 0;
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		while ((P2001_UART->r.STATUS & 0x3f) > TX_MIN_BUF)
+			barrier();
+		P2001_UART->w.TX[0] = xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		tx_enabled(port) = 0;
+
+	P2001_UART->w.IRQ_Status |= (1<<0);
+}
+
+/* uart interrupt receive routine */
+static void p2001_uart_rx_chars(struct uart_port *port, struct pt_regs *regs)
+{
+	struct tty_struct *tty = port->info->tty;
+	unsigned int status;
+	unsigned int rxddelta;
+	unsigned int rx;
+	unsigned int max_count = 256;
+
+	status = P2001_UART->r.IRQ_Status;
+	rxddelta = (P2001_UART->r.STATUS >> 6) & 0x3f;
+	while (rxddelta && max_count--) {
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+			tty->flip.work.func((void *)tty);
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+				printk(KERN_WARNING "TTY_DONT_FLIP set\n");
+				return;
+			}
+		}
+
+		rx = P2001_UART->r.RX[0];
+
+		*tty->flip.char_buf_ptr = rx & 0xff;
+		*tty->flip.flag_buf_ptr = TTY_NORMAL;
+		port->icount.rx++;
+
+		/*
+		 * Note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (status & ((1<<7)|(1<<6)|(1<<9))) {
+			if (status & (1<<7)) {			/* RxD_BRK */
+				port->icount.brk++;
+				if (uart_handle_break(port))
+					goto ignore_chars;
+			} else if (status & (1<<6))		/* RxD_FIFO_PAR_ERR */
+				port->icount.parity++;
+			if (status & (1<<9))			/* RxD_LOST */
+				port->icount.overrun++;
+
+			status &= port->read_status_mask;
+
+			if (status & (1<<7))			/* RxD_BRK */
+				*tty->flip.flag_buf_ptr = TTY_BREAK;
+			else if (status & (1<<6))		/* RxD_FIFO_PAR_ERR */
+				*tty->flip.flag_buf_ptr = TTY_PARITY;
+				
+		}
+
+		if (uart_handle_sysrq_char(port, ch, regs))
+			goto ignore_chars;
+
+		if (rx && port->ignore_status_mask == 0) {
+			tty->flip.flag_buf_ptr++;
+			tty->flip.char_buf_ptr++;
+			tty->flip.count++;
+		}
+		if ((status & (1<<9)) &&		/* RxD_LOST */
+		    tty->flip.count < TTY_FLIPBUF_SIZE) {
+			/*
+			 * Overrun is special, since it's reported
+			 * immediately, and doesn't affect the current
+			 * character
+			 */
+			*tty->flip.char_buf_ptr++ = 0;
+			*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+			tty->flip.count++;
+		}
+	ignore_chars:
+		rxddelta = (P2001_UART->r.STATUS >> 6) & 0x3f;
+	}
+	tty_flip_buffer_push(tty);
+
+	P2001_UART->w.IRQ_Status |= (1<<3) | (1<<6) | (1<<7) | (1<<9);
+}
+
+/* uart interrupt routine */
+static irqreturn_t p2001_uart_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_port *port = dev_id;
+	unsigned int status;
+
+	spin_lock(&port->lock);
+
+	status = P2001_UART->r.IRQ_Status;
+	// TXD_SEND | TXD_LAST_DATA
+	if (status & (1<<0)) // (1<<2)
+		p2001_uart_tx_chars(port);
+	// RXD_DATA | RxD_FIFO_PAR_ERR | RxD_BRK | RxD_LOST
+	if (status & ((1<<3) | (1<<6) | (1<<7) | (1<<9)))
+		p2001_uart_rx_chars(port, regs);
+
+	//status &= ~((1<<0) | (1<<2) | (1<<3));
+	//if (status & 0x3ff)
+	//	printk(KERN_INFO "p2001_uart_interrupt: status=0x%8.8x\n", status);
+
+	P2001_UART->w.IRQ_Status &= ~0x3ff;
+
+	spin_unlock(&port->lock);
+
+	return IRQ_HANDLED;
+}
+
+
+
+/**************************************************************************
+ * UART Operations
+ **************************************************************************/
+
+/* returns if the port transmitter is empty or not. */
+static unsigned int p2001_uart_ops_tx_empty(struct uart_port *port)
+{
+	unsigned int txddelta = P2001_UART->r.STATUS & 0x3f;
+	return (txddelta > 0) ? 0 : TIOCSER_TEMT;
+}
+
+/* sets a new value for the MCR UART register. */
+static void p2001_uart_ops_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* no modem control lines */
+}
+
+/* gets the current MCR UART register value. */
+static unsigned int p2001_uart_ops_get_mctrl(struct uart_port *port)
+{
+	/* no modem control lines */
+	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+}
+
+/* stops the port from sending data. */
+static void p2001_uart_ops_stop_tx(struct uart_port *port)
+{
+	if (tx_enabled(port)) {
+		P2001_UART->w.IRQ_Status &= ~((1<<20) | (1<<22));	// TXD_SEND | TXD_LAST_DATA
+		tx_enabled(port) = 0;
+	}
+}
+
+/* starts the port sending data. */
+static void p2001_uart_ops_start_tx(struct uart_port *port)
+{
+	if (!tx_enabled(port)) {
+		P2001_UART->w.IRQ_Status |= (1<<20) | (1<<22);	// TXD_SEND | TXD_LAST_DATA
+		tx_enabled(port) = 1;
+	}
+	p2001_uart_tx_chars(port);
+}
+
+/* tells the port to send the XOFF character to the host. */
+#if 0
+static void p2001_uart_ops_send_xchar(struct uart_port *port, char ch)
+{
+#warning "p2001_uart_ops_send_xchar is not implemented."
+}
+#endif
+
+/* stops receiving data. */
+static void p2001_uart_ops_stop_rx(struct uart_port *port)
+{
+	if (rx_enabled(port)) {
+		P2001_UART->w.IRQ_Status &= ~(1<<23);	// RXD_DATA
+		rx_enabled(port) = 0;
+	}
+}
+
+/* enables the modem status interrupts. */
+static void p2001_uart_ops_enable_ms(struct uart_port *port)
+{
+	/* empty */
+}
+
+/* sends the BREAK value over the port. */
+static void p2001_uart_ops_break_ctl(struct uart_port *port, int ctl)
+{
+	/* no break signal */
+}
+
+/* called once each time the open call happens */
+static int p2001_uart_ops_startup(struct uart_port *port)
+{
+	int ret;
+
+	tx_enabled(port) = 1;
+	rx_enabled(port) = 1;
+
+	ret = request_irq(port->irq, p2001_uart_interrupt, 0, p2001_uart_name, port);
+
+	P2001_UART->w.Clear    = 0;
+	// TXD_SEND | TXD_LAST_DATA
+	P2001_UART->w.IRQ_Status |= (1<<20) | (1<<22);
+	// RXD_DATA | RxD_FIFO_PAR_ERR | RxD_BRK | RxD_LOST
+	P2001_UART->w.IRQ_Status |= (1<<23) | (1<<26) | (1<<27) | (1<<29);
+
+	return ret;
+}
+
+/* called when the port is closed */
+static void p2001_uart_ops_shutdown(struct uart_port *port)
+{
+	free_irq(port->irq, port);
+}
+
+/* called whenever the port line settings need to be modified */
+static void p2001_uart_ops_set_termios(struct uart_port *port, struct termios *new, struct termios *old)
+{
+	unsigned int config;
+	unsigned long flags;
+	unsigned int prod, quot;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, new, old, 0, port->uartclk);	// min:0/max:port->uartclk
+	prod = 3;
+	quot = (port->uartclk * prod)/baud;
+
+	/* interrupt level */
+	config = (12 << 11) | (12 << 17);	/* RXDHIGHWATER = 12, TXDLOWWATER = 12 */
+
+	/* data bits */
+	switch (new->c_cflag & CSIZE) {
+		case CS5:
+			config |= (5 << 5);	/* WORDLENGTH = 5 */
+			break;
+		case CS6:
+			config |= (6 << 5);	/* WORDLENGTH = 6 */
+			break;
+		case CS7:
+			config |= (7 << 5);	/* WORDLENGTH = 7 */
+			break;
+		default: /* CS8 */
+			config |= (8 << 5);	/* WORDLENGTH = 8 */
+			break;
+	}
+
+	/* parity */
+	if (new->c_cflag & PARENB) {
+		if (!(new->c_cflag & PARODD))
+			config |= (1 << 2);	/* PARITYMODE = 1 (Even Parity) */
+		else
+			config |= (2 << 2);	/* PARITYMODE = 2 (Odd Parity) */
+	}
+
+	/* stop bits */
+	if (new->c_cflag & CSTOPB)
+		config |= (1 << 0);		/* STOPBITAW = 1 (1 Stopbit) */
+
+	/* hardware flow control */
+	if (new->c_cflag & CRTSCTS) {
+		config |= (1 << 10);		/* USECTS = 1 */
+		P2001_GPIO->PIN_MUX |= (1<<5);
+	} else {
+		P2001_GPIO->PIN_MUX &= ~(1<<5);
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, new->c_cflag, baud);
+
+	port->read_status_mask = (1<<9);			/* RXD_DATA_LOST */
+	if (new->c_iflag & INPCK)
+		port->read_status_mask |= (1<<6);		/* RxD_FIFO_PAR_ERR */
+	if (new->c_iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= (1<<7);		/* RxD_BRK */
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (new->c_iflag & IGNPAR)
+		port->ignore_status_mask |= (1<<6);		/* RxD_FIFO_PAR_ERR */
+	if (new->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= (1<<7);		/* RxD_BRK */
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (new->c_iflag & IGNPAR)
+			port->ignore_status_mask |= (1<<9);	/* RxD_LOST */
+	}
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((new->c_cflag & CREAD) == 0)
+		port->ignore_status_mask |= (1<<3);		/* RXD_DATA */
+
+	/* Set baud rate */
+	P2001_UART->w.Baudrate = (quot<<16)+prod;
+	P2001_UART->w.Config   = config;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/* power management: power the hardware down */
+#ifdef CONFIG_PM
+static void p2001_uart_ops_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+#warning "p2001_uart_ops_pm is not implemented."
+}
+#endif
+
+/* power management: power the hardware up */
+#ifdef CONFIG_PM
+static int p2001_uart_ops_set_wake(struct uart_port *port, unsigned int state)
+{
+#warning "p2001_uart_ops_set_wake is not implemented."
+}
+#endif
+
+/*
+ * Return a string describing the port type
+ */
+static const char *p2001_uart_ops_type(struct uart_port *port)
+{
+	return port->type == PORT_P2001 ? "P2001" : NULL;
+}
+
+/*
+ * Release IO and memory resources used by
+ * the port. This includes iounmap if necessary.
+ */
+static void p2001_uart_ops_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, 0x30);
+}
+
+/*
+ * Request IO and memory resources used by the
+ * port. This includes iomapping the port if
+ * necessary.
+ */
+static int p2001_uart_ops_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->mapbase, 0x30, p2001_uart_name)
+			 != NULL ? 0 : -EBUSY;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void p2001_uart_ops_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE && p2001_uart_ops_request_port(port) == 0)
+		port->type = PORT_P2001;
+}
+
+/*
+ * Verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int p2001_uart_ops_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_P2001)
+		ret = -EINVAL;
+	if (ser->irq != NO_IRQ)
+		ret = -EINVAL;
+	return ret;
+}
+
+/* device specific ioctl calls */
+#if 0
+static int p2001_uart_ops_ioctl(struct uart_port *port, unsigned int, unsigned long)
+{
+#warning "p2001_uart_ops_ioctl is not implemented."
+}
+#endif
+
+
+static struct uart_ops p2001_uart_ops = {
+	.tx_empty	= p2001_uart_ops_tx_empty,	/* returns if the port transmitter is empty or not. */
+	.set_mctrl	= p2001_uart_ops_set_mctrl,	/* sets a new value for the MCR UART register. */
+	.get_mctrl	= p2001_uart_ops_get_mctrl,	/* gets the current MCR UART register value. */
+	.stop_tx	= p2001_uart_ops_stop_tx,	/* stops the port from sending data. */
+	.start_tx	= p2001_uart_ops_start_tx,	/* starts the port sending data. */
+//	.send_xchar	= p2001_uart_ops_send_xchar,	/* tells the port to send the XOFF character to the host. */
+	.stop_rx	= p2001_uart_ops_stop_rx,	/* stops receiving data. */
+	.enable_ms	= p2001_uart_ops_enable_ms,	/* enables the modem status interrupts. */
+	.break_ctl	= p2001_uart_ops_break_ctl,	/* sends the BREAK value over the port. */
+	.startup	= p2001_uart_ops_startup,	/* called once each time the open call happens */
+	.shutdown	= p2001_uart_ops_shutdown,	/* called when the port is closed */
+	.set_termios	= p2001_uart_ops_set_termios,	/* called whenever the port line settings need to be modified */
+#ifdef CONFIG_PM
+	.pm		= p2001_uart_ops_pm,		/* power management: power the hardware down */
+	.set_wake	= p2001_uart_ops_set_wake,	/* power management: power the hardware up */
+#endif
+	.type		= p2001_uart_ops_type,		/* Return a string describing the port type */
+	.release_port	= p2001_uart_ops_release_port,	/* Release the region(s) being used by 'port' */
+	.request_port	= p2001_uart_ops_request_port,	/* Request the region(s) being used by 'port' */
+	.config_port	= p2001_uart_ops_config_port,	/* Configure/autoconfigure the port. */
+	.verify_port	= p2001_uart_ops_verify_port,	/* Verify the new serial_struct (for TIOCSSERIAL). */
+//	.ioctl		= p2001_uart_ops_ioctl,		/* device specific ioctl calls */
+};
+
+
+
+/**************************************************************************
+ * CPU frequency scaling
+ **************************************************************************/
+
+#ifdef CONFIG_CPU_FREQ
+
+/*
+ * Starts receiving data.
+ */
+static void p2001_uart_ops_start_rx(struct uart_port *port)
+{
+	if (!rx_enabled(port)) {
+		P2001_UART->w.IRQ_Status |= (1<<23);	// RXD_DATA
+		rx_enabled(port) = 1;
+	}
+}
+
+/*
+ * Here we define a transistion notifier so that we can update all of our
+ * ports' baud rate when the peripheral clock changes.
+ */
+static int p2001_uart_notifier(struct notifier_block *self, unsigned long phase, void *data)
+{
+	struct cpufreq_freqs *cf = data;
+	unsigned int prod, quot;
+	struct uart_port *port = &p2001_uart_port;
+
+	if (phase == CPUFREQ_PRECHANGE) {
+		/* Stop transceiver */
+		p2001_uart_ops_stop_rx(&p2001_uart_port);
+		p2001_uart_ops_stop_tx(&p2001_uart_port);
+
+		while (!p2001_uart_ops_tx_empty(port))
+			barrier();
+	}
+
+	if ((phase == CPUFREQ_POSTCHANGE) ||
+	    (phase == CPUFREQ_RESUMECHANGE)){
+		/* Set new baud rate */
+		port->uartclk = 1000 * cf->new / 8;	// in MHz
+		prod = 3;
+		quot = (port->uartclk * prod)/baud;
+		P2001_UART->w.Baudrate = (quot<<16)+prod;
+
+		/* Start transceiver */
+		p2001_uart_ops_start_rx(&p2001_uart_port);
+		p2001_uart_ops_start_tx(&p2001_uart_port);
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block p2001_uart_nb = { &p2001_uart_notifier, NULL, 0 };
+
+#endif /* CONFIG_CPU_FREQ */
+
+
+
+/**************************************************************************
+ * Console
+ **************************************************************************/
+
+#ifdef CONFIG_SERIAL_P2001_UART_CONSOLE
+
+/* the function used to print kernel messages */
+static void p2001_console_write(struct console *co, const char *s, unsigned int count)
+{
+	int i;
+
+	for (i = 0; i < count; i++) {
+		while ((P2001_UART->r.STATUS & 0x3f) > TX_MIN_BUF)
+			barrier();
+		P2001_UART->w.TX[0] = s[i];
+		if (s[i] == '\n') {
+			while ((P2001_UART->r.STATUS & 0x3f) > TX_MIN_BUF)
+				barrier();
+			P2001_UART->w.TX[0] = '\r';
+		}
+	}
+}
+
+/* the function is called when the console=  command-line argument matches the name for this console structure. */
+static int __init p2001_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port = &p2001_uart_port;
+	int parity = 'n';
+	int bits   = 8;
+	int flow   = 'n';
+
+	baud = DEFAULT_BAUD;
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+
+static struct console p2001_console = {
+	.name		= "ttyS",			/* the name of the console device is used to parse the console= command line option. */
+	.write		= p2001_console_write,		/* the function used to print kernel messages */
+//	.read		= p2001_console_read,		/* ??? */
+	.device		= uart_console_device,		/* a function that returns the device number for the underlying tty device that is currently acting as a console */
+//	.unblank	= p2001_console_unblank,	/* the function, if defined, is used to unblank the screen. */
+	.setup		= p2001_console_setup,		/* the function is called when the console=  command-line argument matches the name for this console structure. */
+	.flags		= CON_PRINTBUFFER,		/* various console flags */
+	.index		= -1,				/* the number of the device acting as a console in an array of devices. */
+//	.cflag		= 0,
+	.data		= &p2001_uart_driver,
+};
+
+static int __init p2001_console_init(void)
+{
+	register_console(&p2001_console);
+	return 0;
+}
+console_initcall(p2001_console_init);
+#endif
+
+
+
+/**************************************************************************
+ * Module functions
+ **************************************************************************/
+
+static int __init p2001_uart_module_init(void)
+{
+	int ret;
+
+	printk(version);
+
+	ret = uart_register_driver(&p2001_uart_driver);
+	if (ret != 0) return ret;
+
+	ret = uart_add_one_port(&p2001_uart_driver, &p2001_uart_port);
+	if (ret != 0) return ret;
+
+#ifdef CONFIG_CPU_FREQ
+	ret = cpufreq_register_notifier(&p2001_uart_nb, CPUFREQ_TRANSITION_NOTIFIER);
+	printk("p2001_uart: CPU frequency notifier registered\n");
+#endif
+
+	return ret;
+}
+
+static void __exit p2001_uart_module_exit(void)
+{
+#ifdef CONFIG_CPU_FREQ
+        cpufreq_unregister_notifier(&p2001_uart_nb, CPUFREQ_TRANSITION_NOTIFIER);
+        printk("p2001_uart: CPU frequency notifier unregistered\n");
+#endif
+	uart_remove_one_port(&p2001_uart_driver, &p2001_uart_port);
+	uart_unregister_driver(&p2001_uart_driver);
+}
+
+module_init(p2001_uart_module_init);
+module_exit(p2001_uart_module_exit);
+
+MODULE_AUTHOR("Tobias Lorenz");
+MODULE_DESCRIPTION("P2001 uart driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14-uc0/drivers/serial/serial_atmel.c linux-2.6.14-uc0-hsc0/drivers/serial/serial_atmel.c
--- linux-2.6.14-uc0/drivers/serial/serial_atmel.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/drivers/serial/serial_atmel.c	2005-11-08 14:19:18.000000000 +0900
@@ -0,0 +1,1888 @@
+/* serial port driver for the Atmel AT91 series builtin USARTs
+ *
+ * Copyright (C) 2000, 2001  Erik Andersen <andersen@lineo.com>
+ * Copyright (C) 2004 Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * Based on:
+ * drivers/char/68302serial.c
+ * and also based on trioserial.c from Aplio, though this driver
+ * has been extensively changed since then.  No author was 
+ * listed in trioserial.c.
+ * 
+ * Phil Wilshire 12/31/2002  Fixed multiple ^@ chars on TCSETA 
+ * Hyok S. Choi  03/22/2004  2.6 port
+ */
+
+/* Enable this to force this driver to always operate at 57600 */
+#undef FORCE_57600
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/serial.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/config.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/console.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/arch/irq.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/bitops.h>
+#include <asm/delay.h>
+#include <asm/uaccess.h>
+
+#include "serial_atmel.h"
+
+#define USE_INTS	1
+
+static volatile struct atmel_usart_regs *usarts[AT91_USART_CNT] = {
+	(volatile struct atmel_usart_regs *) AT91_USART0_BASE,
+	(volatile struct atmel_usart_regs *) AT91_USART1_BASE
+};
+
+#define SERIAL_XMIT_SIZE	PAGE_SIZE
+#define RX_SERIAL_SIZE		256
+
+static struct atmel_serial atmel_info[AT91_USART_CNT];
+static struct tty_struct *serial_table[AT91_USART_CNT];
+struct atmel_serial *atmel_consinfo = 0;
+
+#define UART_CLOCK	(ARM_CLK/16)
+
+static struct work_struct serialpoll;
+
+#ifdef CONFIG_CONSOLE
+extern wait_queue_head_t keypress_wait; 
+#endif
+
+struct tty_driver *serial_driver;
+
+/* serial subtype definitions */
+#define SERIAL_TYPE_NORMAL	1
+
+/* number of characters left in xmit buffer before we ask for more */
+#define WAKEUP_CHARS 256
+
+/* Debugging... DEBUG_INTR is bad to use when one of the zs
+ * lines is your console ;(
+ */
+#undef SERIAL_DEBUG_INTR
+#undef SERIAL_DEBUG_OPEN
+#undef SERIAL_DEBUG_FLOW
+
+#define RS_ISR_PASS_LIMIT 256
+
+#define _INLINE_ inline
+
+#ifndef MIN
+#define MIN(a,b)	((a) < (b) ? (a) : (b))
+#endif
+
+
+
+/*
+ * tmp_buf is used as a temporary buffer by serial_write.  We need to
+ * lock it in case the memcpy_fromfs blocks while swapping in a page,
+ * and some other program tries to do a serial write at the same time.
+ * Since the lock will only come under contention when the system is
+ * swapping and available memory is low, it makes sense to share one
+ * buffer across all the serial ports, since it significantly saves
+ * memory if large numbers of serial ports are open.
+ */
+static unsigned char tmp_buf[SERIAL_XMIT_SIZE];	/* This is cheating */
+DECLARE_MUTEX(tmp_buf_sem);
+
+static inline int serial_paranoia_check(struct atmel_serial *info,
+					char *name, const char *routine)
+{
+#ifdef SERIAL_PARANOIA_CHECK
+	static const char *badmagic =
+		"Warning: bad magic number for serial struct %s in %s\n";
+	static const char *badinfo =
+		"Warning: null atmel_serial struct for %s in %s\n";
+
+	if (!info) {
+		printk(badinfo, name, routine);
+		return 1;
+	}
+	if (info->magic != SERIAL_MAGIC) {
+		printk(badmagic, name, routine);
+		return 1;
+	}
+#endif
+	return 0;
+}
+
+static unsigned char * rx_buf_table[AT91_USART_CNT];
+
+static unsigned char rx_buf1[RX_SERIAL_SIZE];
+static unsigned char rx_buf2[RX_SERIAL_SIZE];
+
+/* Console hooks... */
+
+static void serpoll(void *data);
+
+static void change_speed(struct atmel_serial *info);
+
+static char prompt0;
+static void xmit_char(struct atmel_serial *info, char ch);
+static void xmit_string(struct atmel_serial *info, char *p, int len);
+static void start_rx(struct atmel_serial *info);
+static void wait_EOT(volatile struct atmel_usart_regs *);
+static void uart_init(struct atmel_serial *info);
+static void uart_speed(struct atmel_serial *info, unsigned cflag);
+
+static void tx_enable(volatile struct atmel_usart_regs *uart);
+static void rx_enable(volatile struct atmel_usart_regs *uart);
+static void tx_disable(volatile struct atmel_usart_regs *uart);
+static void rx_disable(volatile struct atmel_usart_regs *uart);
+static void tx_stop(volatile struct atmel_usart_regs *uart);
+static void tx_start(volatile struct atmel_usart_regs *uart);
+static void rx_stop(volatile struct atmel_usart_regs *uart);
+static void rx_start(volatile struct atmel_usart_regs *uart, int ints);
+static void set_ints_mode(int yes, struct atmel_serial *info);
+static irqreturn_t rs_interrupt(struct atmel_serial *info);
+extern void show_net_buffers(void);
+extern void hard_reset_now(void);
+static void handle_termios_tcsets(struct termios * ptermios, struct atmel_serial * ptty);
+
+static int global;
+
+static void coucou1(void)
+{
+	global = 0;
+}
+
+static void coucou2(void)
+{
+	global = 1;
+}
+static void _INLINE_ tx_enable(volatile struct atmel_usart_regs *uart)
+{
+	uart->ier = US_TXEMPTY;
+}
+static void _INLINE_ rx_enable(volatile struct atmel_usart_regs *uart)
+{
+	uart->ier = US_ENDRX | US_TIMEOUT;
+}
+static void _INLINE_ tx_disable(volatile struct atmel_usart_regs *uart)
+{
+	uart->idr = US_TXEMPTY;
+}
+static void _INLINE_ rx_disable(volatile struct atmel_usart_regs *uart)
+{
+	uart->idr = US_ENDRX | US_TIMEOUT;
+}
+static void _INLINE_ tx_stop(volatile struct atmel_usart_regs *uart)
+{
+	tx_disable(uart);
+	uart->tcr = 0;
+	uart->cr = US_TXDIS;
+}
+static void _INLINE_ tx_start(volatile struct atmel_usart_regs *uart)
+{
+	tx_enable(uart);
+	uart->cr = US_TXEN;
+}
+static void _INLINE_ rx_stop(volatile struct atmel_usart_regs *uart)
+{
+	rx_disable(uart);
+	uart->rtor = 0;
+	// PSW fixes slew of ^@ chars on a TCSETA ioctl 
+        //uart->rcr = 0;
+	uart->cr = US_RXDIS;
+}
+static void _INLINE_ rx_start(volatile struct atmel_usart_regs *uart, int ints)
+{
+	uart->cr = US_RXEN | US_STTO;
+	uart->rtor = 20;
+	if (ints) {
+		rx_enable(uart);
+	}
+}
+static void _INLINE_ reset_status(volatile struct atmel_usart_regs *uart)
+{
+	uart->cr = US_RSTSTA;
+}
+static void set_ints_mode(int yes, struct atmel_serial *info)
+{
+	info->use_ints = yes;
+// FIXME: check
+#if 0
+	(yes) ? unmask_irq(info->irq) : mask_irq(info->irq);
+#endif
+}
+
+#ifdef US_RTS
+static void atmel_cts_off(struct atmel_serial *info)
+{
+	volatile struct atmel_usart_regs *uart;
+
+	uart = info->usart;
+	uart->mc &= ~(unsigned long) US_RTS;
+	info->cts_state = 0;
+}
+static void atmel_cts_on(struct atmel_serial *info)
+{
+	volatile struct atmel_usart_regs *uart;
+
+	uart = info->usart;
+	uart->mc |= US_RTS;
+	info->cts_state = 1;
+}
+/* Sets or clears DTR/RTS on the requested line */
+static inline void atmel_rtsdtr(struct atmel_serial *ss, int set)
+{
+        volatile struct atmel_usart_regs *uart;
+
+        uart = ss->usart;
+        if (set) {
+              uart->mc |= US_DTR | US_RTS;
+        } else {
+              uart->mc &= ~(unsigned long) (US_DTR | US_RTS);
+        }
+        return;
+}
+#endif	/* US_RTS */
+
+/*
+ * ------------------------------------------------------------
+ * rs_stop() and rs_start()
+ *
+ * This routines are called before setting or resetting tty->stopped.
+ * They enable or disable transmitter interrupts, as necessary.
+ * ------------------------------------------------------------
+ */
+static void rs_stop(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->name, "rs_stop"))
+		return;
+
+	save_flags(flags); cli();
+	tx_stop(info->usart);
+	rx_stop(info->usart);
+	restore_flags(flags);
+}
+
+static void rs_put_char(struct atmel_serial *info, char ch)
+{
+	int flags = 0;
+
+	save_flags(flags); cli();
+	xmit_char(info, ch);
+	wait_EOT(info->usart);
+	restore_flags(flags);
+}
+
+static void rs_start(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->name, "rs_start"))
+		return;
+
+	save_flags(flags); cli();
+	tx_start(info->usart);
+	rx_start(info->usart, info->use_ints);
+	/* FIXME */
+//	start_rx(info);
+	restore_flags(flags);
+}
+
+/* Drop into either the boot monitor or kadb upon receiving a break
+ * from keyboard/console input.
+ */
+static void batten_down_hatches(void)
+{
+	/* Drop into the debugger */
+}
+
+static _INLINE_ void status_handle(struct atmel_serial *info, unsigned long status)
+{
+#if 0
+	if (status & DCD) {
+		if ((info->tty->termios->c_cflag & CRTSCTS) &&
+			((info->curregs[3] & AUTO_ENAB) == 0)) {
+			info->curregs[3] |= AUTO_ENAB;
+			info->pendregs[3] |= AUTO_ENAB;
+			write_zsreg(info->atmel_channel, 3, info->curregs[3]);
+		}
+	} else {
+		if ((info->curregs[3] & AUTO_ENAB)) {
+			info->curregs[3] &= ~AUTO_ENAB;
+			info->pendregs[3] &= ~AUTO_ENAB;
+			write_zsreg(info->atmel_channel, 3, info->curregs[3]);
+		}
+	}
+#endif
+	/* Whee, if this is console input and this is a
+	 * 'break asserted' status change interrupt, call
+	 * the boot prom.
+	 */
+	if ((status & US_RXBRK) && info->break_abort)
+		batten_down_hatches();
+
+	/* XXX Whee, put in a buffer somewhere, the status information
+	 * XXX whee whee whee... Where does the information go...
+	 */
+	reset_status(info->usart);
+	return;
+}
+
+static _INLINE_ void receive_chars(struct atmel_serial *info, unsigned long status)
+{
+	int count;
+	volatile struct atmel_usart_regs *uart = info->usart;
+
+	struct tty_struct *tty = info->tty;
+
+	if (!(info->flags & S_INITIALIZED))
+		return;
+	count = RX_SERIAL_SIZE - uart->rcr;
+	// hack to receive chars by polling only BD fields
+	if (!count) {
+		return;
+	}
+
+	if (!tty)
+		goto clear_and_exit;
+
+	if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+		schedule_work(&tty->flip.work);
+
+	if ((count + tty->flip.count) >= TTY_FLIPBUF_SIZE) {
+#ifdef US_RTS
+		atmel_cts_off(info);
+#endif
+		serialpoll.data = (void *) info;
+		schedule_work(&serialpoll);
+	}
+	memset(tty->flip.flag_buf_ptr, 0, count);
+	memcpy(tty->flip.char_buf_ptr, info->rx_buf, count);
+	tty->flip.char_buf_ptr += count;
+
+	if (status & US_PARE)
+		*(tty->flip.flag_buf_ptr - 1) = TTY_PARITY;
+	else if (status & US_OVRE)
+		*(tty->flip.flag_buf_ptr - 1) = TTY_OVERRUN;
+	else if (status & US_FRAME)
+		*(tty->flip.flag_buf_ptr - 1) = TTY_FRAME;
+
+	tty->flip.count += count;
+
+	schedule_work(&tty->flip.work);
+
+  clear_and_exit:
+	start_rx(info);
+	return;
+}
+
+static _INLINE_ void transmit_chars(struct atmel_serial *info)
+{
+	if (info->x_char) {
+		/* Send next char */
+		xmit_char(info, info->x_char);
+		info->x_char = 0;
+		goto clear_and_return;
+	}
+
+	if ((info->xmit_cnt <= 0) || info->tty->stopped) {
+		/* That's peculiar... */
+		tx_stop(info->usart);
+		goto clear_and_return;
+	}
+
+	if (info->xmit_tail + info->xmit_cnt < SERIAL_XMIT_SIZE) {
+		xmit_string(info, info->xmit_buf + info->xmit_tail,
+					info->xmit_cnt);
+		info->xmit_tail =
+			(info->xmit_tail + info->xmit_cnt) & (SERIAL_XMIT_SIZE - 1);
+		info->xmit_cnt = 0;
+	} else {
+		coucou1();
+		xmit_string(info, info->xmit_buf + info->xmit_tail,
+					SERIAL_XMIT_SIZE - info->xmit_tail);
+		//xmit_string(info, info->xmit_buf, info->xmit_tail + info->xmit_cnt - SERIAL_XMIT_SIZE);
+		info->xmit_cnt =
+			info->xmit_cnt - (SERIAL_XMIT_SIZE - info->xmit_tail);
+		info->xmit_tail = 0;
+	}
+
+	if (info->xmit_cnt < WAKEUP_CHARS)
+		schedule_work(&info->tqueue);
+
+	if (info->xmit_cnt <= 0) {
+		//tx_stop(info->usart);
+		goto clear_and_return;
+	}
+
+  clear_and_return:
+	/* Clear interrupt (should be auto) */
+	return;
+}
+
+/*
+ * This is the serial driver's generic interrupt routine
+ */
+static irqreturn_t rs_interrupta(int irq, void *dev_id, struct pt_regs *regs)
+{
+	return rs_interrupt(&atmel_info[0]);
+}
+static irqreturn_t rs_interruptb(int irq, void *dev_id, struct pt_regs *regs)
+{
+	return rs_interrupt(&atmel_info[1]);
+}
+static irqreturn_t rs_interrupt(struct atmel_serial *info)
+{
+	unsigned long status;
+
+	status = info->usart->csr;
+	if (status & (US_ENDRX | US_TIMEOUT)) {
+		receive_chars(info, status);
+	}
+	if (status & (US_TXEMPTY)) {
+		transmit_chars(info);
+	}
+	status_handle(info, status);
+
+#ifdef US_RTS
+	if (!info->cts_state) {
+		if (info->tty->flip.count < TTY_FLIPBUF_SIZE - RX_SERIAL_SIZE) {
+			atmel_cts_on(info);
+		}
+	}
+#endif
+	if (!info->use_ints) {
+		serialpoll.data = (void *) info;
+		schedule_work(&serialpoll);
+	}
+	return IRQ_HANDLED;
+}
+static void serpoll(void *data)
+{
+	struct atmel_serial *info = data;
+
+	rs_interrupt(info);
+}
+
+/*
+ * -------------------------------------------------------------------
+ * Here ends the serial interrupt routines.
+ * -------------------------------------------------------------------
+ */
+
+
+static void do_softint(void *private_)
+{
+	struct atmel_serial *info = (struct atmel_serial *) private_;
+	struct tty_struct *tty;
+
+	tty = info->tty;
+	if (!tty)
+		return;
+#if 0 	// FIXME - CHECK
+	if (clear_bit(RS_EVENT_WRITE_WAKEUP, &info->event)) {
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+			tty->ldisc.write_wakeup) (tty->ldisc.write_wakeup) (tty);
+		wake_up_interruptible(&tty->write_wait);
+	}
+#endif
+}
+
+/*
+ * This routine is called from the scheduler tqueue when the interrupt
+ * routine has signalled that a hangup has occurred.  The path of
+ * hangup processing is:
+ *
+ * 	serial interrupt routine -> (scheduler tqueue) ->
+ * 	do_serial_hangup() -> tty->hangup() -> rs_hangup()
+ *
+ */
+static void do_serial_hangup(void *private_)
+{
+	struct atmel_serial *info = (struct atmel_serial *) private_;
+	struct tty_struct *tty;
+
+	tty = info->tty;
+	if (!tty)
+		return;
+
+	tty_hangup(tty);
+}
+
+
+/*
+ * This subroutine is called when the RS_TIMER goes off.  It is used
+ * by the serial driver to handle ports that do not have an interrupt
+ * (irq=0).  This doesn't work at all for 16450's, as a sun has a Z8530.
+ */
+#if 0
+static void rs_timer(void)
+{
+	panic("rs_timer called\n");
+	return;
+}
+#endif
+
+static unsigned long calcCD(unsigned long br)
+{
+	return (UART_CLOCK / br);
+}
+
+static void uart_init(struct atmel_serial *info)
+{
+	volatile struct atmel_usart_regs *uart;
+
+	if (info) {
+		uart = info->usart;
+	} else {
+		uart = usarts[0];
+	}
+
+	/* Reset the USART */
+	uart->cr = US_TXDIS | US_RXDIS | US_RSTTX | US_RSTRX;
+	/* clear Rx receive and Tx sent counters */
+	uart->rcr = 0;
+	uart->tcr = 0;
+
+	/* Disable interrups till we say we want them */
+	tx_disable(info->usart);
+	rx_disable(info->usart);
+	
+	/* Set the serial port into a safe sane state */
+	uart->mr = US_USCLKS(0) | US_CLK0 | US_CHMODE(0) | US_NBSTOP(0) |
+		    US_PAR(4) | US_CHRL(3);
+
+#ifndef FORCE_57600
+	uart->brgr = calcCD(9600);
+#else
+	uart->brgr = calcCD(57600);
+#endif
+
+	uart->rtor = 20;			// timeout = value * 4 *bit period
+	uart->ttgr = 0;				// no guard time
+	uart->rcr = 0;
+	uart->rpr = 0;
+	uart->tcr = 0;
+	uart->tpr = 0;
+#ifdef US_RTS
+	uart->mc = 0; 
+#endif
+}
+
+/* It is the responsibilty of whoever calls this function to be sure
+ * that that have called
+ *	tx_stop(uart); rx_stop(uart);
+ * before calling the function.  Failure to do this will cause messy
+ * things to happen.  You have been warned.   */
+static void uart_speed(struct atmel_serial *info, unsigned cflag)
+{
+	unsigned baud = info->baud;
+	volatile struct atmel_usart_regs *uart = info->usart;
+
+	// disable tx and rx
+	uart->cr = US_TXDIS | US_RXDIS;
+	
+	// disable interrupts
+	tx_disable(uart);
+	rx_disable(uart);
+	
+#ifndef FORCE_57600
+	uart->brgr = calcCD(baud);
+#else
+	uart->brgr = calcCD(57600);
+#endif
+/* FIXME */
+#if 0
+	/* probably not needed */
+	uart->US_RTOR = 20;			// timeout = value * 4 *bit period
+	uart->US_TTGR = 0;				// no guard time
+	uart->US_RPR = 0;
+	uart->US_RCR = 0;
+	uart->US_TPR = 0;
+	uart->US_TCR = 0;
+#endif
+
+
+/* FIXME */
+#if 0
+	uart->mc = 0;
+	if (cflag != 0xffff) {
+		uart->mr = US_USCLKS(0) | US_CLK0 | US_CHMODE(0) | US_NBSTOP(0) |
+		    US_PAR(0);
+
+		if ((cflag & CSIZE) == CS8)
+			uart->mr |= US_CHRL(3);	// 8 bit char
+		else
+			uart->mr |= US_CHRL(2);	// 7 bit char
+
+		if (cflag & CSTOPB)
+			uart->mr |= US_NBSTOP(2);	// 2 stop bits
+
+		if (!(cflag & PARENB))
+			uart->mr |= US_PAR(4);	// parity disabled
+		else if (cflag & PARODD)
+			uart->mr |= US_PAR(1);	// odd parity
+	}
+#endif	
+	
+/* FIXME */
+#if 0
+	// enable tx and rx
+	uart->cr = US_TXEN | US_RXEN;
+	
+	// enable interrupts
+	tx_enable();
+	rx_enable();
+#endif
+	tx_start(uart);
+	start_rx(info);
+}
+
+static void wait_EOT(volatile struct atmel_usart_regs *uart)
+{
+	// make sure tx is enabled
+	uart->cr = US_TXEN;
+	
+	// wait until all chars sent FIXME - is this sane ?
+	while (1) {
+		if (uart->csr & US_TXEMPTY)
+			break;
+	}
+}
+static int startup(struct atmel_serial *info)
+{
+	unsigned long flags;
+
+	if (info->flags & S_INITIALIZED)
+		return 0;
+
+	if (!info->xmit_buf) {
+		info->xmit_buf = (unsigned char *) __get_free_page(GFP_KERNEL);
+		if (!info->xmit_buf)
+			return -ENOMEM;
+	}
+	if (!info->rx_buf) {
+	    //info->rx_buf = (unsigned char *) ))__get_free_page(GFP_KERNEL);
+		//info->rx_buf = rx_buf1;
+		if (!info->rx_buf)
+			return -ENOMEM;
+	}
+	save_flags(flags);
+	cli();
+#ifdef SERIAL_DEBUG_OPEN
+	printk("starting up ttyS%d (irq %d)...\n", info->line, info->irq);
+#endif
+	/*
+	 * Clear the FIFO buffers and disable them
+	 * (they will be reenabled in change_speed())
+	 */
+
+	if (info->tty)
+		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
+
+	/*
+	 * and set the speed of the serial port
+	 */
+
+	uart_init(info);
+	//set_ints_mode(0, info);
+	change_speed(info);
+	info->flags |= S_INITIALIZED;
+	restore_flags(flags);
+	return 0;
+}
+
+/*
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ */
+static void shutdown(struct atmel_serial *info)
+{
+	unsigned long flags;
+
+	tx_disable(info->usart);
+	rx_disable(info->usart);
+	rx_stop(info->usart);		/* All off! */
+	if (!(info->flags & S_INITIALIZED))
+		return;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("Shutting down serial port %d (irq %d)....\n", info->line,
+		   info->irq);
+#endif
+
+	save_flags(flags);
+	cli();						/* Disable interrupts */
+
+	if (info->xmit_buf) {
+		free_page((unsigned long) info->xmit_buf);
+		info->xmit_buf = 0;
+	}
+
+	if (info->tty)
+		set_bit(TTY_IO_ERROR, &info->tty->flags);
+
+	info->flags &= ~S_INITIALIZED;
+	restore_flags(flags);
+}
+
+/* rate = 1036800 / ((65 - prescale) * (1<<divider)) */
+
+static int baud_table[] = {
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
+	9600, 19200, 38400, 57600, 115200, 0
+};
+
+/*
+ * This routine is called to set the UART divisor registers to match
+ * the specified baud rate for a serial port.
+ */
+static void change_speed(struct atmel_serial *info)
+{
+	unsigned cflag;
+	int      i;
+
+	if (!info->tty || !info->tty->termios)
+		return;
+	cflag = info->tty->termios->c_cflag;
+
+	// disable tx and rx
+	info->usart->cr = US_TXDIS | US_RXDIS;
+	
+	/* First disable the interrupts */
+	tx_stop(info->usart);
+	rx_stop(info->usart);
+
+	/* set the baudrate */
+	i = cflag & CBAUD;
+
+	info->baud = baud_table[i];
+	uart_speed(info, cflag);
+	tx_start(info->usart);
+	rx_start(info->usart, info->use_ints);
+
+	// enable tx and rx
+	info->usart->cr = US_TXEN | US_RXEN;
+	
+	return;
+}
+
+static void start_rx(struct atmel_serial *info)
+{
+	volatile struct atmel_usart_regs *uart = info->usart;
+
+	rx_stop(uart);
+/*  FIXME - rehnberg
+	if (info->rx_buf == rx_buf1) {
+		info->rx_buf = rx_buf2;
+	} else {
+		info->rx_buf = rx_buf1;
+	}
+*/
+	uart->rpr = (unsigned long) info->rx_buf;
+	uart->rcr = (unsigned long) RX_SERIAL_SIZE;
+	rx_start(uart, info->use_ints);
+}
+static void xmit_char(struct atmel_serial *info, char ch)
+{
+	prompt0 = ch;
+	xmit_string(info, &prompt0, 1);
+}
+static void xmit_string(struct atmel_serial *info, char *p, int len)
+{
+	info->usart->tcr = 0;
+	info->usart->tpr = (unsigned long) p;
+	info->usart->tcr = (unsigned long) len;
+	tx_start(info->usart);
+}
+
+/*
+ * atmel_console_print is registered for printk.
+ */
+int atmel_console_initialized;
+
+static void init_console(struct atmel_serial *info)
+{
+	memset(info, 0, sizeof(struct atmel_serial));
+
+#ifdef CONFIG_SWAP_ATMEL_PORTS
+	info->usart = (volatile struct atmel_usart_regs *) AT91_USART1_BASE;
+	info->irqmask = AIC_URT1;
+	info->irq = IRQ_USART1;
+#else
+	info->usart = (volatile struct atmel_usart_regs *) AT91_USART0_BASE;
+	info->irqmask = 1<<IRQ_USART0;
+	info->irq = IRQ_USART0;
+#endif
+	info->tty = 0;
+	info->port = 0;
+	info->use_ints = 0;
+	info->cts_state = 1;
+	info->is_cons = 1;
+	atmel_console_initialized = 1;
+}
+
+
+void console_print_atmel(const char *p)
+{
+	char c;
+	struct atmel_serial *info;
+
+#ifdef CONFIG_SWAP_ATMEL_PORTS
+	info = &atmel_info[1];
+#else
+	info = &atmel_info[0];
+#endif
+
+	if (!atmel_console_initialized) {
+		init_console(info);
+		uart_init(info);
+		info->baud = 9600;
+		tx_stop(info->usart);
+		rx_stop(info->usart);
+		uart_speed(info, 0xffff);
+		tx_start(info->usart);
+		rx_start(info->usart, info->use_ints);
+	}
+
+	while ((c = *(p++)) != 0) {
+		if (c == '\n')
+			rs_put_char(info, '\r');
+		rs_put_char(info, c);
+	}
+
+	/* Comment this if you want to have a strict interrupt-driven output */
+#if 0
+	if (!info->use_ints)
+	    rs_fair_output(info);
+#endif
+
+	return;
+}
+
+static void rs_set_ldisc(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->name, "rs_set_ldisc"))
+		return;
+
+	info->is_cons = (tty->termios->c_line == N_TTY);
+
+	printk("ttyS%d console mode %s\n", info->line,
+		   info->is_cons ? "on" : "off");
+}
+
+static void rs_flush_chars(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->name, "rs_flush_chars"))
+		return;
+	if (!info->use_ints) {
+		for (;;) {
+			if (info->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
+				!info->xmit_buf) return;
+
+			/* Enable transmitter */
+			save_flags(flags);
+			cli();
+			tx_start(info->usart);
+		}
+	} else {
+		if (info->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
+			!info->xmit_buf) return;
+
+		/* Enable transmitter */
+		save_flags(flags);
+		cli();
+		tx_start(info->usart);
+	}
+
+	if (!info->use_ints)
+		wait_EOT(info->usart);
+	/* Send char */
+	xmit_char(info, info->xmit_buf[info->xmit_tail++]);
+	info->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE - 1);
+	info->xmit_cnt--;
+
+	restore_flags(flags);
+}
+
+extern void console_printn(const char *b, int count);
+
+static int rs_write(struct tty_struct *tty, int from_user,
+					const unsigned char *buf, int count)
+{
+	int c, total = 0;
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->name, "rs_write"))
+		return 0;
+
+	if (!tty || !info->xmit_buf)
+		return 0;
+
+	save_flags(flags);
+	while (1) {
+		cli();
+		c = MIN(count, MIN(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+						   SERIAL_XMIT_SIZE - info->xmit_head));
+		if (c <= 0)
+			break;
+
+		if (from_user) {
+			down(&tmp_buf_sem);
+			copy_from_user(tmp_buf, buf, c);
+			memcpy(info->xmit_buf + info->xmit_head, tmp_buf, c);
+			up(&tmp_buf_sem);
+		} else {
+			memcpy(info->xmit_buf + info->xmit_head, buf, c);
+		}
+		info->xmit_head = (info->xmit_head + c) & (SERIAL_XMIT_SIZE - 1);
+		info->xmit_cnt += c;
+		restore_flags(flags);
+		buf += c;
+		count -= c;
+		total += c;
+	}
+
+	if (info->xmit_cnt && !tty->stopped && !tty->hw_stopped) {
+		/* Enable transmitter */
+
+		cli();
+		/*printk("Enabling transmitter\n"); */
+
+		if (!info->use_ints) {
+			while (info->xmit_cnt) {
+				wait_EOT(info->usart);
+				/* Send char */
+				xmit_char(info, info->xmit_buf[info->xmit_tail++]);
+				wait_EOT(info->usart);
+				info->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE - 1);
+				info->xmit_cnt--;
+			}
+		} else {
+			if (info->xmit_cnt) {
+				/* Send char */
+				wait_EOT(info->usart);
+				if (info->xmit_tail + info->xmit_cnt < SERIAL_XMIT_SIZE) {
+					xmit_string(info, info->xmit_buf + info->xmit_tail,
+								info->xmit_cnt);
+					info->xmit_tail =
+						(info->xmit_tail +
+						 info->xmit_cnt) & (SERIAL_XMIT_SIZE - 1);
+					info->xmit_cnt = 0;
+				} else {
+					coucou2();
+					xmit_string(info, info->xmit_buf + info->xmit_tail,
+								SERIAL_XMIT_SIZE - info->xmit_tail);
+					//xmit_string(info, info->xmit_buf, info->xmit_tail + info->xmit_cnt - SERIAL_XMIT_SIZE);
+					info->xmit_cnt =
+						info->xmit_cnt - (SERIAL_XMIT_SIZE - info->xmit_tail);
+					info->xmit_tail = 0;
+				}
+			}
+		}
+	} else {
+		/*printk("Skipping transmit\n"); */
+	}
+
+#if 0
+	printk("Enabling stuff anyhow\n");
+	tx_start(0);
+
+	if (SCC_EOT(0, 0)) {
+		printk("TX FIFO empty.\n");
+		/* Send char */
+		atmel_xmit_char(info->usart, info->xmit_buf[info->xmit_tail++]);
+		info->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE - 1);
+		info->xmit_cnt--;
+	}
+#endif
+
+	restore_flags(flags);
+	return total;
+}
+
+static int rs_write_room(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	int ret;
+
+	if (serial_paranoia_check(info, tty->name, "rs_write_room"))
+		return 0;
+	ret = SERIAL_XMIT_SIZE - info->xmit_cnt - 1;
+	if (ret < 0)
+		ret = 0;
+	return ret;
+}
+
+static int rs_chars_in_buffer(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->name, "rs_chars_in_buffer"))
+		return 0;
+	return info->xmit_cnt;
+}
+
+static void rs_flush_buffer(struct tty_struct *tty)
+{
+	unsigned long flags;
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->name, "rs_flush_buffer"))
+		return;
+	save_flags(flags);
+	cli();
+	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
+	restore_flags(flags);
+	wake_up_interruptible(&tty->write_wait);
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+		tty->ldisc.write_wakeup) (tty->ldisc.write_wakeup) (tty);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_throttle()
+ *
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled.
+ * ------------------------------------------------------------
+ */
+static void rs_throttle(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+#ifdef SERIAL_DEBUG_THROTTLE
+	char buf[64];
+
+	printk("throttle %s: %d....\n", _tty_name(tty, buf),
+		   tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (serial_paranoia_check(info, tty->name, "rs_throttle"))
+		return;
+
+	if (I_IXOFF(tty))
+		info->x_char = STOP_CHAR(tty);
+
+	/* Turn off RTS line (do this atomic) */
+}
+
+static void rs_unthrottle(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+#ifdef SERIAL_DEBUG_THROTTLE
+	char buf[64];
+
+	printk("unthrottle %s: %d....\n", _tty_name(tty, buf),
+		   tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (serial_paranoia_check(info, tty->name, "rs_unthrottle"))
+		return;
+
+	if (I_IXOFF(tty)) {
+		if (info->x_char)
+			info->x_char = 0;
+		else
+			info->x_char = START_CHAR(tty);
+	}
+
+	/* Assert RTS line (do this atomic) */
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_ioctl() and friends
+ * ------------------------------------------------------------
+ */
+
+static int get_serial_info(struct atmel_serial *info,
+						   struct serial_struct *retinfo)
+{
+	struct serial_struct tmp;
+
+	if (!retinfo)
+		return -EFAULT;
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.type = info->type;
+	tmp.line = info->line;
+	tmp.port = info->port;
+	tmp.irq = info->irq;
+	tmp.flags = info->flags;
+	tmp.baud_base = info->baud_base;
+	tmp.close_delay = info->close_delay;
+	tmp.closing_wait = info->closing_wait;
+	tmp.custom_divisor = info->custom_divisor;
+	copy_to_user(retinfo, &tmp, sizeof(*retinfo));
+	return 0;
+}
+
+static int set_serial_info(struct atmel_serial *info,
+						   struct serial_struct *new_info)
+{
+	struct serial_struct new_serial;
+	struct atmel_serial old_info;
+	int retval = 0;
+
+	if (!new_info)
+		return -EFAULT;
+	copy_from_user(&new_serial, new_info, sizeof(new_serial));
+	old_info = *info;
+
+	if (!capable(CAP_SYS_ADMIN)) {
+		if ((new_serial.baud_base != info->baud_base) ||
+			(new_serial.type != info->type) ||
+			(new_serial.close_delay != info->close_delay) ||
+			((new_serial.flags & ~S_USR_MASK) !=
+		     (info->flags & ~S_USR_MASK)))
+			return -EPERM;
+		info->flags = ((info->flags & ~S_USR_MASK) |
+					   (new_serial.flags & S_USR_MASK));
+		info->custom_divisor = new_serial.custom_divisor;
+		goto check_and_exit;
+	}
+
+	if (info->count > 1)
+		return -EBUSY;
+
+	/*
+	 * OK, past this point, all the error checking has been done.
+	 * At this point, we start making changes.....
+	 */
+
+	info->baud_base = new_serial.baud_base;
+	info->flags = ((info->flags & ~S_FLAGS) |
+				   (new_serial.flags & S_FLAGS));
+	info->type = new_serial.type;
+	info->close_delay = new_serial.close_delay;
+	info->closing_wait = new_serial.closing_wait;
+
+  check_and_exit:
+	//retval = startup(info);
+	change_speed(info);
+	retval = 0;
+	return retval;
+}
+
+/*
+ * get_lsr_info - get line status register info
+ *
+ * Purpose: Let user call ioctl() to get info when the UART physically
+ * 	    is emptied.  On bus types like RS485, the transmitter must
+ * 	    release the bus after transmitting. This must be done when
+ * 	    the transmit shift register is empty, not be done when the
+ * 	    transmit holding register is empty.  This functionality
+ * 	    allows an RS485 driver to be written in user space.
+ */
+static int get_lsr_info(struct atmel_serial *info, unsigned int *value)
+{
+	unsigned char status;
+
+	cli();
+	status = info->usart->csr;
+	status &= US_TXEMPTY;
+	sti();
+	put_user(status, value);
+	return 0;
+}
+
+/*
+ * This routine sends a break character out the serial port.
+ */
+static void send_break(struct atmel_serial *info, int duration)
+{
+        unsigned long flags;
+        if (!info->port)  return;
+
+	current->state = TASK_INTERRUPTIBLE;
+	save_flags(flags); cli();
+	info->usart->cr = US_STTBRK;
+	if (!info->use_ints) {
+		while (US_TXRDY != (info->usart->csr & US_TXRDY)) {
+			;					// this takes max 2ms at 9600
+		}
+		info->usart->cr = US_STPBRK;
+	}
+	restore_flags(flags);
+}
+
+static int rs_ioctl(struct tty_struct *tty, struct file *file,
+					unsigned int cmd, unsigned long arg)
+{
+	int error;
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	int retval;
+
+	if (serial_paranoia_check(info, tty->name, "rs_ioctl"))
+		return -ENODEV;
+
+	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+		(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGWILD) &&
+		(cmd != TIOCSERSWILD) && (cmd != TIOCSERGSTRUCT)) {
+		if (tty->flags & (1 << TTY_IO_ERROR))
+			return -EIO;
+	}
+
+	switch (cmd) {
+	case TCSBRK:				/* SVID version: non-zero arg --> no break */
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		if (!arg)
+			send_break(info, HZ / 4);	/* 1/4 second */
+		return 0;
+	case TCSBRKP:				/* support for POSIX tcsendbreak() */
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		send_break(info, arg ? arg * (HZ / 10) : HZ / 4);
+		return 0;
+	case TIOCGSOFTCAR:
+		error = verify_area(VERIFY_WRITE, (void *) arg, sizeof(long));
+		if (error)
+			return error;
+		put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long *) arg);
+		return 0;
+	case TIOCSSOFTCAR:
+		arg = get_user(arg,(unsigned long *) arg);
+		tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) | (arg ? CLOCAL : 0));
+		return 0;
+	case TIOCGSERIAL:
+		error = verify_area(VERIFY_WRITE, (void *) arg, sizeof(struct serial_struct));
+		if (error)
+			return error;
+		return get_serial_info(info, (struct serial_struct *) arg);
+	case TIOCSSERIAL:
+		return set_serial_info(info, (struct serial_struct *) arg);
+	case TIOCSERGETLSR:		/* Get line status register */
+		error = verify_area(VERIFY_WRITE, (void *) arg,
+			sizeof(unsigned int));
+		if (error)
+			return error;
+		else
+			return get_lsr_info(info, (unsigned int *) arg);
+
+	case TIOCSERGSTRUCT:
+		error = verify_area(VERIFY_WRITE, (void *) arg,
+			sizeof(struct atmel_serial));
+		if (error)
+			return error;
+		copy_to_user((struct atmel_serial *) arg, info,
+			sizeof(struct atmel_serial));
+		return 0;
+
+	case TCSETS:	
+		handle_termios_tcsets((struct termios *)arg, info);
+		//		return set_serial_info(info, (struct serial_struct *) arg);
+		break;	
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+static void handle_termios_tcsets(struct termios * ptermios, struct atmel_serial * pinfo )
+{
+	/*
+	 * hmmmm....
+	 */
+	if (pinfo->tty->termios->c_cflag != ptermios->c_cflag)
+		pinfo->tty->termios->c_cflag = ptermios->c_cflag;
+	change_speed(pinfo);
+}
+	  
+static void rs_set_termios(struct tty_struct *tty,
+	struct termios *old_termios)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (tty->termios->c_cflag == old_termios->c_cflag)
+		return;
+
+	change_speed(info);
+
+	if ((old_termios->c_cflag & CRTSCTS) &&
+		!(tty->termios->c_cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		rs_start(tty);
+	}
+
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_close()
+ *
+ * This routine is called when the serial port gets closed.  First, we
+ * wait for the last remaining data to be sent.  Then, we unlink its
+ * S structure from the interrupt chain if necessary, and we free
+ * that IRQ if nothing is left in the chain.
+ * ------------------------------------------------------------
+ */
+static void rs_close(struct tty_struct *tty, struct file *filp)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	unsigned long flags;
+
+	if (!info || serial_paranoia_check(info, tty->name, "rs_close"))
+		return;
+
+	save_flags(flags);
+	cli();
+
+	if (tty_hung_up_p(filp)) {
+		restore_flags(flags);
+		return;
+	}
+#ifdef SERIAL_DEBUG_OPEN
+	printk("rs_close ttyS%d, count = %d\n", info->line, info->count);
+#endif
+	if ((tty->count == 1) && (info->count != 1)) {
+		/*
+		 * Uh, oh.  tty->count is 1, which means that the tty
+		 * structure will be freed.  Info->count should always
+		 * be one in these conditions.  If it's greater than
+		 * one, we've got real problems, since it means the
+		 * serial port won't be shutdown.
+		 */
+		printk("rs_close: bad serial port count; tty->count is 1, "
+			   "info->count is %d\n", info->count);
+		info->count = 1;
+	}
+	if (--info->count < 0) {
+		printk("rs_close: bad serial port count for ttyS%d: %d\n",
+			   info->line, info->count);
+		info->count = 0;
+	}
+	if (info->count) {
+		restore_flags(flags);
+		return;
+	}
+	// closing port so disable interrupts
+	set_ints_mode(0, info);
+
+	info->flags |= S_CLOSING;
+	/*
+	 * Now we wait for the transmit buffer to clear; and we notify
+	 * the line discipline to only process XON/XOFF characters.
+	 */
+	tty->closing = 1;
+	if (info->closing_wait != S_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->closing_wait);
+	/*
+	 * At this point we stop accepting input.  To do this, we
+	 * disable the receive line status interrupts, and tell the
+	 * interrupt driver to stop checking the data ready bit in the
+	 * line status register.
+	 */
+
+	shutdown(info);
+	if (tty->driver->flush_buffer)
+		tty->driver->flush_buffer(tty);
+	if (tty->ldisc.flush_buffer)
+		tty->ldisc.flush_buffer(tty);
+	tty->closing = 0;
+	info->event = 0;
+	info->tty = 0;
+#warning "This is not and has never been valid so fix it"	
+#if 0
+	if (tty->ldisc.num != ldiscs[N_TTY].num) {
+		if (tty->ldisc.close)
+			(tty->ldisc.close) (tty);
+		tty->ldisc = ldiscs[N_TTY];
+		tty->termios->c_line = N_TTY;
+		if (tty->ldisc.open)
+			(tty->ldisc.open) (tty);
+	}
+#endif
+	if (info->blocked_open) {
+		if (info->close_delay) {
+			current->state = TASK_INTERRUPTIBLE;
+			schedule_timeout(info->close_delay);
+		}
+		wake_up_interruptible(&info->open_wait);
+	}
+	info->flags &= ~(S_NORMAL_ACTIVE | S_CALLOUT_ACTIVE | S_CLOSING);
+	wake_up_interruptible(&info->close_wait);
+	restore_flags(flags);
+}
+
+/*
+ * rs_hangup() --- called by tty_hangup() when a hangup is signaled.
+ */
+static void rs_hangup(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->name, "rs_hangup"))
+		return;
+
+	rs_flush_buffer(tty);
+	shutdown(info);
+	info->event = 0;
+	info->count = 0;
+	info->flags &= ~S_NORMAL_ACTIVE;
+	info->tty = 0;
+	wake_up_interruptible(&info->open_wait);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_open() and friends
+ * ------------------------------------------------------------
+ */
+static int block_til_ready(struct tty_struct *tty, struct file *filp,
+						   struct atmel_serial *info)
+{
+	DECLARE_WAITQUEUE(wait, current); 
+	int retval;
+	int do_clocal = 0;
+
+	/*
+	 * If the device is in the middle of being closed, then block
+	 * until it's done, and then try again.
+	 */
+	if (info->flags & S_CLOSING) {
+		interruptible_sleep_on(&info->close_wait);
+#ifdef SERIAL_DO_RESTART
+		if (info->flags & S_HUP_NOTIFY)
+			return -EAGAIN;
+		else
+			return -ERESTARTSYS;
+#else
+		return -EAGAIN;
+#endif
+	}
+
+	/*
+	 * If non-blocking mode is set, or the port is not enabled,
+	 * then make the check up front and then exit.
+	 */
+	if ((filp->f_flags & O_NONBLOCK) ||
+	    (tty->flags & (1 << TTY_IO_ERROR))) {
+		info->flags |= S_NORMAL_ACTIVE;
+		return 0;
+	}
+
+	if (tty->termios->c_cflag & CLOCAL)
+		do_clocal = 1;
+
+	/*
+	 * Block waiting for the carrier detect and the line to become
+	 * free (i.e., not in use by the callout).  While we are in
+	 * this loop, info->count is dropped by one, so that
+	 * rs_close() knows when to free things.  We restore it upon
+	 * exit, either normal or abnormal.
+	 */
+	retval = 0;
+	add_wait_queue(&info->open_wait, &wait);
+#ifdef SERIAL_DEBUG_OPEN
+	printk("block_til_ready before block: ttyS%d, count = %d\n",
+		   info->line, info->count);
+#endif
+	info->count--;
+	info->blocked_open++;
+	while (1) {
+#ifdef US_RTS
+		save_flags(flags);
+		cli();
+		atmel_rtsdtr(info, 1);
+		restore_flags(flags);
+#endif
+		current->state = TASK_INTERRUPTIBLE;
+		if (tty_hung_up_p(filp) ||
+	    	     !(info->flags & S_INITIALIZED)) {
+#ifdef SERIAL_DO_RESTART
+			if (info->flags & S_HUP_NOTIFY)
+				retval = -EAGAIN;
+			else
+				retval = -ERESTARTSYS;
+#else
+			retval = -EAGAIN;
+#endif
+			break;
+		}
+		if (!(info->flags & S_CLOSING) && do_clocal)
+			break;
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			break;
+		}
+#ifdef SERIAL_DEBUG_OPEN
+		printk("block_til_ready blocking: ttyS%d, count = %d\n",
+			   info->line, info->count);
+#endif
+		schedule();
+	}
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&info->open_wait, &wait);
+	if (!tty_hung_up_p(filp))
+		info->count++;
+	info->blocked_open--;
+#ifdef SERIAL_DEBUG_OPEN
+	printk("block_til_ready after blocking: ttyS%d, count = %d\n",
+		   info->line, info->count);
+#endif
+	if (retval)
+		return retval;
+	info->flags |= S_NORMAL_ACTIVE;
+	if (!info->use_ints) {
+		serialpoll.data = (void *) info;
+		schedule_work(&serialpoll);
+	}
+	return 0;
+}
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port, linking in its S structure into
+ * the IRQ chain.   It also performs the serial-specific
+ * initialization for the tty structure.
+ */
+int rs_open(struct tty_struct *tty, struct file *filp)
+{
+	struct atmel_serial *info;
+	int retval, line;
+
+	line = tty->index;
+
+	// check if line is sane
+	if (line < 0 || line >= AT91_USART_CNT)
+		return -ENODEV;
+
+	info = &atmel_info[line];
+	if (serial_paranoia_check(info, tty->name, "rs_open"))
+		return -ENODEV;
+
+	info->count++;
+	tty->driver_data = info;
+	info->tty = tty;
+
+	/*
+	 * Start up serial port
+	 */
+	set_ints_mode(1, info);
+	
+	retval = startup(info);
+	if (retval)
+		return retval;
+
+	return block_til_ready(tty, filp, info);
+}
+
+
+static struct irqaction irq_usart0 =
+	{ rs_interrupta, 0, 0, "usart0", NULL, NULL };
+static struct irqaction irq_usart1 =
+	{ rs_interruptb, 0, 0, "usart1", NULL, NULL };
+
+static void interrupts_init(void)
+{
+	setup_irq(IRQ_USART0, &irq_usart0);
+	setup_irq(IRQ_USART1, &irq_usart1);
+}
+
+static void show_serial_version(void)
+{
+	printk("Atmel USART driver version 0.99\n");
+}
+
+static struct tty_operations rs_ops = {
+	.open = rs_open,
+	.close = rs_close,
+	.write = rs_write,
+	.flush_chars = rs_flush_chars,
+	.write_room = rs_write_room,
+	.chars_in_buffer = rs_chars_in_buffer,
+	.flush_buffer = rs_flush_buffer,
+	.ioctl = rs_ioctl,
+	.throttle = rs_throttle,
+	.unthrottle = rs_unthrottle,
+	.set_termios = rs_set_termios,
+	.stop = rs_stop,
+	.start = rs_start,
+	.hangup = rs_hangup,
+	.set_ldisc = rs_set_ldisc,
+};
+
+/* rs_init inits the driver */
+static int __init
+rs_atmel_init(void)
+{
+	int flags, i;
+	struct atmel_serial *info;
+
+	/* initialise PIO for serial port */
+	HW_AT91_USART_INIT 
+
+	serial_driver = alloc_tty_driver(2);
+	if (!serial_driver)
+		return -ENOMEM;
+
+	// FIXME - do this right
+	rx_buf_table[0] = rx_buf1;
+	rx_buf_table[1] = rx_buf2;
+	
+	show_serial_version();
+
+	/* Initialize the tty_driver structure */
+
+	// set the tty_struct pointers to NULL to let the layer
+	// above allocate the structs.
+	for (i=0; i < AT91_USART_CNT; i++)
+		serial_table[i] = NULL;
+		
+	serial_driver->name = "ttyS";
+	serial_driver->major = TTY_MAJOR;
+	serial_driver->minor_start = 64;
+	serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	serial_driver->subtype = SERIAL_TYPE_NORMAL;
+	serial_driver->init_termios = tty_std_termios;
+	serial_driver->init_termios.c_cflag = 
+		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	serial_driver->flags = TTY_DRIVER_REAL_RAW;
+	tty_set_operations(serial_driver, &rs_ops);
+
+	if (tty_register_driver(serial_driver)) {
+		put_tty_driver(serial_driver);
+		printk(KERN_ERR "Couldn't register serial driver\n");
+		return -ENOMEM;
+	}
+
+	save_flags(flags); cli();
+	for (i = 0; i < 2; i++) {
+		info = &atmel_info[i];
+		info->magic = SERIAL_MAGIC;
+		info->usart = usarts[i];
+		info->tty = 0;
+		info->irqmask = (i) ? (1<<IRQ_USART1) : (1<<IRQ_USART0);
+		info->irq = (i) ? IRQ_USART1 : IRQ_USART0;
+#ifdef CONFIG_SWAP_ATMEL_PORTS
+		info->port = (i) ? 2 : 1;
+		info->line = !i;
+#ifdef CONFIG_ATMEL_CONSOLE
+		info->is_cons = i;
+#else
+		info->is_cons = 0;
+#endif	
+#else
+		info->port = (i) ? 1 : 2;
+		info->line = i;
+#ifdef CONFIG_ATMEL_CONSOLE
+		info->is_cons = !i;
+#else
+		info->is_cons = 0;
+#endif	
+#endif
+#ifdef CONFIG_CONSOLE_ON_SC28L91
+		info->line += 1;
+#endif
+		set_ints_mode(0, info);
+		info->custom_divisor = 16;
+		info->close_delay = 50;
+		info->closing_wait = 3000;
+		info->cts_state = 1;
+		info->x_char = 0;
+		info->event = 0;
+		info->count = 0;
+		info->blocked_open = 0;
+	    	INIT_WORK(&info->tqueue, do_softint, info);
+	    	INIT_WORK(&info->tqueue_hangup, do_serial_hangup, info);
+		init_waitqueue_head(&info->open_wait);
+		init_waitqueue_head(&info->close_wait);
+		info->rx_buf = rx_buf_table[i];
+
+		printk("%s%d at 0x%p (irq = %d)", serial_driver->name, info->line,
+			   info->usart, info->irq);
+		printk(" is a builtin Atmel APB USART\n");
+	}
+	
+	// FIXME
+	info->usart->cr = 0x1ac; // reset, disable
+	info->usart->idr = 0xffffffff; // disable all interrupts
+	info->usart->tcr = 0; // stop transmit
+	info->usart->rcr = 0; // stop receive
+	
+	interrupts_init();
+
+	restore_flags(flags);
+	// hack to do polling
+	serialpoll.func = serpoll;
+	serialpoll.data = 0;
+
+	return 0;
+}
+
+module_init(rs_atmel_init);
+
+#if 0
+/*
+ * register_serial and unregister_serial allows for serial ports to be
+ * configured at run-time, to support PCMCIA modems.
+ */
+/* SPARC: Unused at this time, just here to make things link. */
+static int register_serial(struct serial_struct *req)
+{
+	return -1;
+}
+
+static void unregister_serial(int line)
+{
+	return;
+}
+
+static void dbg_putc(int ch)
+{
+	static char tmp[2];
+#define US_TPR  (0x38) /* Transmit Pointer Register */
+#define US_TCR  (0x3C) /* Transmit Counter Register */
+
+	tmp[0] = ch;
+
+	outl_t((unsigned long) tmp, (USART0_BASE + US_TPR) );
+	outl_t(1, (USART0_BASE + US_TCR) );
+
+	while (inl_t((USART0_BASE + US_TCR) )) {
+	}
+}
+
+static void dbg_print(const char *str)
+{
+	const char *p;
+
+	for (p = str; *p; p++) {
+		if (*p == '\n') {
+			dbg_putc('\r');
+		}
+		dbg_putc(*p);
+	}
+}
+
+static void dbg_printk(const char *fmt, ...)
+{
+	char tmp[256];
+	va_list args;
+
+	va_start(args, fmt);
+	vsprintf(tmp, fmt, args);
+	va_end(args);
+	dbg_print(tmp);
+}
+
+static void rs_atmel_print(const char *str)
+{
+	dbg_printk(str);
+}
+
+static void dump_a(unsigned long a, unsigned int s)
+{
+	unsigned long q;
+
+	for (q = 0; q < s; q++) {
+		if (q % 16 == 0) {
+			dbg_printk("%08X: ", q + a);
+		}
+		if (q % 16 == 7) {
+			dbg_printk("%02X-", *(unsigned char *) (q + a));
+		} else {
+			dbg_printk("%02X ", *(unsigned char *) (q + a));
+		}
+		if (q % 16 == 15) {
+			dbg_printk(" :\n");
+		}
+	}
+	if (q % 16) {
+		dbg_printk(" :\n");
+	}
+}
+#endif
+
+int atmel_console_setup(struct console *cp, char *arg)
+{
+  if (!cp)
+       return(-1);
+  HW_AT91_USART_INIT
+  return 0;
+}
+
+static struct tty_driver *atmel_console_device(struct console *c, int *index)
+{
+	*index = c->index;
+	return serial_driver;
+}
+
+void atmel_console_write (struct console *co, const char *str,
+			   unsigned int count)
+{
+	struct atmel_serial *info;
+
+#ifdef CONFIG_SWAP_ATMEL_PORTS
+	info = &atmel_info[1];
+#else
+	info = &atmel_info[0];
+#endif
+
+	if (!atmel_console_initialized) {
+		init_console(info);
+		uart_init(info);
+		info->baud = 9600;
+		tx_stop(info->usart);
+		rx_stop(info->usart);
+		uart_speed(info, 0xffff);
+		tx_start(info->usart);
+		rx_start(info->usart, info->use_ints);
+	}
+
+    	while (count--) {
+        	if (*str == '\n')
+           		rs_put_char(info,'\r');
+        	rs_put_char(info, *str++ );
+    	}
+}
+
+static struct console atmel_driver = {
+	name:		"ttyS",
+	write:		atmel_console_write,
+	device:		atmel_console_device,
+	setup:		atmel_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+
+static int __init atmel_console_init(void)
+{
+	register_console(&atmel_driver);
+	return 0;
+}
+
+console_initcall(atmel_console_init);
diff -Naur linux-2.6.14-uc0/drivers/serial/serial_atmel.h linux-2.6.14-uc0-hsc0/drivers/serial/serial_atmel.h
--- linux-2.6.14-uc0/drivers/serial/serial_atmel.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/drivers/serial/serial_atmel.h	2005-11-08 14:19:45.000000000 +0900
@@ -0,0 +1,125 @@
+/* serial-atmel.h: Definitions for the Atmel serial driver.
+ *
+ * Copyright (C) 1998  Kenneth Albanowski <kjahds@kjahds.com>,
+ *                     D. Jeff Dionne <jeff@uClinux.org>,
+ *                     The Silver Hammer Group, Ltd.
+ * Copyright (C) 2004 Hyok S. Choi <hyok.choi@samsung.com>
+ *			   2.6 port
+ *
+ * Based on:
+ *
+ * drivers/char/68328serial.h
+ *
+ * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
+ */
+
+#ifndef _ATMEL_SERIAL_H
+#define _ATMEL_SERIAL_H
+
+#include <linux/config.h>
+#include <asm/page.h>
+#include <asm/arch/hardware.h>
+
+/*
+ * For the close wait times, 0 means wait forever for serial port to
+ * flush its output.  65535 means don't wait at all.
+ */
+#define S_CLOSING_WAIT_INF	0
+#define S_CLOSING_WAIT_NONE	65535
+
+/*
+ * Definitions for S_struct (and serial_struct) flags field
+ */
+#define S_HUP_NOTIFY 0x0001 /* Notify getty on hangups and closes 
+				   on the callout port */
+#define S_FOURPORT  0x0002	/* Set OU1, OUT2 per AST Fourport settings */
+#define S_SAK	0x0004	/* Secure Attention Key (Orange book) */
+#define S_SPLIT_TERMIOS 0x0008 /* Separate termios for dialin/callout */
+
+#define S_SPD_MASK	0x0030
+#define S_SPD_HI	0x0010	/* Use 56000 instead of 38400 bps */
+
+#define S_SPD_VHI	0x0020  /* Use 115200 instead of 38400 bps */
+#define S_SPD_CUST	0x0030  /* Use user-specified divisor */
+
+#define S_SKIP_TEST	0x0040 /* Skip UART test during autoconfiguration */
+#define S_AUTO_IRQ  0x0080 /* Do automatic IRQ during autoconfiguration */
+#define S_SESSION_LOCKOUT 0x0100 /* Lock out cua opens based on session */
+#define S_PGRP_LOCKOUT    0x0200 /* Lock out cua opens based on pgrp */
+#define S_CALLOUT_NOHUP   0x0400 /* Don't do hangups for cua device */
+
+#define S_FLAGS	0x0FFF	/* Possible legal S flags */
+#define S_USR_MASK 0x0430	/* Legal flags that non-privileged
+				 * users can set or reset */
+
+/* Internal flags used only by kernel/chr_drv/serial.c */
+#define S_INITIALIZED	0x80000000 /* Serial port was initialized */
+#define S_CALLOUT_ACTIVE	0x40000000 /* Call out device is active */
+#define S_NORMAL_ACTIVE	0x20000000 /* Normal device is active */
+#define S_BOOT_AUTOCONF	0x10000000 /* Autoconfigure port on bootup */
+#define S_CLOSING		0x08000000 /* Serial port is closing */
+#define S_CTS_FLOW		0x04000000 /* Do CTS flow control */
+#define S_CHECK_CD		0x02000000 /* i.e., CLOCAL */
+
+#define RS_EVENT_WRITE_WAKEUP   0
+#define SERIAL_MAGIC 0x5301
+
+/* Software state per channel */
+
+/*
+ * This is our internal structure for each serial port's state.
+ * 
+ * Many fields are paralleled by the structure used by the serial_struct
+ * structure.
+ *
+ * For definitions of the flags field, see tty.h
+ */
+
+struct atmel_serial {
+	char soft_carrier;  /* Use soft carrier on this channel */
+	char break_abort;   /* Is serial console in, so process brk/abrt */
+	char is_cons;       /* Is this our console. */
+
+	/* We need to know the current clock divisor
+	 * to read the bps rate the chip has currently
+	 * loaded.
+	 */
+	unsigned char clk_divisor;  /* May be 1, 16, 32, or 64 */
+	int baud;
+	int			magic;
+	int			baud_base;
+	int			port;
+	int			irq;
+	int			irqmask;
+	int			flags; 		/* defined in tty.h */
+	int			type; 		/* UART type */
+	int			use_ints;
+	volatile struct atmel_usart_regs	*usart;
+	int			cts_state;
+	struct tty_struct 	*tty;
+	int			read_status_mask;
+	int			ignore_status_mask;
+	int			timeout;
+	int			xmit_fifo_size;
+	int			custom_divisor;
+	int			x_char;	/* xon/xoff character */
+	int			close_delay;
+	unsigned short		closing_wait;
+	unsigned short		closing_wait2;
+	unsigned long		event;
+	unsigned long		last_active;
+	int			line;
+	int			count;	    /* # of fd on device */
+	int			blocked_open; /* # of blocked opens */
+	unsigned char 		*xmit_buf;
+	unsigned char 		*rx_buf;
+	int			xmit_head;
+	int			xmit_tail;
+	int			xmit_cnt;
+	struct work_struct	tqueue;
+	struct work_struct	tqueue_hangup;
+	wait_queue_head_t	open_wait;
+	wait_queue_head_t	close_wait;
+};
+
+#endif /* !(_ATMEL_SERIAL_H) */
diff -Naur linux-2.6.14-uc0/drivers/serial/serial_s3c24a0.c linux-2.6.14-uc0-hsc0/drivers/serial/serial_s3c24a0.c
--- linux-2.6.14-uc0/drivers/serial/serial_s3c24a0.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/drivers/serial/serial_s3c24a0.c	2005-11-08 14:21:25.000000000 +0900
@@ -0,0 +1,596 @@
+/*
+ * drivser/serial/serial_s3c24a0.c
+ *
+ * device for S3C24A0
+ *
+ * $Id: serial_s3c24a0.c,v 1.1 2004/06/03 01:35:26 hcyun Exp $
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/serial_core.h>
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/arch/clocks.h>
+
+#define CONFIG_USE_ERR_IRQ        0
+
+#define __DRIVER_NAME    "Samsung S3C24A0 Internal UART"
+
+
+#ifdef CONFIG_BOARD_S3C24A0_SMDK
+#define UART_NR                   1
+#else
+#define UART_NR                   2
+#endif
+
+#define UART_ULCON(port)          __REG((port)->iobase + oULCON)
+#define UART_UCON(port)           __REG((port)->iobase + oUCON)
+#define UART_UFCON(port)          __REG((port)->iobase + oUFCON)
+#define UART_UTRSTAT(port)        __REG((port)->iobase + oUTRSTAT)
+#define UART_UERSTAT(port)        __REG((port)->iobase + oUERSTAT)
+#define UART_UTXH(port)           __REG((port)->iobase + oUTXH)
+#define UART_URXH(port)           __REG((port)->iobase + oURXH)
+#define UART_UBRDIV(port)         __REG((port)->iobase + oUBRDIV)
+
+#define ERR_IRQ(port)             ((port)->irq + 2)
+#define TX_IRQ(port)              ((port)->irq + 1)
+#define RX_IRQ(port)              ((port)->irq)
+
+#define INT_DISABLE(port)         disable_irq(port);
+#define INT_ENABLE(port)          enable_irq(port);
+/*
+ * Internal helper function
+ */
+static void __xmit_char(struct uart_port *port, const char ch)
+{
+        while (!(UART_UTRSTAT(port) & UTRSTAT_TX_EMP));
+        UART_UTXH(port) = ch;
+        if (ch == '\n') {
+                while (!(UART_UTRSTAT(port) & UTRSTAT_TX_EMP));
+                UART_UTXH(port) = '\r';
+        }
+}
+
+static void __xmit_string(struct uart_port *port, const char *p, int len)
+{
+        while( len-- > 0) {
+                __xmit_char( port, *p++);
+        }
+}
+
+
+
+static void elfinuart_stop_tx(struct uart_port *port)
+{
+}
+
+static void elfinuart_start_tx(struct uart_port *port)
+{
+        struct uart_info *info = port->info;
+        struct circ_buf *xmit = &port->info->xmit;
+
+        int count;
+
+        if (port->x_char) {
+                __xmit_char(port, port->x_char);
+                port->icount.tx++;
+                port->x_char = 0;
+                return;
+        }
+
+        if (uart_circ_empty( xmit) || uart_tx_stopped( port)) {
+                elfinuart_stop_tx(port);
+                return;
+        }
+
+        count = port->fifosize >> 1;
+        do {
+                __xmit_char( port, xmit->buf[xmit->tail]);
+                info->xmit.tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+                port->icount.tx++;
+                if (uart_circ_empty(xmit))
+                        break;
+        } while (--count > 0);
+
+        if (uart_circ_chars_pending( xmit) < WAKEUP_CHARS)
+                uart_write_wakeup( port);
+
+        if (uart_circ_empty(xmit))
+                elfinuart_stop_tx( port);
+}
+
+static void elfinuart_stop_rx(struct uart_port *port)
+{
+}
+
+static void elfinuart_enable_ms(struct uart_port *port)
+{
+}
+
+static void elfinuart_rx_char(struct uart_port *port)
+{
+        unsigned int status, ch, max_count = 256;
+        struct tty_struct *tty = port->info->tty;
+
+        status = UART_UTRSTAT(port);
+        while ((status & UTRSTAT_RX_RDY) && max_count--) {
+                if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+                        tty->flip.work.func((void *) tty);
+                        if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+                                printk(KERN_WARNING "TTY_DONT_FLIP set\n");
+                                return;
+                        }
+                }
+
+                ch = UART_URXH(port);
+
+                *tty->flip.char_buf_ptr = ch;
+                *tty->flip.flag_buf_ptr = TTY_NORMAL;
+                port->icount.rx++;
+                tty->flip.flag_buf_ptr++;
+                tty->flip.char_buf_ptr++;
+                tty->flip.count++;
+                /* No error handling just yet.
+                 * On the MX1 these are seperate
+                 * IRQs, so we need to deal with
+                 * the sanity of 5 IRQs for one
+                 * serial port before we deal
+                 * with the error path properly.
+                 */
+                status = UART_UTRSTAT(port);
+        }
+        tty_flip_buffer_push(tty);
+}
+
+static u_int elfinuart_tx_empty(struct uart_port *port)
+{
+        return (UART_UTRSTAT(port) & UTRSTAT_TR_EMP ? 0 : TIOCSER_TEMT);
+}
+
+static u_int elfinuart_get_mctrl(struct uart_port *port)
+{
+        return (TIOCM_CTS | TIOCM_DSR | TIOCM_CAR);
+}
+
+static void elfinuart_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+}
+
+static void elfinuart_break_ctl(struct uart_port *port, int break_state)
+{
+        u_int ucon;
+
+        ucon = UART_UCON(port);
+
+        if (break_state == -1)
+                ucon |= UCON_BRK_SIG;
+        else
+                ucon &= ~UCON_BRK_SIG;
+
+        UART_UCON(port) = ucon;
+}
+
+static irqreturn_t elfinuart_rx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+        struct uart_port *port = dev_id;
+        elfinuart_rx_char(port);
+
+        return IRQ_HANDLED;
+}
+
+static irqreturn_t elfinuart_tx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+        struct uart_port *port = dev_id;
+        elfinuart_start_tx(port);
+        return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_USE_ERR_IRQ
+static irqreturn_t elfinuart_err_int(int irq, void *dev_id,
+                                      struct pt_regs *reg)
+{
+        struct uart_port *port = dev_id;
+        struct uart_info *info = port->info;
+        struct tty_struct *tty = info->tty;
+        unsigned char err = UART_UERSTAT(port) & UERSTAT_ERR_MASK;
+        unsigned int ch, flg =  TTY_NORMAL;
+
+        ch = UART_URXH(port);
+        if (!err)
+                return IRQ_HANDLED;
+
+        if (err & UERSTAT_OVERRUN)
+                port->icount.overrun++;
+
+        err &= port->read_status_mask;
+
+        if (err & UERSTAT_OVERRUN) {
+                *tty->flip.char_buf_ptr = ch;
+                *tty->flip.flag_buf_ptr = flg;
+                tty->flip.flag_buf_ptr++;
+                tty->flip.char_buf_ptr++;
+                tty->flip.count++;
+                if (tty->flip.count < TTY_FLIPBUF_SIZE) {
+                        ch = 0;
+                        flg = TTY_OVERRUN;
+                }
+        }
+
+        *tty->flip.flag_buf_ptr++ = flg;
+        *tty->flip.char_buf_ptr++ = ch;
+        tty->flip.count++;
+        return IRQ_HANDLED;
+}
+#endif
+
+static struct irqaction __rx_irqaction[UART_NR] = {
+        {
+                name:     "serial0_rx",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_rx_int,
+        },
+        {
+                name:     "serial1_rx",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_rx_int,
+        },
+};
+
+static struct irqaction __tx_irqaction[UART_NR] = {
+        {
+                name:     "serial0_tx",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_tx_int,
+        },
+        {
+                name:     "serial1_tx",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_tx_int,
+        },
+};
+
+static struct irqaction __err_irqaction[UART_NR] = {
+        {
+                name:     "serial0_err",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_err_int,
+        },
+        {
+                name:     "serial1_err",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_err_int,
+        },
+};
+
+static int elfinuart_startup(struct uart_port *port)
+{
+        int ret;
+        u_int ucon;
+
+        /*
+         * Allocate the IRQs for TX and RX
+         */
+        __tx_irqaction[port->line].dev_id = (void *)port;
+        __rx_irqaction[port->line].dev_id = (void *)port;
+        __err_irqaction[port->line].dev_id = (void *)port;
+
+        ret = setup_irq( RX_IRQ(port), &__rx_irqaction[port->line]);
+        if (ret) goto rx_failed;
+
+#if 0
+        ret = setup_irq( TX_IRQ(port), &__tx_irqaction[port->line]);
+        if (ret) goto tx_failed;
+#endif
+
+#ifdef CONFIG_USE_ERR_IRQ
+        ret = setup_irq( ERR_IRQ(port), &__err_irqaction[port->line]);
+        if (ret) goto err_failed;
+#endif
+
+        ucon = (UCON_TX_INT_LVL | UCON_RX_INT_LVL |
+                        UCON_TX_INT | UCON_RX_INT | UCON_RX_TIMEOUT);
+
+
+        spin_lock_irq( &port->lock);
+
+        UART_UCON(port) = ucon;
+
+        spin_unlock_irq( &port->lock);
+
+        return 0;
+
+#ifdef CONFIG_USE_ERR_IRQ
+err_failed:
+        printk(KERN_ERR "%s: err failed\n", __FUNCTION__);
+        INT_DISABLE( ERR_IRQ(port));
+#endif
+tx_failed:
+        printk(KERN_ERR "%s: tx  failed\n", __FUNCTION__);
+        INT_DISABLE( TX_IRQ(port));
+rx_failed:
+        printk(KERN_ERR "%s: rx  failed\n", __FUNCTION__);
+        INT_DISABLE( RX_IRQ(port));
+        return ret;
+}
+
+static void elfinuart_shutdown(struct uart_port *port)
+{
+#ifdef CONFIG_USE_ERR_IRQ
+        INT_DISABLE( ERR_IRQ(port));
+#endif
+        INT_DISABLE( TX_IRQ(port));
+        INT_DISABLE( RX_IRQ(port));
+
+        UART_UCON(port) = 0x0;
+}
+
+#if 0
+static void elfinuart_change_speed(struct uart_port *port, u_int cflag, u_int iflag, u_int quot)
+{
+        u_int ulcon, ufcon;
+        int flags;
+
+        ufcon = UART_UFCON(port);
+
+        switch (cflag & CSIZE) {
+                case CS5:
+                        ulcon = ULCON_WL5;
+                break;
+                case CS6:
+                        ulcon = ULCON_WL6;
+                break;
+                case CS7:
+                        ulcon = ULCON_WL7;
+                break;
+                default:
+                        ulcon = ULCON_WL8;
+                break;
+        }
+
+        if (cflag & CSTOPB)
+                ulcon |= ULCON_STOP;
+        if (cflag & PARENB) {
+                if (!(cflag & PARODD))
+            ulcon |= ULCON_PAR_EVEN;
+        }
+
+        if (port->fifosize > 1)
+                ufcon |= UFCON_FIFO_EN;
+
+        port->read_status_mask =  UERSTAT_OVERRUN;
+
+        port->ignore_status_mask = 0;
+        if (iflag & IGNBRK) {
+                if (iflag & IGNPAR)
+                    port->ignore_status_mask |= UERSTAT_OVERRUN;
+        }
+
+        quot -= 1;
+
+        spin_lock_irqsave( &port->lock, flags );
+
+        UART_UFCON(port) = ufcon;
+        UART_ULCON(port) = ulcon;
+        UART_UBRDIV(port) = quot;
+
+        spin_unlock_irqrestore(&port->lock, flags);
+}
+
+#endif
+
+static void elfinuart_set_termios(struct uart_port *port, struct termios *termios, struct termios *old)
+{
+        int quot;
+
+        uart_update_timeout(port, termios->c_cflag, 115200);
+#if 0
+        quot = uart_get_divisor(port, 115200);
+        elfinuart_change_speed(port, termios->c_cflag, 0, quot);
+#endif
+
+}
+static void elfinuart_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+}
+
+static int elfinuart_set_wake(struct uart_port *port, unsigned int state)
+{
+        return 0;
+}
+
+
+
+
+static const char *elfinuart_type(struct uart_port *port)
+{
+        return __DRIVER_NAME;
+}
+
+static void elfinuart_config_port(struct uart_port *port, int flags)
+{
+        if (flags & UART_CONFIG_TYPE)
+                port->type = PORT_S3C24A0;
+}
+
+static void elfinuart_release_port(struct uart_port *port)
+{
+}
+
+static int elfinuart_request_port(struct uart_port *port)
+{
+        return 0;
+}
+
+static int elfinuart_verify_port(struct uart_port *port, struct serial_struct *serial)
+{
+        return 0;
+}
+
+static struct uart_ops elfin_pops = {
+        tx_empty     : elfinuart_tx_empty,
+        set_mctrl    : elfinuart_set_mctrl,
+        get_mctrl    : elfinuart_get_mctrl,
+        stop_tx      : elfinuart_stop_tx,
+        start_tx     : elfinuart_start_tx,
+        stop_rx      : elfinuart_stop_rx,
+        enable_ms    : elfinuart_enable_ms,
+        break_ctl    : elfinuart_break_ctl,
+        startup      : elfinuart_startup,
+        shutdown     : elfinuart_shutdown,
+        set_termios:    elfinuart_set_termios,
+        pm:             elfinuart_pm,
+        set_wake:       elfinuart_set_wake,
+        type         : elfinuart_type,
+        config_port  : elfinuart_config_port,
+        release_port : elfinuart_release_port,
+        request_port : elfinuart_request_port,
+        verify_port:    elfinuart_verify_port,
+};
+
+static struct uart_port elfin_ports[UART_NR] = {
+        {
+                iobase   : (unsigned long)(UART0_CTL_BASE),
+                irq      : IRQ_RXD0,
+                uartclk  : 130252800,
+                fifosize : 64,
+                ops      : &elfin_pops,
+                type     : PORT_S3C24A0,
+                flags    : ASYNC_BOOT_AUTOCONF,
+        },
+#ifndef CONFIG_BOARD_S3C24A0_SMDK
+        {
+                iobase   : (unsigned long)(UART1_CTL_BASE),
+                irq      : IRQ_RXD1,
+                uartclk  : 130252800,
+                fifosize : 64,
+                ops      : &elfin_pops,
+                type     : PORT_S3C24A0,
+                flags    : ASYNC_BOOT_AUTOCONF,
+        }
+#endif /* !CONFIG_BOARD_S3C24A0_SMDK */
+};
+
+void __init elfin_register_uart(int idx, int port)
+{
+        if (idx >= UART_NR) {
+                printk(KERN_ERR "%s: bad index number %d\n"
+                        , __FUNCTION__, idx);
+                return;
+        }
+        elfin_ports[idx].uartclk = elfin_get_bus_clk(GET_PCLK);
+
+        switch (port) {
+                case 0:
+                        elfin_ports[idx].iobase = (unsigned long)(UART0_CTL_BASE);
+                        elfin_ports[idx].irq  = IRQ_RXD0;
+                break;
+                case 1:
+                        elfin_ports[idx].iobase = (unsigned long)(UART1_CTL_BASE);
+                        elfin_ports[idx].irq  = IRQ_RXD1;
+                break;
+                default:
+                        printk(KERN_ERR "%s : bad port number %d\n", __FUNCTION__, port);
+        }
+}
+
+
+
+#ifdef CONFIG_SERIAL_S3C24A0_CONSOLE
+
+static void elfin_console_write(struct console *co, const char *s, u_int count)
+{
+        struct uart_port *port = elfin_ports + co->index;
+        __xmit_string( port, s, count);
+}
+
+static int __init elfin_console_setup(struct console *co, char *options)
+{
+        struct uart_port *port;
+        int baud = 115200;
+        int bits = 8;
+        int parity = 'n';
+        int flow = 0;
+
+        port = uart_get_console(elfin_ports, UART_NR, co);
+
+        if (options)
+                uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+        return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver elfin_reg;
+static struct console elfin_cons = {
+        name     : "ttyS",
+        write    : elfin_console_write,
+        device   : uart_console_device,
+        setup    : elfin_console_setup,
+        flags    : CON_PRINTBUFFER,
+        index    : -1,
+        data     : &elfin_reg,
+};
+
+static int __init elfin_console_init(void)
+{
+        register_console(&elfin_cons);
+        return 0;
+}
+
+console_initcall(elfin_console_init);
+
+#define S3C24A0_CONSOLE         &elfin_cons
+#else   /* CONFIG_SERIAL_S3C24A0_CONSOLE */
+#define S3C24A0_CONSOLE         NULL
+#endif  /* CONFIG_SERIAL_S3C24A0_CONSOLE */
+
+
+static struct uart_driver elfin_reg = {
+        owner          : THIS_MODULE,
+        driver_name    : "ttyS",
+        dev_name       : "ttyS",
+        major   : TTY_MAJOR,
+        minor   : 64,
+        nr      : UART_NR,
+        cons           : S3C24A0_CONSOLE,
+};
+
+static int __init elfinuart_init(void)
+{
+        int ret;
+
+        printk("Initializing %s\n", __DRIVER_NAME);
+        ret = uart_register_driver(&elfin_reg);
+        if (ret == 0) {
+                int i;
+
+                for (i = 0; i < UART_NR; i++)
+                        uart_add_one_port(&elfin_reg, &elfin_ports[i]);
+        }
+        return ret;
+
+}
+
+static void __exit elfinuart_exit(void)
+{
+        uart_unregister_driver(&elfin_reg);
+}
+
+module_init(elfinuart_init);
+module_exit(elfinuart_exit);
+
+
+MODULE_AUTHOR("Samsung");
+MODULE_DESCRIPTION("S3C24A0 generic serial port driver");
+MODULE_SUPPORTED_DEVICE("ttyS");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14-uc0/drivers/serial/serial_s3c4510b.c linux-2.6.14-uc0-hsc0/drivers/serial/serial_s3c4510b.c
--- linux-2.6.14-uc0/drivers/serial/serial_s3c4510b.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/drivers/serial/serial_s3c4510b.c	2005-11-08 14:22:55.000000000 +0900
@@ -0,0 +1,638 @@
+/*
+ *  linux/drivers/serial/serial_s3c4510b.c
+ *
+ *  Driver for S3C4510B serial ports
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Based on drivers/char/serial_amba.c
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/serial_core.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/uart.h>
+
+#define __DRIVER_NAME    "Samsung S3C4510B Internal UART"
+
+#define _SDEBUG
+#ifdef _SDEBUG
+#  define _DPRINTK(format, args...)  \
+          printk (KERN_INFO "%s():%05d "format".\n" , __FUNCTION__ , __LINE__ , ## args);
+#else
+#  define _DPRINTK(format, args...)
+#endif
+
+/**
+ **
+ ** Internal(private) helper functions
+ **
+ **/
+
+static void __xmit_char(struct uart_port *port, const char ch) {
+
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+
+	while( !uart->m_stat.bf.txBufEmpty);
+
+	uart->m_tx = ch;
+
+	if ( ch == '\n') {
+		while( !uart->m_stat.bf.txBufEmpty);
+		uart->m_tx = '\r';
+	}
+
+}
+
+static void __xmit_string(struct uart_port *port, const char *p, int len)
+{
+	while( len-- > 0) {
+		__xmit_char( port, *p++);
+	}
+}
+
+static void __s3c4510b_init(const struct uart_port *port, int baud)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+	UART_CTRL      uctrl;
+	UART_LINE_CTRL ulctrl;
+	UART_BAUD_DIV  ubd;
+
+	/* Reset the UART */
+	/* control register */
+	uctrl.ui = 0x0;
+	uctrl.bf.rxMode = 0x1;
+	uctrl.bf.rxIrq = 0x1;
+	uctrl.bf.txMode = 0x1;
+	uctrl.bf.DSR = 0x1;
+	uctrl.bf.sendBreak = 0x0;
+	uctrl.bf.loopBack = 0x0;
+	uart->m_ctrl.ui = uctrl.ui;
+	
+	/* Set the line control register into a safe sane state */
+	ulctrl.ui  = 0x0;
+	ulctrl.bf.wordLen   = 0x3; /* 8 bit data */
+	ulctrl.bf.nStop     = 0x0; /* 1 stop bit */
+	ulctrl.bf.parity    = 0x0; /* no parity */
+	ulctrl.bf.clk       = 0x0; /* internal clock */
+	ulctrl.bf.infra_red = 0x0; /* no infra_red */
+	uart->m_lineCtrl.ui = ulctrl.ui;
+
+	ubd.ui = 0x0;
+
+	/* see table on page 10-15 in SAMSUNG S3C4510B manual */
+	/* get correct divisor */
+	switch( baud ? baud : 19200) {
+
+	case 1200:
+		ubd.bf.cnt0 = 1301;
+		break;
+
+	case 2400:
+		ubd.bf.cnt0 = 650;
+		break;
+
+	case 4800:
+		ubd.bf.cnt0 = 324;
+		break;
+
+	case 9600:
+		ubd.bf.cnt0 = 162;
+		break;
+
+	case 19200:
+		ubd.bf.cnt0 = 80;
+		break;
+
+	case 38400:
+		ubd.bf.cnt0 = 40;
+		break;
+
+	case 57600:
+		ubd.bf.cnt0 = 26;
+		break;
+
+	case 115200:
+		ubd.bf.cnt0 = 13;
+		break;
+	}
+
+	uart->m_baudDiv.ui = ubd.ui;
+	uart->m_baudCnt = 0x0;
+	uart->m_baudClk = 0x0;
+
+}
+
+/**
+ **
+ ** struct uart_ops functions below
+ **
+ **/
+
+static void __s3c4510b_stop_tx(struct uart_port *port)
+{
+
+}
+
+
+static void __s3c4510b_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	int count;
+
+	// _DPRINTK("called with info = 0x%08x", (unsigned int) port);
+
+	if ( port->x_char) {
+		__xmit_char( port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+
+	if (uart_circ_empty( xmit) || uart_tx_stopped( port)) {
+		__s3c4510b_stop_tx( port);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		__xmit_char( port, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup( port);
+
+	if (uart_circ_empty(xmit))
+		__s3c4510b_stop_tx( port);
+}
+
+static void __s3c4510b_start_tx(struct uart_port *port)
+{
+	__s3c4510b_tx_chars( port);
+}
+
+static void __s3c4510b_send_xchar(struct uart_port *port, char ch)
+{
+	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static void __s3c4510b_stop_rx(struct uart_port *port)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+	UART_CTRL      uctrl;
+
+	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	uctrl.ui = uart->m_ctrl.ui;
+	uctrl.bf.rxMode = 0x0;
+	uart->m_ctrl.ui = uctrl.ui;
+}
+
+static void __s3c4510b_enable_ms(struct uart_port *port)
+{
+	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static void __s3c4510b_rx_char(struct uart_port *port)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+	struct tty_struct *tty = port->info->tty;
+	unsigned int ch;
+	UART_STAT status;
+
+	status.ui = uart->m_stat.ui;
+	if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+		tty->flip.work.func((void *)tty);
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+			printk(KERN_WARNING "TTY_DONT_FLIP set\n");
+			return;
+		}
+	}
+
+	ch = uart->m_rx & 0xFF;
+
+	*tty->flip.char_buf_ptr = ch;
+	*tty->flip.flag_buf_ptr = TTY_NORMAL;
+	port->icount.rx++;
+
+	/*
+	 * Note that the error handling code is
+	 * out of the main execution path
+	 */
+	if ( status.bf.breakIrq) {
+		port->icount.brk++;
+		if (uart_handle_break(port))
+			goto ignore_char;
+		*tty->flip.flag_buf_ptr = TTY_BREAK;
+	}
+	else if ( status.bf.parity) {
+		port->icount.parity++;
+		*tty->flip.flag_buf_ptr = TTY_PARITY;
+	}
+	else if ( status.bf.frame) {
+		port->icount.frame++;
+		*tty->flip.flag_buf_ptr = TTY_FRAME;
+	}
+	else if ( status.bf.overrun) {
+		port->icount.overrun++;
+		if ( tty->flip.count < TTY_FLIPBUF_SIZE) {
+			/*
+			 * Overrun is special, since it's reported
+			 * immediately, and doesn't affect the current
+			 * character
+			 */
+			*tty->flip.char_buf_ptr++ = 0;
+			*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+			tty->flip.count++;
+		}
+	}
+	else {
+		/* no errors */
+		tty->flip.flag_buf_ptr++;
+		tty->flip.char_buf_ptr++;
+		tty->flip.count++;
+	}
+
+ignore_char:
+
+	tty_flip_buffer_push(tty);
+
+
+}
+
+static irqreturn_t __s3c4510b_rx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+//	_DPRINTK("called with irq = 0x%08x", irq);
+
+	struct uart_port *port = dev_id;
+
+	LED_SET(2);
+	__s3c4510b_rx_char( port);		
+	LED_CLR(2);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t __s3c4510b_tx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+//	_DPRINTK("called with irq = 0x%08x", irq);
+
+	struct uart_port *port = dev_id;
+
+	LED_SET(1);
+	__s3c4510b_start_tx( port);		
+	LED_CLR(1);
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int __s3c4510b_tx_empty(struct uart_port *port)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	return uart->m_stat.bf.txBufEmpty ? 1 : 0;
+}
+
+static unsigned int __s3c4510b_get_mctrl(struct uart_port *port)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	return 0;
+}
+
+static void __s3c4510b_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+//	_DPRINTK("called with port = 0x%08x, mctrl = 0x%08x", (unsigned int) port, mctrl);
+}
+
+static void __s3c4510b_break_ctl(struct uart_port *port, int break_state)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static struct irqaction __rx_irqaction[UART_NR] = {
+	{
+		name:	  "serial0_rx",
+		flags:	  SA_INTERRUPT,
+		handler:  __s3c4510b_rx_int,
+	},
+	{
+		name:	  "serial1_rx",
+		flags:	  SA_INTERRUPT,
+		handler:  __s3c4510b_rx_int,
+	},
+};
+
+static struct irqaction __tx_irqaction[UART_NR] = {
+	{
+		name:	  "serial0_tx",
+		flags:	  SA_INTERRUPT,
+		handler:  __s3c4510b_tx_int,
+	},
+	{
+		name:	  "serial1_tx",
+		flags:	  SA_INTERRUPT,
+		handler:  __s3c4510b_tx_int,
+	},
+};
+
+static int __s3c4510b_startup(struct uart_port *port)
+{
+	int status;
+
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	__s3c4510b_init(port, 19200);
+
+	/*
+	 * Allocate the IRQs for TX and RX
+	 */
+	__tx_irqaction[port->line].dev_id = (void *)port;
+	__rx_irqaction[port->line].dev_id = (void *)port;
+
+	status = setup_irq( port->irq, &__tx_irqaction[port->line]);
+	if ( status) {
+		printk( KERN_ERR "Unabled to hook interrupt for serial %d TX\n", port->line);
+		return status;
+	}
+
+	status = setup_irq( port->irq+1, &__rx_irqaction[port->line]);
+	if ( status) {
+		printk( KERN_ERR "Unabled to hook interrupt for serial %d RX\n", port->line);
+		return status;
+	}
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	spin_lock_irq( &port->lock);
+	INT_ENABLE( port->irq);
+	INT_ENABLE( port->irq+1);
+	spin_unlock_irq( &port->lock);
+
+	return 0;
+}
+
+static void __s3c4510b_shutdown(struct uart_port *port)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+
+	// _DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	INT_DISABLE( port->irq);
+	INT_DISABLE( port->irq+1);
+
+	/* turn off TX/RX */
+	uart->m_ctrl.ui = 0x0;
+
+}
+
+static void __s3c4510b_set_termios(struct uart_port *port, struct termios *termios, struct termios *old)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	/**
+	 ** Ignore -- only 19200 baud supported
+	 **/
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, 19200);
+
+}
+
+static void __s3c4510b_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+//	_DPRINTK("called with port = 0x%08x, state = %u", (unsigned int) port, state);
+}
+
+static int __s3c4510b_set_wake(struct uart_port *port, unsigned int state)
+{
+//	_DPRINTK("called with port = 0x%08x, state = %u", (unsigned int) port, state);
+	return 0;
+}
+
+static const char *__s3c4510b_type(struct uart_port *port)
+{
+	return __DRIVER_NAME;
+}
+
+
+static void __s3c4510b_release_port(struct uart_port *port)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static int __s3c4510b_request_port(struct uart_port *port)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+	return 0;
+}
+
+static void __s3c4510b_config_port(struct uart_port *port, int config)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static int __s3c4510b_verify_port(struct uart_port *port, struct serial_struct *serial)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+	return 0;
+}
+
+#if 0
+static int __s3c4510b_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+//	_DPRINTK("called with port = 0x%08x, cmd %u, arg 0x%08lx", (unsigned int) port, cmd, arg);
+	return 0;
+}
+#endif
+
+static struct uart_ops s3c4510b_pops = {
+	tx_empty:	__s3c4510b_tx_empty,
+	set_mctrl:	__s3c4510b_set_mctrl,
+	get_mctrl:	__s3c4510b_get_mctrl,
+	stop_tx:	__s3c4510b_stop_tx,
+	start_tx:	__s3c4510b_start_tx,
+	send_xchar:     __s3c4510b_send_xchar,
+	stop_rx:	__s3c4510b_stop_rx,
+	enable_ms:	__s3c4510b_enable_ms,
+	break_ctl:	__s3c4510b_break_ctl,
+	startup:	__s3c4510b_startup,
+	shutdown:	__s3c4510b_shutdown,
+	set_termios:    __s3c4510b_set_termios,
+	pm:             __s3c4510b_pm,
+	set_wake:       __s3c4510b_set_wake,
+	type:           __s3c4510b_type,
+	release_port:   __s3c4510b_release_port,
+	request_port:   __s3c4510b_request_port,
+	config_port:    __s3c4510b_config_port,
+	verify_port:    __s3c4510b_verify_port,
+//	ioctl:          __s3c4510b_ioctl,
+};
+
+
+static struct uart_port __s3c4510b_ports[UART_NR] = {
+	{
+		iobase:			UART0_BASE,
+		line: 			0,
+		irq:			INT_UARTTX0,
+		fifosize:		1,
+		ops:			&s3c4510b_pops,
+		ignore_status_mask:	0x0000000F,
+		type:			PORT_S3C4510B,
+	},
+	{
+		iobase:			UART1_BASE,
+		line:			1,
+		irq:			INT_UARTTX1,
+		fifosize:		1,
+		ops:			&s3c4510b_pops,
+		ignore_status_mask:	0x0000000F,
+		type:			PORT_S3C4510B,
+	}
+};
+
+#ifdef CONFIG_SERIAL_S3C4510B_CONSOLE
+/************** console driver *****************/
+
+static void __s3c4510b_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = &__s3c4510b_ports[co->index];
+
+	__xmit_string( port, s, count);
+
+}
+
+static int __init __s3c4510b_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 19200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 0;
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	port = uart_get_console(__s3c4510b_ports, UART_NR, co);
+
+//	_DPRINTK("using port = 0x%08x", (unsigned int) port);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	__s3c4510b_init(port, baud);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver __s3c4510b_driver;
+static struct console __s3c4510b_console = {
+	name:           "ttyS",
+	write:		__s3c4510b_console_write,
+	device:		uart_console_device,
+	setup:		__s3c4510b_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+	data:           &__s3c4510b_driver,
+};
+
+static int __init __s3c4510b_console_init(void)
+{
+	register_console(&__s3c4510b_console);
+	return 0;
+}
+
+console_initcall(__s3c4510b_console_init);
+
+#endif /* CONFIG_SERIAL_S3C4510B_CONSOLE */
+
+
+static struct uart_driver __s3c4510b_driver = {
+	owner:           THIS_MODULE,
+	driver_name:     __DRIVER_NAME,
+	dev_name:        "ttyS",
+	major:           TTY_MAJOR,
+	minor:           64,
+	nr:              UART_NR,
+#ifdef CONFIG_SERIAL_S3C4510B_CONSOLE
+	cons:            &__s3c4510b_console,
+#endif
+};
+
+static int __init __s3c4510b_serial_init(void)
+{
+
+	int    status, i;
+
+//	_DPRINTK("initializing driver with drv = 0x%08x", (unsigned int) &__s3c4510b_driver);
+
+	status = uart_register_driver( &__s3c4510b_driver);
+
+	if ( status) {
+		_DPRINTK("uart_register_driver() returned %d", status);
+	}
+
+	for ( i = 0; i < UART_NR; i++) {
+		status = uart_add_one_port( &__s3c4510b_driver, &__s3c4510b_ports[i]);
+		if ( status) {
+			_DPRINTK("uart_add_one_port(%d) returned %d", i, status);
+		}
+	}
+	
+	return 0;
+}
+
+module_init(__s3c4510b_serial_init);
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/at91x40.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/at91x40.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/at91x40.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/at91x40.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,57 @@
+/*
+ ******************* AT91x40xxx ********************
+ */
+
+#define ARM_CLK	CONFIG_ARM_CLK
+
+#define AT91_USART_CNT 2
+#define AT91_USART0_BASE	(0xfffd0000)
+#define AT91_USART1_BASE	(0xfffcc000)
+#define AT91_TC_BASE		(0xfffe0000)
+#define AIC_BASE		(0xfffff000)	
+#define AT91_PIOA_BASE		(0xffff0000)
+#define AT91_SF_CIDR		(0xfff00000)
+
+#define HARD_RESET_NOW()
+
+#define HW_AT91_TIMER_INIT(timer)	/* no PMC */
+
+/* use TC0 as hardware timer to create high resolution timestamps for debugging.
+ *  Timer 0 must be set up as a free running counter, e.g. in the bootloader
+ */
+#define HW_COUNTER  (((struct at91_timers *)AT91_TC_BASE)->chans[0].ch.cv)
+
+/* enable US0,US1 */
+#define HW_AT91_USART_INIT ((volatile struct pio_regs *)AT91_PIOA_BASE)->pdr = \
+				PIOA_RXD0|PIOA_TXD0|PIOA_RXD1|PIOA_TXD1; 
+/* PIOA bit allocation */
+#define PIOA_TCLK0	(1<<0)					
+#define PIOA_TI0A0	(1<<1)					
+#define PIOA_TI0B0	(1<<2)					
+#define PIOA_TCLK1	(1<<3)					
+#define PIOA_TIOA1	(1<<4)				
+#define PIOA_TIOB1	(1<<5)				
+#define PIOA_TCLK2	(1<<6)					
+#define PIOA_TIOA2	(1<<7)				
+#define PIOA_TIOB2	(1<<8)				
+#define PIOA_IRQ0	(1<<9)				
+#define PIOA_IRQ1	(1<<10)				
+#define PIOA_IRQ2	(1<<11)				
+#define PIOA_FIQ	(1<<12)					
+#define PIOA_SCK0	(1<<13)					
+#define PIOA_TXD0	(1<<14)					
+#define PIOA_RXD0	(1<<15)
+
+#define PIOA_SCK1	(1<<20)					
+#define PIOA_TXD1	(1<<21)					
+#define PIOA_RXD1	(1<<22)
+
+#define PIOA_MCK0	(1<<25)	
+#define PIOA_NCS2	(1<<26)
+#define PIOA_NCS3	(1<<27)	
+
+#define PIOA_A20_CS7	(1<<28)
+#define PIOA_A21_CS6	(1<<29)	
+#define PIOA_A22_CS5	(1<<30)
+#define PIOA_A23_CS4	(1<<31)
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/at91x63.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/at91x63.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/at91x63.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/at91x63.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,73 @@
+/*
+ ******************* AT91x63xxx ********************
+ */
+
+#define ARM_CLK		CONFIG_ARM_CLK
+
+#define AT91_USART_CNT 2
+#define AT91_USART0_BASE	(0xfffc0000)
+#define AT91_USART1_BASE	(0xfffc4000)
+#define AT91_TC_BASE		(0xfffd0000)
+#define AIC_BASE		(0xfffff000)
+#define AT91_PIOA_BASE 		(0xfffec000)
+#define AT91_PIOB_BASE 		(0xffff0000)
+#define AT91_PMC_BASE		(0xffff4000)
+
+/* enable US0,US1 */
+#define HW_AT91_USART_INIT ((volatile struct pmc_regs *)AT91_PMC_BASE)->pcer = \
+				(1<<2) | (1<<3) | (1<<13); \
+			   ((volatile struct pio_regs *)AT91_PIOA_BASE)->pdr = \
+				PIOA_RXD0|PIOA_TXD0|PIOA_RXD1|PIOA_TXD1; 
+
+#define HW_AT91_TIMER_INIT(timer) ((volatile struct pmc_regs *)AT91_PMC_BASE)->pcer = \
+				1<<(timer+6);
+
+/* PIOA bit allocation */
+#define PIOA_TCLK3	(1<<0)					
+#define PIOA_TI0A3	(1<<1)					
+#define PIOA_TI0B3	(1<<2)					
+#define PIOA_TCLK4	(1<<3)					
+#define PIOA_TI0A4	(1<<4)					
+#define PIOA_TI0B4	(1<<5)					
+#define PIOA_TCLK5	(1<<6)					
+#define PIOA_TI0A5	(1<<7)					
+#define PIOA_TI0B5	(1<<8)					
+#define PIOA_IRQ0	(1<<9)
+#define PIOA_IRQ1	(1<<10)
+#define PIOA_IRQ2	(1<<11)
+#define PIOA_IRQ3	(1<<12)
+#define PIOA_FIQ	(1<<13)
+#define PIOA_SCK0	(1<<14)	
+#define PIOA_TXD0	(1<<15)
+#define PIOA_RXD0	(1<<16)
+#define PIOA_SCK1	(1<<17)	
+#define PIOA_TXD1	(1<<18)
+#define PIOA_RXD1	(1<<19)
+#define PIOA_SCK2	(1<<20)	
+#define PIOA_TXD2	(1<<21)
+#define PIOA_RXD2	(1<<22)
+#define PIOA_SPCK	(1<<23)					
+#define PIOA_MISO	(1<<24)					
+#define PIOA_MOSI	(1<<25)					
+#define PIOA_NPCS0	(1<<26)					
+#define PIOA_NPCS1	(1<<27)					
+#define PIOA_NPCS2	(1<<28)					
+#define PIOA_NPCS3	(1<<29)					
+
+/* PIOB bit allocation */
+#define PIOB_MPI_NOE	(1<<0)					
+#define PIOB_MPI_NLB	(1<<1)				
+#define PIOB_MPI_NUB	(1<<2)				
+
+#define PIOB_MCK0	(1<<17)				
+#define PIOB_BMS	(1<<18)				
+#define PIOB_TCLK0	(1<<19)				
+#define PIOB_TIOA0	(1<<20)				
+#define PIOB_TIOB0	(1<<21)				
+#define PIOB_TCLK1	(1<<22)				
+#define PIOB_TIOA1	(1<<23)				
+#define PIOB_TIOB1	(1<<24)				
+#define PIOB_TCLK2	(1<<25)				
+#define PIOB_TIOA2	(1<<26)				
+#define PIOB_TIOB2	(1<<27)		
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/dma.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/dma.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/dma.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/dma.h
+ *
+ * Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_ATMEL_ARCH_DMA_H
+#define __ASM_ATMEL_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ * 
+ */
+#define MAX_DMA_ADDRESS		0x01000000
+/*
+ * The atmel has 13 internal DMA channels.
+ */
+#define MAX_DMA_CHANNELS        13
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#define arch_dma_init(dma_chan) 
+#endif /* _ASM_ATMEL_ARCH_DMA_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/entry-macro.S linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/entry-macro.S
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/entry-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/entry-macro.S	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,39 @@
+/*
+ *  arch/armnommu/mach-atmel/entry-macro.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  Samsung Electronics Co.,Ltd.
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if defined(CONFIG_ARCH_ATMEL)
+		.macro  disable_fiq
+		.endm
+                        /* r0     r6      r5   lr */
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	r4, =AIC_IVR
+		ldr	\irqnr, [r4]		@ignore value
+		ldr	r4, =AIC_ISR		@read interrupt nr.
+		ldr	\irqnr, [r4]
+		teq	\irqnr, #0
+		.endm   
+                
+		.macro  irq_prio_table
+		.endm
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/hardware.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/hardware.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/hardware.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/hardware.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,255 @@
+/*
+ * linux/include/asm-arm/arch-atmel/hardware.h
+ *
+ * for Atmel AT91 series
+ * 2001 Erwin Authried
+ * 
+ * modified for linux 2.6 by Hyok S. Choi, 2004
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+
+#ifndef __ASSEMBLY__
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(1)
+
+#endif
+
+#define ATMEL_MEM_SIZE     (CONFIG_DRAM_SIZE) 
+#define MEM_SIZE            ATMEL_MEM_SIZE
+#define PA_SDRAM_BASE         CONFIG_DRAM_BASE
+
+/* 0=TC0, 1=TC1, 2=TC2 */
+#define KERNEL_TIMER 1	
+
+#ifdef CONFIG_CPU_AT91X40
+#include "at91x40.h"
+#elif CONFIG_CPU_AT91X63
+#include "at91x63.h"
+#else 
+  #error "Configuration error: No CPU defined"
+#endif
+
+/*
+ ******************* COMMON PART ********************
+ */
+#define AIC_SMR(i)  (AIC_BASE+i*4)
+#define AIC_IVR	    (AIC_BASE+0x100)
+#define AIC_FVR	    (AIC_BASE+0x104)
+#define AIC_ISR	    (AIC_BASE+0x108)
+#define AIC_IPR	    (AIC_BASE+0x10C)
+#define AIC_IMR	    (AIC_BASE+0x110)
+#define AIC_CISR	(AIC_BASE+0x114)
+#define AIC_IECR	(AIC_BASE+0x120)
+#define AIC_IDCR	(AIC_BASE+0x124)
+#define AIC_ICCR	(AIC_BASE+0x128)
+#define AIC_ISCR	(AIC_BASE+0x12C)
+#define AIC_EOICR   (AIC_BASE+0x130)
+
+
+#ifndef __ASSEMBLER__
+struct at91_timer_channel
+{
+	unsigned long ccr;				// channel control register		(WO)
+	unsigned long cmr;				// channel mode register		(RW)
+	unsigned long reserved[2];		
+	unsigned long cv;				// counter value				(RW)
+	unsigned long ra;				// register A					(RW)
+	unsigned long rb;				// register B					(RW)
+	unsigned long rc;				// register C					(RW)
+	unsigned long sr;				// status register				(RO)
+	unsigned long ier;				// interrupt enable register	(WO)
+	unsigned long idr;				// interrupt disable register	(WO)
+	unsigned long imr;				// interrupt mask register		(RO)
+};
+
+struct at91_timers
+{
+	struct {
+		struct at91_timer_channel ch;
+		unsigned char padding[0x40-sizeof(struct at91_timer_channel)];
+	} chans[3];
+	unsigned  long bcr;				// block control register		(WO)
+	unsigned  long bmr;				// block mode	 register		(RW)
+};
+#endif
+
+/*  TC control register */
+#define TC_SYNC	(1)
+
+/*  TC mode register */
+#define TC2XC2S(x)	(x & 0x3)
+#define TC1XC1S(x)	(x<<2 & 0xc)
+#define TC0XC0S(x)	(x<<4 & 0x30)
+#define TCNXCNS(timer,v) ((v) << (timer<<1))
+
+/* TC channel control */
+#define TC_CLKEN	(1)			
+#define TC_CLKDIS	(1<<1)			
+#define TC_SWTRG	(1<<2)			
+
+/* TC interrupts enable/disable/mask and status registers */
+#define TC_MTIOB	(1<<18)
+#define TC_MTIOA	(1<<17)
+#define TC_CLKSTA	(1<<16)
+
+#define TC_ETRGS	(1<<7)
+#define TC_LDRBS	(1<<6)
+#define TC_LDRAS	(1<<5)
+#define TC_CPCS		(1<<4)
+#define TC_CPBS		(1<<3)
+#define TC_CPAS		(1<<2)
+#define TC_LOVRS	(1<<1)
+#define TC_COVFS	(1)
+
+/*
+ *	USART registers
+ */
+
+
+/*  US control register */
+#define US_SENDA	(1<<12)
+#define US_STTO		(1<<11)
+#define US_STPBRK	(1<<10)
+#define US_STTBRK	(1<<9)
+#define US_RSTSTA	(1<<8)
+#define US_TXDIS	(1<<7)
+#define US_TXEN		(1<<6)
+#define US_RXDIS	(1<<5)
+#define US_RXEN		(1<<4)
+#define US_RSTTX	(1<<3)
+#define US_RSTRX	(1<<2)
+
+/* US mode register */
+#define US_CLK0		(1<<18)
+#define US_MODE9	(1<<17)
+#define US_CHMODE(x)(x<<14 & 0xc000)
+#define US_NBSTOP(x)(x<<12 & 0x3000)
+#define US_PAR(x)	(x<<9 & 0xe00)
+#define US_SYNC		(1<<8)
+#define US_CHRL(x)	(x<<6 & 0xc0)
+#define US_USCLKS(x)(x<<4 & 0x30)
+
+/* US interrupts enable/disable/mask and status register */
+#define US_DMSI		(1<<10)
+#define US_TXEMPTY	(1<<9)
+#define US_TIMEOUT	(1<<8)
+#define US_PARE		(1<<7)
+#define US_FRAME	(1<<6)
+#define US_OVRE		(1<<5)
+#define US_ENDTX	(1<<4)
+#define US_ENDRX	(1<<3)
+#define US_RXBRK	(1<<2)
+#define US_TXRDY	(1<<1)
+#define US_RXRDY	(1)
+
+#define US_ALL_INTS (US_DMSI|US_TXEMPTY|US_TIMEOUT|US_PARE|US_FRAME|US_OVRE|US_ENDTX|US_ENDRX|US_RXBRK|US_TXRDY|US_RXRDY)
+
+#ifndef __ASSEMBLER__
+struct atmel_usart_regs{
+	unsigned long cr;		// control 
+	unsigned long mr;		// mode
+	unsigned long ier;		// interrupt enable
+	unsigned long idr;		// interrupt disable
+	unsigned long imr;		// interrupt mask
+	unsigned long csr;		// channel status
+	unsigned long rhr;		// receive holding 
+	unsigned long thr;		// tramsmit holding		
+	unsigned long brgr;		// baud rate generator		
+	unsigned long rtor;		// rx time-out
+	unsigned long ttgr;		// tx time-guard
+	unsigned long res1;
+	unsigned long rpr;		// rx pointer
+	unsigned long rcr;		// rx counter
+	unsigned long tpr;		// tx pointer
+	unsigned long tcr;		// tx counter
+};
+
+static inline void at91_usart_init(volatile struct atmel_usart_regs *uart, int baudrate)
+{
+
+        uart->cr = US_TXDIS | US_RXDIS | US_RSTTX | US_RSTRX;
+        /* clear Rx receive and Tx sent counters */
+        uart->rcr = 0;
+        uart->tcr = 0;
+
+	uart->idr = US_TXEMPTY;		/* tx disable */
+	uart->idr = US_ENDRX | US_TIMEOUT; /* rx disable */
+	
+        /* Set the serial port into a safe sane state */
+        uart->mr = US_USCLKS(0) | US_CLK0 | US_CHMODE(0) | US_NBSTOP(0) |
+                    US_PAR(4) | US_CHRL(3);
+
+        uart->brgr = ARM_CLK/16/baudrate;
+
+        uart->rtor = 20;                        // timeout = value * 4 *bit period
+        uart->ttgr = 0;                         // no guard time
+        uart->rcr = 0;
+        uart->rpr = 0;
+        uart->tcr = 0;
+        uart->tpr = 0;
+#ifdef US_RTS
+        uart->mc = 0;
+#endif
+}
+
+static inline void at91_usart_putc(volatile struct atmel_usart_regs *uart, unsigned char c)
+{
+       uart->cr=US_TXEN;
+       uart->thr=c;
+       while(1) {
+                if (uart->csr & US_TXEMPTY) break;
+       }
+}
+#endif
+		
+#define PIO(i)		(1<<i)
+
+#ifndef __ASSEMBLER__
+struct pio_regs{
+	unsigned long per;
+	unsigned long pdr;
+	unsigned long psr;
+	unsigned long res1;
+	unsigned long oer;
+	unsigned long odr;
+	unsigned long osr;
+	unsigned long res2;
+	unsigned long ifer;
+	unsigned long ifdr;
+	unsigned long ifsr;
+	unsigned long res3;
+	unsigned long sodr;
+	unsigned long codr;
+	unsigned long odsr;
+	unsigned long pdsr;
+	unsigned long ier;
+	unsigned long idr;
+	unsigned long imr;
+	unsigned long isr;
+};
+#endif
+
+#ifndef __ASSEMBLER__
+struct pmc_regs{
+	unsigned long scer;
+	unsigned long scdr;
+	unsigned long scsr;
+	unsigned long reserved;
+	unsigned long pcer;
+	unsigned long pcdr;
+	unsigned long pcsr;
+};
+#endif
+
+#endif  /* _ASM_ARCH_HARDWARE_H */
+
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/io.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/io.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/io.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,40 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/io.h
+ *
+ * Copyright (C) 1997-1999 Russell King
+ * modified for 2.6 by Hyok S. Choi
+ *
+ * Modifications:
+ *  06-12-1997	RMK	Created.
+ *  07-04-1999	RMK	Major cleanup
+ *  02-19-2001  gjm     Leveraged for armnommu/dsc21
+ *  03-15-2004  hsc     modified 
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a) (CONFIG_IO16_BASE + (a))
+#define __iob(a) (CONFIG_IO8_BASE + (a))	// byte io address
+#define __mem_pci(a)	((unsigned long)(a))	 
+
+/*
+ * Defining these two gives us ioremap for free. See asm/io.h.
+ * --gmcnutt
+ */
+#define iomem_valid_addr(iomem,sz) (1)
+#define iomem_to_phys(iomem) (iomem)
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+# error not_yet_supported
+#define __io_noswap 1
+#endif
+
+#endif
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/irq.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/irq.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/irq.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,22 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/irq.h:
+ * 2001 Erwin Authried
+ */
+
+#ifndef __ASM_ARCH_IRQ_H__
+#define __ASM_ARCH_IRQ_H__
+
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+
+#define fixup_irq(x) (x)
+
+extern void at91_mask_irq(unsigned int irq);
+extern void at91_unmask_irq(unsigned int irq);
+extern void at91_mask_ack_irq(unsigned int irq);
+
+#endif /* __ASM_ARCH_IRQ_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/irqs.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/irqs.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/irqs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/irqs.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,65 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/irqs.h:
+ * 2001 Mindspeed
+ */
+#ifndef __ASM_ARCH_IRQS_H__
+#define __ASM_ARCH_IRQS_H__
+
+
+#ifdef CONFIG_CPU_AT91X40
+/*
+ ******************* AT91x40xxx ********************
+ */
+
+#define NR_IRQS		24
+#define VALID_IRQ(i)	(i<=8 ||(i>=16 && i<NR_IRQS))
+
+
+#define IRQ_FIQ		0
+#define IRQ_SWI		1
+#define IRQ_USART0	2
+#define IRQ_USART1	3
+#define IRQ_TC0		4
+#define IRQ_TC1		5
+#define IRQ_TC2		6
+#define IRQ_WD		7
+#define IRQ_PIOA	8
+
+#define IRQ_EXT0	16
+#define IRQ_EXT1	17
+#define IRQ_EXT2	18
+
+#elif CONFIG_CPU_AT91X63
+/*
+ ******************* AT91x63xxx ********************
+ */
+
+#define NR_IRQS		32
+#define VALID_IRQ(i)	(i<=14 ||(i>=28 && i<NR_IRQS))
+
+#define IRQ_FIQ		0
+#define IRQ_SWI		1
+#define IRQ_USART0	2
+#define IRQ_USART1	3
+#define IRQ_USART2	4
+#define IRQ_SP		5
+#define IRQ_TC0		6
+#define IRQ_TC1		7
+#define IRQ_TC2		8
+#define IRQ_TC3		9
+#define IRQ_TC4		10
+#define IRQ_TC5		11
+#define IRQ_WD		12
+#define IRQ_PIOA	13
+#define IRQ_PIOB	14
+
+#define IRQ_EXT0	31
+#define IRQ_EXT1	30
+#define IRQ_EXT2	29
+#define IRQ_EXT3	28
+
+#else 
+  #error "Configuration error: No CPU defined"
+#endif
+
+#endif /* __ASM_ARCH_IRQS_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/keyboard.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/keyboard.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/keyboard.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/keyboard.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/keyboard.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  just a cite from other architecture :)
+ */
+#ifndef __ASM_ARM_ARCH_ATMEL_KEYBOARD_H
+#define __ASM_ARM_ARCH_ATMEL_KEYBOARD_H
+
+#define kbd_setkeycode(sc,kc) (-EINVAL)
+#define kbd_getkeycode(sc) (-EINVAL)
+#define kbd_translate(sc,kcp,rm) ({ *(kcp) = (sc); 1; })
+#define kbd_unexpected_up(kc) (0200)
+#define kbd_leds(leds)
+#define kbd_init_hw()
+#define kbd_enable_irq()
+#define kbd_disable_irq()
+
+#endif /* __ASM_ARM_ARCH_ATMEL_KEYBOARD_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/memory.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/memory.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/memory.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/memory.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,30 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/memory.h
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *		Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x01a00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((unsigned long) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((unsigned long) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/param.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/param.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/param.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/sizes.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/sizes.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/sizes.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/sizes.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/system.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/system.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/system.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,42 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/system.h
+ *
+ *  Copyright (C) 2002 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+static void arch_idle(void)
+{
+	 cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+ 	/* machine should reboot */
+ 	mdelay(5000);
+ 	panic("Watchdog timer reset failed!\n");
+ 	printk(" Jump to address 0 \n");
+ 	cpu_reset(0);
+}
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/time.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/time.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/time.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,29 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/time.h
+ *
+ * Copyright (C) 2001/02 Erwin Authried <eauth@softsys.co.at>
+ * Modified by Hyok S. Choi for 2.6, 2004.
+ */
+
+#ifndef __ASM_ARCH_TIME_H__
+#define __ASM_ARCH_TIME_H__
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/timex.h>
+
+#define CLOCKS_PER_USEC	(CONFIG_ARM_CLK/1000000)
+
+#if (KERNEL_TIMER==0)
+#   define KERNEL_TIMER_IRQ_NUM IRQ_TC0
+#elif (KERNEL_TIMER==1)
+#   define KERNEL_TIMER_IRQ_NUM IRQ_TC1
+#elif (KERNEL_TIMER==2)
+#   define KERNEL_TIMER_IRQ_NUM IRQ_TC2
+#else
+#error Wierd -- KERNEL_TIMER is not defined or something....
+#endif
+
+#endif
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/timex.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/timex.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/timex.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,10 @@
+/*
+ * timex.h:
+ * 2001 Mindspeed
+ */
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#define CLOCK_TICK_RATE	   0x270f
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/uncompress.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/uncompress.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/uncompress.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/uncompress.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,58 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/uncompress.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm-armnommu/hardware/dcc.h>
+
+#ifndef __UNCOMPRESS_H__
+#define __UNCOMPRESS_H__
+
+/*
+ * just use DCC JTAG1 port
+ */
+static inline void puts(const char *s)
+{
+	dcc_puts(s);
+}
+
+static void puts_hex(unsigned long i)
+{
+	char lhex_buf[]="0x00000000";
+	unsigned long ii,v;
+
+	for(ii=9;ii>1;ii--)
+	{
+		v=(((0x0000000F << ((9-ii)*4)) & i) >> ((9-ii)*4));
+		if(v>9)
+			lhex_buf[ii]=(char)('A'+v-10);
+		else
+			lhex_buf[ii]=(char)('0'+v);
+	}
+
+	dcc_puts(lhex_buf);
+}
+
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-atmel/vmalloc.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/vmalloc.h
--- linux-2.6.14-uc0/include/asm-arm/arch-atmel/vmalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-atmel/vmalloc.h	2005-11-08 09:06:51.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/vmalloc.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_ATMEL_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_ATMEL_SDRAM_SIZE)   
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/dma.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/dma.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/dma.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,29 @@
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/dma.h
+ *
+ * Currently this is not used for the s3c4510b port
+ *
+ * Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_S3C4510B_ARCH_DMA_H
+#define __ASM_S3C4510B_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ * 
+ */
+#define MAX_DMA_ADDRESS		0x03000000
+/*
+ * The S3C4510B has 2 internal DMA channels.
+ */
+#define MAX_DMA_CHANNELS	2
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#endif /* __ASM_S3C4510B_ARCH_DMA_H */
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/entry-macro.S linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/entry-macro.S
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/entry-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/entry-macro.S	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ *  arch/armnommu/mach-espd_4510b/entry-macro.S
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ */
+
+#if defined(CONFIG_ARCH_ESPD_4510B)
+
+		.macro disable_fiq
+		.endm
+
+		.macro get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =REG_INTOSET_IRQ
+		ldr	\irqnr, [\base]
+		mov	\irqnr, \irqnr, lsr #2
+		teq	\irqnr, #NR_IRQS
+		.endm
+
+		.macro irq_prio_table
+		.endm
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/hardware.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/hardware.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/hardware.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/hardware.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/hardware.h
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                   Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+#include <asm/arch/s3c4510b.h>
+
+#ifndef __ASSEMBLY__
+
+#define HARD_RESET_NOW()
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(1)
+
+#endif
+
+#endif  /*   END OF __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/io.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/io.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/io.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,67 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/io.h
+ *
+ * Copyright (C) 2003 Thomas Eschenbacher <eschenbacher@sympat.de>
+ * Modified by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+/*
+ * We have the this routine to use usb host device driver
+ */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a)			(PCI_IO_VADDR + (a))
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(PCI_MEMORY_VADDR + (unsigned long)(a))
+
+
+/*
+ * These macros were copied from arch/armnommu/io.h and are used instead
+ * of the definitions found there, because we want to do 16/32 bit i/o
+ * without byte swapping.
+ * --the
+ */
+
+#undef __io
+
+#ifndef __iob
+  #define __iob(a) __io(a)
+#endif
+
+#define outb(v,p)       __raw_writeb(v, p)
+#define outw(v,p)       __raw_writew(v, p)
+#define outl(v,p)       __raw_writel(v, p)
+
+#define inb(p)          ({ unsigned int __v = __raw_readb(p); __v; })
+#define inw(p)          ({ unsigned int __v = __raw_readw(p); __v; })
+#define inl(p)          ({ unsigned int __v = __raw_readl(p); __v; })
+
+#define outsb(p,d,l)    __raw_writesb(p, d, l)
+#define outsw(p,d,l)    __raw_writesw(p, d, l)
+#define outsl(p,d,l)    __raw_writesl(p, d, l)
+
+#define insb(p,d,l)     __raw_readsb(p, d, l)
+#define insw(p,d,l)     __raw_readsw(p, d, l)
+#define insl(p,d,l)     __raw_readsl(p, d, l)
+
+/*
+ * Validate the pci memory address for ioremap.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ */
+#define iomem_to_phys(iomem)	(iomem)
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/irq.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/irq.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/irq.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/irq.h
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __ARCH_S3C4510B_irq_h
+#define __ARCH_S3C4510B_irq_h
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+extern unsigned  int fixup_irq(int i);
+
+extern void do_IRQ(int irq, struct pt_regs *regs);
+
+extern void s3c4510b_init_irq(void);
+
+#define 	irq_init_irq 	s3c4510b_init_irq
+
+#endif 
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/irqs.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/irqs.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/irqs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/irqs.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,42 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/irqs.h
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Based on:
+ *  linux-2.4.x/asm/arch-samsung/irqs.h:
+ *  Mac Wang <mac@os.nctu.edu.tw>
+ *
+ */
+#ifndef __ASM_ARCH_IRQS_H__
+#define __ASM_ARCH_IRQS_H__
+#define NR_IRQS		21
+#define VALID_IRQ(i)	(i<=8 ||(i>=16 && i<NR_IRQS))
+
+#define INT_EXTINT0	0
+#define INT_EXTINT1	1
+#define INT_EXTINT2	2
+#define INT_EXTINT3	3
+#define INT_UARTTX0	4
+#define INT_UARTRX0	5
+#define INT_UARTTX1	6
+#define INT_UARTRX1	7
+#define INT_GDMA0	8
+#define INT_GDMA1	9
+#define INT_TIMER0	10
+#define INT_TIMER1	11
+#define INT_HDLCTXA	12
+#define INT_HDLCRXA	13
+#define INT_HDLCTXB	14
+#define INT_HDLCRXB	15
+#define INT_BDMATX	16
+#define INT_BDMARX	17
+#define INT_MACTX	18
+#define INT_MACRX	19
+#define INT_IIC		20
+#define INT_GLOBAL	21
+
+#define IRQ_TIMER	INT_TIMER0
+
+#endif /* __ASM_ARCH_IRQS_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/keyboard.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/keyboard.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/keyboard.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/keyboard.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/keyboard.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  just a cite from other architecture :)
+ */
+#ifndef __ASM_ARMNOMMU_ARCH_S3C4510B_KEYBOARD_H
+#define __ASM_ARMNOMMU_ARCH_S3C4510B_KEYBOARD_H
+
+#define kbd_setkeycode(sc,kc) (-EINVAL)
+#define kbd_getkeycode(sc) (-EINVAL)
+#define kbd_translate(sc,kcp,rm) ({ *(kcp) = (sc); 1; })
+#define kbd_unexpected_up(kc) (0200)
+#define kbd_leds(leds)
+#define kbd_init_hw()
+#define kbd_enable_irq()
+#define kbd_disable_irq()
+
+#endif /* __ASM_ARMNOMMU_ARCH_S3C4510B_KEYBOARD_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/memory.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/memory.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/memory.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/memory.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,25 @@
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/memory.h
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *		Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x01a00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((void *) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((void *) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/param.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/param.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/param.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/s3c4510b.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/s3c4510b.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/s3c4510b.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/s3c4510b.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,255 @@
+#ifndef __HW_S3C4510_H
+#define __HW_S3C4510_H
+
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/s3c4510b.h
+ *
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * MODULE:        $Id: s3c4510b.h,v 1.1 2004/08/25 13:52:35 gerg Exp $
+ * Description:   Samsung S3C4510B register layout
+ * Runtime Env:   ARM7TDMI
+ * Change History:
+ *     03-02-04    Create (Curt Brune) curt@cucy.com
+ */
+
+/*------------------------------------------------------------------------
+ *	  ASIC Address Definition
+ *----------------------------------------------------------------------*/
+
+
+#define S3C4510B_MEM_SIZE     (CONFIG_DRAM_SIZE) 
+#define MEM_SIZE              S3C4510B_MEM_SIZE
+#define PA_SDRAM_BASE         CONFIG_DRAM_BASE
+
+/* L1 8KB on chip SRAM base address */
+#define SRAM_BASE       (0x03fe0000)
+
+/* Special Register Start Address After System Reset */
+#define REG_BASE	(0x03ff0000)
+#define SPSTR      	(REG_BASE)
+
+/* *********************** */
+/* System Manager Register */
+/* *********************** */
+#define REG_SYSCFG	(REG_BASE+0x0000)
+
+#define REG_CLKCON      (REG_BASE+0x3000)
+#define REG_EXTACON0	(REG_BASE+0x3008)
+#define REG_EXTACON1	(REG_BASE+0x300c)
+#define REG_EXTDBWTH	(REG_BASE+0x3010)
+#define REG_ROMCON0	(REG_BASE+0x3014)
+#define REG_ROMCON1	(REG_BASE+0x3018)
+#define REG_ROMCON2	(REG_BASE+0x301c)
+#define REG_ROMCON3	(REG_BASE+0x3020)
+#define REG_ROMCON4	(REG_BASE+0x3024)
+#define REG_ROMCON5	(REG_BASE+0x3028)
+#define REG_DRAMCON0	(REG_BASE+0x302c)
+#define REG_DRAMCON1	(REG_BASE+0x3030)
+#define REG_DRAMCON2	(REG_BASE+0x3034)
+#define REG_DRAMCON3	(REG_BASE+0x3038)
+#define REG_REFEXTCON	(REG_BASE+0x303c)
+
+/* *********************** */
+/* Ethernet BDMA Register  */
+/* *********************** */
+#define REG_BDMATXCON	(REG_BASE+0x9000)
+#define REG_BDMARXCON	(REG_BASE+0x9004)
+#define REG_BDMATXPTR	(REG_BASE+0x9008)
+#define REG_BDMARXPTR	(REG_BASE+0x900c)
+#define REG_BDMARXLSZ	(REG_BASE+0x9010)
+#define REG_BDMASTAT	(REG_BASE+0x9014)
+
+/* Content Address Memory */
+#define REG_CAM_BASE	(REG_BASE+0x9100)
+
+#define REG_BDMATXBUF	(REG_BASE+0x9200)
+#define REG_BDMARXBUF	(REG_BASE+0x9800)
+
+/* *********************** */
+/* Ethernet MAC Register   */
+/* *********************** */
+#define REG_MACCON	(REG_BASE+0xa000)
+#define REG_CAMCON	(REG_BASE+0xa004)
+#define REG_MACTXCON	(REG_BASE+0xa008)
+#define REG_MACTXSTAT	(REG_BASE+0xa00c)
+#define REG_MACRXCON	(REG_BASE+0xa010)
+#define REG_MACRXSTAT	(REG_BASE+0xa014)
+#define REG_STADATA	(REG_BASE+0xa018)
+#define REG_STACON	(REG_BASE+0xa01c)
+#define REG_CAMEN	(REG_BASE+0xa028)
+#define REG_EMISSCNT	(REG_BASE+0xa03c)
+#define REG_EPZCNT	(REG_BASE+0xa040)
+#define REG_ERMPZCNT	(REG_BASE+0xa044)
+#define REG_ETXSTAT	(REG_BASE+0x9040)
+#define REG_MACRXDESTR	(REG_BASE+0xa064)
+#define REG_MACRXSTATEM	(REG_BASE+0xa090)
+#define REG_MACRXFIFO	(REG_BASE+0xa200)
+ 
+/********************/
+/* I2C Bus Register */
+/********************/
+#define REG_I2C_CON	(REG_BASE+0xf000)
+#define REG_I2C_BUF	(REG_BASE+0xf004)
+#define REG_I2C_PS	(REG_BASE+0xf008)
+#define REG_I2C_COUNT 	(REG_BASE+0xf00c)
+
+/********************/
+/*    GDMA 0        */
+/********************/
+#define REG_GDMACON0	(REG_BASE+0xb000)
+#define REG_GDMA0_RUN_ENABLE (REG_BASE+0xb020)
+#define REG_GDMASRC0	(REG_BASE+0xb004)
+#define REG_GDMADST0	(REG_BASE+0xb008)
+#define REG_GDMACNT0	(REG_BASE+0xb00c)
+
+/********************/
+/*    GDMA 1        */
+/********************/
+#define REG_GDMACON1	(REG_BASE+0xc000)
+#define REG_GDMA1_RUN_ENABLE (REG_BASE+0xc020)
+#define REG_GDMASRC1	(REG_BASE+0xc004)
+#define REG_GDMADST1	(REG_BASE+0xc008)
+#define REG_GDMACNT1	(REG_BASE+0xc00c)
+
+#define UART_CNT        (2)
+/********************/
+/*      UART 0      */
+/********************/
+#define UART0_BASE       (REG_BASE+0xd000)
+#define REG_UART0_LCON   (REG_BASE+0xd000)
+#define REG_UART0_CTRL   (REG_BASE+0xd004)
+#define REG_UART0_STAT   (REG_BASE+0xd008)
+#define REG_UART0_TXB    (REG_BASE+0xd00c)
+#define REG_UART0_RXB    (REG_BASE+0xd010)
+#define REG_UART0_BAUD_DIV    (REG_BASE+0xd014)
+#define REG_UART0_BAUD_CNT    (REG_BASE+0xd018)
+#define REG_UART0_BAUD_CLK    (REG_BASE+0xd01C)
+
+/********************/
+/*     UART 1       */
+/********************/
+#define UART1_BASE       (REG_BASE+0xe000)
+#define REG_UART1_LCON   (REG_BASE+0xe000)
+#define REG_UART1_CTRL   (REG_BASE+0xe004)
+#define REG_UART1_STAT   (REG_BASE+0xe008)
+#define REG_UART1_TXB    (REG_BASE+0xe00c)
+#define REG_UART1_RXB    (REG_BASE+0xe010)
+#define REG_UART1_BAUD_DIV    (REG_BASE+0xe014)
+#define REG_UART1_BAUD_CNT    (REG_BASE+0xe018)
+#define REG_UART1_BAUD_CLK    (REG_BASE+0xe01C)
+
+/********************/
+/*  Timer Register  */
+/********************/
+#define REG_TMOD  	(REG_BASE+0x6000)
+#define REG_TDATA0	(REG_BASE+0x6004)
+#define REG_TDATA1	(REG_BASE+0x6008)
+#define REG_TCNT0	(REG_BASE+0x600c)
+#define REG_TCNT1	(REG_BASE+0x6010)
+
+/**********************/
+/* I/O Port Interface */
+/**********************/
+#define REG_IOPMODE	(REG_BASE+0x5000)
+#define REG_IOPCON  	(REG_BASE+0x5004)
+#define REG_IOPDATA 	(REG_BASE+0x5008)
+
+/*********************************/
+/* Interrupt Controller Register */
+/*********************************/
+#define REG_INTMODE     (REG_BASE+0x4000)
+#define REG_INTPEND     (REG_BASE+0x4004)
+#define REG_INTMASK     (REG_BASE+0x4008)
+
+#define REG_INTPRI0     (REG_BASE+0x400c)
+#define REG_INTPRI1	(REG_BASE+0x4010)
+#define REG_INTPRI2	(REG_BASE+0x4014)
+#define REG_INTPRI3	(REG_BASE+0x4018)
+#define REG_INTPRI4	(REG_BASE+0x401c)
+#define REG_INTPRI5	(REG_BASE+0x4020)
+#define REG_INTOFFSET	(REG_BASE+0x4024)
+#define REG_INTPNDPRI	(REG_BASE+0x4028)
+#define REG_INTPNDTST	(REG_BASE+0x402C)
+#define REG_INTOSET_FIQ	(REG_BASE+0x4030)
+#define REG_INTOSET_IRQ	(REG_BASE+0x4034)
+
+#define INT_MODE_IRQ	0x000000
+#define INT_MODE_FIQ	0x1FFFFF
+#define INT_MASK_DIS	0x1FFFFF
+#define INT_MASK_ENA	0x000000
+
+/*********************************/
+/* CACHE CONTROL MASKS           */
+/*********************************/
+#define CACHE_STALL      (0x00000001) 
+#define CACHE_ENABLE     (0x00000002)
+#define CACHE_WRITE_BUFF (0x00000004)
+#define CACHE_MODE       (0x00000030)
+#define CACHE_MODE_00    (0x00000000)
+#define CACHE_MODE_01    (0x00000010)
+#define CACHE_MODE_10    (0x00000020)
+
+/*********************************/
+/* CACHE RAM BASE ADDRESSES      */
+/*********************************/
+#define CACHE_SET0_RAM   (0x10000000)
+#define CACHE_SET1_RAM   (0x10800000)
+#define CACHE_TAG_RAM    (0x11000000)
+
+/*********************************/
+/* CACHE_DISABLE MASK            */
+/*********************************/
+#define CACHE_DISABLE_MASK (0x04000000)
+
+/*********************************************************/
+/*	       TIMER MODE REGISTER                       */
+/*********************************************************/
+#define  TM0_RUN      0x01  /* Timer 0 enable */
+#define  TM0_TOGGLE   0x02  /* 0, interval mode */
+#define  TM0_OUT_1    0x04  /* Timer 0 Initial TOUT0 value */
+#define  TM1_RUN      0x08  /* Timer 1 enable */
+#define  TM1_TOGGLE   0x10  /* 0, interval mode */
+#define  TM1_OUT_1    0x20  /* Timer 0 Initial TOUT0 value */
+
+/*********************************************************
+ *	       INTERRUPT CONTROL                         
+ *
+ * An interrupt is enabled when mask bit is clear.
+ * An interrupt is disabled when mask bit is set. 
+ *********************************************************/
+#define INT_ENABLE(n)		outl( inl(REG_INTMASK) & ~( 1 << (n)), REG_INTMASK)
+#define INT_DISABLE(n)		outl( inl(REG_INTMASK) | ( 1 << (n)), REG_INTMASK)
+#define CLEAR_PEND_INT(n)	outl( (1 << (n)), REG_INTPEND)
+#define SET_PEND_INT(n)		outl( inl(REG_INTPNDTST) | ( 1 << (n)), REG_INTPNDMASK)
+
+#ifdef CONFIG_ARCH_ESPD_4510B
+#define LED_SET(n)              outl( inl(REG_IOPDATA) & ~(1<<(n)), REG_IOPDATA)
+#define LED_CLR(n)              outl( inl(REG_IOPDATA) |  (1<<(n)), REG_IOPDATA)
+#define LED_TOGGLE(n)		outl( inl(REG_IOPDATA) ^  (1<<(n)), REG_IOPDATA)
+#else
+#define LED_SET(n)
+#define LED_CLR(n)
+#define LED_TOGGLE(n)
+#endif
+
+#endif /* __S3C4510_h */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/sizes.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/sizes.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/sizes.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/sizes.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/system.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/system.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/system.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/system.h
+ *
+ *  Copyright (C) 2002 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+extern void __do_dump( const char *s);
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+ 	printk(KERN_ERR"arch_reset() not implemented\n");
+ 	BUG();
+}
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/time.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/time.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/time.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,31 @@
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/time.h
+ *
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * 2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ * modifed by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * Setup for 32 bit timer 0, used as system timer.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_TIME_H__
+#define __ASM_ARCH_TIME_H__
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/timex.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/timex.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/timex.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/timex.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                           Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#define CLOCK_TICK_RATE (CONFIG_ARM_CLK)
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/uart.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/uart.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/uart.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/uart.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,114 @@
+#ifndef _SC34510B_UART_H
+#define _SC34510B_UART_H
+
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/uart.h
+ *
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Description:   S3C4510B UART register layout
+ * Runtime Env:   ARM7TDMI
+ * Change History:
+ *     03-03-04    Create (Curt Brune)
+ */
+
+/* UART LINE CONTROL register */
+typedef struct __BF_UART_LINE_CTRL {
+	u32    wordLen: 2;
+	u32      nStop: 1;
+	u32     parity: 3;
+	u32        clk: 1;
+	u32  infra_red: 1;
+	u32     unused:24;
+} BF_UART_LINE_CTRL;
+
+typedef union _UART_LINE_CTRL {
+	u32               ui;
+	BF_UART_LINE_CTRL bf;
+} UART_LINE_CTRL;
+
+/* UART CONTROL register */
+typedef struct __BF_UART_CTRL {
+	u32     rxMode: 2;
+	u32      rxIrq: 1;
+	u32     txMode: 2;
+	u32        DSR: 1;
+	u32  sendBreak: 1;
+	u32   loopBack: 1;
+	u32     unused:24;
+} BF_UART_CTRL;
+
+typedef union _UART_CTRL {
+	u32            ui;
+	BF_UART_CTRL   bf;
+} UART_CTRL;
+
+/* UART STATUS register */
+typedef struct __BF_UART_STAT {
+	u32      overrun: 1;
+	u32       parity: 1;
+	u32        frame: 1;
+	u32     breakIrq: 1;
+	u32          DTR: 1;
+	u32      rxReady: 1;
+	u32   txBufEmpty: 1;
+	u32   txComplete: 1;
+	u32       unused:24;
+} BF_UART_STAT;
+
+typedef union _UART_STAT {
+	u32            ui;
+	BF_UART_STAT   bf;
+} UART_STAT;
+
+/* UART BAUD_DIV register */
+typedef struct __BF_UART_BAUD_DIV {
+	u32      cnt1: 4;
+	u32      cnt0:12;
+	u32    unused:16;
+} BF_UART_BAUD_DIV;
+
+typedef union _UART_BAUD_DIV {
+	u32                ui;
+	BF_UART_BAUD_DIV   bf;
+} UART_BAUD_DIV;
+
+/* UART register block */
+struct uart_regs {
+	volatile UART_LINE_CTRL  m_lineCtrl;
+	volatile UART_CTRL           m_ctrl;
+	volatile UART_STAT           m_stat;
+	volatile u32                   m_tx;
+	volatile u32                   m_rx;
+	volatile UART_BAUD_DIV    m_baudDiv;
+	volatile u32              m_baudCnt;
+	volatile u32              m_baudClk;
+};
+
+#define NL          0x0A
+#define CR          0x0D
+#define BSP         0x08
+#define ESC         0x1B
+#define CTRLZ       0x1A
+#define RUBOUT      0x7F
+
+#define UART_ANY_RX (0x2F)
+#define UART_NR    (2)
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/uncompress.c linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/uncompress.c
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/uncompress.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/uncompress.c	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,69 @@
+/*
+ * linux/include/asm/arch-samsung/uncompress.c
+ * 2001 Mac Wang <mac@os.nctu.edu.tw>
+ *
+ * linux-2.6.7/include/asm-armnommu/arch-espd_4510b/uncompress.c
+ * 2004 JS H. <asky@syncom.com.tw
+ */
+
+#include "hardware.h"
+
+#define VPint   *(volatile unsigned int *)
+
+#ifndef CSR_WRITE
+#   define CSR_WRITE(addr,data) (VPint(addr) = (data))
+#endif
+
+#ifndef CSR_READ
+#   define CSR_READ(addr)       (VPint(addr))
+#endif
+
+/** Console UART Port */
+#define DEBUG_CONSOLE   (0)
+
+#if (DEBUG_CONSOLE == 0)
+	#define DEBUG_TX_BUFF_BASE	REG_UART0_TXB
+	#define DEBUG_RX_BUFF_BASE      REG_UART0_RXB
+	#define DEBUG_UARTLCON_BASE     REG_UART0_LCON
+	#define DEBUG_UARTCONT_BASE     REG_UART0_CTRL
+	#define DEBUG_UARTBRD_BASE      REG_UART0_BAUD_DIV
+	#define DEBUG_CHK_STAT_BASE     REG_UART0_STAT
+#else /* DEBUG_CONSOLE == 1 */
+	#define DEBUG_TX_BUFF_BASE      REG_UART1_TXB
+	#define DEBUG_RX_BUFF_BASE      REG_UART1_RXB
+	#define DEBUG_UARTLCON_BASE     REG_UART1_LCON
+	#define DEBUG_UARTCONT_BASE     REG_UART1_CTRL
+	#define DEBUG_UARTBRD_BASE      REG_UART1_BAUD_DIV
+	#define DEBUG_CHK_STAT_BASE     REG_UART1_STAT
+#endif
+
+#define DEBUG_ULCON_REG_VAL     (0x3)
+#define DEBUG_UCON_REG_VAL      (0x9)
+#define DEBUG_UBRDIV_REG_VAL    (0x500)
+#define DEBUG_RX_CHECK_BIT      (0X20)
+#define DEBUG_TX_CAN_CHECK_BIT  (0X40)
+#define DEBUG_TX_DONE_CHECK_BIT (0X80)
+
+/** Setup console UART as 19200 bps */
+static void s3c4510b_decomp_setup(void)
+{
+	CSR_WRITE(DEBUG_UARTLCON_BASE, DEBUG_ULCON_REG_VAL);
+	CSR_WRITE(DEBUG_UARTCONT_BASE, DEBUG_UCON_REG_VAL);
+	CSR_WRITE(DEBUG_UARTBRD_BASE,  DEBUG_UBRDIV_REG_VAL);
+}
+
+static void s3c4510b_putc(char c)
+{
+	CSR_WRITE(DEBUG_TX_BUFF_BASE, c);
+	while(!(CSR_READ(DEBUG_CHK_STAT_BASE) & DEBUG_TX_DONE_CHECK_BIT));
+
+	if(c == '\n')
+		s3c4510b_putc('\r');
+}
+
+static void s3c4510b_puts(const char *s)
+{
+	while(*s != '\0')
+		s3c4510b_putc(*s++);
+}
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/uncompress.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/uncompress.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/uncompress.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/uncompress.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,50 @@
+/*
+ * asm/arch/uncompress.c:
+ *         Optional routines to aid in debugging the decompression phase
+ *         of kernel boot.
+ * copyright:
+ *         (C) 2001 RidgeRun, Inc. (http://www.ridgerun.com)
+ * author: Gordon McNutt <gmcnutt@ridgerun.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ * WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ * USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <asm/arch/uncompress.c>
+/*
+ * This is used by arch/armnommu/boot/compressed/misc.c to write progress info
+ * out the serial port so that the user can see debug messages up to the point
+ * where the kernel is decompressed. The STANDALONE_DEBUG macro chooses between
+ * this and the standard printf. Punt.
+ * --gmcnutt
+ */
+#define putstr(s)			s3c4510b_puts(s)
+
+/*
+ * Not sure what this is for. Probably an optional watchdog to check if the
+ * decompress got hung so we can warn the user. Punt.
+ */
+#define arch_decomp_wdog()
+
+/*
+ * If we need to do some setup prior to decompression (like initializing the
+ * UART if we want to use puts() above) then we define it here. Punt.
+ */
+#define arch_decomp_setup()	s3c4510b_decomp_setup()
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/vmalloc.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/vmalloc.h
--- linux-2.6.14-uc0/include/asm-arm/arch-espd_4510b/vmalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-espd_4510b/vmalloc.h	2005-11-08 09:06:54.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King. 
+ *  modified by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_S3C4510_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_S3C4510_SDRAM_SIZE)   
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/debug-macro.S linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/debug-macro.S
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/debug-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/debug-macro.S	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,37 @@
+/* linux/include/asm-arm/arch-p2001/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ * by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		/* UART base address */
+		.macro	addruart,rx
+		mov	\rx, #0x00140000
+		.endm
+
+		/* send char */
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx]
+		.endm
+
+		/* wait for end of transmission */
+		.macro	busyuart,rd,rx
+1001:		ldrb	\rd, [\rx, #0x24]
+		cmp	\rd, #0
+		bne	1001b
+		.endm
+
+		/* wait for fifo space */
+		/* quickest way here: test for >0x20 chars in fifo */
+		.macro	waituart,rd,rx
+1001:		ldrb	\rd, [\rx, #0x24]
+		tst	\rd, #0x20
+		bne	1001b
+		.endm
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/dma.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/dma.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/dma.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,32 @@
+/*
+ * linux/include/asm-armnommu/arch-p2001/dma.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ * 
+ */
+#define MAX_DMA_ADDRESS		0x01000000
+#define MAX_DMA_TRANSFER_SIZE   0x100000
+/*  TODO TODO TODO TODO TODO  */
+
+/***************************************************************************/
+/* this means that We will use arch/arm/mach/dma.h i.e generic dma module  */
+#define MAX_DMA_CHANNELS	0
+/***************************************************************************/
+
+#define arch_dma_init(dma_chan) 
+#endif /* _ASM_ARCH_DMA_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/entry-macro.S linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/entry-macro.S
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/entry-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/entry-macro.S	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,168 @@
+/*
+ *  linux/arch/armnommu/mach-p2001/entry-macro.S
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/arch/irqs.h>
+
+#define Adr_INT_CTRL_BASE		0x00130000
+#define REL_Adr_Main_NFIQ_Int_Ctrl	0x00
+#define REL_Adr_Main_NIRQ_Int_Ctrl	0x04
+#define REL_Adr_Status_NFIQ		0x08
+#define REL_Adr_Status_NIRQ		0x0c
+
+#define NR_IRQS				27	/* 27 Interrupts: INT 0..26 */
+
+
+		/* disable FIQ */
+                .macro  disable_fiq
+                .endm
+
+
+		/*
+		 * get the irq number(at least), and others.
+		 * irqnr  :  The number of the IRQ that you want to raise.
+		 * irqstat: ???
+		 * base   :  The comments suggest this is a prioritization mechanism, but it doesn't appear
+		 *           to be actually used anywhere.  That's why many of the irq_prio_table macros are empty.
+		 * flags  :  This is non-obvious, but you'll notice that every get_irqnr_and_base macro
+		 *           does a test at the end of the macro.  If you don't have a flag (I think it's the Z) set,
+		 *           then you'll never call do_IRQ.  It's basically a check to avoid calling do_IRQ if you had
+		 *           a spurious interrupt (or one that was masked).
+		 */
+		/* irqnr=r0 irqstat=r6 base=r5 tmp=lr */
+                .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	\irqstat, #Adr_INT_CTRL_BASE
+		ldr	\irqstat, [\irqstat, #REL_Adr_Status_NIRQ]
+
+                mov	\irqnr, #IRQ_EU0_DATA
+		tst	\irqstat, #(1<<IRQ_EU0_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU1_DATA
+		tst	\irqstat, #(1<<IRQ_EU1_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_TIMER1
+		tst	\irqstat, #(1<<IRQ_TIMER1)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU0_ERROR
+		tst	\irqstat, #(1<<IRQ_EU0_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU1_ERROR
+		tst	\irqstat, #(1<<IRQ_EU1_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_UART
+		tst	\irqstat, #(1<<IRQ_UART)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_USB
+		tst	\irqstat, #(1<<IRQ_USB)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PWM
+		tst	\irqstat, #(1<<IRQ_PWM)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_FSC
+		tst	\irqstat, #(1<<IRQ_FSC)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_GPIO
+		tst	\irqstat, #(1<<IRQ_GPIO)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PFS0
+		tst	\irqstat, #(1<<IRQ_PFS0)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PFS1
+		tst	\irqstat, #(1<<IRQ_PFS1)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PFS2
+		tst	\irqstat, #(1<<IRQ_PFS2)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PFS3
+		tst	\irqstat, #(1<<IRQ_PFS3)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_SO0
+		tst	\irqstat, #(1<<IRQ_SO0)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_SO1
+		tst	\irqstat, #(1<<IRQ_SO1)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_DTMF
+		tst	\irqstat, #(1<<IRQ_DTMF)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_WATCHDOG
+		tst	\irqstat, #(1<<IRQ_WATCHDOG)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_PCMHW
+		tst	\irqstat, #(1<<IRQ_PCMHW)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_HDLC_MTS
+		tst	\irqstat, #(1<<IRQ_HDLC_MTS)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_HDLC_ERROR
+		tst	\irqstat, #(1<<IRQ_HDLC_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_HDLC_DATA
+		tst	\irqstat, #(1<<IRQ_HDLC_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU2_DATA
+		tst	\irqstat, #(1<<IRQ_EU2_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU2_ERROR
+		tst	\irqstat, #(1<<IRQ_EU2_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU3_DATA
+		tst	\irqstat, #(1<<IRQ_EU3_DATA)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_EU3_ERROR
+		tst	\irqstat, #(1<<IRQ_EU3_ERROR)
+		bne	1001f
+
+                mov	\irqnr, #IRQ_TIMER2
+		tst	\irqstat, #(1<<IRQ_TIMER2)
+1001:
+                .endm
+
+
+		/* irq priority table */
+                .macro  irq_prio_table
+                .endm
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/hardware.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/hardware.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/hardware.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/hardware.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,351 @@
+/*
+ * linux/include/asm-arm/arch-p2001/hardware.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+#ifndef __ASSEMBLY__
+
+/* DMA descriptor */
+typedef struct {
+	u32	stat;			/* status: own, start, end, offset, status */
+	u32	cntl;			/* control: loop, int, type, channel, length */
+	char	*buf;			/* buffer */
+	void	*next;			/* nextdsc */
+} DMA_DSC;
+
+
+/* The address definitions are from asic_bf.h */
+typedef struct {					// 0x00100000U
+	volatile unsigned int reserved1[0x3];
+	volatile unsigned int ArmDmaPri;		// 0x0000000CU
+	volatile unsigned int SDRAM_Ctrl;		// 0x00000010U
+	volatile unsigned int ExtMem_Ctrl;		// 0x00000014U
+	volatile unsigned int WaitState_Ext;		// 0x00000018U
+	volatile unsigned int WaitState_Asic;		// 0x0000001CU
+	volatile unsigned int TOP;			// 0x00000020U
+	volatile unsigned int reserved2[0x3];
+	volatile unsigned int Adr1_EQ_30Bit;		// 0x00000030U
+	volatile unsigned int Adr2_EQ_30Bit;		// 0x00000034U
+	volatile unsigned int Adr3_EQ_30Bit;		// 0x00000038U
+	volatile unsigned int Dat3_EQ_32Bit;		// 0x0000003CU
+	volatile unsigned int Adr4_HE_20Bit;		// 0x00000040U
+	volatile unsigned int Adr4_LT_20Bit;		// 0x00000044U
+	volatile unsigned int Adr5_HE_20Bit;		// 0x00000048U
+	volatile unsigned int Adr5_LT_20Bit;		// 0x0000004CU
+	volatile unsigned int Adr_Control;		// 0x00000050U
+	volatile unsigned int ABORT_IA_32Bit;		// 0x00000054U	
+} *P2001_SYS_regs_ptr;
+#define P2001_SYS ((volatile P2001_SYS_regs_ptr) 0x00100000UL)
+
+typedef struct {					// 0x00110000U
+	volatile unsigned int Timer1;			// 0x00000000U
+	volatile unsigned int Timer2;			// 0x00000004U
+	volatile unsigned int TIMER_PRELOAD;		// 0x00000008U
+	volatile unsigned int Timer12_PreDiv;		// 0x0000000CU
+	volatile unsigned int TIMER_INT;		// 0x00000010U
+	volatile unsigned int Freerun_Timer;		// 0x00000014U
+	volatile unsigned int WatchDog_Timer;		// 0x00000018U
+	volatile unsigned int reserved1[0x1];
+	volatile unsigned int PWM_CNT;			// 0x00000020U
+	volatile unsigned int PWM_CNT2;			// 0x00000024U
+	volatile unsigned int reserved2[0x2];
+	volatile unsigned int PLL_12000_config;		// 0x00000030U
+	volatile unsigned int PLL_12288_config;		// 0x00000034U
+	volatile unsigned int DIV_12288_config;		// 0x00000038U
+	volatile unsigned int MOD_CNT_768;		// 0x0000003CU
+	volatile unsigned int FSC_IRQ_STATUS;		// 0x00000040U
+	volatile unsigned int FSC_CONFIG;		// 0x00000044U
+	volatile unsigned int FSC_CONSTRUCT;		// 0x00000048U
+	volatile unsigned int FSC_base_clk_reg;		// 0x0000004CU
+	volatile unsigned int SYSCLK_SHAPE;		// 0x00000050U
+	volatile unsigned int SDRAMCLK_SHAPE;		// 0x00000054U
+	volatile unsigned int RING_OSZI;		// 0x00000058U
+} *P2001_TIMER_regs_ptr;
+#define P2001_TIMER ((volatile P2001_TIMER_regs_ptr) 0x00110000UL)
+
+typedef struct {					// 0x00120000U
+	volatile unsigned int reserved1[0x5];
+	volatile unsigned int GPIO_Config;		// 0x00000014U
+	volatile unsigned int GPIO_INT;			// 0x00000018U
+	volatile unsigned int GPIO_Out;			// 0x0000001CU
+	volatile unsigned int GPIO_IN;			// 0x00000020U
+	volatile unsigned int GPIO_En;			// 0x00000024U
+	volatile unsigned int PIN_MUX;			// 0x00000028U
+	volatile unsigned int NRES_OUT;			// 0x0000002CU
+	volatile unsigned int GPIO2_Out;		// 0x00000030U
+	volatile unsigned int GPIO2_IN;			// 0x00000034U
+	volatile unsigned int GPIO2_En;			// 0x00000038U
+	volatile unsigned int GPIO_INT_SEL;		// 0x0000003CU
+	volatile unsigned int GPI3_IN;			// 0x00000040U
+	volatile unsigned int GPO4_OUT;			// 0x00000044U
+} *P2001_GPIO_regs_ptr;
+#define P2001_GPIO ((volatile P2001_GPIO_regs_ptr) 0x00120000UL)
+
+typedef struct {					// 0x00130000U
+	volatile unsigned int Main_NFIQ_Int_Ctrl;	// 0x00000000U
+	volatile unsigned int Main_NIRQ_Int_Ctrl;	// 0x00000004U
+	volatile unsigned int Status_NFIQ;		// 0x00000008U
+	volatile unsigned int Status_NIRQ;		// 0x0000000CU
+} *P2001_INT_CTRL_regs_ptr;
+#define P2001_INT_CTRL ((volatile P2001_INT_CTRL_regs_ptr) 0x00130000UL)
+
+typedef struct {					// 0x00130000U
+	volatile unsigned int IRQ_STATUS;		// 0x00000000U
+	volatile unsigned int FIQ_STATUS;		// 0x00000004U
+	volatile unsigned int RAW_INTR;			// 0x00000008U
+	volatile unsigned int INT_SELECT;		// 0x0000000CU
+	volatile unsigned int INT_ENABLE;		// 0x00000010U
+	volatile unsigned int INT_ENCLEAR;		// 0x00000014U
+	volatile unsigned int SOFTINT;			// 0x00000018U
+	volatile unsigned int SOFTINT_CLEAR;		// 0x0000001CU
+	volatile unsigned int PROTECTION;		// 0x00000020U
+	volatile unsigned int reserved1[0x3];
+	volatile unsigned int CUR_VECT_ADDR;		// 0x00000030U
+	volatile unsigned int DEF_VECT_ADDR;		// 0x00000034U
+	volatile unsigned int reserved2[0x32];
+	volatile unsigned int VECT_ADDR[16];		// 0x00000100U - 0x013CU
+	volatile unsigned int reserved3[0x30];
+	volatile unsigned int VECT_CNTL[16];		// 0x00000200U - 0x023CU
+} *P2001_LPEC_VIC_regs_ptr;
+#define P2001_LPEC_VIC ((volatile P2001_LPEC_VIC_regs_ptr) 0x00130000UL)
+
+typedef union {						// 0x00140000U
+	struct {	// write
+		volatile unsigned int TX[4];		// 0x00000000U-0x000CU
+		volatile unsigned int Baudrate;		// 0x00000010U
+		volatile unsigned int reserved1[0x3];
+		volatile unsigned int Config;		// 0x00000020U
+		volatile unsigned int Clear;		// 0x00000024U
+		volatile unsigned int Echo_EN;		// 0x00000028U
+		volatile unsigned int IRQ_Status;	// 0x0000002CU
+	} w;		// write
+	
+	struct {	// read
+		volatile unsigned int RX[4];		// 0x00000000U-0x000CU
+		volatile unsigned int reserved1[0x4];
+		volatile unsigned int PRE_STATUS;	// 0x00000020U
+		volatile unsigned int STATUS;		// 0x00000024U
+		volatile unsigned int reserved2[0x1];
+		volatile unsigned int IRQ_Status;	// 0x0000002CU
+	} r;		// read
+} *P2001_UART_regs_ptr;
+#define P2001_UART ((volatile P2001_UART_regs_ptr) 0x00140000UL)
+
+typedef struct {					// 0x00150000U
+	struct {
+		volatile unsigned char S[0x100];	// 0x00000000U
+		volatile unsigned char H[0x100];	// 0x00000100U
+	} BASE[8];
+	struct {
+		volatile unsigned char S[0x100];	// 0x00001000U
+		volatile unsigned char H[0x100];	// 0x00001100U
+	} HDLC;
+	struct {
+		volatile unsigned char S[0x100];	// 0x00001200U
+		volatile unsigned char H[0x100];	// 0x00001300U
+	} DTMF;
+	volatile unsigned int reserved1[0x300];
+	struct {
+		volatile unsigned int Control;		// 0x00002000U
+		volatile unsigned int Timeslot_Enable;	// 0x00002004U
+		volatile unsigned int Status;		// 0x00002008U
+		volatile unsigned int reserved1[0x1];
+	} CTS[8];
+	struct {
+		volatile unsigned int Control;		// 0x00002080U
+		volatile unsigned int Status;		// 0x00002084U
+		volatile unsigned int reserved1[0x2];
+	} HDLC_WB;
+	struct {
+		volatile unsigned int Control;		// 0x00002080U
+		volatile unsigned int Status;		// 0x00002084U
+		volatile unsigned int reserved1[0x2];
+	} DTMF_WB;
+	volatile unsigned int Peripheral_Frame_Sync[4];	// 0x000020A0U - 0x20ACU
+	volatile unsigned int BSCK_FSC_Select;		// 0x000020B0U
+} *P2001_PCM_HW_regs_ptr;
+#define P2001_PCM_HW ((volatile P2001_PCM_HW_regs_ptr) 0x00150000UL)
+
+typedef struct {					// 0x00160000U
+	volatile unsigned int COEF_1394_697;		// 0x00000000U
+	volatile unsigned int COEF_1540_770;		// 0x00000004U
+	volatile unsigned int COEF_1704_852;		// 0x00000008U
+	volatile unsigned int COEF_1882_941;		// 0x0000000CU
+	volatile unsigned int COEF_2418_1209;		// 0x00000010U
+	volatile unsigned int COEF_2672_1336;		// 0x00000014U
+	volatile unsigned int COEF_2954_1477;		// 0x00000018U
+	volatile unsigned int COEF_3266_1633;		// 0x0000001CU
+	volatile unsigned int COEF_SIGNS;		// 0x00000020U
+	volatile unsigned int RECURSION_COUNTER;	// 0x00000024U
+	volatile unsigned int LAW_SCALE;		// 0x00000028U
+	volatile unsigned int reserved1[0x3];
+	volatile unsigned int MAC_TABLE_LO_N;		// 0x00000038U
+	volatile unsigned int MAC_TABLE_HI_N;		// 0x0000003CU
+	volatile unsigned int MAG_TONE[8];		// 0x00000040U
+	volatile unsigned int MAG_OVERTONE[8];		// 0x00000060U
+	/* Basetone T = 0:697Hz / 1:770Hz / ... / 7:1633Hz */
+	struct {
+		volatile unsigned int TAP1;		// 0x00000080U
+		volatile unsigned int TAP2;		// 0x00000084U
+	} TONE[8];
+	/* Overtone OT= 0:1394Hz / 1:1540Hz / ... / 7:3266Hz */
+	struct {
+		volatile unsigned int TAP1;		// 0x000000C0U
+		volatile unsigned int TAP2;		// 0x000000C4U
+	} OVERTONE[8];
+} *P2001_DTMF_COEF_regs_ptr;
+#define P2001_DTMF_COEF(x) ((volatile P2001_DTMF_COEF_regs_ptr) ((unsigned int) 0x00160000UL+(0x100UL*(x)))) /* x = 0..31 */
+
+typedef struct {					// 0x00162000U
+	volatile unsigned int ENA_REG;			// 0x00000000U
+	volatile unsigned int IRQ_STAT_REG;		// 0x00000004U
+} *P2001_DTMF_regs_ptr;
+#define P2001_DTMF ((volatile P2001_DTMF_regs_ptr) 0x00162000UL)
+
+typedef struct {					// 0x00164000U
+	volatile unsigned int VAL_LO;			// 0x00000000U
+	volatile unsigned int VAL_HI;			// 0x00000004U
+	volatile unsigned int RES;			// 0x00000008U
+} *P2001_MAC_CMP_regs_ptr;
+#define P2001_MAC_CMP ((volatile P2001_MAC_CMP_regs_ptr) 0x00164000UL)
+
+typedef struct {					// 0x00170_00U _=0,4
+	volatile unsigned int B1_REC;			// 0x00000000U
+	volatile unsigned int B1_SEND;			// 0x00000004U
+	volatile unsigned int B2_REC;			// 0x00000008U
+	volatile unsigned int B2_SEND;			// 0x0000000CU
+	volatile unsigned int D_REC;			// 0x00000010U
+	volatile unsigned int D_SEND;			// 0x00000014U
+	volatile unsigned int E_REC;			// 0x00000018U
+	volatile unsigned int CTRL;			// 0x0000001CU
+	volatile unsigned int INT_EN;			// 0x00000020U
+	volatile unsigned int INT_STATUS;		// 0x00000024U
+	volatile unsigned int FSC_PHASE;		// 0x00000028U
+	volatile unsigned int reserved1[0x25];
+	/* HFC-S+ Registers */
+	volatile unsigned int STATES;			// 0x000000C0U (HFC-S+ Adr 30)
+	volatile unsigned int SCTRL;			// 0x000000C4U (HFC-S+ Adr 31)
+	volatile unsigned int SCTRL_E;			// 0x000000C8U (HFC-S+ Adr 32)
+	volatile unsigned int SCTRL_R;			// 0x000000CCU (HFC-S+ Adr 33)
+	volatile unsigned int SQ_REC_SEND;		// 0x000000D0U (HFC-S+ Adr 34)
+	volatile unsigned int reserved2[0x2];
+	volatile unsigned int CLKDEL;			// 0x000000DCU (HFC-S+ Adr 37)
+} *P2001_S0_regs_ptr;
+#define P2001_S0(x) ((volatile P2001_S0_regs_ptr) ((unsigned int) 0x00170000UL+(0x400UL*(x)))) /* x = 0..1 */
+
+typedef struct {					// 0x0018_000U _=0,1,2,3
+	volatile DMA_DSC *    RMAC_DMA_DESC;		// 0x00000000U
+	volatile unsigned int RMAC_DMA_CNTL;		// 0x00000004U
+	volatile unsigned int RMAC_DMA_STAT;		// 0x00000008U
+	volatile unsigned int RMAC_DMA_EN;		// 0x0000000CU
+	volatile unsigned int RMAC_CNTL;		// 0x00000010U
+	volatile unsigned int RMAC_TLEN;		// 0x00000014U
+	volatile unsigned int RMAC_PHYU;		// 0x00000018U
+	volatile unsigned int RMAC_PHYL;		// 0x0000001CU
+	volatile unsigned int RMAC_PFM[8];		// 0x00000020U-0x003CU
+	volatile unsigned int RMAC_MIB[6];		// 0x00000040U-0x0054U
+	volatile unsigned int reserved1[0x1e8];
+	volatile unsigned int RMAC_DMA_DATA;		// 0x000007F8U
+	volatile unsigned int RMAC_DMA_ADR;		// 0x000007FCU
+	volatile DMA_DSC *    TMAC_DMA_DESC;		// 0x00000800U
+	volatile unsigned int TMAC_DMA_CNTL;		// 0x00000804U
+	volatile unsigned int TMAC_DMA_STAT;		// 0x00000808U
+	volatile unsigned int TMAC_DMA_EN;		// 0x0000080CU
+	volatile unsigned int TMAC_CNTL;		// 0x00000810U
+	volatile unsigned int TMAC_MIB[2];		// 0x00000814U-0x0818U
+	volatile unsigned int reserved2[0x1];
+	volatile unsigned int MU_CNTL;			// 0x00000820U
+	volatile unsigned int MU_DATA;			// 0x00000824U
+	volatile unsigned int MU_DIV;			// 0x00000828U
+	volatile unsigned int CONF_RMII;		// 0x0000082CU
+	volatile unsigned int reserved3[0x1f2];
+	volatile unsigned int TMAC_DMA_DATA;		// 0x00000FF8U
+	volatile unsigned int TMAC_DMA_ADR;		// 0x00000FFCU
+} *P2001_ETH_regs_ptr;
+#define P2001_EU(x) ((volatile P2001_ETH_regs_ptr) ((unsigned int) 0x00180000UL+(0x1000UL*(x)))) /* x = 0..3 */
+#define P2001_MU  P2001_EU(0)
+
+typedef struct {				// 0x00184__0U _=00,...7C
+	volatile unsigned int v_tx_dma_desc;	// 0x00000000U
+	volatile unsigned int reserved1[0x1];
+	volatile unsigned int v_tx_dma_stat;	// 0x00000008U
+	volatile unsigned int v_tx_dma_en;	// 0x0000000CU
+	volatile unsigned int v_rx_dma_desc;	// 0x00000010U
+	volatile unsigned int v_rx_dma_cntl;	// 0x00000014U
+	volatile unsigned int v_rx_dma_stat;	// 0x00000018U
+	volatile unsigned int v_rx_dma_en;	// 0x0000001CU
+	volatile unsigned int v_mode;		// 0x00000020U
+	volatile unsigned int v_es_reg;		// 0x00000024U
+	volatile unsigned int v_es_stat;	// 0x00000028U
+	volatile unsigned int reserved2[0x5];
+} *P2001_HDLC_DMA_regs_ptr[32];
+#define P2001_HDLC_DMA ((volatile P2001_HDLC_regs_ptr) 0x00184000UL)
+
+typedef struct {				// 0x001847F0U
+	volatile unsigned int reserved1[0x2];
+	volatile unsigned int rx_data;		// 0x000007F8U
+	volatile unsigned int rx_adr;		// 0x000007FCU
+	volatile unsigned int mts_tsa_base;	// 0x00000800U
+	volatile unsigned int reserved2[0x183];
+	volatile unsigned int pcm_cntl;		// 0x00000E10U
+	volatile unsigned int reserved3[0x1];
+	volatile unsigned int frame_end;	// 0x00000E18U
+	volatile unsigned int v_data_stat;	// 0x00000E1CU
+	volatile unsigned int v_err_stat;	// 0x00000E20U
+	volatile unsigned int reserved4[0x75];
+	volatile unsigned int tx_data;		// 0x00000FF8U
+	volatile unsigned int tx_adr;		// 0x00000FFCU
+} *P2001_HDLC_regs_ptr;
+#define P2001_HDLC ((volatile P2001_HDLC_regs_ptr) 0x001847F0UL)
+
+typedef struct {					// 0x00190000U
+	volatile unsigned int FUNC_ADDR;		// 0x00000000U
+	volatile unsigned int MODE_CTRL;		// 0x00000004U
+	volatile unsigned int CTRL;			// 0x00000008U
+	volatile unsigned int MAIN_EVENT;		// 0x0000000CU
+	volatile unsigned int MAIN_EVENT_MSK;		// 0x00000010U
+	volatile unsigned int STATIC_EVENT;		// 0x00000014U
+	volatile unsigned int STATIC_EVENT_MSK;		// 0x00000018U
+	volatile unsigned int FRM_TIMER;		// 0x0000001CU
+	volatile unsigned int OUT_EP_SEL;		// 0x00000020U
+	volatile unsigned int OUT_DATA;			// 0x00000024U
+	volatile unsigned int OUT_CMD;			// 0x00000028U
+	volatile unsigned int OUT_STAT;			// 0x0000002CU
+	volatile unsigned int IN_EP_SEL;		// 0x00000030U
+	volatile unsigned int IN_DATA;			// 0x00000034U
+	volatile unsigned int IN_CMD;			// 0x00000038U
+	volatile unsigned int reserved1[0x1];
+	volatile unsigned int OEP_ENA;			// 0x00000040U
+	volatile unsigned int IEP_ENA;			// 0x00000044U
+	volatile unsigned int OEP_STALL;		// 0x00000048U
+	volatile unsigned int IEP_STALL;		// 0x0000004CU
+	volatile unsigned int OUT_EVENT;		// 0x00000050U
+	volatile unsigned int OUT_EVENT_MSK;		// 0x00000054U
+	volatile unsigned int IN_EVENT;			// 0x00000058U
+	volatile unsigned int IN_EVENT_MSK;		// 0x0000005CU
+	volatile unsigned int IN_ISO_CONF_REG;		// 0x00000060U
+	volatile unsigned int OUT_ISO_CONF_REG;		// 0x00000064U
+	volatile unsigned int IN_PTR_REG;		// 0x00000068U
+	volatile unsigned int OUT_PTR_REG;		// 0x0000006CU
+	volatile unsigned int reserved2[0x3];
+	volatile unsigned int CTRL_REG;			// 0x0000007CU
+} *P2001_USB_regs_ptr;
+#define P2001_USB ((volatile P2001_USB_regs_ptr) 0x00190000UL)
+
+typedef volatile unsigned char *P2001_USB_FIFO_ptr[64];
+#define P2001_USB_EPxIN(x)  ((volatile P2001_USB_FIFO_ptr) ((unsigned int) 0x001A0000UL+(0x40UL*(x)))) /* x = 0..5 */
+#define P2001_USB_EPxOUT(x) ((volatile P2001_USB_FIFO_ptr) ((unsigned int) 0x001A0180UL+(0x40UL*(x)))) /* x = 0..5 */
+
+#endif
+
+#endif  /* _ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/io.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/io.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/io.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,36 @@
+/*
+ * linux/include/asm-armnommu/arch-p2001/io.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __mem_pci(a)            (a)
+
+#define __io(a) ((unsigned long)(a))
+
+/*
+ * Defining these two gives us ioremap for free. See asm/io.h.
+ * --gmcnutt
+ */
+#define iomem_valid_addr(iomem,size) (1)
+#define iomem_to_phys(iomem) (iomem)
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/irq.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/irq.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/irq.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,32 @@
+/*
+ *  linux/include/asm-armnommu/arch-p2001/irq.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_IRQ_H__
+#define __ASM_ARCH_IRQ_H__
+
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+#define fixup_irq(x) (x)
+
+extern void do_IRQ(int irq, struct pt_regs *regs);
+
+extern void p2001_mask_irq(unsigned int irq);
+extern void p2001_unmask_irq(unsigned int irq);
+extern void p2001_mask_ack_irq(unsigned int irq);
+
+extern void p2001_init_irq(void);
+
+#define 	irq_init_irq 	p2001_init_irq
+
+#endif /* __ASM_ARCH_IRQ_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/irqs.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/irqs.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/irqs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/irqs.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,42 @@
+/*
+ *  linux/include/asm-armnommu/arch-p2001/irqs.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H__
+#define __ASM_ARCH_IRQS_H__
+
+#define IRQ_USB		0
+#define IRQ_UART	1
+#define IRQ_PWM		2
+#define IRQ_FSC		3
+#define IRQ_GPIO	4
+#define IRQ_PFS0	5
+#define IRQ_PFS1	6
+#define IRQ_PFS2	7
+#define IRQ_PFS3	8
+#define IRQ_SO0		9
+#define IRQ_SO1		10
+#define IRQ_DTMF	11
+#define IRQ_WATCHDOG	12
+#define IRQ_PCMHW	13
+#define IRQ_HDLC_MTS	14
+#define IRQ_HDLC_ERROR	15
+#define IRQ_HDLC_DATA	16
+#define IRQ_EU0_DATA	17
+#define IRQ_EU0_ERROR	18
+#define IRQ_EU1_DATA	19
+#define IRQ_EU1_ERROR	20
+#define IRQ_EU2_DATA	21
+#define IRQ_EU2_ERROR	22
+#define IRQ_EU3_DATA	23
+#define IRQ_EU3_ERROR	24
+#define IRQ_TIMER1	25
+#define IRQ_TIMER2	26
+
+#endif /* __ASM_ARCH_IRQS_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/memory.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/memory.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/memory.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/memory.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,33 @@
+/*
+ * linux/include/asm-arm/arch-p2001/memory.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x01a00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((void *) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((void *) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/param.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/param.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/param.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,16 @@
+/*
+ *  linux/include/asm-armnommu/arch-p2001/param.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/system.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/system.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/system.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,32 @@
+/*
+ *  linux/include/asm-armnommu/arch-p2001/system.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+ 	/* machine should reboot */
+ 	mdelay(5000);
+ 	panic("Watchdog timer reset failed!\n");
+ 	printk(" Jump to address 0 \n");
+ 	cpu_reset(0);
+}
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/timex.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/timex.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/timex.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,17 @@
+/*
+ *  linux/include/asm-armnommu/arch-p2001/timex.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#define CLOCK_TICK_RATE (CONFIG_SYSCLK)
+//#define CLOCK_TICK_RATE 12288000
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/uncompress.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/uncompress.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/uncompress.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/uncompress.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,43 @@
+/*
+ *  linux/include/asm-armnommu/arch-p2001/uncompress.h
+ *
+ *  Copyright (C) 2004 Tobias Lorenz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __UNCOMPRESS_H__
+#define __UNCOMPRESS_H__
+
+#include <asm/hardware.h>
+
+static __inline__ void putc(char c)
+{
+	while ((P2001_UART->r.STATUS & 0x3f) > 0)
+		barrier();
+	P2001_UART->w.TX[0] = c;
+}
+
+/*
+ * This does not append a newline
+ */
+static void puts(const char *s)
+{
+	while (*s) {
+		putc(*s);
+		if (*s == '\n')
+			putc('\r');
+		s++;
+	}
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-p2001/vmalloc.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/vmalloc.h
--- linux-2.6.14-uc0/include/asm-arm/arch-p2001/vmalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-p2001/vmalloc.h	2005-11-08 09:06:53.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King. 
+ *  modified by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_P2001_SDRAM_SIZE (0x01000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_P2001_SDRAM_SIZE)   
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/bitfield.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/bitfield.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/bitfield.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/bitfield.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,116 @@
+/*
+ *	FILE    	bitfield.h
+ *
+ *	Version 	1.1
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	April 1998 (April 1997)
+ *	System  	Advanced RISC Machine (ARM)
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of macros to operate on bit fields.
+ */
+
+
+
+#ifndef __BITFIELD_H
+#define __BITFIELD_H
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+#else
+#define UData(Data)	(Data)
+#endif
+
+
+/*
+ * MACRO: Fld
+ *
+ * Purpose
+ *    The macro "Fld" encodes a bit field, given its size and its shift value
+ *    with respect to bit 0.
+ *
+ * Note
+ *    A more intuitive way to encode bit fields would have been to use their
+ *    mask. However, extracting size and shift value information from a bit
+ *    field's mask is cumbersome and might break the assembler (255-character
+ *    line-size limit).
+ *
+ * Input
+ *    Size      	Size of the bit field, in number of bits.
+ *    Shft      	Shift value of the bit field with respect to bit 0.
+ *
+ * Output
+ *    Fld       	Encoded bit field.
+ */
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+
+/*
+ * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
+ *
+ * Purpose
+ *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
+ *    the size, shift value, mask, aligned mask, and first bit of a
+ *    bit field.
+ *
+ * Input
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FSize     	Size of the bit field, in number of bits.
+ *    FShft     	Shift value of the bit field with respect to bit 0.
+ *    FMsk      	Mask for the bit field.
+ *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
+ *    F1stBit   	First bit of the bit field.
+ */
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
+#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
+#define F1stBit(Field)	(UData (1) << FShft (Field))
+
+#define FClrBit(Data, Bit)	(Data = (Data & ~(Bit)))
+#define FClrFld(Data, Field)	(Data = (Data & ~FMsk(Field)))
+
+
+/*
+ * MACRO: FInsrt
+ *
+ * Purpose
+ *    The macro "FInsrt" inserts a value into a bit field by shifting the
+ *    former appropriately.
+ *
+ * Input
+ *    Value     	Bit-field value.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FInsrt    	Bit-field value positioned appropriately.
+ */
+
+#define FInsrt(Value, Field) \
+                	(UData (Value) << FShft (Field))
+
+
+/*
+ * MACRO: FExtr
+ *
+ * Purpose
+ *    The macro "FExtr" extracts the value of a bit field by masking and
+ *    shifting it appropriately.
+ *
+ * Input
+ *    Data      	Data containing the bit-field to be extracted.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FExtr     	Bit-field value.
+ */
+
+#define FExtr(Data, Field) \
+                	((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
+
+
+#endif /* __BITFIELD_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/clocks.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/clocks.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/clocks.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/clocks.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-s3c24a0/clocks.h
+ *
+ * $Id: clocks.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _S3C24A0_CLOCK_H_
+#define _S3C24A0_CLOCK_H_
+
+#include <asm/hardware.h>
+
+#define GET_PCLK	0
+#define GET_HCLK	1
+#define GET_UPLL        2
+
+#define GET_MDIV(x)	FExtr(x, fPLL_MDIV)
+#define GET_PDIV(x)	FExtr(x, fPLL_PDIV)
+#define GET_SDIV(x)	FExtr(x, fPLL_SDIV)
+
+#define get_cpu_clk()  elfin_get_cpu_clk()
+#define get_bus_clk(x) elfin_get_bus_clk((x))
+
+unsigned long elfin_get_cpu_clk(void);
+unsigned long elfin_get_bus_clk(int);
+#endif /* _S3C24A0_CLOCK_H_ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/debug-macro.S linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/debug-macro.S
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/debug-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/debug-macro.S	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,40 @@
+/* linux/include/asm-arm/arch-s3c24a0/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 2005 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+       		.macro  addruart, rx
+                .endm
+
+		.macro	senduart,rd,rx
+ 		mov	r1, #0x00000002
+		MRC	p14, 0, r3, c0, c0 	;read comms control reg
+ 		AND	r3, r3, r1
+		CMP	r3, #2
+ 		BEQ	$-0x0C
+		CMP	r0, #0x0a
+		BNE	$+0x1C
+		mov	r3, #0x0d
+		MCR	p14, 0, r3, c1, c0	;write comms data reg
+		MRC	p14, 0, r3, c0, c0 	;read comms control reg
+		AND	r3, r3, r1
+		CMP	r3, #2
+		BEQ	$-0x0C
+		MCR	p14, 0, r0, c1, c0	;write comms data reg
+		mov 	pc,r14
+                .endm 
+
+       		.macro	busyuart, rd, rx
+		.endm
+
+		.macro	waituart,rd,rx
+		.endm
+                
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/dma.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/dma.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/dma.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,55 @@
+/*
+ *  include/asm-arm/arch-s3c24a0/dma.h
+ *  
+ *  $Id: dma.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on linux/include/asm-arm/arch-s3c2410/dma.h
+ *
+ */
+
+#ifndef __ASM_ARCH_DMA_H__
+#define __ASM_ARCH_DMA_H__
+
+#include "hardware.h"
+
+#define MAX_DMA_ADDRESS	0xffffffff
+
+/*
+ * NB: By nandy
+ * If MAX_DMA_CHANNELS is zero, It means that this architecuture not use 
+ * the regular generic DMA interface provided by kernel.
+ * Why? I don't know. I will investigate S3C24A0 DMA model and generic
+ * DMA interface. But not yet.
+ */
+#define MAX_DMA_CHANNELS	0
+
+/* The S3C24A0 has four internal DMA channels. */
+#define S3C24A0_DMA_CHANNELS	4
+
+#define MAX_S3C24A0_DMA_CHANNELS	S3C24A0_DMA_CHANNELS
+
+#define DMA_CH0			0
+#define DMA_CH1			1
+#define DMA_CH2			2
+#define DMA_CH3			3
+
+#define DMA_BUF_WR		1
+#define DMA_BUF_RD		0
+
+typedef void (*dma_callback_t)(void *buf_id, int size);
+
+/* S3C24A0 DMA API */
+extern int elfin_request_dma(const char *device_id, dmach_t channel,
+				dma_callback_t write_cb, dma_callback_t read_cb); 
+extern int elfin_dma_queue_buffer(dmach_t channel, void *buf_id, 
+					dma_addr_t data, int size, int write);
+extern int elfin_dma_flush_all(dmach_t channel);
+extern void elfin_free_dma(dmach_t channel);
+extern int elfin_dma_get_current(dmach_t channel, void **buf_id, dma_addr_t *addr);
+extern int elfin_dma_stop(dmach_t channel);
+    
+#endif /* __ASM_ARCH_DMA_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/entry-macro.S linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/entry-macro.S
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/entry-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/entry-macro.S	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,32 @@
+/*
+ *  arch/armnommu/mach-s3c24a0/entry-macro.S
+ * 
+ *  Heechul Yun <heechul.yun@samsung.com>
+ *  Hyok S. Choi <hyok.choi@samsung.com> for fixup patch
+ */
+
+
+#include <asm/hardware.h>        
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+                mov     \irqstat,   #io_p2v(0x40000000) @ Virtual Address
+                add     \irqstat, \irqstat,#0x00200000  @ INT Ctrl base
+                                                                                                                                                      
+                ldr     \irqnr,   [\irqstat,#0x14]      @ INTOFFSET
+                cmp     \irqnr,#0
+                beq     1001f
+		mov	r0, \irqnr
+		bl	fixup_irq
+		b	1002f
+1001:
+                ldr     \irqstat,[\irqstat,#-0x4]       @ INTPND
+                tst     \irqstat,#0x1                   @ EINT0_2 happens ?
+1002:
+
+                .endm 
+		.macro	disable_fiq
+		.endm
+
+		/* we don't have an irq priority table */
+		.macro irq_prio_table
+		.endm
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/hardware.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/hardware.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/hardware.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/hardware.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,145 @@
+/*
+ * include/asm-arm/arch-s3c24a0/hardware.h
+ *
+ * $Id: hardware.h,v 1.2 2004/07/13 07:07:01 noyman Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * based on S3C2410.h modified by hcyun <heechul.yun@samsung.com>
+ * modified for hybrid MM support (uClinux and Linux) by Hyok S. Choi
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <linux/config.h>
+
+#ifndef CONFIG_MMU
+/* called on reserve_node_zero() for reserving mmu section table */
+#ifndef CONFIG_DRAM_BASE
+  #define CONFIG_DRAM_BASE 0x10000000
+#endif
+
+#define MACH_RESERVE_BOOTMEM()  do { \
+    reserve_bootmem_node(pgdat, (CONFIG_DRAM_BASE + 0x4000), 0x4000); \
+  } while(0)
+
+#define MACH_FREE_BOOTMEM()
+
+#endif /* !CONFIG_MMU */
+
+#define PCIO_BASE               0
+
+#if defined(CONFIG_DRAM_BASE) && defined(CONFIG_DRAM_SIZE)
+  #define PA_SDRAM_BASE          (CONFIG_DRAM_BASE)
+  #define MEM_SIZE               (CONFIG_DRAM_SIZE)
+#else
+  #define PA_SDRAM_BASE          0x10000000
+  #define MEM_SIZE               0x04000000
+#endif
+
+/*
+ * S3C24A0 internal I/O mappings
+ *
+ * We have the following mapping:
+ *              phys            virt
+ *              40000000        e0000000
+ */
+
+#ifdef CONFIG_MMU
+
+#define VIO_BASE                0xe0000000      /* virtual start of IO space */
+#define PIO_START               0x40000000      /* physical start of IO space */
+
+#define io_p2v(x) ((x) | 0xa0000000)
+#define io_v2p(x) ((x) & ~0xa0000000)
+
+#define io_p2v_isp(x) ((x) + 0xec000000)
+#define io_v2p_isp(x) ((x) - 0xec000000)
+
+
+#else /* UCLINUX */
+
+#define PIO_START               0x40000000
+#define VIO_BASE                PIO_START
+
+#define io_p2v(x) (x)
+#define io_v2p(x) (x)
+
+#define io_p2v_isp(x) (x)
+#define io_v2p_isp(x) (x)
+
+
+#endif  /* CONFIG_MMU */
+
+
+#ifndef __ASSEMBLY__
+#include <asm/types.h>
+
+/*
+ * This __REG() version gives the same results as the one above, except
+ * that we are fooling gcc some how so it generates far better and smaller
+ * assembly code for access to contigous registers. It's a shame that gcc
+ * doesn't guess this by itself
+ */
+typedef struct { volatile u32 offset[4096]; } __regbase;
+#define __REGP(x)       ((__regbase *)((x)&~4095))->offset[((x)&4095)>>2]
+#define __REG(x)        __REGP(io_p2v(x))
+
+/* Let's kick gcc's ass again... */
+# define __REG2(x,y)    \
+        ( __builtin_constant_p(y) ? (__REG((x) + (y))) \
+                                  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+
+#define __PREG(x)       (io_v2p((u32)&(x)))
+
+/*SEO add  to allocate vertual memory address for ISP1583 */
+#define __REG_ISP(x)    io_p2v_isp(x)
+#define __PREG_ISP(x)   io_v2p_isp(x)
+
+
+#else   /* __ASSEMBLY__ */
+
+# define __REG(x)       io_p2v(x)
+# define __PREG(x)      io_v2p(x)
+
+#endif  /* __ASSEMBLY__ */
+
+#include "S3C24A0.h"
+
+#ifndef __ASSEMBLY__
+
+#define EINT_PULLUP_EN          (0)
+#define EINT_PULLUP_DIS         (1)
+
+#define EINT_LOW_LEVEL          (0x0)
+#define EINT_HIGH_LEVEL         (0x1)
+#define EINT_FALLING_EDGE       (0x2)
+#define EINT_RISING_EDGE        (0x4)
+#define EINT_BOTH_EDGES         (0x6)
+
+extern int set_external_irq(int irq, int edge, int pullup);
+
+#endif
+
+#ifdef CONFIG_ARCH_SMDK24A0
+#include "smdk.h"
+#else
+#error not defined board
+#endif
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/ide.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/ide.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/ide.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/ide.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,148 @@
+/*
+ * include/asm-arm/arch-s3c24a0/ide.h
+ *
+ *
+ * Originally based upon linux/include/asm-arm/arch-sa1100/ide.h
+ *
+ * Changes
+ *
+ * 2004/06/10 <heechul.yun@samsung.com>  SPJ CPLD IDE support
+ * 2004/06/13 <heechul.yun@samsung.com>  CPLD IDE and USB csupport for SPJ
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+
+#ifndef MAX_HWIFS
+        #define MAX_HWIFS       1
+#else
+        #undef MAX_HWIFS
+        #define MAX_HWIFS 1
+#endif
+
+#define CPLD_IDE_DEBUG  // hcyun
+
+/*
+ * Set up a hw structure for a specified data port, control port and IRQ.
+ * This should follow whatever the default interface uses.
+ */
+static __inline__ void
+ide_init_hwif_ports(hw_regs_t *hw, int data_port, int ctrl_port, int *irq)
+{
+        ide_ioreg_t reg;
+
+        memset(hw, 0, sizeof(*hw));
+
+        reg = (ide_ioreg_t)data_port;
+
+        /* increasing 8 */
+        hw->io_ports[IDE_DATA_OFFSET] =  reg + 0;
+        hw->io_ports[IDE_ERROR_OFFSET] = reg + (1 << 3);
+        hw->io_ports[IDE_NSECTOR_OFFSET] = reg + (2 << 3);
+        hw->io_ports[IDE_SECTOR_OFFSET] = reg + (3 << 3);
+        hw->io_ports[IDE_LCYL_OFFSET] = reg + (4 << 3);
+        hw->io_ports[IDE_HCYL_OFFSET] = reg + (5 << 3);
+        hw->io_ports[IDE_SELECT_OFFSET] = reg + (6 << 3);
+        hw->io_ports[IDE_STATUS_OFFSET] = reg + (7 << 3);
+
+        hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
+
+        if (irq)
+                *irq = 0;
+}
+
+
+/*
+ * CPLD IDE reset. to reset first assert 0 and then assert 1
+ */
+
+static __inline__ void ide_set_reset(int on)
+{
+        volatile unsigned char *usb_reset = (unsigned char *)(SMDK_CPLD_USB_VIO+0x00800000);
+        volatile unsigned char *ide_reset = (unsigned char *)(SMDK_CPLD_IDE_VIO+0x00800000);
+
+        if ( on ) {
+                /* turn CPLD to IDE mode */
+                *ide_reset = 0x02;
+
+                /* turn on IDE */
+                *ide_reset = 0x03;
+
+        } else {
+                /* turn off IDE */
+                *ide_reset = 0x02;
+
+                *ide_reset = 0x02;
+        }
+
+/*
+        *ide_reset = 0x1;
+        *usb_reset = 0x0;
+        *usb_reset = 0x1;
+*/
+
+}
+
+
+/*
+ * Register the standard ports for this architecture with the IDE driver.
+ */
+static __inline__ void
+ide_init_default_hwifs(void)
+{
+        /*
+                A7      A6      A5      A4      A3      <-- CPLD address line used
+
+                CE2     CE1     A2      A1      A0       IORD   IOWR
+                ---------------------------------
+                1       0       0       0       0        data port
+                ..
+                ..
+
+                0       1       1       1       0        control port
+
+                data port = SMDK_CPLD_IDE_VIO + 0x80
+                control port = SMDK_CPLD_IDE_VIO + 0x70
+
+         */
+
+        /* Nothing to declare... */
+
+        int ret;
+
+        hw_regs_t hw;
+
+        ide_init_hwif_ports(&hw, SMDK_CPLD_IDE_VIO + 0x80, SMDK_CPLD_IDE_VIO + 0x70, NULL);
+
+        hw.irq = SMDK_CPLD_IDE_IRQ;
+
+        ide_register_hw(&hw, NULL);
+
+
+#ifdef CPLD_IDE_DEBUG
+        printk("SMDK24A0 : IDE initialize - hcyun \n");
+        printk("!!FIXME!! IDE and cs8900 are controlled by SROM bank1 and need different timing and bus width\n");
+#endif
+
+        bank1_set_state(B1_IDE_PIO4);
+
+        // ide reset
+        ide_set_reset(0);
+
+        mdelay(250);
+
+        ide_set_reset(1);
+
+        mdelay(500); // wait 250ms see ATA spec
+
+        printk("riging edge interrupt\n");
+        ret = set_external_irq(SMDK_CPLD_IDE_IRQ, EINT_RISING_EDGE, EINT_PULLUP_EN);
+
+        if (ret)
+                printk("ERROR: irq set failed\n");
+
+}
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/io.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/io.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/io.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,45 @@
+/*
+ * include/asm-arm/arch-s3c24a0/io.h
+ *
+ * $Id: io.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)         (PCIO_BASE + (a))
+#define __mem_pci(a)    ((unsigned long)(a))
+#define __mem_isa(a)    ((unsigned long)(a))
+
+#if 0
+/*
+ * Generic virtual read/write
+ */
+#define __arch_getw(a)                  (*(volatile unsigned short *)(a))
+#define __arch_putw(v,a)                (*(volatile unsigned short *)(a) = (v))
+#endif
+
+#define iomem_valid_addr(iomem,sz)      (1)
+#define iomem_to_phys(iomem)            (iomem)
+
+#endif /* __ASM_ARM_ARCH_IO_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/irq.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/irq.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/irq.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,16 @@
+/*
+ * include/asm-arm/arch-s3c24a0/irq.h
+ * 
+ * $Id: irq.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This prototype is required for cascading of multiplexed interrupts.
+ * Since it doesn't exist elsewhere, we'll put it here for now.
+ */
+extern unsigned int fixup_irq(int i);
+extern void do_IRQ(int irq, struct pt_regs *regs);
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/irqs.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/irqs.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/irqs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/irqs.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,144 @@
+/*
+ * include/asm-arm/arch-s3c24a0/irqs.h
+ * 
+ * $Id: irqs.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*                    +-+
+ *                    |m|    +---------+
+ *    sub-irq ------\ |a|--> | sub-irq |
+ *    sources ------/ |s|    | status  |\
+ *                    |k|    +---------+ \
+ *                    +-+                 \
+ *                                         \
+ *                    +-+                   \      +-+
+ *                    |m|    +---------+     +---> |m|     +--------+
+ * external irq ----\ |a|--> | ext-irq |---------> |a|--\  |main-irq|
+ *    sources   ----/ |s|    | status  |       +-> |s|--/  | status |
+ *                    |k|    +---------+      /    |k|     +--------+
+ *                    +-+                    /     +-+
+ *                                          /
+ *                                         /
+ *                                        /
+ *  irq sources -------------------------/
+ *
+ */
+
+
+/*
+ * We have three groups.
+ * #0 : Normal (or Main) IRQs
+ * #1 : Sub-IRQs
+ * #2 : External IRQs
+ */
+#define NR_IRQ_GRP			(32)	/* number of irqs in group */
+#define IRQ_GRP0_START		(0)
+#define IRQ_GRP1_START		(IRQ_GRP0_START + NR_IRQ_GRP)
+#define IRQ_GRP2_START		(IRQ_GRP1_START + NR_IRQ_GRP)
+
+#define NR_IRQS				(NR_IRQ_GRP * 3)
+
+#define SUBIRQ_ENC(x)		((x) + IRQ_GRP1_START)
+#define SUBIRQ_DEC(x)		((x) - IRQ_GRP1_START)
+#define EINTIRQ_ENC(x)		((x) + IRQ_GRP2_START)
+#define EINTIRQ_DEC(x)		((x) - IRQ_GRP2_START)
+
+/* Interrupt controller */
+#define IRQ_EINT0_2			(0)		/* External interrupt 0 ~ 2 */
+#define IRQ_EINT3_6			(1)		/* External interrupt 3 ~ 6 */
+#define IRQ_EINT7_10			(2)		/* External interrupt 7 ~ 10 */
+#define IRQ_EINT11_14			(3)		/* External interrupt 11 ~ 14 */
+#define IRQ_EINT15_18			(4)		/* External interrupt 15 ~ 18 */
+#define IRQ_TIC				(5)		/* RTC time tick */
+#define IRQ_DCTQ			(6)		/* DCTQ */
+#define IRQ_MC				(7)		/* MC */
+#define IRQ_ME				(8)		/* ME */
+#define IRQ_KEYPAD			(9)		/* Keypad */
+#define IRQ_TIMER0			(10)	/* Timer 0 */
+#define IRQ_TIMER1			(11)	/* Timer 1 */
+#define IRQ_TIMER2			(12)	/* Timer 2 */
+#define IRQ_TIMER3_4			(13)	/* Timer 3, 4 */
+#define IRQ_LCD_POST			(14)	/* LCD/POST */
+#define IRQ_CAM_C			(15)	/* Camera Codec */
+#define IRQ_WDT_BATFLT			(16)	/* WDT/BATFLT */
+#define IRQ_UART0			(17)	/* UART 0 */
+#define IRQ_CAM_P			(18)	/* Camera Preview */
+#define IRQ_MODEM			(19)	/* Modem */
+#define IRQ_DMA				(20)	/* DMA channels for S-bus */
+#define IRQ_SDI				(21)	/* SDI MMC */
+#define IRQ_SPI0			(22)	/* SPI 0 */
+#define IRQ_UART1			(23)	/* UART 1 */
+#define IRQ_AC97_NFLASH			(24)	/* AC97/NFALASH */
+#define IRQ_USBD			(25)	/* USB device */
+#define IRQ_USBH			(26)	/* USB host */
+#define IRQ_IIC				(27)	/* IIC */
+#define IRQ_IRDA_MSTICK			(28)	/* IrDA/MSTICK */
+#define IRQ_VLX_SPI1			(29)	/* SPI 1 */
+#define IRQ_RTC				(30)	/* RTC alaram */
+#define IRQ_ADC_PENUPDN			(31)	/* ADC EOC/Pen up/Pen down */
+
+/* SUB IRQ */
+#define IRQ_RXD0			SUBIRQ_ENC(0)
+#define IRQ_TXD0			SUBIRQ_ENC(1)
+#define IRQ_ERR0			SUBIRQ_ENC(2)
+#define IRQ_RXD1			SUBIRQ_ENC(3)
+#define IRQ_TXD1			SUBIRQ_ENC(4)
+#define IRQ_ERR1			SUBIRQ_ENC(5)
+#define IRQ_IRDA			SUBIRQ_ENC(6)
+#define IRQ_MSTICK			SUBIRQ_ENC(7)
+#define IRQ_TIMER3			SUBIRQ_ENC(11)
+#define IRQ_TIMER4			SUBIRQ_ENC(12)
+#define IRQ_WDT				SUBIRQ_ENC(13)
+#define IRQ_BATFLT			SUBIRQ_ENC(14)
+#define IRQ_POST			SUBIRQ_ENC(15)
+#define IRQ_DISP_FIFO			SUBIRQ_ENC(16)
+#define IRQ_PENUP			SUBIRQ_ENC(17)
+#define IRQ_PENDN			SUBIRQ_ENC(18)
+#define IRQ_ADC				SUBIRQ_ENC(19)
+#define IRQ_DISP_FRAME			SUBIRQ_ENC(20)
+#define IRQ_NFLASH			SUBIRQ_ENC(21)
+#define IRQ_AC97			SUBIRQ_ENC(22)
+#define IRQ_SPI1			SUBIRQ_ENC(23)
+#define IRQ_VLX				SUBIRQ_ENC(24)
+#define IRQ_DMA0			SUBIRQ_ENC(25)
+#define IRQ_DMA1			SUBIRQ_ENC(26)
+#define IRQ_DMA2			SUBIRQ_ENC(27)
+#define IRQ_DMA3			SUBIRQ_ENC(28)
+
+/* External IRQ */
+#define IRQ_EINT0			EINTIRQ_ENC(0)
+#define IRQ_EINT1			EINTIRQ_ENC(1)
+#define IRQ_EINT2			EINTIRQ_ENC(2)
+#define IRQ_EINT3			EINTIRQ_ENC(3)
+#define IRQ_EINT4			EINTIRQ_ENC(4)
+#define IRQ_EINT5			EINTIRQ_ENC(5)
+#define IRQ_EINT6			EINTIRQ_ENC(6)
+#define IRQ_EINT7			EINTIRQ_ENC(7)
+#define IRQ_EINT8			EINTIRQ_ENC(8)
+#define IRQ_EINT9			EINTIRQ_ENC(9)
+#define IRQ_EINT10			EINTIRQ_ENC(10)
+#define IRQ_EINT11			EINTIRQ_ENC(11)
+#define IRQ_EINT12			EINTIRQ_ENC(12)
+#define IRQ_EINT13			EINTIRQ_ENC(13)
+#define IRQ_EINT14			EINTIRQ_ENC(14)
+#define IRQ_EINT15			EINTIRQ_ENC(15)
+#define IRQ_EINT16			EINTIRQ_ENC(16)
+#define IRQ_EINT17			EINTIRQ_ENC(17)
+#define IRQ_EINT18			EINTIRQ_ENC(18)
+#define IRQ_EINT19			EINTIRQ_ENC(19)
+#define IRQ_EINT20			EINTIRQ_ENC(20)
+#define IRQ_EINT21			EINTIRQ_ENC(21)
+#define IRQ_EINT22			EINTIRQ_ENC(22)
+#define IRQ_EINT23			EINTIRQ_ENC(23)
+#define IRQ_EINT24			EINTIRQ_ENC(24)
+#define IRQ_EINT25			EINTIRQ_ENC(25)
+#define IRQ_EINT26			EINTIRQ_ENC(26)
+#define IRQ_EINT27			EINTIRQ_ENC(27)
+#define IRQ_EINT28			EINTIRQ_ENC(28)
+#define IRQ_EINT29			EINTIRQ_ENC(29)
+#define IRQ_EINT30			EINTIRQ_ENC(30)
+#define IRQ_EINT31			EINTIRQ_ENC(31)
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/keyboard.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/keyboard.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/keyboard.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/keyboard.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,134 @@
+/*
+ * keyboard.h
+ *
+ * $Id: keyboard.h,v 1.2 2004/07/23 07:45:32 hcyun Exp $
+ *
+ */
+
+#ifndef _S3C24A0_KEYBOARD_H
+#define _S3C24A0_KEYBOARD_H
+
+#define kbd_disable_irq()       do { } while(0);
+#define kbd_enable_irq()        do { } while(0);
+
+#define k_leds(x...)
+#define k_setkeycode(x...)
+#define k_getkeycode(x...)
+#define k_unexpected_up(x...)   (1)
+
+/* S3C24A0 SPI */
+
+#if 1 // hcyun
+extern int elfin_kbd_init (void);
+#define kbd_init_hw()           elfin_kbd_init()
+#else
+#define kbd_init_hw()           do {} while(0);
+#endif
+
+/* Generic Keyboard Scan Codes */
+#define KK_NONE         0x00
+#define KK_ESC          0x01
+#define KK_F1           0x3b
+#define KK_F2           0x3c
+#define KK_F3           0x3d
+#define KK_F4           0x3e
+#define KK_F5           0x3f
+#define KK_F6           0x40
+#define KK_F7           0x41
+#define KK_F8           0x42
+#define KK_F9           0x43
+#define KK_F10          0x44
+#define KK_F11          0x57
+#define KK_F12          0x58
+#define KK_PRNT         0x63    /* PrintScreen */
+#define KK_SCRL         0x46    /* Scroll Lock */
+#define KK_BRK          0x77    /* Break */
+#define KK_AGR          0x29    /* ` */
+#define KK_1            0x02
+#define KK_2            0x03
+#define KK_3            0x04
+#define KK_4            0x05
+#define KK_5            0x06
+#define KK_6            0x07
+#define KK_7            0x08
+#define KK_8            0x09
+#define KK_9            0x0a
+#define KK_0            0x0b
+#define KK_MINS         0x0c    /* - */
+#define KK_EQLS         0x0d    /* = */
+#define KK_BKSP         0x0e    /* BKSP */
+#define KK_INS          0x6e    /* Insert */
+#define KK_HOME         0x66
+#define KK_PGUP         0x68
+#define KK_NUML         0x45
+#define KP_SLH          0x62    /* KP / */
+#define KP_STR          0x37    /* KP * */
+#define KP_MNS          0x4a    /* KP - */
+#define KK_TAB          0x0f
+#define KK_Q            0x10
+#define KK_W            0x11
+#define KK_E            0x12
+#define KK_R            0x13
+#define KK_T            0x14
+#define KK_Y            0x15
+#define KK_U            0x16
+#define KK_I            0x17
+#define KK_O            0x18
+#define KK_P            0x19
+#define KK_LSBK         0x1a    /* [ */
+#define KK_RSBK         0x1b    /* ] */
+#define KK_ENTR         0x1c
+#define KK_DEL          0x6f
+#define KK_END          0x6b
+#define KK_PGDN         0x6d
+#define KP_7            0x47
+#define KP_8            0x48
+#define KP_9            0x49
+#define KP_PLS          0x37    /* KP + */
+#define KK_CAPS         0x3a
+#define KK_A            0x1e
+#define KK_S            0x1f
+#define KK_D            0x20
+#define KK_F            0x21
+#define KK_G            0x22
+#define KK_H            0x23
+#define KK_J            0x24
+#define KK_K            0x25
+#define KK_L            0x26
+#define KK_SEMI         0x27    /* ; */
+#define KK_SQOT         0x28    /* ' */
+#define KK_HASH         0x29    /* ` */
+#define KP_4            0x4b
+#define KP_5            0x4c
+#define KP_6            0x4d
+#define KK_LSFT         0x2a    /* L SHIFT */
+#define KK_BSLH         0x2b    /* \ */
+#define KK_Z            0x2c
+#define KK_X            0x2d
+#define KK_C            0x2e
+#define KK_V            0x2f
+#define KK_B            0x30
+#define KK_N            0x31
+#define KK_M            0x32
+#define KK_COMA         0x33    /* , */
+#define KK_DOT          0x34    /* . */
+#define KK_FSLH         0x35    /* / */
+#define KK_RSFT         0x36    /* R SHIFT */
+#define KK_UP           0x67
+#define KP_1            0x4f
+#define KP_2            0x50
+#define KP_3            0x51
+#define KP_ENT          0x60    /* KP Enter */
+#define KK_LCTL         0x1d    /* L CTRL */
+#define KK_LALT         0x38    /* L ALT */
+#define KK_SPCE         0x39    /* SPACE */
+#define KK_RALT         0x64    /* R ALT */
+#define KK_RCTL         0x61    /* R CTRL */
+#define KK_LEFT         0x69
+#define KK_DOWN         0x6c
+#define KK_RGHT         0x6a
+#define KP_0            0x52
+#define KP_DOT          0x53    /* KP . */
+#define KK_21           0x21
+
+#endif  /* _S3C24A0_KEYBOARD_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/memory.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/memory.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/memory.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/memory.h	2005-11-09 19:36:45.000000000 +0900
@@ -0,0 +1,44 @@
+/*
+ * include/asm-arm/arch-s3c24a0/memory.h
+ *
+ * $Id: memory.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * Copyright (C) Heechul Yun <heechul.yun@samsung.com>
+ * Copyright (C) Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H_
+#define __ASM_ARCH_MEMORY_H_
+
+#ifndef CONFIG_MMU
+
+#ifndef TASK_SIZE_26
+#define TASK_SIZE       END_MEM
+#define TASK_SIZE_26    TASK_SIZE
+#endif
+
+#define PAGE_OFFSET (PHYS_OFFSET)
+
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((unsigned long) (ppage))
+
+#endif /* !CONFIG_MMU */
+
+#ifndef CONFIG_DRAM_BASE
+#define PHYS_OFFSET (0x10000000UL)
+#define END_MEM     (0x13000000UL)
+#else
+#define PHYS_OFFSET (CONFIG_DRAM_BASE)
+#define END_MEM     (CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+#endif
+
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+
+#endif /* __ASM_ARCH_MEMORY_H_ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/param.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/param.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/param.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,11 @@
+/*
+ * include/asm-arm/arch-s3c24a0/param.h
+ * 
+ * $Id: param.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* FIXME: Nothing to do */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0-common.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0-common.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0-common.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0-common.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ * include/asm-arm/arch-s3c24a0/s3c24a0-common.h
+ *
+ * $Id: s3c24a0-common.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#ifndef _INCLUDE_LINUETTE_COMMON_H_
+#define _INCLUDE_LINUETTE_COMMON_H_
+#ifndef __ASSEMBLY__
+
+/* 
+ * New Audio Format MSM9842
+ *
+ * NOTE:
+ *  refer to linux/soundcard.h
+ */
+#define AFMT_4_ADPCM2 0x80000000	// 4bit ADPCM2
+#define AFMT_5_ADPCM2 0x40000000	// 5bit ADPCM2
+#define AFMT_6_ADPCM2 0x20000000	// 6bit ADPCM2
+#define AFMT_7_ADPCM2 0x10000000	// 7bit ADPCM2
+#define AFMT_8_ADPCM2 0x08000000	// 8bit ADPCM2
+
+/*
+ * device name
+ */
+#define BIOS_NAME		"apm_bios"
+
+/* definition of key/buttons */
+#include "s3c24a0-key.h"
+
+#endif	/* __ASSEMBLY__ */
+#endif /* _INCLUDE_LINUETTE_COMMON_H_ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/S3C24A0.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/S3C24A0.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/S3C24A0.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/S3C24A0.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,1462 @@
+/*
+ * linux/include/asm-arm/arch-s3c24a0/S3C24A0.h
+ *
+ * $Id: S3C24A0.h,v 1.2 2004/07/26 13:53:10 hcyun Exp $
+ *
+ */
+
+#ifndef _S3C24A0_H_
+#define _S3C24A0_H_
+
+#include "hardware.h"
+#include "bitfield.h"
+
+/*
+ * clock and power ( chapter 32 )
+ */
+
+#define LOCKTIME        __REG(0x40000000)
+#define XTALWSET        __REG(0x40000004)
+#define MPLLCON         __REG(0x40000010)
+#define UPLLCON         __REG(0x40000014)
+#define CLKCON          __REG(0x40000020)
+#define CLKSRC          __REG(0x40000024)
+#define CLKDIVN         __REG(0x40000028)
+#define POWERMAN        __REG(0x40000030)
+#define SOFTRST         __REG(0x40000038)
+
+/* fields */
+#define fLOCK_U         Fld(12,16) /* UPLL lock time in LOCKTIME */
+#define fLOCK_M         Fld(12,0)  /* MPLL lock time in LOCKTIME */
+#define fXTAL_U         Fld(16,16) /* UPLL wait time in XTALWSET */
+#define fXTAL_M         Fld(16,0)  /* MPLL wait time in XTALWSET */
+#define fPLL_MDIV       Fld(8,12)
+#define fPLL_PDIV       Fld(6,4)
+#define fPLL_SDIV       Fld(2,0)
+#define fEXTDIV         Fld(3,0)   /* external clock div. in CLKSRC */
+#define fCLK_CAMDIV     Fld(4,8)   /* CAM clock div. in CLKDIV */
+#define fCLK_MP4DIV     Fld(4,4)   /* MPEG4 clock div. in CLKDIV */
+#define fCNFG_BF        Fld(2,9)   /* battery fault handling config in PWRMAN */
+#define fSLEEP_CODE     Fld(8,0)   /* sleep mode setting code in PWRMAN */
+/* bits */
+#define CLKCON_VPOST    (1<<25) /* CLKCON */
+#define CLKCON_MPEG4IF  (1<<24)
+#define CLKCON_CAM_UPLL (1<<23)
+#define CLKCON_LCD      (1<<22)
+#define CLKCON_CAM_HCLK (1<<21)
+#define CLKCON_MPEG4    (1<<20)
+#define CLKCON_KEYPAD   (1<<19)
+#define CLKCON_ADC      (1<<18)
+#define CLKCON_SD       (1<<17)
+#define CLKCON_MS       (1<<16)      /* memory stick */
+#define CLKCON_USBD     (1<<15)
+#define CLKCON_GPIO     (1<<14)
+#define CLKCON_IIS      (1<<13)
+#define CLKCON_IIC      (1<<12)
+#define CLKCON_SPI      (1<<11)
+#define CLKCON_UART1    (1<<10)
+#define CLKCON_UART0    (1<<9)
+#define CLKCON_PWM      (1<<8)
+#define CLKCON_USBH     (1<<7)
+#define CLKCON_AC97     (1<<6)
+#define CLKCON_EAHB     (1<<5)
+#define CLKCON_IrDA     (1<<4)
+#define CLKCON_IDLE     (1<<2)
+#define CLKCON_MON      (1<<1)
+#define CLKCON_STOP     (1<<0)
+#define CLKSRC_OSC      (1<<8) /* CLKSRC */
+#define CLKSRC_nUPLL    (1<<7)
+#define CLKSRC_nPLL     (1<<5)
+#define CLKSRC_EXT      (1<<4)
+#define CLKDIV_HCLK     (1<<1) /* CLKDIV */
+#define CLKDIV_PCLK     (1<<0)
+#define PWRMAN_MASKTS   (1<<8) /* PWRMAN */
+
+//#define fCLKDIVN_BUS    Fld(2,0)      /* S3C24A0X */
+#define fCLKDIVN_BUS    Fld(3,0)        /* SW.LEE: S3C24A0A */
+#define CLKDIVN_BUS     FExtr(CLKDIVN, fCLKDIVN_BUS)
+#define CLKDIVN_CAM(x)  FInsrt((x), fCLK_CAMDIV)
+#define CLKDIVN_CAM_MSK FMsk(fCLK_CAMDIV)
+#define CLKDIVN_CAM_VAL FExtr(CLKDIVN, fCLK_CAMDIV)
+#define CLKDIVN_MP4(x)  FInsrt((x), fCLK_MP4DIV)
+#define CLKDIVN_MP4_MSK FMsk(fCLK_MP4DIV)
+
+
+/*
+ * PWM timer ( chapter 7 )
+ *
+ * five 16bit timers.
+ * two 8bit prescalers, four 4bit dividers
+ * programmable duty control of output waveform
+ * auto-load mode, one-shot pulse mode
+ * dead-zone generator
+ */
+#define bPWM_TIMER(Nb)      __REG(0x44000000 + (Nb))
+#define bPWM_BUFn(Nb,x)     bPWM_TIMER(0x0c + (Nb)*0x0c + (x))
+/* Registers */
+#define TCFG0           __REG(0x44000000)
+#define TCFG1           __REG(0x44000004)
+#define TCON            __REG(0x44000008)
+#define TCNTB0          __REG(0x4400000C)
+#define TCMPB0          __REG(0x44000010)
+#define TCNTO0          __REG(0x44000014)
+#define TCNTB1          bPWM_BUFn(1,0x0)
+#define TCMPB1          bPWM_BUFn(1,0x4)
+#define TCNTO1          bPWM_BUFn(1,0x8)
+#define TCNTB2          bPWM_BUFn(2,0x0)
+#define TCMPB2          bPWM_BUFn(2,0x4)
+#define TCNTO2          bPWM_BUFn(2,0x8)
+#define TCNTB3          bPWM_BUFn(3,0x0)
+#define TCMPB3          bPWM_BUFn(3,0x4)
+#define TCNTO3          bPWM_BUFn(3,0x8)
+#define TCNTB4          bPWM_BUFn(4,0x0)
+#define TCNTO4          bPWM_BUFn(4,0x4)
+
+#define fTCFG0_DZONE    Fld(8,16) /* the dead zone length (= timer 0) */
+#define fTCFG0_PRE1     Fld(8,8)  /* prescaler value for time 2,3,4 */
+#define fTCFG0_PRE0     Fld(8,0)  /* prescaler value for time 0,1 */
+#define SET_PRESCALER0(x)       ({ TCFG0 = (TCFG0 & ~(0xff)) | (x); })
+#define GET_PRESCALER0()        FExtr(TCFG0, fTCFG0_PRE0)
+#define SET_PRESCALER1(x)       ({ TCFG0 = (TCFG0 & ~(0xff << 8)) | ((x) << 8); })
+#define GET_PRESCALER1()        FExtr(TCFG0, fTCFG0_PRE0)
+
+#define fTCFG1_DMA      Fld(4,20) /* select DMA request channel */
+#define fTCFG1_T4MUX    Fld(4,16) /* timer4 input mux */
+#define fTCFG1_T3MUX    Fld(4,12) /* timer3 input mux */
+#define fTCFG1_T2MUX    Fld(4,8)  /* timer2 input mux */
+#define fTCFG1_T1MUX    Fld(4,4)  /* timer1 input mux */
+#define fTCFG1_T0MUX    Fld(4,0)  /* timer0 input mux */
+#define TIMER0_DIV(x)   FInsrt((x), fTCFG1_T0MUX)
+#define TIMER1_DIV(x)   FInsrt((x), fTCFG1_T1MUX)
+#define TIMER2_DIV(x)   FInsrt((x), fTCFG1_T2MUX)
+#define TIMER3_DIV(x)   FInsrt((x), fTCFG1_T3MUX)
+#define TIMER4_DIV(x)   FInsrt((x), fTCFG1_T4MUX)
+
+#define fTCON_TIMER4    Fld(3,20)
+#define fTCON_TIMER3    Fld(4,16)
+#define fTCON_TIMER2    Fld(4,12)
+#define fTCON_TIMER1    Fld(4,8)
+#define fTCON_TIMER0    Fld(5,0)
+
+#define fCNTB           Fld(16,0)
+#define fCNTO           Fld(16,0)
+#define fCMPB           Fld(16,0)
+
+#define TCFG0_DZONE(x)  FInsrt((x), fTCFG0_DZONE)
+#define TCFG0_PRE1(x)   FInsrt((x), fTCFG0_PRE1)
+#define TCFG0_PRE0(x)   FInsrt((x), fTCFG0_PRE0)
+#define TCON_4_AUTO             (1 << 22)       /* auto reload on/off for Timer 4 */
+#define TCON_4_UPDATE   (1 << 21)       /* manual Update TCNTB4 */
+#define TCON_4_ONOFF    (1 << 20)       /* 0: Stop, 1: start Timer 4 */
+#define COUNT_4_ON              (TCON_4_ONOFF*1)
+#define COUNT_4_OFF             (TCON_4_ONOFF*0)
+#define TCON_3_AUTO             (1 << 19)       /* auto reload on/off for Timer 3 */
+#define TCON_3_INVERT   (1 << 18)       /* 1: Inverter on for TOUT3 */
+#define TCON_3_MAN              (1 << 17)       /* manual Update TCNTB3,TCMPB3 */
+#define TCON_3_ONOFF    (1 << 16)       /* 0: Stop, 1: start Timer 3 */
+#define TCON_2_AUTO             (1 << 15)       /* auto reload on/off for Timer 3 */
+#define TCON_2_INVERT   (1 << 14)       /* 1: Inverter on for TOUT3 */
+#define TCON_2_MAN              (1 << 13)       /* manual Update TCNTB3,TCMPB3 */
+#define TCON_2_ONOFF    (1 << 12)       /* 0: Stop, 1: start Timer 3 */
+#define TCON_1_AUTO             (1 << 11)       /* auto reload on/off for Timer 3 */
+#define TCON_1_INVERT   (1 << 10)       /* 1: Inverter on for TOUT3 */
+#define TCON_1_MAN              (1 << 9)        /* manual Update TCNTB3,TCMPB3 */
+#define TCON_1_ONOFF    (1 << 8)        /* 0: Stop, 1: start Timer 3 */
+#define TCON_0_AUTO             (1 << 3)        /* auto reload on/off for Timer 3 */
+#define TCON_0_INVERT   (1 << 2)        /* 1: Inverter on for TOUT3 */
+#define TCON_0_MAN              (1 << 1)        /* manual Update TCNTB3,TCMPB3 */
+#define TCON_0_ONOFF    (1 << 0)        /* 0: Stop, 1: start Timer 3 */
+
+#define TIMER3_ATLOAD_ON        (TCON_3_AUTO*1)
+#define TIMER3_ATLAOD_OFF       FClrBit(TCON, TCON_3_AUTO)
+#define TIMER3_IVT_ON           (TCON_3_INVERT*1)
+#define TIMER3_IVT_OFF          (FClrBit(TCON, TCON_3_INVERT))
+#define TIMER3_MANUP            (TCON_3_MAN*1)
+#define TIMER3_NOP              (FClrBit(TCON, TCON_3_MAN))
+#define TIMER3_ON               (TCON_3_ONOFF*1)
+#define TIMER3_OFF              (FClrBit(TCON, TCON_3_ONOFF))
+#define TIMER2_ATLOAD_ON        (TCON_2_AUTO*1)
+#define TIMER2_ATLAOD_OFF       FClrBit(TCON, TCON_2_AUTO)
+#define TIMER2_IVT_ON           (TCON_2_INVERT*1)
+#define TIMER2_IVT_OFF          (FClrBit(TCON, TCON_2_INVERT))
+#define TIMER2_MANUP            (TCON_2_MAN*1)
+#define TIMER2_NOP              (FClrBit(TCON, TCON_2_MAN))
+#define TIMER2_ON               (TCON_2_ONOFF*1)
+#define TIMER2_OFF              (FClrBit(TCON, TCON_2_ONOFF))
+#define TIMER1_ATLOAD_ON        (TCON_1_AUTO*1)
+#define TIMER1_ATLAOD_OFF       FClrBit(TCON, TCON_1_AUTO)
+#define TIMER1_IVT_ON           (TCON_1_INVERT*1)
+#define TIMER1_IVT_OFF          (FClrBit(TCON, TCON_1_INVERT))
+#define TIMER1_MANUP            (TCON_1_MAN*1)
+#define TIMER1_NOP              (FClrBit(TCON, TCON_1_MAN))
+#define TIMER1_ON               (TCON_1_ONOFF*1)
+#define TIMER1_OFF              (FClrBit(TCON, TCON_1_ONOFF))
+#define TIMER0_ATLOAD_ON        (TCON_0_AUTO*1)
+#define TIMER0_ATLAOD_OFF       FClrBit(TCON, TCON_0_AUTO)
+#define TIMER0_IVT_ON           (TCON_0_INVERT*1)
+#define TIMER0_IVT_OFF          (FClrBit(TCON, TCON_0_INVERT))
+#define TIMER0_MANUP            (TCON_0_MAN*1)
+#define TIMER0_NOP              (FClrBit(TCON, TCON_0_MAN))
+#define TIMER0_ON               (TCON_0_ONOFF*1)
+#define TIMER0_OFF              (FClrBit(TCON, TCON_0_ONOFF))
+
+#define TCON_TIMER1_CLR         FClrFld(TCON, fTCON_TIMER1);
+#define TCON_TIMER2_CLR         FClrFld(TCON, fTCON_TIMER2);
+#define TCON_TIMER3_CLR         FClrFld(TCON, fTCON_TIMER3);
+
+
+/*
+ * NAND ( chapter 4 )
+ *
+ */
+#include "s3c24a0_nand.h"
+
+/* S3C24A0-A LCD CONTROLLER DEVICE ONLY */
+#ifdef  CONFIG_ARCH_S3C24A0A
+#define bLCD_CTL(Nb)            __REG(0x4a000000 + (Nb))
+#define LCDCON1                 bLCD_CTL(0x00) /* LCD CONTROL 1 */
+#define LCDCON2                 bLCD_CTL(0x04) /* LCD CONTROL 2 */
+#define LCDTCON1                bLCD_CTL(0x08) /* LCD TIME CONTROL 1 */
+#define LCDTCON2                bLCD_CTL(0x0c) /* LCD TIME CONTROL 2 */
+#define LCDTCON3                bLCD_CTL(0x10) /* LCD TIME CONTROL 3 */
+#define LCDOSD1                 bLCD_CTL(0x14) /* LCD OSD CONTROL REGISTER */
+#define LCDOSD2                 bLCD_CTL(0x18) /* Foreground image(OSD Image) left top position set */
+#define LCDOSD3                 bLCD_CTL(0x1c) /* Foreground image(OSD Image) right bottom position set */
+#define LCDSADDRB1              bLCD_CTL(0x20) /* Frame buffer start address 1 (Background buffer 1) */
+#define LCDSADDRB2              bLCD_CTL(0x24) /* Frame buffer start address 2 (Background buffer 2) */
+#define LCDSADDRF1              bLCD_CTL(0x28) /* Frame buffer start address 1 (Foreground buffer 1) */
+#define LCDSADDRF2              bLCD_CTL(0x2c) /* Frame buffer start address 2 (Foreground buffer 2) */
+#define LCDEADDRB1              bLCD_CTL(0x30) /* Frame buffer end address 1 (Background buffer 1) */
+#define LCDEADDRB2              bLCD_CTL(0x34) /* Frame buffer end address 2 (Background buffer 2) */
+#define LCDEADDRF1              bLCD_CTL(0x38) /* Frame buffer end address 1 (Foreground buffer 1) */
+#define LCDEADDRF3              bLCD_CTL(0x3c) /* Frame buffer end address 2 (Foreground buffer 2) */
+#define LCDVSCRB1               bLCD_CTL(0x40) /* Virture Screen OFFSIZE and PAGE WIDTH (Background buffer 1) */
+#define LCDVSCRB2               bLCD_CTL(0x44) /* Virture Screen OFFSIZE and PAGE WIDTH (Background buffer 2) */
+#define LCDVSCRF1               bLCD_CTL(0x48) /* Virture Screen OFFSIZE and PAGE WIDTH (Foreground buffer 1) */
+#define LCDVSCRF2               bLCD_CTL(0x4c) /* Virture Screen OFFSIZE and PAGE WIDTH (Foreground buffer 2) */
+#define LCDINTCON               bLCD_CTL(0x50) /* LCD Interrupt Control */
+#define LCDKEYCON               bLCD_CTL(0x54) /* COLOR KEY CONTROL 1 */
+#define LCDKEYVAL               bLCD_CTL(0x58) /* COLOR KEY CONTROL 2 */
+#define LCDBGCON                bLCD_CTL(0x5c) /* Background color Control */
+#define LCDFGCON                bLCD_CTL(0x60) /* Foreground color Control */
+#define LCDDITHCON              bLCD_CTL(0x64) /* LCD Dithering control active Matrix */
+
+#define PALETTEBG                       0x4A001000 //Background Palette start address
+#define PALETTEFG                       0x4A002000 //Background Palette start address
+
+/*  LCDCON1 */
+#define fBURSTLEN       Fld(2,28)       /* DMA's BURST length selection*/
+#define BURSTLEN4       FInsrt(0x2, fBURSTLEN)
+#define BURSTLEN8       FInsrt(0x1, fBURSTLEN)
+#define BURSTLEN16      FInsrt(0x0, fBURSTLEN)
+#define BDBCON_BUF1     (0 << 21)       /* Active frame slect control background image */
+#define BDBCON_BUF2     (1 << 21)     /* it will be adoted from next frame data */
+#define FDBCON_BUF1     (0 << 20)     /* Active frame select control foreground image */
+#define FDBCON_BUF2     (1 << 20)       /* it will adopted from next frame data  */
+#define DIVEN           (1 << 19)       /* 1:ENABLE 0:Disable */
+#define DIVDIS          (0 << 19)       /* 0:disable */
+#define fCLKVAL         Fld(6,13)
+#define CLKVALMSK       FMsk(fCLKVAL)   /* clk value bit clear */
+#define CLKVAL(x)       FInsrt((x), fCLKVAL) /*  VCLK = HCLK / [(CLKVAL+1)x2] */
+#define CLKDIR_DIVIDE   (1 << 12)    /* Select the clk src as 0:direct or 1:divide using CLKVAl register*/
+#define CLKDIR_DIRECT   (0 << 12)    /* Select the clk src as 0:direct or 1:divide using CLKVAl register*/
+#define fPNRMODE        Fld(2,9)        /* Select Disaplay mode */
+#define PNRMODE_PRGB    FInsrt(0x00, fPNRMODE)  /* parallel RGB */
+#define PNRMODE_PBGR    FInsrt(0x01, fPNRMODE)  /* parallel BGR */
+#define PNRMODE_SRGB    FInsrt(0x02, fPNRMODE)  /* Serial RGB */
+#define PNRMODE_SBGR    FInsrt(0x03, fPNRMODE)  /* Serial RGB */
+#define fBPPMODEF       Fld(3,6)        /* SELECT THE BPP MODE FOR FOREGROUND IMAGE (OSD)*/
+#define BPPMODEF_8_P    FInsrt(0x3, fBPPMODEF)  /* 8BPP palettized */
+#define BPPMODEF_8_NP   FInsrt(0x4, fBPPMODEF)  /* 8BPP non palettized RGB-3:3:2 */
+#define BPPMODEF_565    FInsrt(0x5, fBPPMODEF)  /* 16BPP NON palettized RGB-5:6:5 */
+#define BPPMODEF_5551   FInsrt(0x6, fBPPMODEF)  /* 16BPP NON palettized RGB-5:5:5:1*/
+#define BPPMODEF_18_UP  FInsrt(0x7, fBPPMODEF)  /* unpaked 18BPP non-palettized */
+#define fBPPMODEB       Fld(4,2)        /* select the BPP mode for fore ground image*/
+#define MPPMODEB_1      FInsrt(0x00, fBPPMODEB) /* 1bpp */
+#define MPPMODEB_2      FInsrt(0x01, fBPPMODEB) /* 2bpp */
+#define MPPMODEB_4      FInsrt(0x02, fBPPMODEB) /* 4bpp */
+#define MPPMODEB_8      FInsrt(0x03, fBPPMODEB) /* 8bpp palettized */
+#define MPPMODEB_8N     FInsrt(0x04, fBPPMODEB) /* 8bpp non palettized 3:3:2*/
+#define MPPMODEB_565    FInsrt(0x05, fBPPMODEB) /* 16bpp non palettized 5:6:5*/
+#define MPPMODEB_5551   FInsrt(0x06, fBPPMODEB) /* 16bpp non palettized 5:5:5:1*/
+#define MPPMODEB_18     FInsrt(0x07, fBPPMODEB) /* unpacked 18bpp */
+#define ENVID           (1 << 1) /* 0:Disable 1:Enable LCD video output and logic immediatly */
+#define ENVID_F         (1 << 0) /* 0:Dis 1:Ena wait until Current frame end. */
+
+/* LCDCON2 */
+#define fPALFRM         Fld(2,9) /* this bit determines the size of the palette data*/
+#define PALFRM_666      FInsrt(0x01, fPALFRM)   /* 18 BIT RGB-6:6:6 */
+#define PALFRM_565      FInsrt(0x02, fPALFRM)   /* 16 BIT RGB-5:6:5 */
+#define PALFRM_5551     FInsrt(0x03, fPALFRM)   /* 16 BIT RGB-5:5:5:1 */
+#define IVCLK_RISING    (1 << 7) /* this bit controls the polarity of the VCLK active edge */
+#define IVCLK_FALLING   (0 << 7) /* 1 :rising edge 0: falling edge */
+#define IHSYNC_INVERT   (1 << 6) /* HSYNC polarity inverted */
+#define IHSYNC_NORMAL   (0 << 6) /* HSYNC polarity normal  */
+#define IVSYNC_INVERT   (1 << 5) /* VSYNC polarity inverted */
+#define IVSYNC_NORMAL   (0 << 5) /* VSYNC polarity normal  */
+#define IVDE_INVERT     (1 << 3) /* DE polarity inverted */
+#define IVDE_NORMAL     (0 << 3) /* DE polarity normal  */
+#define BITSWP_EN       (1 << 2) /* 1:BIT Swap Enable */
+#define BITSWP_DIS      (0 << 2) /* 0:BIT Swap Disable */
+#define BYTESWP_EN      (1 << 1) /* 1:BYTE Swap Enable */
+#define BUTESWP_DIS     (0 << 1) /* 0:BYTE Swap Disable */
+#define HAWSWP_EN       (1 << 0) /* 1:HALF WORD Swap Enable */
+#define HAWSWP_DIS      (0 << 0) /* 0:HALF WORD swap Disable */
+
+/* LCD Time Control 1 Register */
+#define VBPD(x)         FInsrt((x), Fld(8,16))  /* VSync Back porch */
+#define VFPD(x)         FInsrt((x), Fld(8, 8))  /* VSync Front porch */
+#define VSPW(x)         FInsrt((x), Fld(8, 0))  /* VSync level width */
+/* LCD Time Control 2 Register */
+#define HBPD(x)         FInsrt((x), Fld(8,16))  /* VSync Back porch */
+#define HFPD(x)         FInsrt((x), Fld(8, 8))  /* VSync Front porch */
+#define HSPW(x)         FInsrt((x), Fld(8, 0))  /* VSync level width */
+/* LCD Time Control 3 register */
+#define LINEVAL(x)      FInsrt((x), Fld(11,11)) /* these bits determine the vertical size of lcd panel */
+#define HOZVAL(x)       FInsrt((x), Fld(11, 0)) /* these bits determine the horizontal size of lcd panel*//* LCD OSD Control 1 register */
+#define OSDEN           (1 << 9)        /* OSD  Enable */
+#define OSDDIS          (0 << 9)        /* OSD Disable */
+#define OSD_BLD_PIX     (1 << 8)        /* BLENDING MODE Per pixel blending (18 BPP only) */
+#define OSD_BLD_PLANE   (0 << 8)        /* Per plane blending (8/16/18 BPP mode) */
+#define OSD_ALPHA(x)    FInsrt((x), Fld(8,0))   /* 8-bit Alpha value for Per plane defined by Equation 28-1. */
+/* LCD OSD Control 2 Register */
+#define OSD_LEFTTOP_X(x)  FInsrt((x), Fld(11,11)) /*Horizontal screen coordinate for left top pixel of OSD image*/
+#define OSD_LEFTTOP_Y(x)  FInsrt((y), Fld(11, 0)) /* Vertical screen coordinate for left top pixel of OSD image*/
+/* LCD OSD Control 3 Register */
+/*OSD_RIGHTBOT_X,_Y <= LCD Panel size of X, Y */
+#define OSD_RIGHTBOT_X(x) FInsrt((x), Fld(11,11)) /*Hor scr coordinate for right bottom pixel of OSD image. */
+#define OSD_RIGHTBOT_Y(y) FInsrt((y), Fld(11, 0)) /* Ver scr coordinate for right bottom pixel of OSD image.*/
+/* FRAME Buffer start address Register
+        LCDSADDRB1 Frame buffer start address register for Background buffer 1
+        LCDSADDRB2 Frame buffer start address register for Background buffer 2
+        LCDSADDRF1 Frame buffer start address register for Foreground(OSD) buffer 1
+        LCDSADDRF2 Frame buffer start address register for Foreground(OSD) buffer 2*/
+#define LCDBANK(x)      FInsrt((x), Fld( 8,24)) /* the bank location for the video buffer in the system memory. */
+#define LCDBASEU(x)     FInsrt((x), Fld(24, 0)) /* the start address of the LCD frame buffer. */
+/* FRAME BUFFER END address Register
+        LCDEADDRB1 Frame buffer end address register for Background buffer 1
+        LCDEADDRB2 Frame buffer end address register for Background buffer 2
+        LCDEADDRF1 Frame buffer end address register for Foreground(OSD)  buffer 1
+        LCDEADDRF2 Frame buffer end address register for Foreground(OSD) buffer 2
+
+        LCDBASEL = LCDBASEU + (PAGEWIDTH+OFFSIZE) x (LINEVAL+1)    */
+#define LCDBASEL(x)     FInsrt((x), Fld(24,0)) /* the end address of the LCD frame buffer. */
+/* Virture Screen offsize and page width registers
+        LCDVSCRB1 Virtual screen OFFSIZE and PAGEWIDTH for Background buffer 1
+        LCDVSCRB2 Virtual screen OFFSIZE and PAGEWIDTH for Background buffer 2
+        LCDVSCRF1 Virtual screen OFFSIZE and PAGEWIDTH for Foreground(OSD) buffer 1
+        LCDVSCRF2 Virtual screen OFFSIZE and PAGEWIDTH for Foreground(OSD) buffer 2*/
+#define OFFSIZE(x)      FInsrt((x), Fld(13,13)) /* Virtual screen offset size (the number of byte). */
+#define PAGEWIDTH(x)    FInsrt((x), Fld(13, 0)) /* Virtual screen page width (the number of byte). */
+/* LCD Interrupt Control Register */
+#define fFRAME_INT2     Fld(2,10)       /* LCD Frame Interrupt 2 at start of  */
+#define FRAMESEL0_BP    FInsrt(0x0, fFRAME_INT2) /* BACK Porch */
+#define FRAMESEL0_VS    FInsrt(0x1, fFRAME_INT2) /* VSYNC */
+#define FRAMESEL0_ACT   FInsrt(0x2, fFRAME_INT2) /* ACTIVE */
+#define FRAMESEL0_FP    FInsrt(0x3, fFRAME_INT2) /* FRONT  */
+#define fFRAME_INT1     Fld(2,8)        /* LCD Frame Interrupt 1 at start of */
+#define FRAMESEL1_BP    FInsrt(0x1, fFRAME_INT1) /* BACK Porch */
+#define FRAMESEL1_VS    FInsrt(0x2, fFRAME_INT1) /* VSYNC */
+#define FRAMESEL1_FP    FInsrt(0x3, fFRAME_INT1) /* FRONTPorch */
+#define INTFRAME_EN     (1 << 7) /* LCD Frame interrupt Enable */
+#define INTFRAME_DIS    (0 << 7) /* LCD Frame interrupt Disable */
+#define fFIFOSEL        Fld(2,5) /* LCD FIFO INTERRUPT SELECT BIT */
+#define FIFO_ALL        FInsrt(0x00, fFIFOSEL) /* All fifi or CASE */
+#define FIFO_BG         FInsrt(0x01, fFIFOSEL) /* Background only */
+#define FIFO_FG         FInsrt(0x02, fFIFOSEL) /* FOREGROUND FIFO ONLY */
+#define fFIFOLEVEL      Fld(3,2) /* LCD FIFO interrupt level select 1~128 word */
+#define FIFO_32W        FInsrt(0x00, fFIFOLEVEL) /* 32 WORD LEFT */
+#define FIFO_64W        FInsrt(0x01, fFIFOLEVEL) /* 64 WORD */
+#define FIFO_96W        FInsrt(0x02, fFIFOLEVEL) /* 96 WORD */
+#define FIFO_OR         FInsrt(0x03, fFIFOLEVEL) /* 32,64,96 WORD */
+#define INTFIFO_EN      (1<<1)
+#define INTFIFO_DIS     (1<<1)
+#define LCD_INTEN       (1 << 0) /* LCD interrupt Enable  */
+#define LCD_INTDIS      (0 << 0) /* LCD Interrupt Disable */
+/* LCD color key LCDKEYCON 1 register */
+#define KEYEN           (1 << 25) /* color key enable, blending disable */
+#define KEYDIS          (0 << 25) /* color key disable, blending enable */
+#define DIRCON_FORE     (1 << 24) /* pixel from foreground image is displayed (only in OSD area) */
+#define DIRCON_BACK     (0 << 24) /* pixel from background image is displayed (only in OSD area) */
+#define COMPKEY(x)      FInsrt((X), Fld(24,0)) /* Each bit is correspond to the COLVAL[23:0]. */
+/* color key 2 register LCDCOLVAL */
+#define COLVAL(x)       FInsrt((x), Fld(24,0)) /* Color key value for the transparent pixel effect. */
+/* Background Color MAP */
+#define BGCOLEN         (1 << 24) /* Background color mapping control bit enable */
+#define BGCOLDIS        (0 << 24) /* Background color mapping control bit disable */
+#define BGCOLOR(x)      FInsrt((x), Fld(24,0)) /* Color Value */
+/* Foreground Color MAP LCDFGCON */
+#define FGCOLEN         (1 << 24) /* Foreground color mapping control bit Enable. */
+#define FGCOLDIS        (0 << 24) /* Foreground color mapping control bit Disable */
+#define FGCOLOR(x)      FInsrt((x), Fld(24,0)) /* Color Value  */
+/* Dithering Contrl 1 Register LCD DITHERING MODE */
+#define RDITHPOS_6BIT   FInsrt(0x01, Fld(2,5)) /* Red Dither bit control 6bit */
+#define RDITHPOS_5BIT   FInsrt(0x02, Fld(2,5)) /* Red Dither bit control 5bit */
+#define GDITHPOS_6BIT   FInsrt(0x01, Fld(2,3)) /* Green Dither bit control 6bit */
+#define GDITHPOS_5BIT   FInsrt(0x02, Fld(2,3)) /* Green Dither bit control 5bit */
+#define BDITHPOS_6BIT   FInsrt(0x01, Fld(2,5)) /* Blue Dither bit control 6bit */
+#define BDITHPOS_5BIT   FInsrt(0x02, Fld(2,5)) /* Blue Dither bit control 5bit */
+#define DITHEN          (1 << 0) /* Dithering Enable bit */
+#define DITHDIS         (0 << 0) /* Dithering Disable bit */
+
+#else
+/* S3C24A0-X DEVICE ONLY */
+/*
+ * LCD (chapter 27 )
+ */
+#define bLCD_CTL(Nb)     __REG(0x4a000000 + (Nb))
+#define LCDCON1          bLCD_CTL(0x00)
+#define LCDCON2          bLCD_CTL(0x04)
+#define LCDCON3          bLCD_CTL(0x08)
+#define LCDCON4          bLCD_CTL(0x0c)
+#define LCDCON5          bLCD_CTL(0x10)
+#define LCDADDR1         bLCD_CTL(0x14)
+#define LCDADDR2         bLCD_CTL(0x18)
+#define LCDADDR3         bLCD_CTL(0x1c)
+#define TPAL             bLCD_CTL(0x50)
+#define LCDINTPND        bLCD_CTL(0x54)
+#define LCDSRCPND        bLCD_CTL(0x58)
+#define LCDINTMSK        bLCD_CTL(0x5c)
+#define OSD_SADDR        bLCD_CTL(0x6c)
+#define OSD_EADDR        bLCD_CTL(0x70)
+#define OSD_LT           bLCD_CTL(0x74) /* left top */
+#define OSD_RB           bLCD_CTL(0x78) /* right bottom & control */
+#define LCD_PAL          bLCD_CTL(0x400) /* palette register */
+
+#define fLCD1_LINECNT    Fld(10,18)     /* the status of the line counter */
+#define  LCD1_LINECNT    FMsk(fLCD_LINECNT)
+#define fLCD1_CLKVAL     Fld(10,8)      /* rates of VCLK and CLKVAL[9:0] */
+#define  LCD1_CLKVAL(x)  FInsrt((x), fLCD1_CLKVAL)
+#define  LCD1_CLKVAL_MSK FMsk(fLCD1_CLKVAL)
+#define fLCD1_PNR        Fld(2,5)       /* select the display mode */
+#define  LCD1_PNR_TFT    FInsrt(0x3, fLCD1_PNR) /* TFT LCD */
+#define fLCD1_BPP        Fld(4,1)       /* select BPP(Bit Per Pixel) */
+#define  LCD1_BPP_1T     FInsrt(0x8, fLCD1_BPP) /* TFT: 1 bpp */
+#define  LCD1_BPP_2T     FInsrt(0x9, fLCD1_BPP) /* TFT: 2 bpp */
+#define  LCD1_BPP_4T     FInsrt(0xa, fLCD1_BPP) /* TFT: 4 bpp */
+#define  LCD1_BPP_8T     FInsrt(0xb, fLCD1_BPP) /* TFT: 8 bpp */
+#define  LCD1_BPP_16T    FInsrt(0xc, fLCD1_BPP) /* TFT: 16 bpp */
+#define LCD1_ENVID       (1 << 0)       /* 1: Enable the video output */
+#define fLCD2_VBPD       Fld(8,24)      /* Vertical Back Porch */
+#define  LCD2_VBPD(x)    FInsrt(((x)-1), fLCD2_VBPD)
+#define fLCD2_LINEVAL    Fld(10,14)  /* vertical size of LCD */
+#define  LCD2_LINEVAL_MSK FMsk(fLCD2_LINEVAL)
+#define  LCD2_LINEVAL(x) FInsrt(((x)-1), fLCD2_LINEVAL)
+#define fLCD2_VFPD       Fld(8,6)    /* Vertical Front Porch */
+#define  LCD2_VFPD(x)    FInsrt(((x)-1), fLCD2_VFPD)
+#define fLCD2_VSPW       Fld(6,0)    /* Vertical Sync Pulse Width */
+#define  LCD2_VSPW(x)    FInsrt(((x)-1), fLCD2_VSPW)
+#define fLCD3_HBPD       Fld(7,19)   /* Horizontal Back Porch */
+#define  LCD3_HBPD(x)    FInsrt(((x)-1), fLCD3_HBPD)
+#define fLCD3_HOZVAL     Fld(11,8)      /* horizontal size of LCD */
+#define  LCD3_HOZVAL_MSK FMsk(fLCD3_HOZVAL)
+#define  LCD3_HOZVAL(x)  FInsrt(((x)-1), fLCD3_HOZVAL)
+#define fLCD3_HFPD       Fld(8,0)       /* Horizontal Front Porch */
+#define  LCD3_HFPD(x)    FInsrt(((x)-1), fLCD3_HFPD)
+#define fLCD4_HSPW       Fld(8,0)       /* Horizontal Sync Pulse Width */
+#define  LCD4_HSPW(x)    FInsrt(((x)-1), fLCD4_HSPW)
+#define fLCD5_VSTAT      Fld(2,15)      /* Vertical Status (ReadOnly) */
+#define  LCD5_VSTAT      FMsk(fLCD5_VSTAT)
+#define  LCD5_VSTAT_VS   0x00   /* VSYNC */
+#define  LCD5_VSTAT_BP   0x01   /* Back Porch */
+#define  LCD5_VSTAT_AC   0x02   /* Active */
+#define  LCD5_VSTAT_FP   0x03   /* Front Porch */
+#define fLCD5_HSTAT      Fld(2,13)      /* Horizontal Status (ReadOnly) */
+#define  LCD5_HSTAT      FMsk(fLCD5_HSTAT)
+#define  LCD5_HSTAT_HS   0x00   /* HSYNC */
+#define  LCD5_HSTAT_BP   0x01   /* Back Porch */
+#define  LCD5_HSTAT_AC   0x02   /* Active */
+#define  LCD5_HSTAT_FP   0x03   /* Front Porch */
+#define LCD5_FRM565      (1 << 11) /* 1 : RGB 5:6:5 , 0 : RGB 5:5:5:1 */
+#define LCD5_INVVCL      (1 << 10)      /*
+                              1 : video data is fetched at VCLK falling edge
+                              0 : video data is fetched at VCLK rising edge */
+#define LCD5_HSYNC       (1 << 9) /* 1: HSYNC pulse polarity is inverted */
+#define LCD5_VSYNC       (1 << 8) /* 1: VSYNC pulse polarity is inverted */
+#define LCD5_INVVD       (1 << 7) /* 1: VD pulse polarity is inverted */
+#define LCD5_INVVDEN     (1 << 6) /* 1: VDEN signal polarity is inverted */
+#define LCD5_INVPWREN    (1 << 5) /* 1: PWREN signal polarity is inverted */
+#define LCD5_INVLEND     (1 << 4) /* 1: LEND signal polarity is inverted */
+#define LCD5_PWREN       (1 << 3) /* 1: enable PWREN signal */
+#define LCD5_LEND        (1 << 2) /* 1: enable LEND signal */
+#define LCD5_BSWP        (1 << 1) /* 1: Byte swap enable */
+#define LCD5_HWSWP       (1 << 0) /* 1: HalfWord swap enable */
+
+#define fLCDADDR_BANK     Fld(9,21)     /* bank location for video buffer */
+#define  LCDADDR_BANK(x)  FInsrt((x), fLCDADDR_BANK)
+#define fLCDADDR_BASEU    Fld(21,0)     /* address of upper left corner */
+#define  LCDADDR_BASEU(x) FInsrt((x), fLCDADDR_BASEU)
+#define fLCDADDR_BASEL    Fld(21,0)     /* address of lower right corner */
+#define  LCDADDR_BASEL(x) FInsrt((x), fLCDADDR_BASEL)
+#define fLCDADDR_OFFSET   Fld(11,11)    /* Virtual screen offset size
+                                           (# of half words) */
+#define  LCDADDR_OFFSET(x) FInsrt((x), fLCDADDR_OFFSET)
+#define fLCDADDR_PAGE     Fld(11,0)     /* Virtual screen page width
+                                           (# of half words) */
+#define  LCDADDR_PAGE(x)  FInsrt((x), fLCDADDR_PAGE)
+
+#define TPAL_LEN           (1 << 24)    /* 1 : Temp. Pallete Register enable */
+#define fTPAL_VAL          Fld(24,0)    /* Temp. Pallete Register value */
+#define  TPAL_VAL(x)       FInsrt((x), fTPAL_VAL)
+#define  TPAL_VAL_RED(x)   FInsrt((x), Fld(8,16))
+#define  TPAL_VAL_GREEN(x) FInsrt((x), Fld(8,8))
+#define  TPAL_VAL_BLUE(x)  FInsrt((x), Fld(8,0))
+
+#define fOSD_SADDR       Fld(30,0)  /* OSD DMA start address of A[30:1] */
+#define  OSD_Saddr(x)    FInsrt((x), fOSD_SADDR)
+#define fOSD_EADDR       Fld(30,0)  /* OSD DMA end address of A[30:1] */
+#define  OSD_Eaddr(x)    FInsrt((x), fOSD_EADDR)
+#define OSD_BLD          (1<<24) /* 0: per plane blending */
+#define fOSD_ALPHA       Fld(4,20) /* 4-bit alpha value */
+#define  OSD_ALPHA(x)    FInsrt((x), fOSD_ALPHA)
+#define fOSD_LT_X        Fld(10,10) /* left-top X */
+#define  OSD_LT_X(x)     FInsrt((x), fOSD_LT_X)
+#define fOSD_LT_Y        Fld(10,0) /* left-top Y */
+#define  OSD_LT_Y(x)     FInsrt((x), fOSD_LT_Y)
+#define OSD_EN           (1<<31)  /* 1: enable OSD */
+#define fOSD_WIDTH       Fld(11,20) /* OSD width . # of half words */
+#define  OSD_WIDTH(x)    FInsrt((x), fOSD_WIDTH)
+#define fOSD_RB_X        Fld(10,10) /* right bottom X */
+#define  OSD_RB_X(x)     FInsrt((x), fOSD_RB_X)
+#define fOSD_RB_Y        Fld(10,0)  /* right bottom Y */
+#define  OSD_RB_Y(x)     FInsrt((x), fOSD_RB_Y)
+#endif
+
+/*
+ * UART ( chapter 11 )
+ */
+#define UART_CTL_BASE     0x44400000
+#define UART0_CTL_BASE    UART_CTL_BASE
+#define UART1_CTL_BASE    (UART_CTL_BASE + 0x4000)
+#define bUART(x, Nb)      __REG(UART_CTL_BASE + (x)*0x4000 + (Nb))
+/* offset */
+#define oULCON         0x00
+#define oUCON          0x04
+#define oUFCON         0x08
+#define oUMCON         0x0c
+#define oUTRSTAT       0x10
+#define oUERSTAT       0x14
+#define oUFSTAT        0x18
+#define oUMSTAT        0x1c
+#define oUTXH          0x20
+#define oURXH          0x24
+#define oUBRDIV        0x28
+/* Registers */
+#define ULCON0         bUART(0, oULCON)
+#define UCON0          bUART(0, oUCON)
+#define UFCON0         bUART(0, oUFCON)
+#define UMCON0         bUART(0, oUMCON)
+#define UTRSTAT0       bUART(0, oUTRSTAT)
+#define UERSTAT0       bUART(0, oUERSTAT)
+#define UFSTAT0        bUART(0, oUFSTAT)
+#define UMSTAT0        bUART(0, oUMSTAT)
+#define UTXH0          bUART(0, oUTXH)
+#define URXH0          bUART(0, oURXH)
+#define UBRDIV0        bUART(0, oUBRDIV)
+#define ULCON1         bUART(1, oULCON)
+#define UCON1          bUART(1, oUCON)
+#define UFCON1         bUART(1, oUFCON)
+#define UMCON1         bUART(1, oUMCON)
+#define UTRSTAT1       bUART(1, oUTRSTAT)
+#define UERSTAT1       bUART(1, oUERSTAT)
+#define UFSTAT1        bUART(1, oUFSTAT)
+#define UMSTAT1        bUART(1, oUMSTAT)
+#define UTXH1          bUART(1, oUTXH)
+#define URXH1          bUART(1, oURXH)
+#define UBRDIV1        bUART(1, oUBRDIV)
+/* ... */
+
+#define ULCON_IR        (1 << 6)        /* use Infra-Red mode */
+#define fULCON_PAR      Fld(3,3)        /* what parity mode? */
+#define  ULCON_PAR      FMsk(fULCON_PAR)
+#define  ULCON_PAR_NONE FInsrt(0x0, fULCON_PAR) /* No Parity */
+#define  ULCON_PAR_ODD  FInsrt(0x4, fULCON_PAR) /* Odd Parity */
+#define  ULCON_PAR_EVEN FInsrt(0x5, fULCON_PAR) /* Even Parity */
+#define  ULCON_PAR_1    FInsrt(0x6, fULCON_PAR) /* Parity force/checked as 1 */
+#define  ULCON_PAR_0    FInsrt(0x7, fULCON_PAR) /* Parity force/checked as 0 */
+#define ULCON_STOP      (1 << 2)        /* The number of stop bits */
+#define ULCON_ONE_STOP  (0 << 2)        /* 1 stop bit */
+#define ULCON_TWO_STOP  (1 << 2)        /* 2 stop bit */
+#define fULCON_WL       Fld(2, 0)       /* word length */
+#define  ULCON_WL       FMsk(fULCON_WL)
+#define  ULCON_WL5      FInsrt(0x0, fULCON_WL)  /* 5 bits */
+#define  ULCON_WL6      FInsrt(0x1, fULCON_WL)  /* 6 bits */
+#define  ULCON_WL7      FInsrt(0x2, fULCON_WL)  /* 7 bits */
+#define  ULCON_WL8      FInsrt(0x3, fULCON_WL)  /* 8 bits */
+
+#define ULCON_CFGMASK   (ULCON_IR | ULCON_PAR | ULCON_WL)
+
+#define UCON_CLK_SEL      (1 << 10)     /* select clock for UART */
+#define UCON_CLK_PCLK     (0 << 10)     /* PCLK for UART baud rate */
+#define UCON_CLK_UCLK     (1 << 10)     /* UCLK for UART baud rate */
+#define UCON_TX_INT_TYPE  (1 << 9)      /* TX Interrupt request type */
+#define UCON_TX_INT_PLS   (0 << 9)      /* Pulse */
+#define UCON_TX_INT_LVL   (1 << 9)      /* Level */
+#define UCON_RX_INT_TYPE  (1 << 8)      /* RX Interrupt request type */
+#define UCON_RX_INT_PLS   (0 << 8)      /* Pulse */
+#define UCON_RX_INT_LVL   (1 << 8)      /* Level */
+#define UCON_RX_TIMEOUT   (1 << 7)      /* RX timeout enable */
+#define UCON_RX_ERR_INT   (1 << 6)      /* RX error status interrupt enable */
+#define UCON_LOOPBACK     (1 << 5)      /* to enter the loop-back mode */
+#define UCON_BRK_SIG      (1 << 4)      /* to send a break during 1 frame time */
+#define fUCON_TX          Fld(2,2) /* function to write Tx data to the buffer */
+#define  UCON_TX          FMsk(fUCON_TX)
+#define  UCON_TX_DIS      FInsrt(0x0, fUCON_TX) /* Disable */
+#define  UCON_TX_INT      FInsrt(0x1, fUCON_TX) /* Interrupt or polling */
+#define  UCON_TX_DMA02    FInsrt(0x2, fUCON_TX) /* DMA0,2 for UART0 */
+#define  UCON_TX_DMA13    FInsrt(0x3, fUCON_TX) /* DMA1,3 for UART1 */
+#define fUCON_RX          Fld(2,0) /* function to read Rx data from buffer */
+#define  UCON_RX          FMsk(fUCON_RX)
+#define  UCON_RX_DIS      FInsrt(0x0, fUCON_RX) /* Disable */
+#define  UCON_RX_INT      FInsrt(0x1, fUCON_RX) /* Interrupt or polling */
+#define  UCON_RX_DMA02    FInsrt(0x2, fUCON_RX) /* DMA0,2 for UART0 */
+#define  UCON_RX_DMA13    FInsrt(0x3, fUCON_RX) /* DMA1,3 for UART1 */
+
+#define fUFCON_TX_TR      Fld(2,6)      /* trigger level of transmit FIFO */
+#define  UFCON_TX_TR      FMsk(fUFCON_TX_TR)
+#define  UFCON_TX_TR0     FInsrt(0x0, fUFCON_TX_TR)     /* Empty */
+#define  UFCON_TX_TR16    FInsrt(0x1, fUFCON_TX_TR)     /* 16-byte */
+#define  UFCON_TX_TR32    FInsrt(0x2, fUFCON_TX_TR)     /* 32-byte */
+#define  UFCON_TX_TR48    FInsrt(0x3, fUFCON_TX_TR)     /* 48-byte */
+#define fUFCON_RX_TR      Fld(2,4)      /* trigger level of receive FIFO */
+#define  UFCON_RX_TR      FMsk(fUFCON_RX_TR)
+#define  UFCON_RX_TR1     FInsrt(0x0, fUFCON_RX_TR)     /* 1-byte */
+#define  UFCON_RX_TR8     FInsrt(0x1, fUFCON_RX_TR)     /* 8-byte */
+#define  UFCON_RX_TR16    FInsrt(0x2, fUFCON_RX_TR)     /* 16-byte */
+#define  UFCON_RX_TR32    FInsrt(0x3, fUFCON_RX_TR)     /* 32-byte */
+#define UFCON_TX_CLR      (1 << 2)      /* auto-cleared after resetting FIFO */
+#define UFCON_RX_CLR      (1 << 1)      /* auto-cleared after resetting FIFO */
+#define UFCON_FIFO_EN     (1 << 0)      /* FIFO Enable */
+
+#define UMCON_AFC         (1 << 4) /* Enable Auto Flow Control */
+#define UMCON_SEND        (1 << 0) /* if no AFC, set nRTS 1:'L' 0:'H' level */
+
+#define UTRSTAT_TR_EMP    (1 << 2)      /* 1: Transmitter buffer &
+                                                shifter register empty */
+#define UTRSTAT_TX_EMP    (1 << 1)      /* Transmit buffer reg. is empty */
+#define UTRSTAT_RX_RDY    (1 << 0)      /* Receive buffer reg. has data */
+
+#define UERSTAT_OVERRUN   (1 << 0)      /* Overrun Error */
+#define UERSTAT_ERR_MASK  UERSTAT_OVERRUN
+
+#define UFSTAT_TX_FULL    (1 << 14)     /* Transmit FIFO is full */
+#define fUFSTAT_TX_CNT    Fld(6,8)      /* Number of data in Tx FIFO */
+#define  UFSTAT_TX_CNT    FMsk(fUFSTAT_TX_CNT)
+#define UFSTAT_RX_FULL    (1 << 6)      /* Receive FIFO is full */
+#define fUFSTAT_RX_CNT    Fld(6,0)      /* Number of data in Rx FIFO */
+#define  UFSTAT_RX_CNT    FMsk(fUFSTAT_RX_CNT)
+#define UART1_TXFIFO_CNT()      FExtr(UFSTAT1, fUFSTAT_TX_CNT)
+#define UART1_RXFIFO_CNT()      FExtr(UFSTAT1, fUFSTAT_RX_CNT)
+
+#define UMSTAT_dCTS       (1 << 4)      /* delta CTS */
+#define UMSTAT_CTS        (1 << 0)      /* CTS(Clear to Send) signal */
+
+#define UTXH_DATA         0x000000FF    /* Transmit data for UARTn */
+#define URXH_DATA         0x000000FF    /* Receive data for UARTn */
+#define UBRDIVn           0x0000FFFF    /* Baud rate division value (> 0) */
+
+/*
+ * GPIO ( chapter 20 )
+ */
+#define GPIO_CONL_NUM        (2)
+#define GPIO_CONM_NUM        (1)
+#define GPIO_CONU_NUM        (0)
+#define GPIO_CONL_BASE       (0<<3)
+#define GPIO_CONM_BASE       (11<<3)
+#define GPIO_CONU_BASE       (19<<3)
+#define GPIO_CONL            (GPIO_CONL_NUM | GPIO_CONL_BASE)
+#define GPIO_CONM            (GPIO_CONM_NUM | GPIO_CONM_BASE)
+#define GPIO_CONU            (GPIO_CONU_NUM | GPIO_CONU_BASE)
+
+#define GPCON(x)             __REG(0x44800000 + (x) * 0x4)
+#define GPCONU               __REG(0x44800000)
+#define GPCONM               __REG(0x44800004)
+#define GPCONL               __REG(0x44800008)
+#define GPDAT                __REG(0x4480000c)
+#define GPUP                 __REG(0x44800010)
+#define GPIO_OFS_SHIFT       0
+#define GPIO_CON_SHIFT       8
+#define GPIO_PULLUP_SHIFT    16
+#define GPIO_MODE_SHIFT      24
+#define GPIO_OFS_MASK        0x000000ff
+#define GPIO_CON_MASK        0x0000ff00
+#define GPIO_PULLUP_MASK     0x00ff0000
+#define GPIO_MODE_MASK       0xff000000
+#define GPIO_MODE_IN         (0 << GPIO_MODE_SHIFT)
+#define GPIO_MODE_OUT        (1 << GPIO_MODE_SHIFT)
+#define GPIO_MODE_ALT0       (2 << GPIO_MODE_SHIFT)
+#define GPIO_MODE_ALT1       (3 << GPIO_MODE_SHIFT)
+#define GPIO_PULLUP_EN       (0 << GPIO_PULLUP_SHIFT)
+#define GPIO_PULLUP_DIS      (1 << GPIO_PULLUP_SHIFT)
+
+#define MAKE_GPIO_NUM(c, o)  ((c << GPIO_CON_SHIFT) | (o << GPIO_OFS_SHIFT))
+
+#define GRAB_MODE(x)    (((x) & GPIO_MODE_MASK) >> GPIO_MODE_SHIFT)
+#define GRAB_PULLUP(x)  (((x) & GPIO_PULLUP_MASK) >> GPIO_PULLUP_SHIFT)
+#define GRAB_OFS(x)     (((x) & GPIO_OFS_MASK) >> GPIO_OFS_SHIFT)
+#define GRAB_CON_NUM(x) ((((x) & GPIO_CON_MASK) >> GPIO_CON_SHIFT) & 0x07)
+#define GRAB_CON_OFS(x) (GRAB_OFS(x) - (((x) & GPIO_CON_MASK) >> (GPIO_CON_SHIFT+3)))
+
+#define GPIO_0      MAKE_GPIO_NUM(GPIO_CONL, 0)
+#define GPIO_1      MAKE_GPIO_NUM(GPIO_CONL, 1)
+#define GPIO_2      MAKE_GPIO_NUM(GPIO_CONL, 2)
+#define GPIO_3      MAKE_GPIO_NUM(GPIO_CONL, 3)
+#define GPIO_4      MAKE_GPIO_NUM(GPIO_CONL, 4)
+#define GPIO_5      MAKE_GPIO_NUM(GPIO_CONL, 5)
+#define GPIO_6      MAKE_GPIO_NUM(GPIO_CONL, 6)
+#define GPIO_7      MAKE_GPIO_NUM(GPIO_CONL, 7)
+#define GPIO_8      MAKE_GPIO_NUM(GPIO_CONL, 8)
+#define GPIO_9      MAKE_GPIO_NUM(GPIO_CONL, 9)
+#define GPIO_10     MAKE_GPIO_NUM(GPIO_CONL, 10)
+#define GPIO_11     MAKE_GPIO_NUM(GPIO_CONM, 11)
+#define GPIO_12     MAKE_GPIO_NUM(GPIO_CONM, 12)
+#define GPIO_13     MAKE_GPIO_NUM(GPIO_CONM, 13)
+#define GPIO_14     MAKE_GPIO_NUM(GPIO_CONM, 14)
+#define GPIO_15     MAKE_GPIO_NUM(GPIO_CONM, 15)
+#define GPIO_16     MAKE_GPIO_NUM(GPIO_CONM, 16)
+#define GPIO_17     MAKE_GPIO_NUM(GPIO_CONM, 17)
+#define GPIO_18     MAKE_GPIO_NUM(GPIO_CONM, 18)
+#define GPIO_19     MAKE_GPIO_NUM(GPIO_CONU, 19)
+#define GPIO_20     MAKE_GPIO_NUM(GPIO_CONU, 20)
+#define GPIO_21     MAKE_GPIO_NUM(GPIO_CONU, 21)
+#define GPIO_22     MAKE_GPIO_NUM(GPIO_CONU, 22)
+#define GPIO_23     MAKE_GPIO_NUM(GPIO_CONU, 23)
+#define GPIO_24     MAKE_GPIO_NUM(GPIO_CONU, 24)
+#define GPIO_25     MAKE_GPIO_NUM(GPIO_CONU, 25)
+#define GPIO_26     MAKE_GPIO_NUM(GPIO_CONU, 26)
+#define GPIO_27     MAKE_GPIO_NUM(GPIO_CONU, 27)
+#define GPIO_28     MAKE_GPIO_NUM(GPIO_CONU, 28)
+#define GPIO_29     MAKE_GPIO_NUM(GPIO_CONU, 29)
+#define GPIO_30     MAKE_GPIO_NUM(GPIO_CONU, 30)
+#define GPIO_31     MAKE_GPIO_NUM(GPIO_CONU, 31)
+/* major alt. */
+#define GPIO_MODE_EINT            GPIO_MODE_ALT0
+#define GPIO_MODE_RTC_ALARMINT    GPIO_MODE_ALT1
+#define GPIO_MODE_IrDA            GPIO_MODE_ALT1
+#define GPIO_MODE_PWM             GPIO_MODE_ALT0
+#define GPIO_MODE_SPI             GPIO_MODE_ALT1
+#define GPIO_MODE_EXT_DMA         GPIO_MODE_ALT0
+#define GPIO_MODE_EXT_KEYP        GPIO_MODE_ALT1
+#define GPIO_MODE_UART            GPIO_MODE_ALT0
+/* canonical */
+#define GPIO_MODE_IrDA_SDBW       GPIO_MODE_IrDA
+#define GPIO_MODE_IrDA_TXD        GPIO_MODE_IrDA
+#define GPIO_MODE_IrDA_RXD        GPIO_MODE_IrDA
+#define GPIO_MODE_PWM_ECLK        GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT        GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT0       GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT1       GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT2       GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT3       GPIO_MODE_PWM
+#define GPIO_MODE_SPI_MODI        GPIO_MODE_SPI
+#define GPIO_MODE_SPI_MISO        GPIO_MODE_SPI
+#define GPIO_MODE_DMAREQ0         GPIO_MODE_EXT_DMA
+#define GPIO_MODE_DMAREQ1         GPIO_MODE_EXT_DMA
+#define GPIO_MODE_DMAACK0         GPIO_MODE_EXT_DMA
+#define GPIO_MODE_DMAACK1         GPIO_MODE_EXT_DMA
+#define GPIO_MODE_KEYP_ROW0       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_ROW1       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_ROW2       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_ROW3       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_ROW4       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL0       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL1       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL2       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL3       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL4       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_uCTSn1          GPIO_MODE_UART
+#define GPIO_MODE_uRTSn1          GPIO_MODE_UART
+#define GPIO_MODE_uTXD1           GPIO_MODE_UART
+#define GPIO_MODE_uRXD1           GPIO_MODE_UART
+
+#define ENPU          __REG(0x44800040) /* normal port pullup in sleep */
+#define ENPU_EN       __REG(0x44800064) /* ENPU enable */
+#define GPDAT_S       __REG(0x44800048) /* GPDAT in sleep */
+#define GPDAT_SEN     __REG(0x4480004c) /* GPDAT_S enable */
+#define GPUP_S        __REG(0x44800050) /* GPUP in sleep */
+#define DATR0_S       __REG(0x44800054) /* data in sleep */
+#define DATR1_S       __REG(0x44800058) /* data in sleep */
+#define OEN0_S        __REG(0x4480005c) /* output in sleep */
+#define OEN1_S        __REG(0x44800060) /* output in sleep */
+
+#define ALIVECON      __REG(0x44800044) /* clock for alive mode in sleep */
+#define RSTCNT        __REG(0x44800068) /* reset count for power settle-down */
+
+#define set_gpio_ctrl(x) \
+        ({ GPCON(GRAB_CON_NUM((x))) &= ~(0x3 << (GRAB_CON_OFS((x))*2)); \
+           GPCON(GRAB_CON_NUM(x)) |= (GRAB_MODE(x) << (GRAB_CON_OFS((x))*2)); \
+           GPUP &= ~(1 << GRAB_OFS((x))); \
+           GPUP |= (GRAB_PULLUP((x)) << GRAB_OFS((x))); })
+#define read_gpio_bit(x)        ((GPDAT & (1<<GRAB_OFS((x)))) >> GRAB_OFS((x)))
+#define write_gpio_bit(x, v) \
+        ({ GPDAT &= ~(0x1 << GRAB_OFS((x))); \
+           GPDAT |= ((v) << GRAB_OFS((x))); })
+
+/*
+ * USB Host ( chapter 17 )
+ *  - OHCI 1.0
+ *  - USB 1.1
+ */
+#define USB_OHCI_BASE      __REG(0x41000000)
+
+/*
+ * SROM Bank (chapter 2) for CS8900A
+ */
+#define SROM_BW  __REG(0x40c20000)
+#define SROM_BC1 __REG(0x40c20008)
+
+
+/*
+ * Interrupt ( chpater 6 )
+ */
+#define SRCPND                  __REG(0x40200000)
+#define INTMOD                  __REG(0x40200004)
+#define INTMSK                  __REG(0x40200008)
+#define PRIORITY                __REG(0x4020000c)
+#define INTPND                  __REG(0x40200010)
+#define INTOFFSET               __REG(0x40200014)
+#define SUBSRCPND               __REG(0x40200018)
+#define INTSUBMSK               __REG(0x4020001c)
+
+#define EINTMASK                __REG(0x44800034)
+#define EINTPEND                __REG(0x44800038)
+
+#define EINTCR0                 __REG(0x44800018)
+#define EINTCR1                 __REG(0x4480001c)
+#define EINTCR2                 __REG(0x44800020)
+
+
+/*
+ * BUS Martrix
+ */
+
+#define PRIORITY0               __REG(0x40ce0000)
+#define PRIORITY1               __REG(0x40ce0004)
+#define PRIORITY_S_FIX           0x0
+#define PRIORITY_I_FIX           0x2
+
+/*
+ * Watchdog timer ( chapter 8 )
+ */
+#define WTCON                   __REG(0x44100000)
+#define WTDAT                   __REG(0x44100004)
+#define WTCNT                   __REG(0x44100008)
+
+/*
+ * Real time clock ( chapter 10 )
+ *
+ * Note: All RTC registers have to be accessed by byte unit
+ *       using STRB and LDRB instructions or char type pointer (page on 10-4)
+ */
+#define RTCCON                  __REG(0x44200040)
+#define TICNT                   __REG(0x44200044)
+#define RTCALM                  __REG(0x44200050)
+#define ALMSEC                  __REG(0x44200054)
+#define ALMMIN                  __REG(0x44200058)
+#define ALMHOUR                 __REG(0x4420005c)
+#define ALMDATE                 __REG(0x44200060)
+#define ALMMON                  __REG(0x44200064)
+#define ALMYEAR                 __REG(0x44200068)
+#define RTCRST                  __REG(0x4420006c)
+#define BCDSEC                  __REG(0x44200070)
+#define BCDMIN                  __REG(0x44200074)
+#define BCDHOUR                 __REG(0x44200078)
+#define BCDDATE                 __REG(0x4420007c)
+#define BCDDAY                  __REG(0x44200080)
+#define BCDMON                  __REG(0x44200084)
+#define BCDYEAR                 __REG(0x44200088)
+
+/* Fields */
+#define fRTC_SEC                Fld(7,0)
+#define fRTC_MIN                Fld(7,0)
+#define fRTC_HOUR               Fld(6,0)
+#define fRTC_DATE               Fld(6,0)
+#define fRTC_DAY                Fld(2,0)
+#define fRTC_MON                Fld(5,0)
+#define fRTC_YEAR               Fld(8,0)
+/* Mask */
+#define Msk_RTCSEC              FMsk(fRTC_SEC)
+#define Msk_RTCMIN              FMsk(fRTC_MIN)
+#define Msk_RTCHOUR             FMsk(fRTC_HOUR)
+#define Msk_RTCDAY              FMsk(fRTC_DAY)
+#define Msk_RTCDATE             FMsk(fRTC_DATE)
+#define Msk_RTCMON              FMsk(fRTC_MON)
+#define Msk_RTCYEAR             FMsk(fRTC_YEAR)
+/* bits */
+#define RTCCON_EN               (1 << 0) /* RTC Control Enable */
+#define RTCCON_CLKSEL           (1 << 1) /* BCD clock as XTAL 1/2^25 clock */
+#define RTCCON_CNTSEL           (1 << 2) /* 0: Merge BCD counters */
+#define RTCCON_CLKRST           (1 << 3) /* RTC clock count reset */
+
+/* Tick Time count register */
+#define RTCALM_GLOBAL           (1 << 6) /* Global alarm enable */
+#define RTCALM_YEAR                     (1 << 5) /* Year alarm enable */
+#define RTCALM_MON                      (1 << 4) /* Month alarm enable */
+#define RTCALM_DAY                      (1 << 3) /* Day alarm enable */
+#define RTCALM_HOUR                     (1 << 2) /* Hour alarm enable */
+#define RTCALM_MIN                      (1 << 1) /* Minute alarm enable */
+#define RTCALM_SEC                      (1 << 0) /* Second alarm enable */
+#define RTCALM_EN                       (RTCALM_GLOBAL | RTCALM_YEAR | RTCALM_MON |\
+                                                        RTCALM_DAY | RTCALM_HOUR | RTCALM_MIN |\
+                                                        RTCALM_SEC)
+#define RTCALM_DIS                      (~RTCALM_EN)
+
+/* ADC and Touch Screen Interface */
+#define ADC_CTL_BASE    0x45800000
+#define bADC_CTL(Nb)    __REG(ADC_CTL_BASE + (Nb))
+// Registers
+#define ADCCON          bADC_CTL(0x00) // R/W, ADC control register
+#define ADCTSC          bADC_CTL(0x04) // R/W, ADC touch screen ctl reg
+#define ADCDLY          bADC_CTL(0x08) // R/W, ADC start or interval delay reg
+#define ADCDAX          bADC_CTL(0x0c) // R  , ADC conversion data reg
+#define ADCDAY          bADC_CTL(0x10) // R  , ADC conversion data reg
+// ADCCON
+#define fECFLG          Fld(1, 15)      // R , End of conversion flag
+#define ECFLG_VAL       FExtr(ADCCON, fECFLG)
+#define CONV_PROCESS    0
+#define CONV_END        1
+
+#define fPRSCEN         Fld(1, 14)
+#define PRSCEN_DIS      FInsrt(0, fPRSCEN)
+#define PRSCEN_EN       FInsrt(1, fPRSCEN)
+
+#define fPRSCVL         Fld(8, 6)
+#define PRSCVL(x)       FInsrt(x, fPRSCVL)
+
+#define fSEL_MUX        Fld(3, 3)
+#define ADC_IN_SEL(x)   FInsrt(x, fSEL_MUX)
+#define ADC_IN0         0
+#define ADC_IN1         1
+#define ADC_IN2         2
+#define ADC_IN3         3
+#define ADC_IN4         4
+#define ADC_IN5         5
+#define ADC_IN6         6
+#define ADC_IN7         7
+
+#define fSTDBM          Fld(1, 2) // Standby mode select
+#define STDBM_NORMAL    FInsrt(0, fSTDBM)
+#define STDBM_STANDBY   FInsrt(1, fSTDBM)
+
+#define fREAD_START     Fld(1, 1)
+#define READ_START_DIS  FInsrt(0, fREAD_START)
+#define READ_START_EN   FInsrt(1, fREAD_START)
+
+#define fENABLE_START   Fld(1, 0)
+#define ENABLE_START_NOOP    FInsrt(0, fENABLE_START)
+#define ENABLE_START_START   FInsrt(1, fENABLE_START)
+
+// ADCTSC
+#define fYM_SEN         Fld(1, 7)
+#define YM_HIZ          FInsrt(0, fYM_SEN)
+#define YM_GND          FInsrt(1, fYM_SEN)
+#define fYP_SEN         Fld(1, 6)
+#define YP_EXTVLT       FInsrt(0, fYP_SEN)
+#define YP_AIN5         FInsrt(1, fYP_SEN)
+#define fXM_SEN         Fld(1, 5)
+#define XM_HIZ          FInsrt(0, fXM_SEN)
+#define XM_GND          FInsrt(1, fXM_SEN)
+#define fXP_SEN         Fld(1, 4)
+#define XP_EXTVLT       FInsrt(0, fXP_SEN)
+#define XP_AIN7         FInsrt(1, fXP_SEN)
+#define fPULL_UP        Fld(1, 3)
+#define XP_PULL_UP_EN   FInsrt(0, fPULL_UP)
+#define XP_PULL_UP_DIS  FInsrt(1, fPULL_UP)
+#define fAUTO_PST       Fld(1, 2)
+#define AUTO_PST_NORMAL FInsrt(0, fAUTO_PST)
+#define AUTO_PST_AUTO   FInsrt(1, fAUTO_PST)
+#define fXY_PST         Fld(2, 0)
+#define XY_PST_NOOP     FInsrt(0, fXY_PST)
+#define XY_PST_X_POS    FInsrt(1, fXY_PST)
+#define XY_PST_Y_POS    FInsrt(2, fXY_PST)
+#define XY_PST_WAIT_INT FInsrt(3, fXY_PST)
+
+// ADC Conversion DATA Field, commons
+#define fUPDOWN         Fld(1, 15)
+#define fDAT_AUTO_PST   Fld(1, 14)
+#define fDAT_XY_PST     Fld(2, 12)
+#define fPST_DATA       Fld(10, 0) // PST : position
+
+#define PST_DAT_MSK     0x3FF
+#define PST_DAT_VAL(x)  (FExtr(x, fPST_DATA) & PST_DAT_MSK)
+// ADCDAX
+#define XPDATA          PST_DAT_VAL(ADCDAX)
+// ADCDAY
+#define YPDATA          PST_DAT_VAL(ADCDAY)
+
+/*
+ * IIS Bus Interface  ( chapter 14 )
+ */
+#define IISCON          __REG(0x44700000)
+#define IISMOD          __REG(0x44700004)
+#define IISPSR          __REG(0x44700008)
+#define IISFIFOC        __REG(0x4470000c)
+#define IISFIFOE        __REG(0x44700010)
+
+#define IISCON_CH_RIGHT (1 << 8)        /* Right channel */
+#define IISCON_CH_LEFT  (0 << 8)        /* Left channel */
+#define IISCON_TX_RDY   (1 << 7)        /* Transmit FIFO is ready(not empty) */
+#define IISCON_RX_RDY   (1 << 6)        /* Receive FIFO is ready (not full) */
+#define IISCON_TX_DMA   (1 << 5)        /* Transmit DMA service reqeust */
+#define IISCON_RX_DMA   (1 << 4)        /* Receive DMA service reqeust */
+#define IISCON_TX_IDLE  (1 << 3)        /* Transmit Channel idle */
+#define IISCON_RX_IDLE  (1 << 2)        /* Receive Channel idle */
+#define IISCON_PRESCALE (1 << 1)        /* IIS Prescaler Enable */
+#define IISCON_EN       (1 << 0)        /* IIS enable(start) */
+
+#define IISMOD_SEL_MA   (0 << 8)        /* Master mode
+                                                                                      (IISLRCK, IISCLK are Output) */
+#define IISMOD_SEL_SL   (1 << 8)        /* Slave mode
+                                                                                      (IISLRCK, IISCLK are Input) */
+#define fIISMOD_SEL_TR  Fld(2, 6)       /* Transmit/Receive mode */
+#define IISMOD_SEL_TR   FMsk(fIISMOD_SEL_TR)
+#define IISMOD_SEL_NO   FInsrt(0x0, fIISMOD_SEL_TR)     /* No Transfer */
+#define IISMOD_SEL_RX   FInsrt(0x1, fIISMOD_SEL_TR)     /* Receive */
+#define IISMOD_SEL_TX   FInsrt(0x2, fIISMOD_SEL_TR)     /* Transmit */
+#define IISMOD_SEL_BOTH FInsrt(0x3, fIISMOD_SEL_TR)     /* Tx & Rx */
+#define IISMOD_CH_RIGHT (0 << 5)        /* high for right channel */
+#define IISMOD_CH_LEFT  (1 << 5)        /* high for left channel */
+#define IISMOD_FMT_IIS  (0 << 4)        /* IIS-compatible format */
+#define IISMOD_FMT_MSB  (1 << 4)        /* MSB(left)-justified format */
+#define IISMOD_BIT_8    (0 << 3)        /* Serial data bit/channel is 8 bit*/
+#define IISMOD_BIT_16   (1 << 3)        /* Serial data bit/channel is 16 bit*/
+#define IISMOD_FREQ_256 (0 << 2)        /* Master clock freq = 256 fs */
+#define IISMOD_FREQ_384 (1 << 2)        /* Master clock freq = 384 fs */
+#define fIISMOD_SFREQ   Fld(2, 0)       /* Serial bit clock frequency */
+#define IISMOD_SFREQ    FMsk(fIISMOD_SFREQ)     /* fs = sampling frequency */
+#define IISMOD_SFREQ_16 FInsrt(0x0, fIISMOD_SFREQ)      /* 16 fs */
+#define IISMOD_SFREQ_32 FInsrt(0x1, fIISMOD_SFREQ)      /* 32 fs */
+#define IISMOD_SFREQ_48 FInsrt(0x2, fIISMOD_SFREQ)      /* 48 fs */
+
+#define fIISPSR_A       Fld(5, 5)       /* Prescaler Control A */
+#define IISPSR_A(x)     FInsrt((x), fIISPSR_A)
+#define fIISPSR_B       Fld(5, 0)       /* Prescaler Control B */
+#define IISPSR_B(x)     FInsrt((x), fIISPSR_B)
+
+#define IISFCON_TX_NORM (0 << 15)       /* Transmit FIFO access mode: normal */
+#define IISFCON_TX_DMA  (1 << 15)       /* Transmit FIFO access mode: DMA */
+#define IISFCON_RX_NORM (0 << 14)       /* Receive FIFO access mode: normal */
+#define IISFCON_RX_DMA  (1 << 14)       /* Receive FIFO access mode: DMA */
+#define IISFCON_TX_EN   (1 << 13)        /* Transmit FIFO enable */
+#define IISFCON_RX_EN   (1 << 12)        /* Recevice FIFO enable */
+#define fIISFCON_TX_CNT Fld(6, 6)       /* Tx FIFO data count (Read-Only) */
+#define IISFCON_TX_CNT  FMsk(fIISFCON_TX_CNT)
+#define fIISFCON_RX_CNT Fld(6, 0)       /* Rx FIFO data count (Read-Only) */
+#define IISFCON_RX_CNT  FMsk(fIISFCON_RX_CNT)
+
+/*
+ * DMA controller ( chapter 9 )
+ */
+#define DMA_CTL_BASE    0x40400000
+#define bDMA_CTL(Nb,x)  __REG(DMA_CTL_BASE + (0x100000*Nb) + (x))
+/* DMA channel 0 */
+#define DISRC0                  bDMA_CTL(0, 0x00)
+#define DISRCC0                 bDMA_CTL(0, 0x04)
+#define DIDST0                  bDMA_CTL(0, 0x08)
+#define DIDSTC0                 bDMA_CTL(0, 0x0c)
+#define DCON0                   bDMA_CTL(0, 0x10)
+#define DSTAT0                  bDMA_CTL(0, 0x14)
+#define DCSRC0                  bDMA_CTL(0, 0x18)
+#define DCDST0                  bDMA_CTL(0, 0x1c)
+#define DMTRIG0                 bDMA_CTL(0, 0x20)
+/* DMA channel 1 */
+#define DISRC1                  bDMA_CTL(1, 0x00)
+#define DISRCC1                 bDMA_CTL(1, 0x04)
+#define DIDST1                  bDMA_CTL(1, 0x08)
+#define DIDSTC1                 bDMA_CTL(1, 0x0c)
+#define DCON1                   bDMA_CTL(1, 0x10)
+#define DSTAT1                  bDMA_CTL(1, 0x14)
+#define DCSRC1                  bDMA_CTL(1, 0x18)
+#define DCDST1                  bDMA_CTL(1, 0x1c)
+#define DMTRIG1                 bDMA_CTL(1, 0x20)
+/* DMA channel 2 */
+#define DISRC2                  bDMA_CTL(2, 0x00)
+#define DISRCC2                 bDMA_CTL(2, 0x04)
+#define DIDST2                  bDMA_CTL(2, 0x08)
+#define DIDSTC2                 bDMA_CTL(2, 0x0c)
+#define DCON2                   bDMA_CTL(2, 0x10)
+#define DSTAT2                  bDMA_CTL(2, 0x14)
+#define DCSRC2                  bDMA_CTL(2, 0x18)
+#define DCDST2                  bDMA_CTL(2, 0x1c)
+#define DMTRIG2                 bDMA_CTL(2, 0x20)
+/* DMA channel 3 */
+#define DISRC3                  bDMA_CTL(3, 0x00)
+#define DISRCC3                 bDMA_CTL(3, 0x04)
+#define DIDST3                  bDMA_CTL(3, 0x08)
+#define DIDSTC3                 bDMA_CTL(3, 0x0c)
+#define DCON3                   bDMA_CTL(3, 0x10)
+#define DSTAT3                  bDMA_CTL(3, 0x14)
+#define DCSRC3                  bDMA_CTL(3, 0x18)
+#define DCDST3                  bDMA_CTL(3, 0x1c)
+#define DMTRIG3                 bDMA_CTL(3, 0x20)
+
+/* DISRC, DIDST Control registers */
+#define fDMA_BASE_ADDR          Fld(30, 0)      /* base address of src/dst data */
+#define DMA_BASE_ADDR(x)        FInsrt(x, fDMA_BASE_ADDR)
+#define LOC_SRC                 (1 << 1)        /* select the location of source */
+#define ON_AHB                  (LOC_SRC*0)
+#define ON_APB                  (LOC_SRC*1)
+#define ADDR_MODE               (1 << 0)       /* select the address increment */
+#define ADDR_INC                (ADDR_MODE*0)
+#define ADDR_FIX                (ADDR_MODE*1)
+
+/* DCON Definitions */
+#define DCON_MODE               (1 << 31)       /* 0: demand, 1: handshake */
+#define DEMAND_MODE             (DCON_MODE*0)
+#define HS_MODE                 (DCON_MODE*1)
+#define DCON_SYNC               (1 << 30)       /* sync to 0:PCLK, 1:HCLK */
+#define SYNC_PCLK               (DCON_SYNC*0)
+#define SYNC_HCLK               (DCON_SYNC*1)
+#define DCON_INT                (1 << 29)
+#define POLLING_MODE            (DCON_INT*0)
+#define INT_MODE                (DCON_INT*1)
+#define DCON_TSZ                (1 << 28)       /* tx size 0: a unit, 1: burst */
+#define TSZ_UNIT                (DCON_TSZ*0)
+#define TSZ_BURST               (DCON_TSZ*1)
+#define DCON_SERVMODE           (1 << 27)       /* 0: single, 1: whole service */
+#define SINGLE_SERVICE          (DCON_SERVMODE*0)
+#define WHOLE_SERVICE           (DCON_SERVMODE*1)
+#define fDCON_HWSRC             Fld(3, 24)      /* select request source */
+#define CH0_nXDREQ0             0
+#define CH0_UART0               1
+#define CH0_I2SSDI              2
+#define CH0_TIMER               3
+#define CH0_USBEP1              4
+#define CH0_AC97_PCMOUT         5
+#define CH0_MSTICK              6
+#define CH0_IRDA                7
+#define CH1_nXDREQ1             0
+#define CH1_UART1               1
+#define CH1_I2SSDO              2
+#define CH1_SPI                 3
+#define CH1_USBEP2              4
+#define CH1_AC97_PCMIN          5
+#define CH1_AC97_PCMOUT         6
+#define CH1_IRDA                7
+#define CH2_UART0               0
+#define CH2_I2SSDO              1
+#define CH2_SDMMC               2
+#define CH2_TIMER               3
+#define CH2_USBEP3              4
+#define CH2_AC97_MICIN          5
+#define CH2_AC97_PCMIN          6
+#define CH3_UART1               0
+#define CH3_SDMMC               1
+#define CH3_SPI                 2
+#define CH3_TIMER               3
+#define CH3_USBEP4              4
+#define CH3_MSTICK              5
+#define CH3_AC97_MICIN          6
+#define HWSRC(x)                FInsrt(x, fDCON_HWSRC)
+#define DCON_SWHW_SEL           (1 << 23)       /* DMA src 0: s/w 1: h/w */
+#define DMA_SRC_SW              (DCON_SWHW_SEL*0)
+#define DMA_SRC_HW              (DCON_SWHW_SEL*1)
+#define DCON_RELOAD             (1 << 22)       /* set auto-reload */
+#define SET_ATRELOAD            (DCON_RELOAD*0)
+#define CLR_ATRELOAD            (DCON_RELOAD*1)
+#define fDCON_DSZ               Fld(2, 20)
+#define DSZ_BYTE                0
+#define DSZ_HALFWORD            1
+#define DSZ_WORD                2
+#define DSZ(x)                  FInsrt(x, fDCON_DSZ)
+#define readDSZ(x)              FExtr(x, fDCON_DSZ)
+#define fDCON_TC                Fld(20,0)
+#define TX_CNT(x)               FInsrt(x, fDCON_TC)
+/* STATUS Register Definitions  */
+#define fDSTAT_ST               Fld(2,20)       /* Status of DMA Controller */
+#define fDSTAT_TC               Fld(20,0)       /* Current value of transfer count */
+#define DMA_STATUS(chan)        FExtr((DSTAT0 + (0x20 * chan)), fDSTAT_ST)
+#define DMA_BUSY                (1 << 0)
+#define DMA_READY               (0 << 0)
+#define DMA_CURR_TC(chan)       FExtr((DSTAT0 + (0x20 * chan)), fDSTAT_TC)
+/* DMA Trigger Register Definitions */
+#define DMASKTRIG_STOP          (1 << 2)        /* Stop the DMA operation */
+#define DMA_STOP                (DMASKTRIG_STOP*1)
+#define DMA_STOP_CLR            (DMASKTRIG_STOP*0)
+#define DMASKTRIG_ONOFF         (1 << 1)        /* DMA channel on/off */
+#define CHANNEL_ON              (DMASKTRIG_ONOFF*1)
+#define CHANNEL_OFF             (DMASKTRIG_ONOFF*0)
+#define DMASKTRIG_SW            (1 << 0)        /* Trigger DMA ch. in S/W req. mode */
+#define DMA_SW_REQ_CLR          (DMASKTRIG_SW*0)
+#define DMA_SW_REQ              (DMASKTRIG_SW*1)
+
+/*
+ * KeyIF - keypad interface
+ * chapter 28
+ */
+#define KEYDAT    __REG(0x44900000)
+#define KEYINTC   __REG(0x44900004)
+#define KEYFLT0   __REG(0x44900008)
+#define KEYFLT1   __REG(0x4490000C)
+#define  fKEYDAT_KEYS       Fld(5,0) /* RO : intput decoding data */
+#define KEYDAT_KEYS         FExtr(KEYDAT, fKEYDAT_KEYS)
+#define KEYDAT_KEYVAL       (1<<5) /* RO : 0=valid, 1=invalid */
+#define KEYDAT_KEYCLR       (1<<6) /* WO : 0=noaction, 1=clear */
+#define KEYDAT_KEYEN        (1<<7) /* RW : 0=disable, 1=enable */
+#define  fKEYINTLV          Fld(3,0)
+#define  KEYINTLV_LL        0 /* low level */
+#define  KEYINTLV_HL        1 /* high level */
+#define  KEYINTLV_RE        2 /* rising edge */
+#define  KEYINTLV_FE        4 /* falling edge */
+#define  KEYINTLV_BE        6 /* both edges */
+#define KEYINTLV(x)         FInsrt((x), fKEYINTLV)
+#define KEYINTEN            (1<<3) /* interrupt enable */
+#define  fKEYFLT_SELCLK     Fld(1,0)
+#define  SELCLK_RTC         0
+#define  SELCLK_GCLK        1
+#define KEYFLT_SELCLK(x)    FInsrt((x),fKEYFLT_SELCLK)
+#define KEYFLT_FILEN        (1<<1)
+#define  fKEYFLT_WIDTH Fld( 14,0)
+#define KEYFLT_WIDTH(x)     FInsrt((x), fKEYFLT_WIDTH)
+#define  KEYP_STAT                      (((GPDAT & 0x00FF0000) >> 16 ) & 0x7D )
+
+/*
+ * Video Post Processor ?
+ *
+ * chapter 26.
+ */
+#define VP_MODE       __REG(0x4a100000) /* RW */
+#define VP_RATIO_Y    __REG(0x4a100004) /* RW */
+#define VP_RATIO_CB   __REG(0x4a100008) /* RW */
+#define VP_RATIO_CR   __REG(0x4a10000c) /* RW */
+#define VP_SRC_WIDTH  __REG(0x4a100010) /* RW */
+#define VP_SRC_HEIGHT __REG(0x4a100014) /* RW */
+#define VP_DST_WIDTH  __REG(0x4a100018) /* RW */
+#define VP_DST_HEIGHT __REG(0x4a10001c) /* RW */
+#define VP_START_Y1   __REG(0x4a100020) /* RW */
+#define VP_START_Y2   __REG(0x4a100024) /* RW */
+#define VP_START_Y3   __REG(0x4a100028) /* RW */
+#define VP_START_Y4   __REG(0x4a10002c) /* RW */
+#define VP_START_CB1  __REG(0x4a100030) /* RW */
+#define VP_START_CB2  __REG(0x4a100034) /* RW */
+#define VP_START_CB3  __REG(0x4a100038) /* RW */
+#define VP_START_CB4  __REG(0x4a10003c) /* RW */
+#define VP_START_CR1  __REG(0x4a100040) /* RW */
+#define VP_START_CR2  __REG(0x4a100044) /* RW */
+#define VP_START_CR3  __REG(0x4a100048) /* RW */
+#define VP_START_CR4  __REG(0x4a10004c) /* RW */
+#define VP_START_RGB1 __REG(0x4a100050) /* RW */
+#define VP_START_RGB2 __REG(0x4a100054) /* RW */
+#define VP_START_RGB3 __REG(0x4a100058) /* RW */
+#define VP_START_RGB4 __REG(0x4a10005c) /* RW */
+#define VP_END_Y1     __REG(0x4a100060) /* RW */
+#define VP_END_Y2     __REG(0x4a100064) /* RW */
+#define VP_END_Y3     __REG(0x4a100068) /* RW */
+#define VP_END_Y4     __REG(0x4a10006c) /* RW */
+#define VP_END_CB1    __REG(0x4a100070) /* RW */
+#define VP_END_CB2    __REG(0x4a100074) /* RW */
+#define VP_END_CB3    __REG(0x4a100078) /* RW */
+#define VP_END_CB4    __REG(0x4a10007c) /* RW */
+#define VP_END_CR1    __REG(0x4a100080) /* RW */
+#define VP_END_CR2    __REG(0x4a100084) /* RW */
+#define VP_END_CR3    __REG(0x4a100088) /* RW */
+#define VP_END_CR4    __REG(0x4a10008c) /* RW */
+#define VP_END_RGB1   __REG(0x4a100090) /* RW */
+#define VP_END_RGB2   __REG(0x4a100094) /* RW */
+#define VP_END_RGB3   __REG(0x4a100098) /* RW */
+#define VP_END_RGB4   __REG(0x4a10009c) /* RW */
+#define VP_BYPASS     __REG(0x4a1000f0) /* RW */
+#define VP_OFS_Y      __REG(0x4a1000f4) /* RW */
+#define VP_OFS_CB     __REG(0x4a1000f8) /* RW */
+#define VP_OFS_CR     __REG(0x4a1000fc) /* RW */
+#define VP_OFS_RGB    __REG(0x4a100100) /* RW */
+
+#define VP_STY(__x)   __REG(0x4a100020 + 4*(__x))
+#define VP_STCB(__x)  __REG(0x4a100030 + 4*(__x))
+#define VP_STCR(__x)  __REG(0x4a100040 + 4*(__x))
+#define VP_STRGB(__x) __REG(0x4a100050 + 4*(__x))
+#define VP_EDY(__x)   __REG(0x4a100060 + 4*(__x))
+#define VP_EDCB(__x)  __REG(0x4a100070 + 4*(__x))
+#define VP_EDCR(__x)  __REG(0x4a100080 + 4*(__x))
+#define VP_EDRGB(__x) __REG(0x4a100090 + 4*(__x))
+
+#define  fVP_MODE_FRMCNT  Fld(2,10)
+#define VP_MODE_FRMCNT(x) FExtr((x), fVP_MODE_FRMCNT)
+#define VP_MODE_BYPASSFC  (1<<9)
+#define VP_MODE_BYPASSCSC (1<<8)
+#define VP_MODE_INT       (1<<7)
+#define VP_MODE_INTPND    (1<<6)
+#define VP_MODE_EN        (1<<5)
+#define VP_MODE_ORGB24    (1<<4) /* output : 0=RGB16(565) , 1=RGB24 */
+#define VP_MODE_IFMT      (1<<3) /* input  : 0=YUV , 1=RGB */
+#define VP_MODE_INTLV     (1<<2)
+#define VP_MODE_IRGB24    (1<<1) /* input  : 0=RGB16(565) , 1=RGB24 */
+#define VP_MODE_IYUV      (1<<0) /* if (VP_MODE_IFMT==0 && VP_MODE_INTLV==1)
+                                       0=YUYV , 1=UYVY */
+
+#define  fVP_RATIO_V      Fld(16,16)
+#define  fVP_RATIO_H      Fld(16,0)
+#define VP_RATIO_V(x)     FInsrt((x), fVP_RATIO_V)
+#define VP_RATIO_H(x)     FInsrt((x), fVP_RATIO_H)
+
+#define  fVP_IMG_SIZE_Y   Fld(10,20)
+#define  fVP_IMG_SIZE_CB  Fld(10,10)
+#define  fVP_IMG_SIZE_CR  Fld(10,0)
+#define VP_IMG_SIZE_Y(x)  FInsrt((x), fVP_IMG_SIZE_Y)
+#define VP_IMG_SIZE_CB(x) FInsrt((x), fVP_IMG_SIZE_CB)
+#define VP_IMG_SIZE_CR(x) FInsrt((x), fVP_IMG_SIZE_CR)
+#define VP_IMG_SIZE_R(x)  FInsrt((x), fVP_IMG_SIZE_Y)
+#define VP_IMG_SIZE_G(x)  FInsrt((x), fVP_IMG_SIZE_CB)
+#define VP_IMG_SIZE_B(x)  FInsrt((x), fVP_IMG_SIZE_CR)
+#define VP_SIZE_XX(__x)   ((__x)-1)
+
+#define VP_BYPASS_EN      (1<<24)
+#define  fVP_BYPASS_LOW   Fld(12,12)
+#define  fVP_BYPASS_HIGH  Fld(12,0)
+#define VP_BYPASS_LOW(x)  FInsrt((x), fVP_BYPASS_LOW)
+#define VP_BYPASS_HIGH(x) FInsrt((x), fVP_BYPASS_HIGH)
+
+
+/*
+ * IrDA Controller (Chapter 12)
+ */
+#define IRDACNT         __REG(0x41800000)       /* Control */
+#define IRDAMDR         __REG(0x41800004)       /* Mode definition */
+#define IRDACNF         __REG(0x41800008)       /* IRQ//DMA configuration */
+#define IRDAIER         __REG(0x4180000c)       /* IRQ enable */
+#define IRDAIIR         __REG(0x41800010)       /* IRQ indentification */
+#define IRDALSR         __REG(0x41800014)       /* Line status */
+#define IRDAFCR         __REG(0x41800018)       /* FIFO control */
+#define IRDAPRL         __REG(0x4180001c)       /* Preamble length */
+#define IRDARBR         __REG(0x41800020)       /* Tx/Rx Buffer */
+#define IRDATXNO        __REG(0x41800024)       /* Total number of data bytes remained in Tx FIFO */
+#define IRDARXNO        __REG(0x41800028)       /* Total number of data remained in Rx FIFO (in bytes) */
+#define IRDATXFLL       __REG(0x4180002c)       /* Tx frame length (Low) */
+#define IRDATXFLH       __REG(0x41800030)       /* Tx frame length (High) */
+#define IRDARXFLL       __REG(0x41800034)       /* Rx frame length (Low) */
+#define IRDARXFLH       __REG(0x41800038)       /* Rx frame length (High */
+#define IRDATIME        __REG(0x4180003c)       /* Timing control */
+
+/*
+ * SPI Interface
+ */
+#define SPCON0          __REG(0x44500000)
+#define SPSTA0          __REG(0x44500004)
+#define SPPIN0          __REG(0x44500008)
+#define SPPRE0          __REG(0x4450000C)
+#define SPTDAT0         __REG(0x44500010)
+#define SPRDAT0         __REG(0x44500014)
+#define SPCON1          __REG(0x44500020)
+#define SPSTA1          __REG(0x44500024)
+#define SPPIN1          __REG(0x44500028)
+#define SPPRE1          __REG(0x4450002C)
+#define SPTDAT1         __REG(0x44500030)
+#define SPRDAT1         __REG(0x44500034)
+
+#define fSPCON_SMOD     Fld(2,5)                /* SPI mode select */
+#define SPCON_SMOD      FMsk(fSPCON_SMOD)
+#define SPCON_SMOD_POLL FInsrt(0x0, fSPCON_SMOD)
+#define SPCON_SMOD_INT  FInsrt(0x1, fSPCON_SMOD)
+#define SPCON_SMOD_DMA  FInsrt(0x2, fSPCON_SMOD)
+#define SPCON_ENSCK     (1 << 4)
+#define SPCON_MSTR      (1 << 3)
+#define SPCON_CPOL      (1 << 2)
+#define SPCON_CPOL_LOW  (1 << 2)
+#define SPCON_CPOL_HIGH (0 << 2)
+#define SPCON_CPHA      (1 << 1)
+#define SPCON_CPHA_FMTA (0 << 1)
+#define SPCON_CPHA_FMTB (1 << 1)
+#define SPCON_TAGD      (1 << 0)
+
+#define SPSTA_DCOL      (1 << 2)                /* Data Collision Error */
+#define SPSTA_MULF      (1 << 1)                /* Multi Master Error */
+#define SPSTA_READY     (1 << 0)                /* Data Tx/Rx ready */
+
+/*
+ * IIC Controller (Chapter 13)
+ */
+
+#define IICCON          __REG(0x44600000)
+#define IICSTAT         __REG(0x44600004)
+#define IICADD          __REG(0x44600008)
+#define IICDS           __REG(0x4460000C)
+#define IICADADLY       __REG(0x44600010)
+
+/*
+ * Memory Stick Controller (Chapter 31)
+ */
+#define _MS_BASE0       0x46100000
+#define _MS_BASE1       0x46108000
+#define bMS_CTL0(x)     __REG(_MS_BASE0 + (x))
+#define bMS_CTL1(x)     __REG(_MS_BASE1 + 4*(x))
+#define MSPRE           bMS_CTL0(0)     /* Prescaler Control */
+#define MSFINTCON       bMS_CTL0(4)     /* FIFO Interrupt Control */
+#define MS_TP_CMD       bMS_CTL1(0)     /* Transfer Protocol Command */
+#define MS_CTRL_STA     bMS_CTL1(1)     /* Control1 and Status */
+#define MS_DAT          bMS_CTL1(2)     /* Data FIFO */
+#define MS_INT          bMS_CTL1(3)     /* Interrupt Control and Status */
+#define MS_INS          bMS_CTL1(4)     /* INS port Control and Status */
+#define MS_ACMD         bMS_CTL1(5)     /* Auto Command/Polarity Control */
+#define MS_ATP_CMD      bMS_CTL1(6)     /* Auto Transfer Protocol Command */
+
+#define MSPRE_EN        (1 << 2)        /* Prescaler control,
+                                           0:Disable, 1:Enable. */
+#define MSPRE_VAL       (0x3 << 0)      /* Prescaler value */
+#define MSPRE_VAL1      (0x0 << 0)      /* 1/1 */
+#define MSPRE_VAL2      (0x1 << 0)      /* 1/2 */
+#define MSPRE_VAL4      (0x2 << 0)      /* 1/4 */
+#define MSPRE_VAL8      (0x3 << 0)      /* 1/8 */
+
+#define MSFINTCON_EN    0x1             /* FIFO interrupt control,
+                                           0:only for XINT,
+                                           1:FIFO interrupt enable */
+
+#define MS_CTRL_RST     (1 << 15)       /* Internal logic reset */
+#define MS_CTRL_PWS     (1 << 14)       /* Power save mode */
+#define MS_CTRL_SIEN    (1 << 13)       /* Serial interface enable */
+#define MS_CTRL_NOCRC   (1 << 11)       /* INT_CRC disable */
+#define MS_CTRL_BSYCNT  (0x7 << 8)      /* Busy timeout count
+                                           timeout time = BSYCNT*4+2[pclks] */
+#define fMS_CTRL_BSYCNT Fld(3,8)
+#define MS_CTRL_BSY(x)  FInsrt((x), fMS_CTRL_BSYCNT)
+#define MS_INT_STA      (1 << 7)        /* interrupt generated */
+#define MS_DRQ_STA      (1 << 6)        /* DMA requested */
+#define MS_RBE_STA      (1 << 3)        /* Receive buffer empty */
+#define MS_RBF_STA      (1 << 2)        /* Receive buffer full */
+#define MS_TBE_STA      (1 << 1)        /* Transmit buffer empty */
+#define MS_TBF_STA      (1 << 0)        /* Transmit buffer full */
+
+#define MS_INT_EN       (1 << 15)       /* Memory stick Interrupt enable */
+#define MS_TR_INTEN     (1 << 14)       /* Data transfer interrupt enable */
+#define MS_INS_INTEN    (1 << 13)       /* Insertion interrupt enable */
+#define MS_INT_P_END    (1 << 7)        /* Protocol end interrupt status
+                                           0 = In progress 1 = Complete */
+#define MS_INT_SIF      (1 << 6)        /* Serial interface receive INTd */
+#define MS_INT_TR       (1 << 5)        /* Data transfer request INTd */
+#define MS_INT_INS      (1 << 4)        /* Insertion INTd */
+#define MS_INT_CRC      (1 << 1)        /* INT_CRC error */
+#define MS_INT_TOE      (1 << 0)        /* BUSY timeout error */
+
+#define MS_INS_EN       (1 << 12)       /* INS port enable */
+#define MS_INS_STA      (1 << 4)        /* INS port status. 1:Low(Insert) */
+
+#define MS_ACMD_EN      (1 << 15)       /* Auto Command op. enable */
+#define MS_ACMD_RISING  (0 << 14)       /* serial data input is rising Edge */
+#define MS_ACMD_FALLING (1 << 14)       /* serial data input is falling Edge */
+
+/*
+ * Modem Interface (Chapter 19)
+ */
+#define INT2AP          __REG(0x41180000)
+#define INT2MDM         __REG(0x41180004)
+
+#define fINT2AP_ADR     Fld(11,0)       /* IRQ to AP address */
+#define INT2AP_ADR      FMsk(fINT2AP_ADR)
+#define fINT2MDM_ADR    Fld(11,0)       /* IRQ to Modem address */
+#define INT2MDM_ADR     FMsk(fINT2MDM_ADR)
+
+/*
+ * Power management
+ */
+#define ALIVECON        __REG(0x44800044)
+#define GPDATINSLEEP    __REG(0x44800048)
+#define ENGPINSLEEP     __REG(0x4480004c)
+#define GPUPINSLEEP     __REG(0x44800050)
+#define DATRINSLEEP0    __REG(0x44800054)
+#define DATRINSLEEP1    __REG(0x44800058)
+#define OENINSLEEP0     __REG(0x4480005c)
+#define OENINSLEEP1     __REG(0x44800060)
+#define ENPUINSLEEP     __REG(0x44800064)
+#define RSTCNT          __REG(0x44800068)
+
+#endif /* _S3C24A0_H_ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0-ioctl.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0-ioctl.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0-ioctl.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0-ioctl.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,156 @@
+/*
+ * include/asm-arm/arch-s3c24a0/s3c24a0-ioctl.h
+ * 
+ * ioctl's defintion.
+ *
+ * $Id: s3c24a0-ioctl.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#include <linux/ioctl.h>
+#include "s3c24a0-common.h"
+
+#ifndef _INCLUDE_LINUETTE_IOCTL_H_
+#define _INCLUDE_LINUETTE_IOCTL_H_
+#ifndef __ASSEMBLY__
+
+/*
+ * see Documentation/ioctl-number.txt
+ */
+#define IOC_MAGIC		('h')
+
+/*
+ * for touch devices
+ */
+typedef struct {
+  unsigned short pressure;
+  unsigned short x;
+  unsigned short y;
+  unsigned short pad;
+} TS_RET;
+
+typedef struct {
+  int xscale;
+  int xtrans;
+  int yscale;
+  int ytrans;
+  int xyswap;
+} TS_CAL;
+
+#define TS_GET_CAL		_IOR(IOC_MAGIC, 0x81, TS_CAL)
+#define TS_SET_CAL		_IOW(IOC_MAGIC, 0x82, TS_CAL)
+#define TS_ENABLE		_IO (IOC_MAGIC, 0x90)
+#define TS_DISABLE		_IO (IOC_MAGIC, 0x91)
+
+/*
+ * below ioctl function is for hacker and iom
+ */
+/*
+ * brightness control
+ */
+#define GET_BRIGHTNESS	_IOR(IOC_MAGIC, 0x83, unsigned int)
+#define SET_BRIGHTNESS	_IOW(IOC_MAGIC, 0x84, unsigned int)
+#define GET_BRIGHTNESS_INFO	_IOR(IOC_MAGIC, 0x8e, unsigned int)
+
+/*
+    . BATTERY_RET.level
+          0~   : valid (usually, values from ADC or 0 ~ 100%)
+          -1   : Unknown
+      _ Remaining battery life
+
+    . BATTERY_RET.ac
+          0x00 : Off-line
+          0x01 : On-line
+          0xff : Unknown
+      _ AC line status
+
+    . BATTERY_RET.battery
+          0x01 : Full		(== 100%)
+          0x02 : Critical	(sleep definitely)
+          0x03 : Charging
+          0x04 : Low		(warning)
+          0x10 : backup battery is low, change it
+          0x40 : backup battery is present
+          0x80 : system battery is present
+          0xff : Unknown
+      _ Battery status
+*/
+
+#define AC_OFF_LINE		0x00
+#define AC_ON_LINE		0x01
+#define AC_UNKNOWN		0xff
+
+#define BATTERY_FULL		0x01
+#define BATTERY_CRIT		0x02
+#define BATTERY_CHARGE		0x03
+#define BATTERY_LOW		0x04
+#define battery_stat(x)	((x) & 0xf)
+#define BATTERY_BAK_LOW		0x10
+#define BATTERY_BAK		0x40
+#define BATTERY_SYS		0x80
+#define BATTERY_UNKNOWN		0xff
+
+#define BATTERY_TIMER_STOP	0	/* unit: sec. */
+
+typedef struct {
+    int level, voltage, raw;
+    unsigned char ac;
+    unsigned char battery;
+} BATTERY_RET;
+#define GET_BATTERY_STATUS	_IOR(IOC_MAGIC, 0x85, BATTERY_RET)
+#define SET_BATTERY_TIMER	_IOR(IOC_MAGIC, 0x8f, unsigned int)
+
+/*
+ * for apm_bios
+ */
+#define PM_STATE_QUERY	0x20
+#define PM_STATE_D0		0
+#define PM_STATE_D1		1
+#define PM_STATE_D2		2
+#define PM_STATE_D3		3
+#define PM_STATE_UNKNOWN	(-1)
+
+struct pm_usr_dev {
+    unsigned long dev;
+    unsigned long type, id;
+    int state;
+};
+#define PM_DEV		_IOW(IOC_MAGIC, 0x86, struct pm_usr_dev) 
+
+/* if some devices gives veto, do not sleep */
+#define USR_SUSPEND		_IO (IOC_MAGIC, 0x87)
+/* sleep simply */
+#define SYS_SUSPEND		_IO (IOC_MAGIC, 0x88)
+/* LCD/INPUT/removable sleep
+   or if not, sleep as soon as possible */
+#define STANDBY		_IO (IOC_MAGIC, 0x89)
+/* wakeup devices */
+#define RESUME		_IO (IOC_MAGIC, 0x8a)
+
+/*
+ * for /dev/misc/apm_bios
+ */
+#define LED_ON		0x01
+#define LED_OFF		0x00
+#define LED_BLINK		0x04
+#define LED_BLINK_RATE	0x08	/* variable-rate blink */
+#define LED_READ_ONLY	0x80
+#define LED_COLOR		0x40
+
+typedef struct {
+  unsigned int index;		/* LED index to control */
+  unsigned int stat;		/* control command or current status */
+  unsigned int rate;		/* blinking rate */
+  unsigned int color;		/* LED color */
+  unsigned int info;		/* capable function */
+} LED_RET;
+
+#define GET_LED_NO		_IOR(IOC_MAGIC, 0x8b, unsigned int)
+#define GET_LED_STATUS	_IOR(IOC_MAGIC, 0x8c, LED_RET)
+#define SET_LED_STATUS	_IOW(IOC_MAGIC, 0x8d, LED_RET)
+
+#include "s3c24a0-machine.h"
+#endif	/* __ASSEMBLY__ */
+#endif /* _INCLUDE_LINUETTE_IOCTL_H_ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0-key.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0-key.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0-key.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0-key.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,116 @@
+/*
+ * include/asm-arm/arch-s3c24a0/s3c24a0-key.h
+ *
+ * $Id: s3c24a0-key.h,v 1.2 2004/06/15 06:42:28 hcyun Exp $
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ * 
+ * Changes 
+ * 
+ * 2004/06/15 <heechul.yun@samsung.com>   Added SPJ key scancode 
+ */
+
+#ifndef _SPJ_KEY_H_
+#define _SPJ_KEY_H_
+#ifndef __ASSEMBLY__
+
+#define KEY_RELEASED	0
+#define KEY_PRESSED	1
+
+/*
+ * Definition of Generic Key Scancode
+ */
+#define SCANCODE_LEFT		0x69
+#define SCANCODE_RIGHT		0x6a
+#define SCANCODE_UP			0x67
+#define SCANCODE_DOWN		0x6c
+#define SCANCODE_ENTER		0x1c
+#define SCANCODE_PAGE_UP		0x68	/* Page Up */
+#define SCANCODE_PAGE_DOWN		0x6d	/* Page Down */
+#define SCANCODE_BKSP		0x0e	/* Back Space */
+
+/*
+ * Key PAD
+ */
+#define SCANCODE_PAD_0		0x52
+#define SCANCODE_PAD_1		0x4f
+#define SCANCODE_PAD_2		0x50
+#define SCANCODE_PAD_3		0x51
+#define SCANCODE_PAD_4		0x4b
+#define SCANCODE_PAD_5		0x4c
+#define SCANCODE_PAD_6		0x4d
+#define SCANCODE_PAD_7		0x47
+#define SCANCODE_PAD_8		0x48
+#define SCANCODE_PAD_9		0x49
+#define SCANCODE_PAD_MINUS		0x4a
+#define SCANCODE_PAD_PLUS		0x4e
+#define SCANCODE_PAD_ENTER		0x60
+#define SCANCODE_PAD_PERIOD		0x53
+#define SCANCODE_PAD_SLASH		0x62
+#define SCANCODE_PAD_ASTERISK	0x37
+
+/*
+ * Function Key
+ */
+#define SCANCODE_F5			0x3f
+#define SCANCODE_F6			0x40
+#define SCANCODE_F7			0x41
+#define SCANCODE_F8			0x42
+#define SCANCODE_F9			0x43
+#define SCANCODE_F10			0x44
+#define SCANCODE_F11			0x57
+#define SCANCODE_F12			0x58
+
+/*
+ * Undefined Region
+ */
+#define SCANCODE_U1			0x78	/* Unknown */
+#define SCANCODE_U2			0x79	/* Unknown */
+#define SCANCODE_U3			0x70	/* Unknown */
+#define SCANCODE_U4			0x71	/* Unknown */
+#define SCANCODE_U5			0x72	/* Unknown */
+#define SCANCODE_U6			0x73	/* Unknown */
+#define SCANCODE_U7			0x74	/* Unknown */
+#define SCANCODE_U8			0x75	/* Unknown */
+#define SCANCODE_U9			0x76	/* Unknown */
+
+/*
+ * Common key definition for PDA
+ */
+#define SCANCODE_POWER		0x7a
+#define SCANCODE_RECORD		0x7b
+#define SCANCODE_ACTION		SCANCODE_ENTER
+#define SCANCODE_SLIDE_UP		SCANCODE_PAGE_UP
+#define SCANCODE_SLIDE_DOWN		SCANCODE_PAGE_DOWN
+#define SCANCODE_SLIDE_CENTER	SCANCODE_PAD_ENTER
+
+/*
+ * Common key definition for Phone
+ */
+#define SCANCODE_ASTERISK		SCANCODE_PAD_ASTERISK
+#define SCANCODE_SHARP		SCANCODE_PAD_MINUS
+#define SCANCODE_SEND		0x7c
+#define SCANCODE_END			0x7d
+#define SCANCODE_MENU		0x7e
+#define NCODE_CLR			0x7f
+
+
+/* These are the scancodes for SPJ buttons on the SMDK24a0 */
+
+#define scPOWER    	120 /* sw1 - 0x78 */ 
+#define scMENU    	121 /* sw3 - 0x79 */
+#define scTOOL     	122 /* sw13 - 0x7a */
+#define scRETURN   	123 /* sw11 - 0x7b */ 
+#define scVOLUP    	124 /* sw5 - 0x7c */ 
+#define scVOLDOWN 	125 /* sw10 - 0x7d */ 
+#define scHOLD     	126 /* sw21 - 0x7e*/ 
+#define scUP       	103 /* sw2, - 0x67 keycode up*/
+#define scRIGHT    	106 /* sw8, - 0x6a keycode right */
+#define scLEFT     	105 /* sw6, - 0x69 keycode left */
+#define scDOWN     	108 /* sw12, - 0x6c keycode down */
+#define scACTION   	96  /* sw7, - 0x60 keycode keypad enter */ 
+
+#endif	/* __ASSEMBLY__ */
+#endif /* _SPJ_KEY_H_ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0-machine.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0-machine.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0-machine.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0-machine.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,223 @@
+/*
+ * include/asm-arm/arch-s3c24a0/s3c24a0-machine.h
+ *
+ * $Id: s3c24a0-machine.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * vendor/machine specifice ioctl function
+ *
+ * extended ioctl for MTD
+ * change the permission of MTDPART
+ */
+
+/*
+ *for CONFIG_SA1100_WISMO
+ */
+#define WS_SET_MODEM_MODE	_IOW(IOC_MAGIC, 0xc0, unsigned long)
+#define WS_GET_MODEM_MODE	_IOR(IOC_MAGIC, 0xc1, unsigned long)
+#define WS_MODEM_MODE_OFF	0x01
+#define WS_MODEM_MODE_READY	0x02	/* i,e,. PowerDown Mode */
+#define WS_MODEM_MODE_CALL	0x03	/* i,e,. Normal Mode */
+
+#define WS_KEYPAD_LED		0
+#define WS_7COLOR_LED		1
+
+#define WS_SUBLCD_ON		_IO (IOC_MAGIC, 0xc2)
+#define WS_SUBLCD_OFF		_IO (IOC_MAGIC, 0xc3)
+#define WS_SUBLCD_DRAW		_IO (IOC_MAGIC, 0xc4)
+#define WS_SUBLCD_BLITE_ON	_IO (IOC_MAGIC, 0xc5)
+#define WS_SUBLCD_BLITE_OFF	_IO (IOC_MAGIC, 0xc6)
+
+
+typedef struct {
+	unsigned char reserved;
+	unsigned char sec; 	/* seconds  0 ~ 59 */
+	unsigned char min;     /* min 0 - 59 */
+	unsigned char hour; 	/* Hour     0 ~ 59 */
+	unsigned char day;     /* Day 	    0 ~ 23 */
+	unsigned char month; 	/* Month    1 ~ 12 */
+} WS_DATE_T;
+#define WS_SET_DATE		_IOW(IOC_MAGIC, 0xc7, WS_DATE_T)
+
+typedef struct {
+	unsigned char reserved;
+	unsigned char batt;
+	unsigned char rssi;
+	unsigned char msg;
+	unsigned char alarm;
+	unsigned char alert;
+	unsigned char unused[2];
+} WS_ICON_T;
+#define WS_SET_ICON		_IOW(IOC_MAGIC, 0xc8, WS_ICON_T)
+
+typedef struct {
+	unsigned char    hlt;
+	unsigned char   llt;
+} WS_MOTOR_T;
+#define WS_MOTOR_ON		_IOW(IOC_MAGIC, 0xc9, WS_MOTOR_T)
+#define WS_MOTOR_OFF		_IO (IOC_MAGIC, 0xca)
+#define WS_TOUCH_ON             _IO (IOC_MAGIC, 0xcb)
+#define WS_TOUCH_OFF            _IO (IOC_MAGIC, 0xcc)
+#define WS_SUBLCD_TIMER         _IO (IOC_MAGIC, 0xce) 
+
+#define WS_LCD_POWER_ON		_IO (IOC_MAGIC, 0xd1)
+#define WS_LCD_POWER_OFF	_IO (IOC_MAGIC, 0xd2)
+#define WS_LCD_BLITE_ON		_IO (IOC_MAGIC, 0xd3)
+#define WS_LCD_BLITE_OFF	_IO (IOC_MAGIC, 0xd4)
+
+
+
+/* button definition */
+#define WS_SIDE_UP_BUTTON	SCANCODE_SLIDE_UP
+#define WS_VOICE_BUTTON		SCANCODE_RECORD
+#define WS_SIDE_DOWN_BUTTON	SCANCODE_SLIDE_DOWN
+
+#define WS_SK1_BUTTON		SCANCODE_U1
+#define WS_SK2_BUTTON		SCANCODE_U2
+#define WS_SK3_BUTTON		SCANCODE_U3
+
+#define WS_WAP_BUTTON		SCANCODE_MENU
+#define WS_CLR_BUTTON		SCANCODE_CLR
+#define WS_SEND_BUTTON		SCANCODE_SEND
+#define WS_END_BUTTON		SCANCODE_END
+
+#define WS_1_BUTTON		SCANCODE_PAD_1
+#define WS_2_BUTTON		SCANCODE_PAD_2
+#define WS_3_BUTTON		SCANCODE_PAD_3
+#define WS_4_BUTTON		SCANCODE_PAD_4
+#define WS_5_BUTTON		SCANCODE_PAD_5
+#define WS_6_BUTTON		SCANCODE_PAD_6
+#define WS_7_BUTTON		SCANCODE_PAD_7
+#define WS_8_BUTTON		SCANCODE_PAD_8
+#define WS_9_BUTTON		SCANCODE_PAD_9
+#define WS_0_BUTTON		SCANCODE_PAD_0
+#define WS_ASTERISK_BUTTON	SCANCODE_ASTERISK
+#define WS_SHARP_BUTTON		SCANCODE_SHARP
+
+#define WS_UP_BUTTON		SCANCODE_UP
+#define WS_DOWN_BUTTON		SCANCODE_DOWN
+#define WS_LEFT_BUTTON		SCANCODE_LEFT
+#define WS_RIGHT_BUTTON		SCANCODE_RIGHT
+
+/* camera definition */
+#define WS_CAM_IOC_MAGIC 'C'
+
+#define WS_CAM_ZOOM_21 0 /* cam : disp = 2 : 1 <== zoom-out */
+#define WS_CAM_ZOOM_11 1 /* cam : disp = 1 : 1 <== normal   */
+#define WS_CAM_ZOOM_12 2 /* cam : disp = 1 : 2 <== zoom-in  */
+#define WS_CAM_SET_ZOOM  _IOW(WS_CAM_IOC_MAGIC, 10, int)
+
+struct ws_cam_set {
+    int res;          /* resolution, WS_CAM_SIZE_???  */
+#define WS_CAM_SIZE_320x240    0 /* capture only            */
+#define WS_CAM_SIZE_240x180    1 /* capture only            */
+#define WS_CAM_SIZE_240x320_OV 2 /* overlay(preview) only   */
+#define WS_CAM_SIZE_240x180_OV 3 /* overlay(preview) only   */
+    int preview_ypos; /* Y position when _res_ is WS_CAM_SIZE_240x180_OV */
+};
+#define WS_CAM_SET_PARAM _IOW(WS_CAM_IOC_MAGIC, 11, struct ws_cam_set)
+
+#define WS_CAM_SET_X_MIRROR _IOW(WS_CAM_IOC_MAGIC, 12, int)
+#define WS_CAM_SET_Y_MIRROR _IOW(WS_CAM_IOC_MAGIC, 13, int)
+#define WS_CAM_SET_EXPOSURE _IOW(WS_CAM_IOC_MAGIC, 14, unsigned long)
+#define WS_CAM_SET_WHITBLNC _IOW(WS_CAM_IOC_MAGIC, 15, unsigned long)
+
+/*
+ * for CONFIG_ARCH_I519
+ */
+/* Audio Path Control */
+#define HN_AUDIO_PATH		_IOW(IOC_MAGIC, 0xc0, unsigned long)
+#define MIC_PDA		0x0001
+#define PDA_SPK		0x0010
+#define MIC_PHONE		0x0002
+#define PHONE_RCV		0x0020
+#define PHONE_SPK		0x2000
+
+#define HFK_PDA		0x0004
+#define PDA_HFK		0x0040
+#define HFK_PHONE		0x0008
+#define PHONE_HFK		0x0080
+
+#define PHONE_PDA		0x0100
+#define PDA_PHONE		0x0200
+
+/* for PXA-ac97 control (debugging only) */
+struct hn_ac97 {
+     unsigned int reg;
+     unsigned int val;
+};
+#define HN_AC97_REG_WRITE	_IOW(IOC_MAGIC, 0xc3, struct hn_ac97)
+#define HN_AC97_REG_READ	_IOR(IOC_MAGIC, 0xc4, struct hn_ac97)
+
+#define HN_ONLY_PDA_SPK		_IO ('h', 0xe3)
+
+/* rescan external perpheral device */
+#define HN_RESCAN_ACCESSARY	_IO (IOC_MAGIC, 0xc1)
+
+/* rescan & get battery type */
+#define HN_RESCAN_BATTERY_TYPE	_IOR(IOC_MAGIC, 0xc2, unsigned int)
+#define HN_BATTERY_TYPE_STD	0x0
+#define HN_BATTERY_TYPE_EXT	0x1
+#define HN_RESCAN_BATTERY_TYPE2	_IOR(IOC_MAGIC, 0xc5, unsigned int)
+
+/* UART & USB port switching */
+#define HN_UART_TO_PHONE	_IO (IOC_MAGIC, 0xc8)
+#define HN_UART_TO_PDA		_IO (IOC_MAGIC, 0xc9)
+#define HN_USB_TO_PHONE		_IO (IOC_MAGIC, 0xca)
+#define HN_USB_TO_PDA		_IO (IOC_MAGIC, 0xcb)
+#define HN_USB_UART_STATE	_IO (IOC_MAGIC, 0xce)
+
+#define HN_UART_PATH_PDA	0x0001
+#define HN_UART_PATH_PHONE	0x0002
+#define HN_USB_PATH_PDA		0x0010
+#define HN_USB_PATH_PHONE	0x0020
+
+/* Vibrator Control */
+#define HN_MOTOR_ON		_IO (IOC_MAGIC, 0xcc)
+#define HN_MOTOR_OFF		_IO (IOC_MAGIC, 0xcd)
+
+/* DPRAM Control for communication between PDA and Phone */
+
+/* DPRAM ioctls for DPRAM tty devices */
+#define HN_DPRAM_PHONE_ON		_IO (IOC_MAGIC, 0xd0)
+#define HN_DPRAM_PHONE_OFF		_IO (IOC_MAGIC, 0xd1)
+#define HN_DPRAM_PHONE_GETSTATUS	_IOR(IOC_MAGIC, 0xd2, unsigned int)
+#define HN_DPRAM_PHONE_DOWNLOAD		_IO (IOC_MAGIC, 0xd5)
+
+/* return codes for HN_DPRAM_PHONE_GETSTATUS */
+#define HN_DPRAM_PHONE_STATUS_OFF	0x00
+#define HN_DPRAM_PHONE_STATUS_ON	0x01
+
+/* DPRAM ioctls for DPRAM ctl device */
+#define HN_DPRAM_PPP_ENABLE		_IO (IOC_MAGIC, 0xd3)
+#define HN_DPRAM_PPP_DISABLE		_IO (IOC_MAGIC, 0xd4)
+#define HN_DPRAM_PPP_AC_ENABLE		_IO (IOC_MAGIC, 0xd6)
+#define HN_DPRAM_PPP_AC_DISABLE		_IO (IOC_MAGIC, 0xd7)
+
+/* DPRAM events through /dev/dpram/ctl */
+#define HN_DPRAM_EVENT_PPP_ACCESS	0x0001
+#define HN_DPRAM_EVENT_PHONE_DN_DONE	0x0002
+
+/* button definition */
+#define HN_POWER_BUTTON		SCANCODE_POWER
+#define HN_CAMERA_BUTTON	SCANCODE_U1
+#define HN_VOICE_BUTTON		SCANCODE_RECORD
+
+#define HN_SIDE_UP_BUTTON	SCANCODE_SLIDE_UP
+#define HN_SIDE_DOWN_BUTTON	SCANCODE_SLIDE_DOWN
+
+#define HN_HOME_BUTTON		SCANCODE_MENU
+#define HN_BACK_BUTTON		SCANCODE_CLR
+#define HN_SEND_BUTTON		SCANCODE_SEND
+#define HN_END_BUTTON		SCANCODE_END
+
+#define HN_UP_BUTTON		SCANCODE_UP
+#define HN_DOWN_BUTTON		SCANCODE_DOWN
+#define HN_LEFT_BUTTON		SCANCODE_LEFT
+#define HN_RIGHT_BUTTON		SCANCODE_RIGHT
+#define HN_OK_BUTTON		SCANCODE_ENTER
+
+#define HN_EAR_SEND_BUTTON	SCANCODE_U2
+
+/* PXA255 clock control */
+#define HN_CLOCK_WRITE		_IOW(IOC_MAGIC, 0xe1, unsigned int)
+#define HN_CLOCK_READ		_IOR(IOC_MAGIC, 0xe2, unsigned int)
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0_nand.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0_nand.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/s3c24a0_nand.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/s3c24a0_nand.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,485 @@
+/*
+ * s3c24a0_nand.h
+ *
+ * s3c24a0 NAND specific definiton
+ *
+ * $Id: s3c24a0_nand.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * Copyright (C) SAMSUNG MOBILE
+ */
+
+#ifndef _S3C24A0_NAND_H_
+#define _S3C24A0_NAND_H_
+
+#define bNAND_CTL(Nb)	__REG(0x40c00000 + (Nb))
+
+#define NFCONF			bNAND_CTL(0x00)
+#define NFCONT			bNAND_CTL(0x04)
+#define NFCMMD			bNAND_CTL(0x08)
+#define NFADDR			bNAND_CTL(0x0c)
+#define NFDATA			bNAND_CTL(0x10)
+#define NFMECCDATA0		bNAND_CTL(0x14)
+#define NFMECCDATA1		bNAND_CTL(0x18)
+#define NFMECCDATA2		bNAND_CTL(0x1c)
+#define NFMECCDATA3		bNAND_CTL(0x20)
+#define NFSECCDATA0		bNAND_CTL(0x24)
+#define NFSECCDATA1		bNAND_CTL(0x28)
+#define NFSTAT			bNAND_CTL(0x2c)
+#define NFESTAT0		bNAND_CTL(0x30)
+#define NFESTAT1		bNAND_CTL(0x34)
+#define NFMECC0			bNAND_CTL(0x38)
+#define NFMECC1			bNAND_CTL(0x3c)
+#define NFSECC			bNAND_CTL(0x40)
+#define NFSBLK			bNAND_CTL(0x44)
+#define NFEBLK			bNAND_CTL(0x48)
+
+
+/*
+ * NFCONF
+ */
+#define fNFCONF_AdvanceFlash	Fld(1,22)
+#define fNFCONF_TCEH			Fld(6,16)
+#define fNFCONF_TACLS			Fld(3,12)
+#define fNFCONF_TWRPH0			Fld(3,8)
+#define fNFCONF_X16Device		Fld(1,7)
+#define fNFCONF_TWRPH1			Fld(3,4)
+#define fNFCONF_Hardware_nCE	Fld(1,3)
+#define fNFCONF_BusWidth		Fld(1,2)
+#define fNFCONF_PageSize		Fld(1,1)
+#define fNFCONF_AddressCycle	Fld(1,0)
+
+#define m1NFCONF_AdvanceFlash	FMsk(fNFCONF_AdvanceFlash)
+#define m1NFCONF_TCEH			FMsk(fNFCONF_TCEH)
+#define m1NFCONF_TACLS			FMsk(fNFCONF_TACLS)
+#define m1NFCONF_TWRPH0			FMsk(fNFCONF_TWRPH0)
+#define m1NFCONF_X16Device		FMsk(fNFCONF_X16Device)
+#define m1NFCONF_TWRPH1			FMsk(fNFCONF_TWRPH1)
+#define m1NFCONF_Hardware_nCE	FMsk(fNFCONF_Hardware_nCE)
+#define m1NFCONF_BusWidth		FMsk(fNFCONF_BusWidth)
+#define m1NFCONF_PageSize		FMsk(fNFCONF_PageSize)
+#define m1NFCONF_AddressCycle	FMsk(fNFCONF_AddressCycle)
+
+#define m0NFCONF_AdvanceFlash		(~m1NFCONF_AdvanceFlash)
+#define m0NFCONF_TCEH				(~m1NFCONF_TCEH)
+#define m0NFCONF_TACLS				(~m1NFCONF_TACLS)
+#define m0NFCONF_TWRPH0				(~m1NFCONF_TWRPH0)
+#define m0NFCONF_X16Device			(~m1NFCONF_X16Device)
+#define m0NFCONF_TWRPH1				(~m1NFCONF_TWRPH1)
+#define m0NFCONF_Hardware_nCE		(~m1NFCONF_Hardware_nCE)
+#define m0NFCONF_BusWidth			(~m1NFCONF_BusWidth)
+#define m0NFCONF_PageSize			(~m1NFCONF_PageSize)
+#define m0NFCONF_AddressCycle		(~m1NFCONF_AddressCycle)
+
+#define sNFCONF_TCEH(f_)			(FInsrt(f_,fNFCONF_TCEH)			& m1NFCONF_TCEH)
+#define sNFCONF_TACLS(f_)			(FInsrt(f_,fNFCONF_TACLS)			& m1NFCONF_TACLS)
+#define sNFCONF_TWRPH0(f_)			(FInsrt(f_,fNFCONF_TWRPH0)			& m1NFCONF_TWRPH0)
+#define sNFCONF_TWRPH1(f_)			(FInsrt(f_,fNFCONF_TWRPH1)			& m1NFCONF_TWRPH1)
+#define sNFCONF_Hardware_nCE(f_)	(FInsrt(f_,fNFCONF_Hardware_nCE)	& m1NFCONF_Hardware_nCE)
+
+
+/*
+ * NFCONT
+ */
+#define fNFCONT_LdStrAddr			Fld(12,16)
+#define fNFCONT_EnbIllegalAccINT	Fld(1,15)
+#define fNFCONT_EnbLoadINT			Fld(1,14)
+#define fNFCONT_EnbStoreINT			Fld(1,13)
+#define fNFCONT_EnbRnBINT			Fld(1,12)
+#define fNFCONT_RnB_TransMode		Fld(1,11)
+#define fNFCONT_SpareECCLock		Fld(1,10)
+#define fNFCONT_MainECCLock			Fld(1,9)
+#define fNFCONT_InitECC				Fld(1,8)
+#define fNFCONT_Reg_nCE				Fld(1,7)
+#define fNFCONT_LoadPageSize		Fld(3,4)
+#define fNFCONT_Lock_tight			Fld(1,3)
+#define fNFCONT_Lock				Fld(1,2)
+#define fNFCONT_Mode				Fld(2,0)
+
+#define m1NFCONT_LdStrAddr			FMsk(fNFCONT_LdStrAddr)
+#define m1NFCONT_EnbIllegalAccINT	FMsk(fNFCONT_EnbIllegalAccINT)
+#define m1NFCONT_EnbLoadINT			FMsk(fNFCONT_EnbLoadINT)
+#define m1NFCONT_EnbStoreINT		FMsk(fNFCONT_EnbStoreINT)
+#define m1NFCONT_EnbRnBINT			FMsk(fNFCONT_EnbRnBINT)
+#define m1NFCONT_RnB_TransMode		FMsk(fNFCONT_RnB_TransMode)
+#define m1NFCONT_SpareECCLock		FMsk(fNFCONT_SpareECCLock)
+#define m1NFCONT_MainECCLock		FMsk(fNFCONT_MainECCLock)
+#define m1NFCONT_InitECC			FMsk(fNFCONT_InitECC)
+#define m1NFCONT_Reg_nCE			FMsk(fNFCONT_Reg_nCE)
+#define m1NFCONT_LoadPageSize		FMsk(fNFCONT_LoadPageSize)
+#define m1NFCONT_Lock_tight			FMsk(fNFCONT_Lock_tight)
+#define m1NFCONT_Lock				FMsk(fNFCONT_Lock)
+#define m1NFCONT_Mode				FMsk(fNFCONT_Mode)
+
+#define m0NFCONT_LdStrAddr			(~m1NFCONT_LdStrAddr)
+#define m0NFCONT_EnbIllegalAccINT	(~m1NFCONT_EnbIllegalAccINT)
+#define m0NFCONT_EnbLoadINT			(~m1NFCONT_EnbLoadINT)
+#define m0NFCONT_EnbStoreINT		(~m1NFCONT_EnbStoreINT)
+#define m0NFCONT_EnbRnBINT			(~m1NFCONT_EnbRnBINT)
+#define m0NFCONT_RnB_TransMode		(~m1NFCONT_RnB_TransMode)
+#define m0NFCONT_SpareECCLock		(~m1NFCONT_SpareECCLock)
+#define m0NFCONT_MainECCLock		(~m1NFCONT_MainECCLock)
+#define m0NFCONT_InitECC			(~m1NFCONT_InitECC)
+#define m0NFCONT_Reg_nCE			(~m1NFCONT_Reg_nCE)
+#define m0NFCONT_LoadPageSize		(~m1NFCONT_LoadPageSize)
+#define m0NFCONT_Lock_tight			(~m1NFCONT_Lock_tight)
+#define m0NFCONT_Lock				(~m1NFCONT_Lock)
+#define m0NFCONT_Mode				(~m1NFCONT_Mode)
+
+#define sNFCONT_LdStrAddr(f_)			(FInsrt(f_,fNFCONT_LdStrAddr)			& m1NFCONT_LdStrAddr)
+#define sNFCONT_EnbIllegalAccINT(f_)	(FInsrt(f_,fNFCONT_EnbIllegalAccINT)	& m1NFCONT_EnbIllegalAccINT)
+#define sNFCONT_EnbLoadINT(f_)			(FInsrt(f_,fNFCONT_EnbLoadINT)			& m1NFCONT_EnbLoadINT)
+#define sNFCONT_EnbStoreINT(f_)			(FInsrt(f_,fNFCONT_EnbStoreINT)			& m1NFCONT_EnbStoreINT)
+#define sNFCONT_EnbRnBINT(f_)			(FInsrt(f_,fNFCONT_EnbRnBINT)			& m1NFCONT_EnbRnBINT)
+#define sNFCONT_RnB_TransMode(f_)		(FInsrt(f_,fNFCONT_RnB_TransMode)		& m1NFCONT_RnB_TransMode)
+#define sNFCONT_SpareECCLock(f_)		(FInsrt(f_,fNFCONT_SpareECCLock)		& m1NFCONT_SpareECCLock)
+#define sNFCONT_MainECCLock(f_)			(FInsrt(f_,fNFCONT_MainECCLock)			& m1NFCONT_MainECCLock)
+#define sNFCONT_InitECC(f_)				(FInsrt(f_,fNFCONT_InitECC)				& m1NFCONT_InitECC)
+#define sNFCONT_Reg_nCE(f_)				(FInsrt(f_,fNFCONT_Reg_nCE)				& m1NFCONT_Reg_nCE)
+#define sNFCONT_LoadPageSize(f_)		(FInsrt(f_,fNFCONT_LoadPageSize)		& m1NFCONT_LoadPageSize)
+#define sNFCONT_Lock_tight(f_)			(FInsrt(f_,fNFCONT_Lock_tight)			& m1NFCONT_Lock_tight)
+#define sNFCONT_Lock(f_)				(FInsrt(f_,fNFCONT_Lock)				& m1NFCONT_Lock)
+#define sNFCONT_Mode(f_)				(FInsrt(f_,fNFCONT_Mode)				& m1NFCONT_Mode)
+
+
+/*
+ * NFCMMD
+ */
+#define fNFCMMD_NFCMMD1		Fld(8,8)
+#define fNFCMMD_NFCMMD0		Fld(8,0)
+
+#define m1NFCMMD_NFCMMD1	FMsk(fNFCMMD_NFCMMD1)
+#define m1NFCMMD_NFCMMD0	FMsk(fNFCMMD_NFCMMD0)
+
+#define m0NFCMMD_NFCMMD1	(~m1NFCMMD_NFCMMD1)
+#define m0NFCMMD_NFCMMD0	(~m1NFCMMD_NFCMMD0)
+
+#define sNFCMMD_NFCMMD1(f_)	(FInsrt(f_,fNFCMMD_NFCMMD1)	& m1NFCMMD_NFCMMD1)
+#define sNFCMMD_NFCMMD0(f_)	(FInsrt(f_,fNFCMMD_NFCMMD0)	& m1NFCMMD_NFCMMD0)
+
+
+/*
+ * NFADDR
+ */
+#define fNFADDR_NFADDR3		Fld(8,24)
+#define fNFADDR_NFADDR2		Fld(8,16)
+#define fNFADDR_NFADDR1		Fld(8,8)
+#define fNFADDR_NFADDR0		Fld(8,0)
+
+#define m1NFADDR_NFADDR3	FMsk(fNFADDR_NFADDR3)
+#define m1NFADDR_NFADDR2	FMsk(fNFADDR_NFADDR2)
+#define m1NFADDR_NFADDR1	FMsk(fNFADDR_NFADDR1)
+#define m1NFADDR_NFADDR0	FMsk(fNFADDR_NFADDR0)
+
+#define m0NFADDR_NFADDR3	(~m1NFADDR_NFADDR3)
+#define m0NFADDR_NFADDR2	(~m1NFADDR_NFADDR2)
+#define m0NFADDR_NFADDR1	(~m1NFADDR_NFADDR1)
+#define m0NFADDR_NFADDR0	(~m1NFADDR_NFADDR0)
+
+#define sNFADDR_NFADDR3(f_)	(FInsrt(f_,fNFADDR_NFADDR3)	& m1NFADDR_NFADDR3)
+#define sNFADDR_NFADDR2(f_)	(FInsrt(f_,fNFADDR_NFADDR2)	& m1NFADDR_NFADDR2)
+#define sNFADDR_NFADDR1(f_)	(FInsrt(f_,fNFADDR_NFADDR1)	& m1NFADDR_NFADDR1)
+#define sNFADDR_NFADDR0(f_)	(FInsrt(f_,fNFADDR_NFADDR0)	& m1NFADDR_NFADDR0)
+
+
+/*
+ * NFDATA
+ */
+#define fNFDATA_NFDATA1		Fld(8,8)
+#define fNFDATA_NFDATA0		Fld(8,0)
+
+#define m1NFDATA_NFDATA1	FMsk(fNFDATA_NFDATA1)
+#define m1NFDATA_NFDATA0	FMsk(fNFDATA_NFDATA0)
+
+#define m0NFDATA_NFDATA1	(~m1NFDATA_NFDATA1)
+#define m0NFDATA_NFDATA0	(~m1NFDATA_NFDATA0)
+
+#define sNFDATA_NFDATA1(f_)	(FInsrt(f_,fNFDATA_NFDATA1)	& m1NFDATA_NFDATA1)
+#define sNFDATA_NFDATA0(f_)	(FInsrt(f_,fNFDATA_NFDATA0)	& m1NFDATA_NFDATA0)
+
+
+/*
+ * NFMECCDATA0
+ */
+#define fNFMECCDATA0_ECCData0_1		Fld(8,8)
+#define fNFMECCDATA0_ECCData0_0		Fld(8,0)
+
+#define m1NFMECCDATA0_ECCData0_1	FMsk(fNFMECCDATA0_ECCData0_1)
+#define m1NFMECCDATA0_ECCData0_0	FMsk(fNFMECCDATA0_ECCData0_0)
+
+#define m0NFMECCDATA0_ECCData0_1	(~m1NFMECCDATA0_ECCData0_1)
+#define m0NFMECCDATA0_ECCData0_0	(~m1NFMECCDATA0_ECCData0_0)
+
+#define sNFMECCDATA0_ECCData0_1(f_)	(FInsrt(f_,fNFMECCDATA0_ECCData0_1)	& m1NFMECCDATA0_ECCData0_1)
+#define sNFMECCDATA0_ECCData0_0(f_)	(FInsrt(f_,fNFMECCDATA0_ECCData0_0)	& m1NFMECCDATA0_ECCData0_0)
+
+/*
+ * NFMECCDATA1
+ */
+#define fNFMECCDATA1_ECCData1_1		Fld(8,8)
+#define fNFMECCDATA1_ECCData1_0		Fld(8,0)
+
+#define m1NFMECCDATA1_ECCData1_1	FMsk(fNFMECCDATA1_ECCData1_1)
+#define m1NFMECCDATA1_ECCData1_0	FMsk(fNFMECCDATA1_ECCData1_0)
+
+#define m0NFMECCDATA1_ECCData1_1	(~m1NFMECCDATA1_ECCData1_1)
+#define m0NFMECCDATA1_ECCData1_0	(~m1NFMECCDATA1_ECCData1_0)
+
+#define sNFMECCDATA1_ECCData1_1(f_)	(FInsrt(f_,fNFMECCDATA1_ECCData1_1)	& m1NFMECCDATA1_ECCData1_1)
+#define sNFMECCDATA1_ECCData1_0(f_)	(FInsrt(f_,fNFMECCDATA1_ECCData1_0)	& m1NFMECCDATA1_ECCData1_0)
+
+/*
+ * NFMECCDATA2
+ */
+#define fNFMECCDATA2_ECCData2_1		Fld(8,8)
+#define fNFMECCDATA2_ECCData2_0		Fld(8,0)
+
+#define m1NFMECCDATA2_ECCData2_1	FMsk(fNFMECCDATA2_ECCData2_1)
+#define m1NFMECCDATA2_ECCData2_0	FMsk(fNFMECCDATA2_ECCData2_0)
+
+#define m0NFMECCDATA2_ECCData2_1	(~m1NFMECCDATA2_ECCData2_1)
+#define m0NFMECCDATA2_ECCData2_0	(~m1NFMECCDATA2_ECCData2_0)
+
+#define sNFMECCDATA2_ECCData2_1(f_)	(FInsrt(f_,fNFMECCDATA2_ECCData2_1)	& m1NFMECCDATA2_ECCData2_1)
+#define sNFMECCDATA2_ECCData2_0(f_)	(FInsrt(f_,fNFMECCDATA2_ECCData2_0)	& m1NFMECCDATA2_ECCData2_0)
+
+/*
+ * NFMECCDATA3
+ */
+#define fNFMECCDATA3_ECCData3_1		Fld(8,8)
+#define fNFMECCDATA3_ECCData3_0		Fld(8,0)
+
+#define m1NFMECCDATA3_ECCData3_1	FMsk(fNFMECCDATA3_ECCData3_1)
+#define m1NFMECCDATA3_ECCData3_0	FMsk(fNFMECCDATA3_ECCData3_0)
+
+#define m0NFMECCDATA3_ECCData3_1	(~m1NFMECCDATA3_ECCData3_1)
+#define m0NFMECCDATA3_ECCData3_0	(~m1NFMECCDATA3_ECCData3_0)
+
+#define sNFMECCDATA3_ECCData3_1(f_)	(FInsrt(f_,fNFMECCDATA3_ECCData3_1)	& m1NFMECCDATA3_ECCData3_1)
+#define sNFMECCDATA3_ECCData3_0(f_)	(FInsrt(f_,fNFMECCDATA3_ECCData3_0)	& m1NFMECCDATA3_ECCData3_0)
+
+
+/*
+ * NFSECCDATA0
+ */
+#define fNFSECCDATA0_ECCData0_1		Fld(8,8)
+#define fNFSECCDATA0_ECCData0_0		Fld(8,0)
+
+#define m1NFSECCDATA0_ECCData0_1	FMsk(fNFSECCDATA0_ECCData0_1)
+#define m1NFSECCDATA0_ECCData0_0	FMsk(fNFSECCDATA0_ECCData0_0)
+
+#define m0NFSECCDATA0_ECCData0_1	(~m1NFSECCDATA0_ECCData0_1)
+#define m0NFSECCDATA0_ECCData0_0	(~m1NFSECCDATA0_ECCData0_0)
+
+#define sNFSECCDATA0_ECCData0_1(f_)	(FInsrt(f_,fNFSECCDATA0_ECCData0_1)	& m1NFSECCDATA0_ECCData0_1)
+#define sNFSECCDATA0_ECCData0_0(f_)	(FInsrt(f_,fNFSECCDATA0_ECCData0_0)	& m1NFSECCDATA0_ECCData0_0)
+
+/*
+ * NFSECCDATA1
+ */
+#define fNFSECCDATA1_ECCData1_1		Fld(8,8)
+#define fNFSECCDATA1_ECCData1_0		Fld(8,0)
+
+#define m1NFSECCDATA1_ECCData1_1	FMsk(fNFSECCDATA1_ECCData1_1)
+#define m1NFSECCDATA1_ECCData1_0	FMsk(fNFSECCDATA1_ECCData1_0)
+
+#define m0NFSECCDATA1_ECCData1_1	(~m1NFSECCDATA1_ECCData1_1)
+#define m0NFSECCDATA1_ECCData1_0	(~m1NFSECCDATA1_ECCData1_0)
+
+#define sNFSECCDATA1_ECCData1_1(f_)	(FInsrt(f_,fNFSECCDATA1_ECCData1_1)	& m1NFSECCDATA1_ECCData1_1)
+#define sNFSECCDATA1_ECCData1_0(f_)	(FInsrt(f_,fNFSECCDATA1_ECCData1_0)	& m1NFSECCDATA1_ECCData1_0)
+
+
+/*
+ * NFSTAT
+ */
+#define fNFSTAT_IllegalAccess		Fld(1,16)
+#define fNFSTAT_AutoLoadDone		Fld(1,15)
+#define fNFSTAT_AutoStoreDone		Fld(1,14)
+#define fNFSTAT_RnB_TransDetect		Fld(1,13)
+#define fNFSTAT_Flash_nCE			Fld(1,12)
+#define fNFSTAT_Flash_RnB1			Fld(1,11)
+#define fNFSTAT_Flash_RnB0			Fld(1,10)
+#define fNFSTAT_STON_A2				Fld(10,0)
+
+#define m1NFSTAT_IllegalAccess		FMsk(fNFSTAT_IllegalAccess)
+#define m1NFSTAT_AutoLoadDone		FMsk(fNFSTAT_AutoLoadDone)
+#define m1NFSTAT_AutoStoreDone		FMsk(fNFSTAT_AutoStoreDone)
+#define m1NFSTAT_RnB_TransDetect	FMsk(fNFSTAT_RnB_TransDetect)
+#define m1NFSTAT_Flash_nCE			FMsk(fNFSTAT_Flash_nCE)
+#define m1NFSTAT_Flash_RnB1			FMsk(fNFSTAT_Flash_RnB1)
+#define m1NFSTAT_Flash_RnB0			FMsk(fNFSTAT_Flash_RnB0)
+#define m1NFSTAT_STON_A2			FMsk(fNFSTAT_STON_A2)
+
+#define m0NFSTAT_IllegalAccess		(~m1NFSTAT_IllegalAccess)
+#define m0NFSTAT_AutoLoadDone		(~m1NFSTAT_AutoLoadDone)
+#define m0NFSTAT_AutoStoreDone		(~m1NFSTAT_AutoStoreDone)
+#define m0NFSTAT_RnB_TransDetect	(~m1NFSTAT_RnB_TransDetect)
+#define m0NFSTAT_Flash_nCE			(~m1NFSTAT_Flash_nCE)
+#define m0NFSTAT_Flash_RnB1			(~m1NFSTAT_Flash_RnB1)
+#define m0NFSTAT_Flash_RnB0			(~m1NFSTAT_Flash_RnB0)
+#define m0NFSTAT_STON_A2			(~m1NFSTAT_STON_A2)
+
+#define sNFSTAT_IllegalAccess(f_)	(FInsrt(f_,fNFSTAT_IllegalAccess)	& m1NFSTAT_IllegalAccess)
+#define sNFSTAT_AutoLoadDone(f_)	(FInsrt(f_,fNFSTAT_AutoLoadDone)	& m1NFSTAT_AutoLoadDone)
+#define sNFSTAT_AutoStoreDone(f_)	(FInsrt(f_,fNFSTAT_AutoStoreDone)	& m1NFSTAT_AutoStoreDone)
+#define sNFSTAT_RnB_TransDetect(f_)	(FInsrt(f_,fNFSTAT_RnB_TransDetect)	& m1NFSTAT_RnB_TransDetect)
+
+
+/*
+ * NFESTAT0
+ */
+#define fNFESTAT0_SErrorDataNo		Fld(4,21)
+#define fNFESTAT0_SErrorBitNo		Fld(3,18)
+#define fNFESTAT0_MErrorDataNo		Fld(11,7)
+#define fNFESTAT0_MErrorBitNo		Fld(3,4)
+#define fNFESTAT0_SpareError		Fld(2,2)
+#define fNFESTAT0_MainError			Fld(2,0)
+
+#define m1NFESTAT0_SErrorDataNo		FMsk(fNFESTAT0_SErrorDataNo)
+#define m1NFESTAT0_SErrorBitNo		FMsk(fNFESTAT0_SErrorBitNo)
+#define m1NFESTAT0_MErrorDataNo		FMsk(fNFESTAT0_MErrorDataNo)
+#define m1NFESTAT0_MErrorBitNo		FMsk(fNFESTAT0_MErrorBitNo)
+#define m1NFESTAT0_SpareError		FMsk(fNFESTAT0_SpareError)
+#define m1NFESTAT0_MainError		FMsk(fNFESTAT0_MainError)
+
+#define m0NFESTAT0_SErrorDataNo		(~m1NFESTAT0_SErrorDataNo)
+#define m0NFESTAT0_SErrorBitNo		(~m1NFESTAT0_SErrorBitNo)
+#define m0NFESTAT0_MErrorDataNo		(~m1NFESTAT0_MErrorDataNo)
+#define m0NFESTAT0_MErrorBitNo		(~m1NFESTAT0_MErrorBitNo)
+#define m0NFESTAT0_SpareError		(~m1NFESTAT0_SpareError)
+#define m0NFESTAT0_MainError		(~m1NFESTAT0_MainError)
+
+#define sNFESTAT0_SErrorDataNo(f_)	(FInsrt(f_,fNFESTAT0_SErrorDataNo)	& m1NFESTAT0_SErrorDataNo)
+#define sNFESTAT0_SErrorBitNo(f_)	(FInsrt(f_,fNFESTAT0_SErrorBitNo)	& m1NFESTAT0_SErrorBitNo)
+#define sNFESTAT0_MErrorDataNo(f_)	(FInsrt(f_,fNFESTAT0_MErrorDataNo)	& m1NFESTAT0_MErrorDataNo)
+#define sNFESTAT0_MErrorBitNo(f_)	(FInsrt(f_,fNFESTAT0_MErrorBitNo)	& m1NFESTAT0_MErrorBitNo)
+#define sNFESTAT0_SpareError(f_)	(FInsrt(f_,fNFESTAT0_SpareError)	& m1NFESTAT0_SpareError)
+#define sNFESTAT0_MainError(f_)		(FInsrt(f_,fNFESTAT0_MainError)		& m1NFESTAT0_MainError)
+
+/*
+ * NFESTAT1
+ */
+#define fNFESTAT1_SErrorDataNo		Fld(4,21)
+#define fNFESTAT1_SErrorBitNo		Fld(3,18)
+#define fNFESTAT1_MErrorDataNo		Fld(11,7)
+#define fNFESTAT1_MErrorBitNo		Fld(3,4)
+#define fNFESTAT1_SpareError		Fld(2,2)
+#define fNFESTAT1_MainError			Fld(2,0)
+
+#define m1NFESTAT1_SErrorDataNo		FMsk(fNFESTAT1_SErrorDataNo)
+#define m1NFESTAT1_SErrorBitNo		FMsk(fNFESTAT1_SErrorBitNo)
+#define m1NFESTAT1_MErrorDataNo		FMsk(fNFESTAT1_MErrorDataNo)
+#define m1NFESTAT1_MErrorBitNo		FMsk(fNFESTAT1_MErrorBitNo)
+#define m1NFESTAT1_SpareError		FMsk(fNFESTAT1_SpareError)
+#define m1NFESTAT1_MainError		FMsk(fNFESTAT1_MainError)
+
+#define m0NFESTAT1_SErrorDataNo		(~m1NFESTAT1_SErrorDataNo)
+#define m0NFESTAT1_SErrorBitNo		(~m1NFESTAT1_SErrorBitNo)
+#define m0NFESTAT1_MErrorDataNo		(~m1NFESTAT1_MErrorDataNo)
+#define m0NFESTAT1_MErrorBitNo		(~m1NFESTAT1_MErrorBitNo)
+#define m0NFESTAT1_SpareError		(~m1NFESTAT1_SpareError)
+#define m0NFESTAT1_MainError		(~m1NFESTAT1_MainError)
+
+#define sNFESTAT1_SErrorDataNo(f_)	(FInsrt(f_,fNFESTAT1_SErrorDataNo)	& m1NFESTAT1_SErrorDataNo)
+#define sNFESTAT1_SErrorBitNo(f_)	(FInsrt(f_,fNFESTAT1_SErrorBitNo)	& m1NFESTAT1_SErrorBitNo)
+#define sNFESTAT1_MErrorDataNo(f_)	(FInsrt(f_,fNFESTAT1_MErrorDataNo)	& m1NFESTAT1_MErrorDataNo)
+#define sNFESTAT1_MErrorBitNo(f_)	(FInsrt(f_,fNFESTAT1_MErrorBitNo)	& m1NFESTAT1_MErrorBitNo)
+#define sNFESTAT1_SpareError(f_)	(FInsrt(f_,fNFESTAT1_SpareError)	& m1NFESTAT1_SpareError)
+#define sNFESTAT1_MainError(f_)		(FInsrt(f_,fNFESTAT1_MainError)		& m1NFESTAT1_MainError)
+
+
+/*
+ * NFMECC0
+ */
+#define fNFMECC0_MECC0_3	Fld(8,24)
+#define fNFMECC0_MECC0_2	Fld(8,16)
+#define fNFMECC0_MECC0_1	Fld(8,8)
+#define fNFMECC0_MECC0_0	Fld(8,0)
+
+#define m1NFMECC0_MECC0_3	FMsk(fNFMECC0_MECC0_3)
+#define m1NFMECC0_MECC0_2	FMsk(fNFMECC0_MECC0_2)
+#define m1NFMECC0_MECC0_1	FMsk(fNFMECC0_MECC0_1)
+#define m1NFMECC0_MECC0_0	FMsk(fNFMECC0_MECC0_0)
+
+#define m0NFMECC0_MECC0_3	(~m1NFMECC0_MECC0_3)
+#define m0NFMECC0_MECC0_2	(~m1NFMECC0_MECC0_2)
+#define m0NFMECC0_MECC0_1	(~m1NFMECC0_MECC0_1)
+#define m0NFMECC0_MECC0_0	(~m1NFMECC0_MECC0_0)
+
+/*
+ * NFMECC1
+ */
+#define fNFMECC1_MECC1_3	Fld(8,24)
+#define fNFMECC1_MECC1_2	Fld(8,16)
+#define fNFMECC1_MECC1_1	Fld(8,8)
+#define fNFMECC1_MECC1_0	Fld(8,0)
+
+#define m1NFMECC1_MECC1_3	FMsk(fNFMECC1_MECC1_3)
+#define m1NFMECC1_MECC1_2	FMsk(fNFMECC1_MECC1_2)
+#define m1NFMECC1_MECC1_1	FMsk(fNFMECC1_MECC1_1)
+#define m1NFMECC1_MECC1_0	FMsk(fNFMECC1_MECC1_0)
+
+#define m0NFMECC1_MECC1_3	(~m1NFMECC1_MECC1_3)
+#define m0NFMECC1_MECC1_2	(~m1NFMECC1_MECC1_2)
+#define m0NFMECC1_MECC1_1	(~m1NFMECC1_MECC1_1)
+#define m0NFMECC1_MECC1_0	(~m1NFMECC1_MECC1_0)
+
+
+/*
+ * NFSECC
+ */
+#define fNFSECC_SECC1_1		Fld(8,24)
+#define fNFSECC_SECC1_0		Fld(8,16)
+#define fNFSECC_SECC0_1		Fld(8,8)
+#define fNFSECC_SECC0_0		Fld(8,0)
+
+#define m1NFSECC_SECC1_1	FMsk(fNFSECC_SECC1_1)
+#define m1NFSECC_SECC1_0	FMsk(fNFSECC_SECC1_0)
+#define m1NFSECC_SECC0_1	FMsk(fNFSECC_SECC0_1)
+#define m1NFSECC_SECC0_0	FMsk(fNFSECC_SECC0_0)
+
+#define m0NFSECC_SECC1_1	(~m1NFSECC_SECC1_1)
+#define m0NFSECC_SECC1_0	(~m1NFSECC_SECC1_0)
+#define m0NFSECC_SECC0_1	(~m1NFSECC_SECC0_1)
+#define m0NFSECC_SECC0_0	(~m1NFSECC_SECC0_0)
+
+
+/*
+ * NFSBLK
+ */
+#define fNFSBLK_SBLK_ADDR2	Fld(8,16)
+#define fNFSBLK_SBLK_ADDR1	Fld(8,8)
+#define fNFSBLK_SBLK_ADDR0	Fld(8,0)
+
+#define m1NFSBLK_SBLK_ADDR2	FMsk(fNFSBLK_SBLK_ADDR2)
+#define m1NFSBLK_SBLK_ADDR1	FMsk(fNFSBLK_SBLK_ADDR1)
+#define m1NFSBLK_SBLK_ADDR0	FMsk(fNFSBLK_SBLK_ADDR0)
+
+#define m0NFSBLK_SBLK_ADDR2	(~m1NFSBLK_SBLK_ADDR2)
+#define m0NFSBLK_SBLK_ADDR1	(~m1NFSBLK_SBLK_ADDR1)
+#define m0NFSBLK_SBLK_ADDR0	(~m1NFSBLK_SBLK_ADDR0)
+
+#define sNFSBLK_SBLK_ADDR2(f_)	(FInsrt(f_,fNFSBLK_SBLK_ADDR2)	& m1NFSBLK_SBLK_ADDR2)
+#define sNFSBLK_SBLK_ADDR1(f_)	(FInsrt(f_,fNFSBLK_SBLK_ADDR1)	& m1NFSBLK_SBLK_ADDR1)
+#define sNFSBLK_SBLK_ADDR0(f_)	(FInsrt(f_,fNFSBLK_SBLK_ADDR0)	& m1NFSBLK_SBLK_ADDR0)
+
+/*
+ * NFEBLK
+ */
+#define fNFEBLK_EBLK_ADDR2	Fld(8,16)
+#define fNFEBLK_EBLK_ADDR1	Fld(8,8)
+#define fNFEBLK_EBLK_ADDR0	Fld(8,0)
+
+#define m1NFEBLK_EBLK_ADDR2	FMsk(fNFEBLK_EBLK_ADDR2)
+#define m1NFEBLK_EBLK_ADDR1	FMsk(fNFEBLK_EBLK_ADDR1)
+#define m1NFEBLK_EBLK_ADDR0	FMsk(fNFEBLK_EBLK_ADDR0)
+
+#define m0NFEBLK_EBLK_ADDR2	(~m1NFEBLK_EBLK_ADDR2)
+#define m0NFEBLK_EBLK_ADDR1	(~m1NFEBLK_EBLK_ADDR1)
+#define m0NFEBLK_EBLK_ADDR0	(~m1NFEBLK_EBLK_ADDR0)
+
+#define sNFEBLK_EBLK_ADDR2(f_)	(FInsrt(f_,fNFEBLK_EBLK_ADDR2)	& m1NFEBLK_EBLK_ADDR2)
+#define sNFEBLK_EBLK_ADDR1(f_)	(FInsrt(f_,fNFEBLK_EBLK_ADDR1)	& m1NFEBLK_EBLK_ADDR1)
+#define sNFEBLK_EBLK_ADDR0(f_)	(FInsrt(f_,fNFEBLK_EBLK_ADDR0)	& m1NFEBLK_EBLK_ADDR0)
+
+#endif /* _S3C24A0_NAND_H_ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/smdk.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/smdk.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/smdk.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/smdk.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,144 @@
+/*
+ * include/asm-arm/arch-s3c24a0/smdk.h
+ *
+ * Changes
+ *
+ * 2004/06/10 <heechul.yun@samsung.com>  CPLD IDE code added
+ *
+ */
+
+#ifndef _SMDK24A0_H_
+#define _SMDK24A0_H_
+
+/* Externl clock frequency used by CPU */
+#define FIN     12000000
+
+/*
+ * on SMDK24A0,
+ * there are so many cross-interference jumpers (h/w switch).
+ */
+
+/*
+ * This is for SPJ Board - hcyun
+
+ XgpIO0  <------ EINT0
+ XgpIO1  <------ EINT1
+ XgpIO2  <------ SD_INT
+ XgpIO3  ------> XGPIO_nSS              <-- not used
+ XgpIO4  ------> LED0
+ XgpIO5  ------> LED1
+ XgpIO6  ------> LED2
+ XgpIO7  ------> LED3
+ XgpIO8  <----->
+ XgpIO9  ------>
+ XgpIO10 <------ EINT10                 <-- not used
+ XgpIO11 <------ EINT11                 <-- not used
+ XgpIO12 <------ MODEM_INT              <-- not used
+ XgpIO13 <------ ETHER_INT
+ XgpIO14 <------ SMC_INT                <-- not used
+ XgpIO15 ------> SMC_WP                 <-- l3-bit-elfin.c I2C??? l3 bus
+ XgpIO16 <------ SPJ IDE                <-- IDE & l3-bit-elfin.c I2C??? l3 bus
+ XgpIO17 <------ SPJ USB                <-- USB
+ XgpIO18 <-----> KP_ROW0
+ XgpIO19 <-----> KP_ROW1                <-- s3c24a0_keyif.c
+ XgpIO20 <-----> KP_ROW2                <-- s3c24a0_keyif.c
+ XgpIO21 <-----> KP_ROW3
+ XgpIO22 <-----> KP_ROW4
+ XgpIO23 <-----> KP_COL0
+ XgpIO24 <-----> KP_COL1
+ XgpIO25 <-----> KP_COL2
+ XgpIO26 <-----> KP_COL3
+ XgpIO27 <-----> KP_COL4
+ XgpIO28 <----->
+ XgpIO29 <----->
+ XgpIO30 <----->
+ XgpIO31 <----->
+
+ *
+ */
+
+#define SMDK_SMC_WP      GPIO_15    /* O   : SMC Write-Protect */
+
+#define SMDK_CAM_SCL     GPIO_9     /* O   : Camera I2C/SCCB clock */
+#define SMDK_CAM_SDA     GPIO_8     /* I/O : Camera I2C/SCCB data */
+#define SMDK_LED7        GPIO_7     /* O   : LED3, Low-Active */
+#define SMDK_LED6        GPIO_6     /* O   : LED2, LOw-Active */
+#define SMDK_LED5        GPIO_5     /* O   : LED1, LOw-Active */
+#define SMDK_LED4        GPIO_4     /* O   : LED0, Low-Active */
+
+/* GPIO buttons. EINT 0,1,10,11 */
+#define SMDK_EINT0_IRQ  IRQ_EINT0
+#define SMDK_EINT1_IRQ  IRQ_EINT1
+#define SMDK_EINT10_IRQ IRQ_EINT10
+#define SMDK_EINT11_IRQ IRQ_EINT11
+#define SMDK_EINT0_GPIO GPIO_0
+#define SMDK_EINT1_GPIO GPIO_1
+#define SMDK_EINT10_GPIO GPIO_10
+#define SMDK_EINT11_GPIO GPIO_11
+
+#ifdef CONFIG_MMU
+  #define SROM_BANK1_PBASE                        0x04000000
+  #define SROM_BANK1_VBASE                        0xf0000000
+#else /* UCLINUX */
+  #define SROM_BANK1_PBASE                        0x04000000
+  #define SROM_BANK1_VBASE                        0x04000000
+#endif /* CONFIG_MMU */
+
+#ifndef __ASSEMBLY__
+/*
+ * BANK1 control for cs89x0, IDE, USB2.0 - hcyun
+ */
+typedef struct {
+        unsigned long bw;
+        unsigned long bc;
+} bank_param_t;
+
+#define B1_STATE_NONE -1
+#define B1_IDE_PIO0 0
+#define B1_IDE_PIO4 1
+#define B1_CS89x0       2
+#define B1_USB2         3
+#define B1_STATE_LIMIT 3
+
+#endif
+
+
+/* CPLD IDE - hcyun
+ * 0x07000000   [0] : IDE reset
+ *                              [1] : 0 - USB, 1 - IDE
+ */
+
+#define SMDK_CPLD_IDE_IRQ_GPIO          GPIO_4
+#define SMDK_CPLD_IDE_IRQ               IRQ_EINT4
+#define SMDK_CPLD_IDE_VIO               (SROM_BANK1_VBASE + 0x03000000) // 0xf3000000
+#define SMDK_CPLD_IDE_PIO               (SROM_BANK1_PBASE + 0x03000000) // 0x04000000
+
+
+/* CPLD USB - hcyun
+ * 0x06000000   [0] : USB reset
+ */
+/*seo 20040616 */
+#define SMDK_CPLD_USB_IRQ_GPIO          GPIO_5
+#define SMDK_CPLD_USB_IRQ               IRQ_EINT5
+#define SMDK_CPLD_USB_VIO               (SROM_BANK1_VBASE + 0x02000000)
+#define SMDK_CPLD_USB_PIO               (SROM_BANK1_PBASE + 0x02000000)
+
+
+/* CS8900A */
+#define SMDK_CS8900_IRQ_GPIO   GPIO_13
+#define SMDK_CS8900_IRQ        IRQ_EINT13
+#define SMDK_CS8900_VIO        SROM_BANK1_VBASE
+#define SMDK_CS8900_PIO        (SROM_BANK1_PBASE | (1<<24))
+
+/* IRDA */
+#define SMDK_IRDA_SDBW          (GPIO_MODE_IrDA_SDBW | GPIO_16 | GPIO_PULLUP_DIS)
+#define SMDK_IRDA_TXD           (GPIO_MODE_IrDA_TXD | GPIO_17 | GPIO_PULLUP_DIS)
+#define SMDK_IRDA_RXD           (GPIO_MODE_IrDA_RXD | GPIO_18 | GPIO_PULLUP_DIS)
+
+/* UART */
+#define SMDK_UART1_nCTS         (GPIO_MODE_UART | GPIO_28 | GPIO_PULLUP_DIS)
+#define SMDK_UART1_nRTS         (GPIO_MODE_UART | GPIO_29 | GPIO_PULLUP_DIS)
+#define SMDK_UART1_TXD          (GPIO_MODE_UART | GPIO_30 | GPIO_PULLUP_DIS)
+#define SMDK_UART1_RXD          (GPIO_MODE_UART | GPIO_31 | GPIO_PULLUP_DIS)
+
+#endif /* _SMDK24A0_H_ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/system.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/system.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/system.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-s3c24a0/system.h
+ * 
+ * $Id: system.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <asm/arch/hardware.h>
+
+static inline 
+void arch_idle(void)
+{
+	/* TODO */
+	cpu_do_idle(/*0*/);
+}
+
+static inline 
+void arch_reset(char mode)
+{
+	if (mode == 's') {
+		/* Jump into ROM at address 0 */
+		cpu_reset(0);
+	} else {
+		WTCNT = 0x100;
+		WTDAT = 0x100;
+		WTCON = 0x8021;
+	}
+}
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/time.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/time.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/time.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,16 @@
+/*
+ * include/asm-arm/arch-s3c24a0/time.h
+ *
+ * $Id: time.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on linux/include/asm-arm/arch-s3c2410/time.h
+ */
+
+#include <linux/time.h> /* for mktime() */
+#include <linux/rtc.h>  /* struct rtc_time */
+#include "clocks.h"
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/timex.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/timex.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/timex.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ * include/asm-arm/arch-s3c24a0/timex.h
+ *
+ * $Id: timex.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on linux/include/asm-arm/arch-s3c2410/timex.h
+ */
+
+
+/* If a value of TCFG1 is a, a value of divider is 2 << a */
+#define CLK_DIVIDER             2
+/* a value of TCFG0_PRE1 */
+#define CLK_PRESCALE            15
+
+#include <asm/arch/clocks.h>
+
+/* PCLK */
+// #define CLK_INPUT               elfin_get_bus_clk(GET_PCLK)
+#define CLK_INPUT               51000000 /* 204-102-51 MHz */
+
+/*#define CLOCK_TICK_RATE               1562500 */
+#define CLOCK_TICK_RATE         (CLK_INPUT / (CLK_PRESCALE ) / CLK_DIVIDER)
+#define CLOCK_TICK_FACTOR       80
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/uncompress.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/uncompress.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/uncompress.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/uncompress.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,60 @@
+/*
+ * include/asm-arm/arch-s3c24a0/uncompress.h
+ *
+ * $Id: uncompress.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader. We use only UART1 on S3C24xx
+ */
+#include <linux/config.h>
+
+#define ULCON                   0x0
+#define UTRSTAT                 0x10
+#define UTXH                    0x20
+#define UTRSTAT_TX_EMPTY        (1 << 2)
+
+#define UART0                   0x44400000
+#define UART1                   0x44404000
+
+#define UART(x)                 (*(volatile unsigned long *)(serial_port + (x)))
+
+static void putstr(const char *s)
+{
+        unsigned long serial_port;
+
+        do {
+                serial_port = UART0;
+                if (UART(ULCON) == 0x3) break;
+                serial_port = UART1;
+                if (UART(ULCON) == 0x3) break;
+        } while (0);
+
+        for (; *s; s++) {
+                /* wait */
+                while (!(UART(UTRSTAT) & UTRSTAT_TX_EMPTY));
+
+                /* send the character out. */
+                UART(UTXH) = *s;
+
+                /* if a LF, also do CR... */
+                if (*s == 10) {
+                        while (!(UART(UTRSTAT) & UTRSTAT_TX_EMPTY));
+
+                        UART(UTXH) = 13;
+                }
+        }
+}
+
+
+/*
+ * Nothing to do for these
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/uncompress-jtag.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/uncompress-jtag.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/uncompress-jtag.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/uncompress-jtag.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,58 @@
+/*
+ *  linux/include/asm-armnommu/arch-s5c7375/uncompress.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm-armnommu/hardware/dcc.h>
+
+#ifndef __UNCOMPRESS_H__
+#define __UNCOMPRESS_H__
+
+/*
+ * just use DCC JTAG1 port
+ */
+static inline void puts(const char *s)
+{
+	dcc_puts(s);
+}
+
+static void puts_hex(unsigned long i)
+{
+	char lhex_buf[]="0x00000000";
+	unsigned long ii,v;
+
+	for(ii=9;ii>1;ii--)
+	{
+		v=(((0x0000000F << ((9-ii)*4)) & i) >> ((9-ii)*4));
+		if(v>9)
+			lhex_buf[ii]=(char)('A'+v-10);
+		else
+			lhex_buf[ii]=(char)('0'+v);
+	}
+
+	dcc_puts(lhex_buf);
+}
+
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/vmalloc.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/vmalloc.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c24a0/vmalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c24a0/vmalloc.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,24 @@
+/*
+ * include/asm-arm/arch-s3c24a0/vmalloc.h
+ * 
+ * $Id: vmalloc.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on linux/include/asm-arm/arch-pxa/vmalloc.h
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/dma.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/dma.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/dma.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-armnommu/arch-s3c3410/dma.h
+ *
+ * Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_S3C3410_ARCH_DMA_H
+#define __ASM_S3C3410_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ * 
+ */
+#define MAX_DMA_ADDRESS		0x03000000
+/*
+ * The S3C3410 has 2 internal DMA channels.
+ */
+#define MAX_DMA_CHANNELS	2
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#endif /* _ASM_S3C3410_ARCH_DMA_H */
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/entry-macro.S linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/entry-macro.S
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/entry-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/entry-macro.S	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,38 @@
+/*
+ *  arch/armnommu/mach-s3c3410/entry-macro.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  Samsung Electronics Co.,Ltd.
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ */
+
+#if defined(CONFIG_ARCH_S3C3410)
+                .macro  disable_fiq
+                .endm
+
+		.macro get_irqnr_and_base, irqnr, irqstat, base, tmp
+		
+		ldr	\irqstat, =(S3C3410X_INTPND)	@ load address of interrupt pending
+@		ldr	\irqstat, [\irqstat]	@ register INTPND
+		ldr	\irqnr, [\irqstat]	@ \irqnr = INTPND
+		add	\irqstat, \irqstat, #(S3C3410X_INTMSK-S3C3410X_INTPND)
+		ldr	\irqstat, [\irqstat]	@ \irqstat = INTMSK
+		and	\irqstat, \irqnr, \irqstat @ \irqstat = (INTPND & INTMSK)
+
+		mov     \irqnr, #0
+1001:
+		tst     \irqstat, #1
+		bne     1002f
+		add     \irqnr, \irqnr, #1
+		mov     \irqstat, \irqstat, lsr #1
+		cmp     \irqnr, #NR_IRQS
+		bcc     1001b
+1002:		/* EQ will be set if we reach 32 */
+		.endm
+
+		.macro irq_prio_table
+		.endm
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/hardware.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/hardware.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/hardware.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/hardware.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/hardware.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                   Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+#include <asm/arch/s3c3410.h>
+
+#ifndef __ASSEMBLY__
+
+#define HARD_RESET_NOW()
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(1)
+
+#endif
+
+#endif  /*   END OF __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/io.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/io.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/io.h	2005-11-08 09:06:42.000000000 +0900
@@ -0,0 +1,67 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/io.h
+ *
+ * Copyright (C) 2003 Thomas Eschenbacher <eschenbacher@sympat.de>
+ * Modified by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+/*
+ * We have the this routine to use usb host device driver
+ */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a)			(PCI_IO_VADDR + (a))
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(PCI_MEMORY_VADDR + (unsigned long)(a))
+
+
+/*
+ * These macros were copied from arch/armnommu/io.h and are used instead
+ * of the definitions found there, because we want to do 16/32 bit i/o
+ * without byte swapping.
+ * --the
+ */
+
+#undef __io
+
+#ifndef __iob
+  #define __iob(a) __io(a)
+#endif
+
+#define outb(v,p)       __raw_writeb(v, p)
+#define outw(v,p)       __raw_writew(v, p)
+#define outl(v,p)       __raw_writel(v, p)
+
+#define inb(p)          ({ unsigned int __v = __raw_readb(p); __v; })
+#define inw(p)          ({ unsigned int __v = __raw_readw(p); __v; })
+#define inl(p)          ({ unsigned int __v = __raw_readl(p); __v; })
+
+#define outsb(p,d,l)    __raw_writesb(p, d, l)
+#define outsw(p,d,l)    __raw_writesw(p, d, l)
+#define outsl(p,d,l)    __raw_writesl(p, d, l)
+
+#define insb(p,d,l)     __raw_readsb(p, d, l)
+#define insw(p,d,l)     __raw_readsw(p, d, l)
+#define insl(p,d,l)     __raw_readsl(p, d, l)
+
+/*
+ * Validate the pci memory address for ioremap.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ */
+#define iomem_to_phys(iomem)	(iomem)
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/irq.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/irq.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/irq.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,24 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/irq.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __S3C3410_irq_h
+#define __S3C3410_irq_h
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+extern unsigned  int fixup_irq(int i);
+
+extern void do_IRQ(int irq, struct pt_regs *regs);
+
+extern void s3c3410_init_irq(void);
+
+#define 	irq_init_irq 	s3c3410_init_irq
+
+#endif 
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/irqs.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/irqs.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/irqs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/irqs.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,48 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/irqs.h
+ *
+ * 2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ *
+ * All IRQ numbers of the S3C3410X CPUs.
+ *
+ */
+
+#ifndef __S3C3410_irqs_h
+#define __S3C3410_irqs_h                        1
+
+#define NR_IRQS		32
+	
+#define S3C3410X_INTERRUPT_EINT0	 0	/* External int. 0 */
+#define S3C3410X_INTERRUPT_EINT1	 1	/* External int. 1 */
+#define S3C3410X_INTERRUPT_URX  	 2	/* UART receive */
+#define S3C3410X_INTERRUPT_UTX  	 3	/* UART transmit */
+#define S3C3410X_INTERRUPT_UERR 	 4	/* UART error */
+#define S3C3410X_INTERRUPT_DMA0 	 5	/* DMA 0 */
+#define S3C3410X_INTERRUPT_DMA1 	 6	/* DMA 1 */
+#define S3C3410X_INTERRUPT_TOF0 	 7	/* Timer 0 overflow */
+#define S3C3410X_INTERRUPT_TMC0 	 8	/* Timer 0 match/capture */
+#define S3C3410X_INTERRUPT_TOF1 	 9	/* Timer 1 overflow */
+#define S3C3410X_INTERRUPT_TMC1 	10	/* Timer 1 match/capture */
+#define S3C3410X_INTERRUPT_TOF2 	11	/* Timer 2 overflow */
+#define S3C3410X_INTERRUPT_TMC2 	12	/* Timer 2 match/capture */
+#define S3C3410X_INTERRUPT_TOF3 	13	/* Timer 3 overflow */
+#define S3C3410X_INTERRUPT_TMC3 	14	/* Timer 3 match/capture */
+#define S3C3410X_INTERRUPT_TOF4 	15	/* Timer 4 overflow */
+#define S3C3410X_INTERRUPT_TMC4 	16	/* Timer 4 match/capture */
+#define S3C3410X_INTERRUPT_BT   	17	/* Basic Timer */
+#define S3C3410X_INTERRUPT_SIO0 	18	/* SIO 0 */
+#define S3C3410X_INTERRUPT_SIO1 	19	/* SIO 1 */
+#define S3C3410X_INTERRUPT_IIC  	20	/* IIC */
+#define S3C3410X_INTERRUPT_RTCA 	21	/* RTC alarm */
+#define S3C3410X_INTERRUPT_RTCT 	22	/* RTC time (SEC/MIN/HOUR) */
+#define S3C3410X_INTERRUPT_TF   	23	/* Timer4 FIFO interrupt */
+#define S3C3410X_INTERRUPT_EINT2	24	/* External int. 2 */
+#define S3C3410X_INTERRUPT_EINT3	25	/* External int. 3 */
+#define S3C3410X_INTERRUPT_EINT4567	26	/* External int. 4/5/6/7 */
+#define S3C3410X_INTERRUPT_ADC   	27	/* ADC interrupt */
+#define S3C3410X_INTERRUPT_EINT8	28	/* External int. 8 */
+#define S3C3410X_INTERRUPT_EINT9	29	/* External int. 9 */
+#define S3C3410X_INTERRUPT_EINT10	30	/* External int. 10 */
+#define S3C3410X_INTERRUPT_EINT11	31	/* External int. 11 */
+
+#endif /* End of __irqs_h */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/keyboard.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/keyboard.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/keyboard.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/keyboard.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/keyboard.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  just a cite from other architecture :)
+ */
+#ifndef __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H
+#define __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H
+
+#define kbd_setkeycode(sc,kc) (-EINVAL)
+#define kbd_getkeycode(sc) (-EINVAL)
+#define kbd_translate(sc,kcp,rm) ({ *(kcp) = (sc); 1; })
+#define kbd_unexpected_up(kc) (0200)
+#define kbd_leds(leds)
+#define kbd_init_hw()
+#define kbd_enable_irq()
+#define kbd_disable_irq()
+
+#endif /* __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/memory.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/memory.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/memory.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/memory.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,25 @@
+/*
+ * linux/include/asm-arm/arch-s3c3410/memory.h
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *		Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x01a00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((void *) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((void *) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/param.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/param.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/param.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/s3c3410.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/s3c3410.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/s3c3410.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/s3c3410.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,384 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/s3c3410.h
+ *
+ * Special function registers of the Samsung S3C3410X
+ *
+ * (C) 2003 sympat GmbH
+ * by Thomas Eschenbacher <thomas.eschenbacher@sympat.de>
+ *
+ */
+
+#ifndef __ASM_ARCH_S3C3410_H
+#define __ASM_ARCH_S3C3410_H
+
+#define S3C3410_MEM_SIZE     (CONFIG_DRAM_SIZE) 
+#define MEM_SIZE            S3C3410_MEM_SIZE
+#define PA_SDRAM_BASE         CONFIG_DRAM_BASE
+
+/* Address offset for accessing external memory uncached (A27=1) */
+#define S3C3410X_UNCACHED        0x08000000             /* (1 << 27) */
+
+/*
+ * SFR Base Address
+ */
+#define S3C3410X_BASE            0x07FF0000
+
+/* ************************ */
+/* System Manager Registers */
+/* ************************ */
+#define S3C3410X_SYSCFG          (S3C3410X_BASE+0x1000) /* System Configuration */
+
+#define S3C3410X_SYSCFG_ST       0x00000001		/* Stall enable */
+#define S3C3410X_SYSCFG_CE       0x00000002		/* Cache enable*/
+#define S3C3410X_SYSCFG_WE       0x00000004		/* Write Buffer enable */
+#define S3C3410X_SYSCFG_SFRSA    0x00007FF0		/* SYSCFG Address (SFR Start Address) */
+
+#define S3C3410X_SYSCFG_CM_MASK  0x00018000		/* Cache Mode (MASK) */
+#define S3C3410X_SYSCFG_CM_22    0x00000000		/* (Cache Mode) 2k Cache / 2k SRAM */
+#define S3C3410X_SYSCFG_CM_CACHE 0x00008000		/* (Cache Mode) 4k Cache */
+#define S3C3410X_SYSCFG_CM_SRAM  0x00010000		/* (Cache Mode) 4k SRAM */
+
+#define S3C3410X_SYSCFG_AME      0x00020000		/* Address Mux Enable */
+#define S3C3410X_SYSCFG_MT0_RFS  0x00000000		/* Memory Type 0 ROM/Flash/SRAM */
+#define S3C3410X_SYSCFG_MT0_FP   0x00040000		/* Memory Type 0 FP DRAM */
+#define S3C3410X_SYSCFG_MT0_EDO  0x00080000		/* Memory Type 0 EDO DRAM */
+#define S3C3410X_SYSCFG_MT0_SD   0x000C0000		/* Memory Type 0 Sync. DRAM */
+#define S3C3410X_SYSCFG_MT1_RFS  0x00000000		/* Memory Type 1 ROM/Flash/SRAM */
+#define S3C3410X_SYSCFG_MT1_FP   0x00100000		/* Memory Type 1 FP DRAM */
+#define S3C3410X_SYSCFG_MT1_EDO  0x00200000		/* Memory Type 1 EDO DRAM */
+#define S3C3410X_SYSCFG_MT1_SD   0x00300000		/* Memory Type 1 Sync. DRAM */
+
+#define S3C3410X_BANKCON0	(S3C3410X_BASE+0x2000) /* Memory Bank 0 Control */
+#define S3C3410X_BANKCON1	(S3C3410X_BASE+0x2004) /* Memory Bank 1 Control */
+#define S3C3410X_BANKCON2	(S3C3410X_BASE+0x2008) /* Memory Bank 2 Control */
+#define S3C3410X_BANKCON3	(S3C3410X_BASE+0x200C) /* Memory Bank 3 Control */
+#define S3C3410X_BANKCON4	(S3C3410X_BASE+0x2010) /* Memory Bank 4 Control */
+#define S3C3410X_BANKCON5	(S3C3410X_BASE+0x2014) /* Memory Bank 5 Control */
+#define S3C3410X_BANKCON6	(S3C3410X_BASE+0x2018) /* Memory Bank 6 Control */
+#define S3C3410X_BANKCON7	(S3C3410X_BASE+0x201C) /* Memory Bank 7 Controlr */
+
+#define S3C3410X_BANKCON_DBW	    0x00000001 	    	/* Data Bus Width (16Bit enable) else 8Bit */
+#define S3C3410X_BANKCON_PMC_1D	    0x00000000 	    	/* Page Mode 1Data */
+#define S3C3410X_BANKCON_PMC_4D	    0x00000002 	    	/* Page Mode 4Data */
+#define S3C3410X_BANKCON_PMC_8D	    0x00000004 	    	/* Page Mode 8Data */
+#define S3C3410X_BANKCON_PMC_16D    0x00000006 	    	/* Page Mode 16Data */
+#define S3C3410X_BANKCON_SM	    0x00000008 	    	/* UB/LB Byte selection enable (see nWE,WE in Chipdesign) */
+#define S3C3410X_BANKCON_TACC_DIS   0x00000000 	    	/* Access Cycle Timing Disabled */
+#define S3C3410X_BANKCON_TACC_2C    0x00000010 	    	/* Access Cycle Timing 2Clocks */
+#define S3C3410X_BANKCON_TACC_3C    0x00000020 	    	/* Access Cycle Timing 3Clocks */
+#define S3C3410X_BANKCON_TACC_4C    0x00000030 	    	/* Access Cycle Timing 4Clocks */
+#define S3C3410X_BANKCON_TACC_5C    0x00000040 	    	/* Access Cycle Timing 5Clocks */
+#define S3C3410X_BANKCON_TACC_6C    0x00000050 	    	/* Access Cycle Timing 6Clocks */
+#define S3C3410X_BANKCON_TACC_7C    0x00000060 	    	/* Access Cycle Timing 7Clocks */
+#define S3C3410X_BANKCON_TACC_10C   0x00000070 	    	/* Access Cycle Timing 10Clocks */
+#define S3C3410X_BANKCON_TACP_2C    0x00000080 	    	/* Page Mode Access Cycle Timing 2Clocks */
+#define S3C3410X_BANKCON_TACP_3C    0x00000100 	    	/* Page Mode Access Cycle Timing 3Clocks */
+#define S3C3410X_BANKCON_TACP_4C    0x00000180 	    	/* Page Mode Access Cycle Timing 4Clocks */
+#define S3C3410X_BANKCON_TACP_5C    0x00000000 	    	/* Page Mode Access Cycle Timing 5Clocks */
+
+#define S3C3410X_REFCON  	(S3C3410X_BASE+0x2020) /* DRAM Refresh Control */
+
+#define S3C3410X_EXTCON0 	(S3C3410X_BASE+0x2030) /* Extra device control 0 */
+#define S3C3410X_EXTCON1 	(S3C3410X_BASE+0x2034) /* Extra device control 1 */
+#define S3C3410X_EXTPORT 	(S3C3410X_BASE+0x203E) /* External port data */
+
+#define S3C3410X_EXTDAT0 	(S3C3410X_BASE+0x202C) /* Extra chip selection data 0 */
+#define S3C3410X_EXTDAT1 	(S3C3410X_BASE+0x202E) /* Extra chip selection data 1 */
+
+/* ************* */
+/* DMA Registers */
+/* ************* */
+#define S3C3410X_DMACON0 	(S3C3410X_BASE+0x300C) /* DMA 0 control */
+#define S3C3410X_DMASRC0 	(S3C3410X_BASE+0x3000) /* DMA 0 source address */
+#define S3C3410X_DMADST0 	(S3C3410X_BASE+0x3004) /* DMA 0 destination address */
+#define S3C3410X_DMACNT0 	(S3C3410X_BASE+0x3008) /* DMA 0 transfer count */
+
+#define S3C3410X_DMACON1 	(S3C3410X_BASE+0x400C) /* DMA 1 control */
+#define S3C3410X_DMASRC1 	(S3C3410X_BASE+0x4000) /* DMA 1 source address */
+#define S3C3410X_DMADST1 	(S3C3410X_BASE+0x4004) /* DMA 1 destination address */
+#define S3C3410X_DMACNT1 	(S3C3410X_BASE+0x4008) /* DMA 1 transfer count */
+
+/* ******************* */
+/* I/O Ports Registers */
+/* ******************* */
+#define S3C3410X_PDAT0   	(S3C3410X_BASE+0xB000) /* Port 0 data */
+#define S3C3410X_PDAT1   	(S3C3410X_BASE+0xB001) /* Port 1 data */
+#define S3C3410X_PDAT2   	(S3C3410X_BASE+0xB002) /* Port 2 data */
+#define S3C3410X_PDAT3   	(S3C3410X_BASE+0xB003) /* Port 3 data */
+#define S3C3410X_PDAT4   	(S3C3410X_BASE+0xB004) /* Port 4 data */
+#define S3C3410X_PDAT5   	(S3C3410X_BASE+0xB005) /* Port 5 data */
+#define S3C3410X_PDAT6   	(S3C3410X_BASE+0xB006) /* Port 6 data */
+#define S3C3410X_PDAT7   	(S3C3410X_BASE+0xB007) /* Port 7 data */
+#define S3C3410X_PDAT8   	(S3C3410X_BASE+0xB008) /* Port 8 data */
+#define S3C3410X_PDAT9   	(S3C3410X_BASE+0xB009) /* Port 9 data */
+
+#define S3C3410X_P7BR    	(S3C3410X_BASE+0xB00B) /* Port 7 buffer */
+
+#define S3C3410X_PCON0   	(S3C3410X_BASE+0xB010) /* Port 0 control */
+#define S3C3410X_PCON1   	(S3C3410X_BASE+0xB012) /* Port 1 control */
+#define S3C3410X_PCON2   	(S3C3410X_BASE+0xB014) /* Port 2 control */
+#define S3C3410X_PCON3   	(S3C3410X_BASE+0xB016) /* Port 3 control */
+#define S3C3410X_PCON4   	(S3C3410X_BASE+0xB018) /* Port 4 control */
+#define S3C3410X_PCON5   	(S3C3410X_BASE+0xB01C) /* Port 5 control */
+#define S3C3410X_PCON6   	(S3C3410X_BASE+0xB020) /* Port 6 control */
+#define S3C3410X_PCON7   	(S3C3410X_BASE+0xB024) /* Port 7 control */
+#define S3C3410X_PCON8   	(S3C3410X_BASE+0xB026) /* Port 8 control */
+#define S3C3410X_PCON9   	(S3C3410X_BASE+0xB027) /* Port 9 control */
+
+#define S3C3410X_PUR0    	(S3C3410X_BASE+0xB028) /* Port 0 pull-up control */
+#define S3C3410X_PDR1    	(S3C3410X_BASE+0xB029) /* Port 1 pull-down control */
+#define S3C3410X_PUR2    	(S3C3410X_BASE+0xB02A) /* Port 2 pull-up control */
+#define S3C3410X_PUR3    	(S3C3410X_BASE+0xB02B) /* Port 3 pull-up control */
+#define S3C3410X_PDR4    	(S3C3410X_BASE+0xB02C) /* Port 4 pull-down control */
+#define S3C3410X_PUR5    	(S3C3410X_BASE+0xB02D) /* Port 5 pull-up control */
+#define S3C3410X_PUR6    	(S3C3410X_BASE+0xB02E) /* Port 6 pull-up control */
+#define S3C3410X_PUR7    	(S3C3410X_BASE+0xB02F) /* Port 7 pull-up control */
+#define S3C3410X_PUR8    	(S3C3410X_BASE+0xB03C) /* Port 8 pull-up control */
+
+#define S3C3410X_EINTPND  	(S3C3410X_BASE+0xB031) /* External interrupt pending */
+#define S3C3410X_EINTCON  	(S3C3410X_BASE+0xB032) /* External interrupt control */
+#define S3C3410X_EINTMOD  	(S3C3410X_BASE+0xB034) /* External interrupt mode */
+
+/* *************** */
+/* Timer Registers */
+/* *************** */
+
+#define S3C3410X_TDAT0   	(S3C3410X_BASE+0x9000) /* Timer 0 data */
+#define S3C3410X_TPRE0   	(S3C3410X_BASE+0x9002) /* Timer 0 prescaler */
+#define S3C3410X_TCON0   	(S3C3410X_BASE+0x9003) /* Timer 0 control */
+#define S3C3410X_TCNT0   	(S3C3410X_BASE+0x9006) /* Timer 0 counter */
+
+#define S3C3410X_T16_ICS	0x00000004	/* 16Bit-Timer Input Select */
+#define S3C3410X_T16_OMS_MODE	0x00000038	/* 16Bit-Timer Mode bits */
+#define S3C3410X_T16_OMS_INTRV	0x00000000	/* 16Bit-Timer Mode (interval mode) */
+#define S3C3410X_T16_OMS_MAOF	0x00000008	/* 16Bit-Timer Mode (match & overflow mode) */
+#define S3C3410X_T16_OMS_MAD	0x00000010	/* 16Bit-Timer Mode (match & DMA mode) */
+#define S3C3410X_T16_OMS_CAPF	0x00000020	/* 16Bit-Timer Mode (capture on falling edge of TCAP 0,1,2) */
+#define S3C3410X_T16_OMS_CAPR	0x00000028	/* 16Bit-Timer Mode (capture on rising edge of TCAP 0,1,2) */
+#define S3C3410X_T16_OMS_CAPRF	0x00000030	/* 16Bit-Timer Mode (capture on rising/falling edge of TCAP 0,1,2) */
+#define S3C3410X_T16_CL		0x00000040	/* 16Bit-Timer Clear */
+#define S3C3410X_T16_TEN	0x00000080	/* 16Bit-Timer Enable */
+
+#define S3C3410X_TDAT1   	(S3C3410X_BASE+0x9010) /* Timer 1 data */
+#define S3C3410X_TPRE1   	(S3C3410X_BASE+0x9012) /* Timer 1 prescaler */
+#define S3C3410X_TCON1   	(S3C3410X_BASE+0x9013) /* Timer 1 control */
+#define S3C3410X_TCNT1   	(S3C3410X_BASE+0x9016) /* Timer 1 counter */
+
+#define S3C3410X_TDAT2   	(S3C3410X_BASE+0x9020) /* Timer 2 data */
+#define S3C3410X_TPRE2   	(S3C3410X_BASE+0x9022) /* Timer 2 prescaler */
+#define S3C3410X_TCON2   	(S3C3410X_BASE+0x9023) /* Timer 2 control */
+#define S3C3410X_TCNT2   	(S3C3410X_BASE+0x9026) /* Timer 2 counter */
+
+#define S3C3410X_TDAT3   	(S3C3410X_BASE+0x9030) /* Timer 3 data */
+#define S3C3410X_TPRE3   	(S3C3410X_BASE+0x9032) /* Timer 3 prescaler */
+#define S3C3410X_TCON3   	(S3C3410X_BASE+0x9033) /* Timer 3 control */
+#define S3C3410X_TCNT3   	(S3C3410X_BASE+0x9037) /* Timer 3 counter */
+
+#define S3C3410X_TDAT4   	(S3C3410X_BASE+0x9041) /* Timer 4 data */
+#define S3C3410X_TPRE4   	(S3C3410X_BASE+0x9042) /* Timer 4 prescaler */
+#define S3C3410X_TCON4   	(S3C3410X_BASE+0x9043) /* Timer 4 control */
+#define S3C3410X_TCNT4   	(S3C3410X_BASE+0x9047) /* Timer 4 counter */
+#define S3C3410X_TFCON   	(S3C3410X_BASE+0x904F) /* Timer 4 FIFO control */
+#define S3C3410X_TFSTAT  	(S3C3410X_BASE+0x904E) /* Timer 4 FIFO status */
+#define S3C3410X_TFB4    	(S3C3410X_BASE+0x904B) /* Timer 4 FIFO @ byte */
+#define S3C3410X_TFHW4   	(S3C3410X_BASE+0x904A) /* Timer 4 FIFO @ half-word */
+#define S3C3410X_TFW4    	(S3C3410X_BASE+0x9048) /* Timer 4 FIFO @ word */
+
+/* #define TDATA0	TDAT0
+   #define TMOD 	TCON0 */
+
+/* ************** */
+/* UART Registers */
+/* ************** */
+
+#define S3C3410X_UART_BASE	(S3C3410X_BASE) /* "virtual" start of UART registers */
+
+#define S3C3410X_ULCON   	(0x5003) /* UART line control */
+#define S3C3410X_UCON    	(0x5007) /* UART control */
+#define S3C3410X_USTAT   	(0x500B) /* UART status */
+#define S3C3410X_UFCON   	(0x500F) /* UART FIFO control */
+#define S3C3410X_UFSTAT  	(0x5012) /* UART FIFO status */
+#define S3C3410X_UTXH    	(0x5017) /* UART transmit holding */
+#define S3C3410X_UTXH_B  	(0x5017) /* UART transmit FIFO @ byte */
+#define S3C3410X_UTXH_HW 	(0x5016) /* UART transmit FIFO @ half-word */
+#define S3C3410X_UTXH_W  	(0x5014) /* UART transmit FIFO @ word */
+#define S3C3410X_URXH    	(0x501B) /* UART receive holding */
+#define S3C3410X_URXH_B  	(0x501B) /* UART receive FIFO @ byte */
+#define S3C3410X_URXH_HW 	(0x501A) /* UART receive FIFO @ half-word */
+#define S3C3410X_URXH_W  	(0x5018) /* UART receive FIFO @ word */
+#define S3C3410X_UBRDIV  	(0x501E) /* baud rate divisor */
+
+/* UART Line Control Register Bits */
+#define ULCON_WL_MASK		0x03	/* UART Word Length Mask */
+#define ULCON_WL_5		0x00	/* UART Word Length: 5 bits */
+#define ULCON_WL_6		0x01	/* UART Word Length: 6 bits */
+#define ULCON_WL_7		0x02	/* UART Word Length: 7 bits */
+#define ULCON_WL_8		0x03	/* UART Word Length: 8 bits */
+#define ULCON_SB		0x04	/* UART Stop Bits */
+#define ULCON_PMD_MASK		0x38	/* UART Parity Mode Mask */
+#define ULCON_PMD_NONE		0x00	/* UART Parity Mode: None */
+#define ULCON_PMD_ODD		0x20	/* UART Parity Mode: Odd */
+#define ULCON_PMD_EVEN		0x28	/* UART Parity Mode: Even */
+#define ULCON_IRM		0x40	/* UART Infrared Mode */
+/* 				0x80	   unused */
+
+
+/* UART Control Register Bits */
+#define UCON_RM_MASK		0x03	/* UART Mask for Receive Mode */
+#define UCON_RM_DISABLED	0x00	/* UART Receive Mode 0 : Disabled */
+#define UCON_RM_IRQ_POLL	0x01	/* UART Receive Mode 1 : Interrupt or Polling Mode */
+#define UCON_RM_DMA0		0x02	/* UART Receive Mode 2 : DMA0 request */
+#define UCON_RM_DMA1		0x03	/* UART Receive Mode 3 : DMA1 request */
+
+#define UCON_TM_MASK		0x0C	/* UART Mask for Transmit Mode */
+#define UCON_TM_DISABLED	0x00	/* UART Transmit Mode 0 : Disabled */
+#define UCON_TM_IRQ_POLL	0x04	/* UART Transmit Mode 1 : Interrupt or Polling Mode */
+#define UCON_TM_DMA0		0x08	/* UART Transmit Mode 2 : DMA0 request */
+#define UCON_TM_DMA1		0x0C	/* UART Transmit Mode 3 : DMA1 request */
+
+#define UCON_SBS		0x10	/* UART Send Break Signal */
+#define UCON_LBM		0x20	/* UART Loopback Mode */
+#define UCON_RSIE		0x40	/* UART Rx Status Interrupt Enable */
+#define UCON_RXTOEL		0x80	/* UART Rx Timeout Enable */
+
+/* UART Status Register Bits */
+#define USTAT_OE 		0x01	/* UART Overrun Error */
+#define USTAT_PE 		0x02	/* UART Parity Error */
+#define USTAT_FE 		0x04	/* UART Framing Error */
+#define USTAT_BD 		0x08	/* UART Break Detect */
+#define USTAT_RTO 		0x10	/* UART Receiver Time Out */
+#define USTAT_RFDR 		0x20	/* UART Receive FIFO Data Ready / Rx Buffer Data Ready */
+#define USTAT_TFE 		0x40	/* UART Transmit FIFO Empty / Tx Holding Register Empty */
+#define USTAT_TSE 		0x80	/* UART Transmit Shift Register Empty */
+
+/* UART FIFO Control Register Bits */
+#define UFCON_FE		0x01	/* UART FIFO Enable */
+#define UFCON_RFR		0x02	/* UART Rx FIFO Reset */
+#define UFCON_TFR		0x04	/* UART Tx FIFO Reset */
+/*				0x08	   reserved */
+#define UFCON_RFTL_MASK		0x30	/* UART Receive FIFO Trigger Level Mask */
+#define UFCON_RFTL_2		0x00	/* UART Receive FIFO Trigger Level: 2 byte */
+#define UFCON_RFTL_4		0x10	/* UART Receive FIFO Trigger Level: 4 byte */
+#define UFCON_RFTL_6		0x20	/* UART Receive FIFO Trigger Level: 6 byte */
+#define UFCON_RFTL_8		0x30	/* UART Receive FIFO Trigger Level: 8 byte */
+
+#define UFCON_TFTL_MASK		0x30	/* UART Transmit FIFO Trigger Level Mask */
+#define UFCON_TFTL_0		0x00	/* UART Transmit FIFO Trigger Level: 0 byte */
+#define UFCON_TFTL_2		0x10	/* UART Transmit FIFO Trigger Level: 2 byte */
+#define UFCON_TFTL_4		0x20	/* UART Transmit FIFO Trigger Level: 4 byte */
+#define UFCON_TFTL_6		0x30	/* UART Transmit FIFO Trigger Level: 6 byte */
+
+#define UFSTAT_RFC_MASK		0x07    /* UART FIFO STATUS Rx FIFO count */
+#define UFSTAT_TFC_MASK		0x38    /* UART FIFO STATUS Rx FIFO count */
+#define UFSTAT_RFF		0x20	/* UART FIFO STATUS Receive FIFO FULL */
+#define UFSTAT_TFF		0x40	/* UART FIFO STATUS Transmit FIFO FULL */
+#define UFSTAT_EIF		0x80	/* UART FIFO STATUS Error in FIFO */
+
+
+/* *********** */
+/* SIO 0 and 1 */
+/* *********** */
+
+#define S3C3410X_ITVCNT0  	(S3C3410X_BASE+0x6000) /* SIO 0 interval counter */
+#define S3C3410X_SBRDR0   	(S3C3410X_BASE+0x6001) /* SIO 0 baud rate prescaler */
+#define S3C3410X_SIODAT0  	(S3C3410X_BASE+0x6002) /* SIO 0 data */
+#define S3C3410X_SIOCON0  	(S3C3410X_BASE+0x6003) /* SIO 0 control */
+
+#define S3C3410X_ITVCNT1  	(S3C3410X_BASE+0x7000) /* SIO 1 interval counter */
+#define S3C3410X_SBRDR1   	(S3C3410X_BASE+0x7001) /* SIO 1 baud rate prescaler */
+#define S3C3410X_SIODAT1  	(S3C3410X_BASE+0x7002) /* SIO 1 data */
+#define S3C3410X_SIOCON1  	(S3C3410X_BASE+0x7003) /* SIO 1 control */
+
+/* ****************************** */
+/* Interrupt Controller Registers */
+/* ****************************** */
+
+#define S3C3410X_INTMOD		(S3C3410X_BASE+0xC000) /* Interrupt mode */
+#define S3C3410X_INTPND		(S3C3410X_BASE+0xC004) /* Interrupt pending */
+#define S3C3410X_INTMSK		(S3C3410X_BASE+0xC008) /* Interrupt mask */
+
+#define S3C3410X_INTPRI0	(S3C3410X_BASE+0xC00C) /* Interrupt priority 0 */
+#define S3C3410X_INTPRI1	(S3C3410X_BASE+0xC010) /* Interrupt priority 1 */
+#define S3C3410X_INTPRI2	(S3C3410X_BASE+0xC014) /* Interrupt priority 2 */
+#define S3C3410X_INTPRI3	(S3C3410X_BASE+0xC018) /* Interrupt priority 3 */
+#define S3C3410X_INTPRI4	(S3C3410X_BASE+0xC01C) /* Interrupt priority 4 */
+#define S3C3410X_INTPRI5	(S3C3410X_BASE+0xC020) /* Interrupt priority 5 */
+#define S3C3410X_INTPRI6	(S3C3410X_BASE+0xC024) /* Interrupt priority 6 */
+#define S3C3410X_INTPRI7	(S3C3410X_BASE+0xC028) /* Interrupt priority 7 */
+
+/* *** */
+/* ADC */
+/* *** */
+
+#define S3C3410X_ADCCON   	(S3C3410X_BASE+0x8002) /* A/D Converter control */
+#define S3C3410X_ADCDAT   	(S3C3410X_BASE+0x8006) /* A/D Converter data */
+
+/* *********** */
+/* Basic Timer */
+/* *********** */
+
+#define S3C3410X_BTCON    	(S3C3410X_BASE+0xA002)	/* Basic Timer control */
+#define S3C3410X_BTCON_WDTC     0x00000001		/* Watchdog Timer Clear */
+#define S3C3410X_BTCON_BTC      0x00000002		/* Basic Timer Clear */
+#define S3C3410X_BTCON_CS_13	0x00000000		/* Watchdog Clock source Fin / 2^13 */
+#define S3C3410X_BTCON_CS_12	0x00000040		/* Watchdog Clock source Fin / 2^12 */
+#define S3C3410X_BTCON_CS_11	0x00000080		/* Watchdog Clock source Fin / 2^11 */
+#define S3C3410X_BTCON_CS_9	0x000000C0		/* Watchdog Clock source Fin / 2^9 */
+
+/* When this value is written into BTCON it will disable the Timer. Any other value will enable it. */
+#define S3C3410X_BTCON_WDTD     0x0000A500		/* Watchdog Timer Disable */
+#define S3C3410X_BTCON_WDTE     0x0000FF00		/* Watchdog Timer Enable */
+
+#define S3C3410X_BTCNT   	(S3C3410X_BASE+0xA007)	/* Basic Timer count */
+
+/* ***************** */
+/* I2C Bus Registers */
+/* ***************** */
+
+#define S3C3410X_IICCON   	(S3C3410X_BASE+0xE000) /* IIC-bus control */
+#define S3C3410X_IICSTAT   	(S3C3410X_BASE+0xE001) /* IIC-bus status */
+#define S3C3410X_IICDS    	(S3C3410X_BASE+0xE002) /* IIC-bus tx/rx data shift reg. */
+#define S3C3410X_IICADD   	(S3C3410X_BASE+0xE003) /* IIC-bus tx/rx address */
+#define S3C3410X_IICPC    	(S3C3410X_BASE+0xE004) /* IIC-bus Prescaler */
+#define S3C3410X_IICPCNT  	(S3C3410X_BASE+0xE005) /* IIC-bus Prescaler counter */
+
+/* *********************** */
+/* System control register */
+/* *********************** */
+
+#define S3C3410X_SYSCON   	(S3C3410X_BASE+0xD003) /* System control */
+
+#define S3C3410X_SYSCON_STOP      0x00000001 /* STOP-Mode */
+#define S3C3410X_SYSCON_IDLE      0x00000002 /* IDLE-Mode */
+#define S3C3410X_SYSCON_DMAIDLE   0x00000004 /* DMA-IDLE-Mode */
+#define S3C3410X_SYSCON_MCLK16    0x00000000 /* system clock = MCLOCK / 16 */
+#define S3C3410X_SYSCON_MCLK2     0x00000010 /* system clock = MCLOCK / 2 */
+#define S3C3410X_SYSCON_MCLK1024  0x00000020 /* system clock = MCLOCK / 1024 */
+#define S3C3410X_SYSCON_MCLK8     0x00000008 /* system clock = MCLOCK / 8 */
+#define S3C3410X_SYSCON_MCLK      0x00000018 /* system clock = MCLOCK */
+#define S3C3410X_SYSCON_GIE       0x00000040 /* Global Interrupt Enable (set when enabled !!) */
+
+/* ************** */
+/* Realtime Clock */
+/* ************** */
+
+#define S3C3410X_RTCCON   	(S3C3410X_BASE+0xA013) /* RTC control */
+#define S3C3410X_RTCALM   	(S3C3410X_BASE+0xA012) /* RTC alarm control */
+#define S3C3410X_ALMSEC   	(S3C3410X_BASE+0xA033) /* Alarm second */
+#define S3C3410X_ALMMIN    	(S3C3410X_BASE+0xA032) /* Alarm minute */
+#define S3C3410X_ALMHOUR    	(S3C3410X_BASE+0xA031) /* Alarm hour */
+#define S3C3410X_ALMDAY   	(S3C3410X_BASE+0xA037) /* Alarm day */
+#define S3C3410X_ALMMON   	(S3C3410X_BASE+0xA036) /* Alarm month */
+#define S3C3410X_ALMYEAR   	(S3C3410X_BASE+0xA035) /* Alarm year */
+#define S3C3410X_BCDSEC   	(S3C3410X_BASE+0xA023) /* BCD second */
+#define S3C3410X_BCDMIN   	(S3C3410X_BASE+0xA022) /* BCD minute */
+#define S3C3410X_BCDHOUR   	(S3C3410X_BASE+0xA021) /* BCD hour */
+#define S3C3410X_BCDDAY   	(S3C3410X_BASE+0xA027) /* BCD day */
+#define S3C3410X_BCDDATE   	(S3C3410X_BASE+0xA020) /* BCD date */
+#define S3C3410X_BCDMON   	(S3C3410X_BASE+0xA026) /* BCD month */
+#define S3C3410X_BCDYEAR   	(S3C3410X_BASE+0xA025) /* BCD year */
+
+#define S3C3410X_RINTPND   	(S3C3410X_BASE+0xA010) /* RTC time interrupt pending */
+#define S3C3410X_RINTCON   	(S3C3410X_BASE+0xA011) /* RTC time interrupt control */
+
+#endif /* __ASM_ARCH_S3C3410_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/sizes.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/sizes.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/sizes.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/sizes.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/system.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/system.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/system.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,29 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/system.h
+ *
+ *  Copyright (C) 2002 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+ 	/* machine should reboot */
+ 	mdelay(5000);
+ 	panic("Watchdog timer reset failed!\n");
+ 	printk(" Jump to address 0 \n");
+ 	cpu_reset(0);
+}
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/time.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/time.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/time.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,23 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/time.h
+ *
+ * 2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ * modifed by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * Setup for 16 bit timer 0, used as system timer.
+ *
+ */
+
+#ifndef __ASM_ARCH_TIME_H__
+#define __ASM_ARCH_TIME_H__
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/timex.h>
+
+#define CLOCKS_PER_USEC	(CONFIG_ARM_CLK/1000000)
+
+#define S3C3410X_TIMER0_PRESCALER 100
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/timex.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/timex.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/timex.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/timex.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                           Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#define CLOCK_TICK_RATE (CONFIG_ARM_CLK)
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/vmalloc.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/vmalloc.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c3410/vmalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c3410/vmalloc.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King. 
+ *  modified by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_S3C3410_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_S3C3410_SDRAM_SIZE)   
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/dma.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/dma.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/dma.h	2005-11-08 09:06:39.000000000 +0900
@@ -0,0 +1,20 @@
+/*
+ * linux/include/asm-armnommu/arch-s3c44b0x/dma.h
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_S3C44B0X_ARCH_DMA_H
+#define __ASM_S3C44B0X_ARCH_DMA_H
+
+// TODO: include dma support
+
+#define MAX_DMA_ADDRESS		0x0D000000
+
+#define MAX_DMA_CHANNELS	0
+#define MAX_DMA_TRANSFER_SIZE   0x100000 
+
+#endif /* _ASM_S3C44B0X_ARCH_DMA_H */
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/entry-macro.S linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/entry-macro.S
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/entry-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/entry-macro.S	2005-11-08 09:06:40.000000000 +0900
@@ -0,0 +1,31 @@
+/*
+ *  arch/armnommu/mach-s3c44b0x/entry-macro.S
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ */
+
+#ifndef CONFIG_ARCH_S3C44B0
+#error
+#endif
+                .macro  disable_fiq
+		/* FIXME */
+                .endm
+
+		.macro get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr     \base, =S3C44B0X_I_ISPR
+		ldr     \base, [\base]
+		mov     \irqnr, #0
+2222:           
+		tst     \base, #1 
+		bne     1111f
+		add     \irqnr, \irqnr, #1      
+		mov     \base, \base, lsr #1
+		cmp     \irqnr, #NR_IRQS
+		bcc     2222b
+1111:           
+		.endm
+
+		.macro irq_prio_table
+		/* FIXME */
+		.endm
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/hardware.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/hardware.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/hardware.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/hardware.h	2005-11-08 09:06:39.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-arm/arch-s3c44b0x/hardware.h
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+#include <asm/arch/s3c44b0x.h>
+
+#ifndef __ASSEMBLY__
+
+#define HARD_RESET_NOW()
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(1)
+
+#endif
+
+#define MEM_SIZE	CONFIG_DRAM_SIZE
+#define PA_SDRAM_BASE	CONFIG_DRAM_BASE
+
+/* The default system speed this box runs */
+#if	!defined(CONFIG_ARM_CLK)
+#define	CONFIG_ARM_CLK	60000000
+#endif
+
+#if	!defined(CONFIG_ARM_CLK_FIN) 
+#define	CONFIG_ARM_CLK_FIN	8000000
+#endif
+
+#endif  /*   END OF __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/io.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/io.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/io.h	2005-11-08 09:06:39.000000000 +0900
@@ -0,0 +1,63 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/io.h
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+/*
+ * We have the this routine to use usb host device driver
+ */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a)			(PCI_IO_VADDR + (a))
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(PCI_MEMORY_VADDR + (unsigned long)(a))
+
+
+/*
+ * These macros were copied from arch/armnommu/io.h and are used instead
+ * of the definitions found there, because we want to do 16/32 bit i/o
+ * without byte swapping.
+ * --the
+ */
+
+#undef __io
+
+#ifndef __iob
+  #define __iob(a) __io(a)
+#endif
+
+#define outb(v,p)       __raw_writeb(v, p)
+#define outw(v,p)       __raw_writew(v, p)
+#define outl(v,p)       __raw_writel(v, p)
+
+#define inb(p)          ({ unsigned int __v = __raw_readb(p); __v; })
+#define inw(p)          ({ unsigned int __v = __raw_readw(p); __v; })
+#define inl(p)          ({ unsigned int __v = __raw_readl(p); __v; })
+
+#define outsb(p,d,l)    __raw_writesb(p, d, l)
+#define outsw(p,d,l)    __raw_writesw(p, d, l)
+#define outsl(p,d,l)    __raw_writesl(p, d, l)
+
+#define insb(p,d,l)     __raw_readsb(p, d, l)
+#define insw(p,d,l)     __raw_readsw(p, d, l)
+#define insl(p,d,l)     __raw_readsl(p, d, l)
+
+/*
+ * Validate the pci memory address for ioremap.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ */
+#define iomem_to_phys(iomem)	(iomem)
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/irq.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/irq.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/irq.h	2005-11-08 09:06:39.000000000 +0900
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/irq.h
+ */
+#ifndef __S3C3410_irq_h
+#define __S3C3410_irq_h
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+extern unsigned  int fixup_irq(int i);
+
+extern void do_IRQ(int irq, struct pt_regs *regs);
+
+extern void s3c3410_init_irq(void);
+
+#define 	irq_init_irq 	s3c3410_init_irq
+
+#endif 
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/irqs.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/irqs.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/irqs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/irqs.h	2005-11-08 09:06:40.000000000 +0900
@@ -0,0 +1,37 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c44b0x/irqs.h
+ */
+
+#ifndef _S3C44B0X_IRQS_H
+#define _S3C44B0X_IRQS_H                        1
+
+#define NR_IRQS	26
+
+#define S3C44B0X_INTERRUPT_EINT0      25      /* External int. 0 */
+#define S3C44B0X_INTERRUPT_EINT1      24      /* External int. 1 */
+#define S3C44B0X_INTERRUPT_EINT2      23      /* External int. 2 */
+#define S3C44B0X_INTERRUPT_EINT3      22      /* External int. 3 */
+#define S3C44B0X_INTERRUPT_EINT4567   21      /* External int. 4,5,6 and 7 */
+#define S3C44B0X_INTERRUPT_TICK       20      /* Clock Tick int. */
+#define S3C44B0X_INTERRUPT_ZDMA0      19      /* ZDMA 0 */
+#define S3C44B0X_INTERRUPT_ZDMA1      18      /* ZDMA 1 */
+#define S3C44B0X_INTERRUPT_BDMA0      17      /* BDMA 0 */
+#define S3C44B0X_INTERRUPT_BDMA1      16      /* BDMA 1 */
+#define S3C44B0X_INTERRUPT_WDT        15      /* Watchdog timer */
+#define S3C44B0X_INTERRUPT_UERR       14      /* UART error */
+#define S3C44B0X_INTERRUPT_TIMER0     13      /* Timer 0 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER1     12      /* Timer 1 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER2     11      /* Timer 2 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER3     10      /* Timer 3 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER4      9      /* Timer 4 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER5      8      /* Timer 5 zero-crossing */
+#define S3C44B0X_INTERRUPT_URX0        7      /* UART0 receive */
+#define S3C44B0X_INTERRUPT_URX1        6      /* UART1 receive */
+#define S3C44B0X_INTERRUPT_IIC         5      /* IIC */
+#define S3C44B0X_INTERRUPT_SIO         4      /* SIO */
+#define S3C44B0X_INTERRUPT_UTX0        3      /* UART0 transmit */
+#define S3C44B0X_INTERRUPT_UTX1        2      /* UART1 transmit */
+#define S3C44B0X_INTERRUPT_RTCT        1      /* RTC time */
+#define S3C44B0X_INTERRUPT_ADC         0      /* ADC interrupt */
+
+#endif /* End of _S3C44B0X_IRQS_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/keyboard.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/keyboard.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/keyboard.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/keyboard.h	2005-11-08 09:06:40.000000000 +0900
@@ -0,0 +1,16 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/keyboard.h
+ */
+#ifndef __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H
+#define __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H
+
+#define kbd_setkeycode(sc,kc) (-EINVAL)
+#define kbd_getkeycode(sc) (-EINVAL)
+#define kbd_translate(sc,kcp,rm) ({ *(kcp) = (sc); 1; })
+#define kbd_unexpected_up(kc) (0200)
+#define kbd_leds(leds)
+#define kbd_init_hw()
+#define kbd_enable_irq()
+#define kbd_disable_irq()
+
+#endif /* __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/memory.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/memory.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/memory.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/memory.h	2005-11-08 09:06:40.000000000 +0900
@@ -0,0 +1,24 @@
+/*
+ * linux/include/asm-arm/arch-s3c3410/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x0cc00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((void *) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((void *) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/param.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/param.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/param.h	2005-11-08 09:06:40.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/s3c44b0x.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/s3c44b0x.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/s3c44b0x.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/s3c44b0x.h	2005-11-08 09:06:40.000000000 +0900
@@ -0,0 +1,704 @@
+#ifndef _S3C44B0X_H_
+#define _S3C44B0X_H_
+
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+#include <asm/io.h>
+
+/* macros defined to easy the operation of system registers */
+#define SYSREG_GET(r)			inl(r)
+#define SYSREG_SET(r, v)		outl((v), r)
+#define SYSREG_AND_SET(r, v)		outl(SYSREG_GET(r) & (v), r)
+#define SYSREG_OR_SET(r, v)		outl(SYSREG_GET(r) | (v), r)
+#define SYSREG_CLR(r, v)		SYSREG_AND_SET(r, ~(v))
+
+#define SYSREG_GETB(r)			inb(r)
+#define SYSREG_SETB(r, v)		outb((v), r)
+#define SYSREG_AND_SETB(r, v)		outb(SYSREG_GETB(r) & (v), r)
+#define SYSREG_OR_SETB(r, v)		outb(SYSREG_GETB(r) | (v), r)
+#define SYSREG_CLRB(r, v)		SYSREG_AND_SETB(r, ~(v))
+
+#define SYSREG_GETW(r)			inw(r)
+#define SYSREG_SETW(r, v)		outw((v), r)
+#define SYSREG_AND_SETW(r, v)		outw(SYSREG_GETW(r) & (v), r)
+#define SYSREG_OR_SETW(r, v)		outw(SYSREG_GETW(r) | (v), r)
+#define SYSREG_CLRW(r, v)		SYSREG_AND_SETW(r, ~(v))
+
+#endif
+
+/**
+ * register definitions for SAMSUNG S3C44B0X
+ *
+ * Copyright (C) 2003 Christian Schulte <schulte@sympat.de>
+ *
+ */
+ 
+/*******************/
+/*** CPU WRAPPER ***/
+/*******************/
+
+#define S3C44B0X_SYSCFG			0x01c00000
+#define S3C44B0X_NCACHBE0		0x01c00004 /* configuration of non-cachable areas */
+#define S3C44B0X_NCACHBE1		0x01c00008 /* configuration of non-cachable areas */
+#define S3C44B0X_SBUSCON		0x01c40000 /* bus configuration */
+
+/* SYSCFG */
+#define S3C44B0X_SYSCFG_DA		0x00000020 /* Data Abort disable */
+#define S3C44B0X_SYSCFG_RSE		0x00000010 /* Read Stall Option enable */
+#define S3C44B0X_SYSCFG_WE		0x00000008 /* Write Buffer enable */
+
+#define S3C44B0X_SYSCFG_CM_NONE		0x00000000 /* Cache Mode */
+#define S3C44B0X_SYSCFG_CM_4K		0x00000002
+#define S3C44B0X_SYSCFG_CM_8K		0x00000006
+
+#define S3C44B0X_SYSCFG_SE		0x00000001 /* Stall Option enable */
+
+/* SBUSCON */
+#define S3C44B0X_SBUSCON_FIX		0x80000000 /* use the fixed configuration that follows (instead of round-robin) */
+#define S3C44B0X_SBUSCON_S_LCD_DMA_1	0x00000000 /* read the bus priority of LCD-DMA */
+#define S3C44B0X_SBUSCON_S_LCD_DMA_2	0x00004000
+#define S3C44B0X_SBUSCON_S_LCD_DMA_3	0x00008000
+#define S3C44B0X_SBUSCON_S_LCD_DMA_4	0x0000c000
+#define S3C44B0X_SBUSCON_S_ZDMA_1	0x00000000 /* read the bus priority of Z DMA */
+#define S3C44B0X_SBUSCON_S_ZDMA_2	0x00001000
+#define S3C44B0X_SBUSCON_S_ZDMA_3	0x00002000
+#define S3C44B0X_SBUSCON_S_ZDMA_4	0x00003000
+#define S3C44B0X_SBUSCON_S_BDMA_1	0x00000000 /* read the bus priority of B DMA */
+#define S3C44B0X_SBUSCON_S_BDMA_2	0x00000400
+#define S3C44B0X_SBUSCON_S_BDMA_3	0x00000800
+#define S3C44B0X_SBUSCON_S_BDMA_4	0x00000c00
+#define S3C44B0X_SBUSCON_S_BREQ_1	0x00000000 /* read the bus priority of external BREAK REQUEST */
+#define S3C44B0X_SBUSCON_S_BREQ_2	0x00000100
+#define S3C44B0X_SBUSCON_S_BREQ_3	0x00000200
+#define S3C44B0X_SBUSCON_S_BREQ_4	0x00000300
+
+#define S3C44B0X_SBUSCON_LCD_DMA_1	0x00000000 /* set the bus priority of LCD-DMA */
+#define S3C44B0X_SBUSCON_LCD_DMA_2	0x00000040
+#define S3C44B0X_SBUSCON_LCD_DMA_3	0x00000080
+#define S3C44B0X_SBUSCON_LCD_DMA_4	0x000000c0
+#define S3C44B0X_SBUSCON_ZDMA_1		0x00000000 /* set the bus priority of Z DMA */
+#define S3C44B0X_SBUSCON_ZDMA_2		0x00000010
+#define S3C44B0X_SBUSCON_ZDMA_3		0x00000020
+#define S3C44B0X_SBUSCON_ZDMA_4		0x00000030
+#define S3C44B0X_SBUSCON_BDMA_1		0x00000000 /* set the bus priority of B DMA */
+#define S3C44B0X_SBUSCON_BDMA_2		0x00000004
+#define S3C44B0X_SBUSCON_BDMA_3		0x00000008
+#define S3C44B0X_SBUSCON_BDMA_4		0x0000000c
+#define S3C44B0X_SBUSCON_BREQ_1		0x00000000 /* set the bus priority of external BREAK REQUEST */
+#define S3C44B0X_SBUSCON_BREQ_2		0x00000001
+#define S3C44B0X_SBUSCON_BREQ_3		0x00000002
+#define S3C44B0X_SBUSCON_BREQ_4		0x00000003
+
+  /*************************/
+  /*** MEMORY CONTROLLER ***/
+  /*************************/
+
+#define S3C44B0X_BWSCON		0x01c80000 /* Bank size, width and type of memory */
+#define S3C44B0X_BANKCON0		0x01c80004 /* timing and page modes */
+#define S3C44B0X_BANKCON1		0x01c80008
+#define S3C44B0X_BANKCON2		0x01c8000c
+#define S3C44B0X_BANKCON3		0x01c80010
+#define S3C44B0X_BANKCON4		0x01c80014
+#define S3C44B0X_BANKCON5		0x01c80018
+#define S3C44B0X_BANKCON6		0x01c8001c
+#define S3C44B0X_BANKCON7		0x01c80020
+#define S3C44B0X_REFRESH		0x01c80024 /* refresh timing */
+#define S3C44B0X_BANKSIZE		0x01c80028 /* bank sizes 2,4,8,16,32 MB */
+#define S3C44B0X_MRSRB6			0x01c8002c /* burst settings, CAS latency */
+#define S3C44B0X_MRSRB7			0x01c80030
+
+/* BWSCON */
+#define S3C44B0X_BWSCON_ST7		0x80000000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS7		0x40000000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW7_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW7_16		0x10000000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW7_32		0x20000000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST6		0x08000000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS6		0x04000000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW6_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW6_16		0x01000000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW6_32		0x02000000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST5		0x00800000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS5		0x00400000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW5_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW5_16		0x00100000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW5_32		0x00200000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST4		0x00080000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS4		0x00040000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW4_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW4_16		0x00010000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW4_32		0x00020000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST3		0x00008000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS3		0x00004000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW3_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW3_16		0x00001000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW3_32		0x00002000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST2		0x00000800 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS2		0x00000400 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW2_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW2_16		0x00000100 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW2_32		0x00000200 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST1		0x00000080 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS1		0x00000040 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW1_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW1_16		0x00000010 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW1_32		0x00000020 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_DW0_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW0_16		0x00000002 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW0_32		0x00000004 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ENDIAN_BIG	0x00000001 /* read-only, samples the endianess input pin */
+
+/* BANKCON */
+#define S3C44B0X_BANKCON_TACS_0		0x00000000 /* time, adress setup to CS (in clocks) */
+#define S3C44B0X_BANKCON_TACS_1		0x00002000
+#define S3C44B0X_BANKCON_TACS_2		0x00004000
+#define S3C44B0X_BANKCON_TACS_4		0x00006000
+
+#define S3C44B0X_BANKCON_TCOS_0		0x00000000 /* time, CS to nOE (in clocks) */
+#define S3C44B0X_BANKCON_TCOS_1		0x00000800
+#define S3C44B0X_BANKCON_TCOS_2		0x00001000
+#define S3C44B0X_BANKCON_TCOS_4		0x00001800
+
+#define S3C44B0X_BANKCON_TACC_1		0x00000000 /* access cycle in clocks (in clocks) */
+#define S3C44B0X_BANKCON_TACC_2		0x00000100
+#define S3C44B0X_BANKCON_TACC_3		0x00000200
+#define S3C44B0X_BANKCON_TACC_4		0x00000300
+#define S3C44B0X_BANKCON_TACC_6		0x00000400
+#define S3C44B0X_BANKCON_TACC_8		0x00000500
+#define S3C44B0X_BANKCON_TACC_10	0x00000600
+#define S3C44B0X_BANKCON_TACC_14	0x00000700
+
+#define S3C44B0X_BANKCON_TOCH_0		0x00000000 /* time, CS hold on nOE (in clocks) */
+#define S3C44B0X_BANKCON_TOCH_1		0x00000040
+#define S3C44B0X_BANKCON_TOCH_2		0x00000080
+#define S3C44B0X_BANKCON_TOCH_4		0x000000c0
+
+#define S3C44B0X_BANKCON_TCAH_0		0x00000000 /* address hold on after CS (in clocks) */
+#define S3C44B0X_BANKCON_TCAH_1		0x00000010
+#define S3C44B0X_BANKCON_TCAH_2		0x00000020
+#define S3C44B0X_BANKCON_TCAH_4		0x00000030
+
+#define S3C44B0X_BANKCON_TPAC_2		0x00000000 /* page mode access cycle (in clocks) */
+#define S3C44B0X_BANKCON_TPAC_3		0x00000004
+#define S3C44B0X_BANKCON_TPAC_4		0x00000008
+#define S3C44B0X_BANKCON_TPAC_6		0x0000000c
+
+#define S3C44B0X_BANKCON_PMC_1		0x00000000 /* page mode config (in datawords) */
+#define S3C44B0X_BANKCON_PMC_4		0x00000001
+#define S3C44B0X_BANKCON_PMC_8		0x00000002
+#define S3C44B0X_BANKCON_PMC_16		0x00000003
+
+#define S3C44B0X_BANKCON_MT_SRAM	0x00000000 /* memory type selection */
+#define S3C44B0X_BANKCON_MT_DRAM	0x00004000
+#define S3C44B0X_BANKCON_MT_EDO		0x00008000
+#define S3C44B0X_BANKCON_MT_SDRAM	0x00018000
+
+/* only for FP-DRAM or EDO-DRAM */
+#define S3C44B0X_BANKCON_TRCD_1		0x00000000 /* RAS to CAS delay */
+#define S3C44B0X_BANKCON_TRCD_2		0x00000010
+#define S3C44B0X_BANKCON_TRCD_3		0x00000020
+#define S3C44B0X_BANKCON_TRCD_4		0x00000030
+
+#define S3C44B0X_BANKCON_TCAS_1		0x00000000 /* CAS pulse width (in clocks) */
+#define S3C44B0X_BANKCON_TCAS_2		0x00000008
+
+#define S3C44B0X_BANKCON_TCP_1		0x00000000 /* CAS precharge (in clocks) */
+#define S3C44B0X_BANKCON_TCP_2		0x00000004
+
+#define S3C44B0X_BANKCON_CAN_8		0x00000000 /* column address number (in bits) */
+#define S3C44B0X_BANKCON_CAN_9		0x00000001
+#define S3C44B0X_BANKCON_CAN_10		0x00000002
+#define S3C44B0X_BANKCON_CAN_11		0x00000003
+
+/* only for SDRAM */
+#define S3C44B0X_BANKCON_SDRAM_TRCD_2	0x00000000 /* RAS to CAS delay */
+#define S3C44B0X_BANKCON_SDRAM_TRCD_3	0x00000004
+#define S3C44B0X_BANKCON_SDRAM_TRCD_4	0x00000008
+
+#define S3C44B0X_BANKCON_SCAN_8		0x00000000 /* column address number (in bits) */
+#define S3C44B0X_BANKCON_SCAN_9		0x00000001
+#define S3C44B0X_BANKCON_SCAN_10	0x00000002
+
+
+/* REFRESH */
+#define S3C44B0X_REFRESH_REFEN		0x00800000
+#define S3C44B0X_REFRESH_TREFMD		0x00400000
+
+
+#define S3C44B0X_REFRESH_TRP_1_5	0x00000000 /* for DRAM */
+#define S3C44B0X_REFRESH_TRP_2_5	0x00000000
+#define S3C44B0X_REFRESH_TRP_3_5	0x00000000
+#define S3C44B0X_REFRESH_TRP_4_5	0x00000000
+#define S3C44B0X_REFRESH_TRP_2		0x00000000 /* for SDRAM */
+#define S3C44B0X_REFRESH_TRP_3		0x00000000
+#define S3C44B0X_REFRESH_TRP_4		0x00000000
+#define S3C44B0X_REFRESH_TRP_NONE	0x00000000
+
+#define S3C44B0X_REFRESH_TRC_4		0x00000000 /* SDRAM RC minimum time */
+#define S3C44B0X_REFRESH_TRC_5		0x00040000
+#define S3C44B0X_REFRESH_TRC_6		0x00080000
+#define S3C44B0X_REFRESH_TRC_7		0x000c0000
+
+#define S3C44B0X_REFRESH_TCHR_1		0x00000000 /* CAS Hold Time (DRAM) */
+#define S3C44B0X_REFRESH_TCHR_2		0x00010000
+#define S3C44B0X_REFRESH_TCHR_3		0x00020000
+#define S3C44B0X_REFRESH_TCHR_4		0x00030000
+
+#define S3C44B0X_REFRESH_COUNTER	0x000003FF /* mask for the refresh counter (bit 0-10) */
+
+/* BANKSIZE */
+#define S3C44B0X_BANKSIZE_SCLKEN	0x00000010
+#define S3C44B0X_BANKSIZE_BK76MAP_2	0x00000004
+#define S3C44B0X_BANKSIZE_BK76MAP_4	0x00000005
+#define S3C44B0X_BANKSIZE_BK76MAP_8	0x00000006
+#define S3C44B0X_BANKSIZE_BK76MAP_16	0x00000007
+#define S3C44B0X_BANKSIZE_BK76MAP_32	0x00000000
+
+/* MRSRB */
+#define S3C44B0X_MRSRB_WBL		0x00000200
+#define S3C44B0X_MRSRB_CL_1		0x00000000
+#define S3C44B0X_MRSRB_CL_2		0x00000020
+#define S3C44B0X_MRSRB_CL_3		0x00000030
+#define S3C44B0X_MRSRB_BT_SEQ		0x00000000
+#define S3C44B0X_MRSRB_BT_NONSEQ	0x00000008
+#define S3C44B0X_MRSRB_BL_1		0x00000000
+
+  /************/
+  /*** UART ***/
+  /************/
+  
+#define S3C44B0X_ULCON0			0x01d00000
+#define S3C44B0X_UCON0			0x01d00004
+#define S3C44B0X_UFCON0			0x01d00008
+#define S3C44B0X_UMCON0			0x01d0000c
+#define S3C44B0X_UTRSTAT0		0x01d00010
+#define S3C44B0X_UERSTAT0		0x01d00014
+#define S3C44B0X_UFSTAT0		0x01d00018
+#define S3C44B0X_UMSTAT0		0x01d0001c
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+#define S3C44B0X_UTXH0			0x01d00023
+#define S3C44B0X_URXH0			0x01d00027
+#else
+#define S3C44B0X_UTXH0			0x01d00020
+#define S3C44B0X_URXH0			0x01d00024
+#endif
+
+#define S3C44B0X_UBRDIV0		0x01d00028
+
+#define S3C44B0X_ULCON1			0x01d04000
+#define S3C44B0X_UCON1			0x01d04004
+#define S3C44B0X_UFCON1			0x01d04008
+#define S3C44B0X_UMCON1			0x01d0400c
+#define S3C44B0X_UTRSTAT1		0x01d04010
+#define S3C44B0X_UERSTAT1		0x01d04014
+#define S3C44B0X_UFSTAT1		0x01d04018
+#define S3C44B0X_UMSTAT1		0x01d0401c
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+#define S3C44B0X_UTXH1			0x01d04023
+#define S3C44B0X_URXH1			0x01d04027
+#else
+#define S3C44B0X_UTXH1			0x01d04020
+#define S3C44B0X_URXH1			0x01d04024
+#endif
+
+#define S3C44B0X_UBRDIV1		0x01d04028
+
+/* ULCON */
+#define S3C44B0X_ULCON_IR		0x00000040
+
+#define S3C44B0X_ULCON_PAR_NO		0x00000000
+#define S3C44B0X_ULCON_PAR_ODD		0x00000020
+#define S3C44B0X_ULCON_PAR_EVEN		0x00000028
+#define S3C44B0X_ULCON_PAR_1		0x00000030
+#define S3C44B0X_ULCON_PAR_0		0x00000038
+
+#define S3C44B0X_ULCON_STOPB_1		0x00000000
+#define S3C44B0X_ULCON_STOPB_2		0x00000004
+
+#define S3C44B0X_ULCON_WORDLN_5		0x00000000
+#define S3C44B0X_ULCON_WORDLN_6		0x00000001
+#define S3C44B0X_ULCON_WORDLN_7		0x00000002
+#define S3C44B0X_ULCON_WORDLN_8		0x00000003
+
+/* UCON */
+#define S3C44B0X_UCON_TXINT_LEVEL	0x00000200
+#define S3C44B0X_UCON_RXINT_LEVEL	0x00000100
+#define S3C44B0X_UCON_TXINT_PULSE	0x00000000
+#define S3C44B0X_UCON_RXINT_PULSE	0x00000000
+#define S3C44B0X_UCON_RX_TIMEOUT_EN	0x00000080
+#define S3C44B0X_UCON_RX_ERR_INT_EN	0x00000040
+#define S3C44B0X_UCON_LOOP		0x00000020
+#define S3C44B0X_UCON_SEND_BREAK	0x00000010
+
+#define S3C44B0X_UCON_TX_DIS		0x00000000
+#define S3C44B0X_UCON_TX_MODE_INT_POLL	0x00000004
+#define S3C44B0X_UCON_TX_MODE_BDMA0	0x00000008
+#define S3C44B0X_UCON_TX_MODE_BDMA1	0x0000000c
+
+#define S3C44B0X_UCON_RX_DIS		0x00000000
+#define S3C44B0X_UCON_RX_MODE_INT_POLL	0x00000001
+#define S3C44B0X_UCON_RX_MODE_BDMA0	0x00000002
+#define S3C44B0X_UCON_RX_MODE_BDMA1	0x00000003
+
+/* UFCON */
+#define S3C44B0X_UFCON_TX_FIFO_0	0x00000000 /* TX FIFO byte size */
+#define S3C44B0X_UFCON_TX_FIFO_4	0x00000040
+#define S3C44B0X_UFCON_TX_FIFO_8	0x00000080
+#define S3C44B0X_UFCON_TX_FIFO_12	0x000000c0
+
+#define S3C44B0X_UFCON_RX_FIFO_4	0x00000000 /* RX FIFO byte size */
+#define S3C44B0X_UFCON_RX_FIFO_8	0x00000010
+#define S3C44B0X_UFCON_RX_FIFO_12	0x00000020
+#define S3C44B0X_UFCON_RX_FIFO_16	0x00000030
+
+#define S3C44B0X_UFCON_TX_FIFO_RST	0x00000004
+#define S3C44B0X_UFCON_RX_FIFO_RST	0x00000002
+#define S3C44B0X_UFCON_FIFO_EN		0x00000001 /* global FIFO enable */
+
+/* UMCON */
+#define S3C44B0X_UMCON_AFC		0x00000010  /* auto flow control */
+#define S3C44B0X_UMCON_RQST_SEND	0x00000001  /* request to send 1=L(active RTS) 0=H(inactive RTS) */
+
+/* UTRSTAT */
+#define S3C44B0X_UTRSTAT_TSE		0x00000004  /* transmitter shifter empty */
+#define S3C44B0X_UTRSTAT_TBE		0x00000002  /* transmitt buffer empty */
+#define S3C44B0X_UTRSTAT_RBDR		0x00000001  /* receive buffer data ready */
+
+/* UERSTAT */
+#define S3C44B0X_UERSTAT_BREAK_DETECT	0x00000008
+#define S3C44B0X_UERSTAT_FRAME_ERROR	0x00000004
+#define S3C44B0X_UERSTAT_PARITY_ERROR	0x00000002
+#define S3C44B0X_UERSTAT_OVERRUN_ERROR	0x00000001
+
+/* UFSTAT */
+#define S3C44B0X_UFSTAT_TX_FIFO_FULL	0x00000200
+#define S3C44B0X_UFSTAT_RX_FIFO_FULL	0x00000100
+#define S3C44B0X_UFSTAT_TX_FIFO_COUNT	0x000000F0
+#define S3C44B0X_UFSTAT_RX_FIFO_COUNT	0x0000000F
+
+  /***********/
+  /*** SIO ***/
+  /***********/
+
+#define S3C44B0X_SIOCON			0x01d14000
+#define S3C44B0X_SIODAT			0x01d14004
+#define S3C44B0X_SBRDR			0x01d14008
+#define S3C44B0X_ITVCNT			0x01d1400c
+#define S3C44B0X_DNCTZ			0x01d14010
+
+  /****************************/
+  /*** IIS (Inter IC Sound) ***/
+  /****************************/
+
+#define S3C44B0X_IISCON			0x01d18000
+#define S3C44B0X_IISMOD			0x01d18004
+#define S3C44B0X_IISPSR			0x01d18008
+#define S3C44B0X_IISFIFCON		0x01d1800c
+#define S3C44B0X_IISFIF			0x01d18010
+
+  /*****************/
+  /*** I/O ports ***/
+  /*****************/
+
+#define S3C44B0X_PCONA			0x01d20000
+#define S3C44B0X_PDATA			0x01d20004
+#define S3C44B0X_PCONB			0x01d20008
+#define S3C44B0X_PDATB			0x01d2000c
+
+#define S3C44B0X_PCONC			0x01d20010
+#define S3C44B0X_PDATC			0x01d20014
+#define S3C44B0X_PUPC			0x01d20018
+#define S3C44B0X_PCOND			0x01d2001c
+#define S3C44B0X_PDATD			0x01d20020
+#define S3C44B0X_PUPD			0x01d20024
+#define S3C44B0X_PCONE			0x01d20028
+#define S3C44B0X_PDATE			0x01d2002c
+#define S3C44B0X_PUPE			0x01d20030
+#define S3C44B0X_PCONF			0x01d20034
+#define S3C44B0X_PDATF			0x01d20038
+#define S3C44B0X_PUPF			0x01d2003c
+#define S3C44B0X_PCONG			0x01d20040
+#define S3C44B0X_PDATG			0x01d20044
+#define S3C44B0X_PUPG			0x01d20048
+#define S3C44B0X_SPUCR			0x01d2004c
+
+  /***************************/
+  /*** external interrupts ***/
+  /***************************/
+
+#define S3C44B0X_EXTINT			0x01d20050
+#define S3C44B0X_EXTINPND		0x01d20054
+
+  /**********************/
+  /*** WATCHDOG TIMER ***/
+  /**********************/
+
+#define S3C44B0X_WTCON			0x01d30000
+#define S3C44B0X_WTDAT			0x01d30004
+#define S3C44B0X_WTCNT			0x01d30008
+
+  /*********************/
+  /*** A/D CONVERTER ***/
+  /*********************/
+
+#define S3C44B0X_ADCCON			0x01d40000
+#define S3C44B0X_ADCPSR			0x01d40004
+#define S3C44B0X_ADCDAT			0x01d40008
+
+  /*****************/
+  /*** PWM TIMER ***/
+  /*****************/
+
+#define S3C44B0X_TCFG0			0x01d50000 /* prescaler configuration */
+#define S3C44B0X_TCFG1			0x01d50004 /* MUX-input for PWM and DMA */
+#define S3C44B0X_TCON			0x01d50008 /* timer control register (start/stop, PWM-out, auto-reload, dead-zone) */
+#define S3C44B0X_TCNTB0 		0x01d5000c /* timer counter "buffer" register (read-write) to update the timer counter */
+#define S3C44B0X_TCMPB0			0x01d50010 /* timer compare register */
+#define S3C44B0X_TCNTO0			0x01d50014 /* timer counter "observation" register (real counter value, read-only) */
+#define S3C44B0X_TCNTB1			0x01d50018
+#define S3C44B0X_TCMPB1			0x01d5001c
+#define S3C44B0X_TCNTO1			0x01d50020
+#define S3C44B0X_TCNTB2			0x01d50024
+#define S3C44B0X_TCMPB2			0x01d50028
+#define S3C44B0X_TCNTO2			0x01d5002c
+#define S3C44B0X_TCNTB3			0x01d50030
+#define S3C44B0X_TCMPB3			0x01d50034
+#define S3C44B0X_TCNTO3			0x01d50038
+#define S3C44B0X_TCNTB4			0x01d5003c
+#define S3C44B0X_TCMPB4			0x01d50040
+#define S3C44B0X_TCNTO4			0x01d50044
+#define S3C44B0X_TCNTB5			0x01d50048
+#define S3C44B0X_TCNTO5			0x01d5004c
+
+/* TCON */
+#define S3C44B0X_TCON_T5_AUTO		0x04000000 /* automatically reload the timer register (cycle) */
+#define S3C44B0X_TCON_T5_MAN_UPDATE	0x02000000 /* manualy update the counter (read from TCNTBn) */
+#define S3C44B0X_TCON_T5_START		0x01000000 /* start the timer (normal modus) if bit not set -> no decrement of counter */
+
+#define S3C44B0X_TCON_T4_AUTO		0x00800000
+#define S3C44B0X_TCON_T4_OUTPUT		0x00400000 /* enable output to the PWM-pin (controlled by TCMPBn and TCNTBn) */
+#define S3C44B0X_TCON_T4_MAN_UPDATE	0x00200000
+#define S3C44B0X_TCON_T4_START		0x00100000
+
+#define S3C44B0X_TCON_T3_AUTO		0x00080000
+#define S3C44B0X_TCON_T3_OUTPUT		0x00040000
+#define S3C44B0X_TCON_T3_MAN_UPDATE	0x00020000
+#define S3C44B0X_TCON_T3_START		0x00010000
+
+#define S3C44B0X_TCON_T2_AUTO		0x00008000
+#define S3C44B0X_TCON_T2_OUTPUT		0x00004000
+#define S3C44B0X_TCON_T2_MAN_UPDATE	0x00002000
+#define S3C44B0X_TCON_T2_START		0x00001000
+
+#define S3C44B0X_TCON_T1_AUTO		0x00000800
+#define S3C44B0X_TCON_T1_OUTPUT		0x00000400
+#define S3C44B0X_TCON_T1_MAN_UPDATE	0x00000200
+#define S3C44B0X_TCON_T1_START		0x00000100
+
+#define S3C44B0X_TCON_DEAD_ZONE_EN	0x00000010 /* enable the dead zone for PWM-mode */
+
+#define S3C44B0X_TCON_T0_AUTO		0x00000008
+#define S3C44B0X_TCON_T0_OUTPUT		0x00000004
+#define S3C44B0X_TCON_T0_MAN_UPDATE	0x00000002
+#define S3C44B0X_TCON_T0_START		0x00000001
+
+  /***********/
+  /*** IIC ***/
+  /***********/
+
+#define S3C44B0X_IICCON			0x01d60000
+#define S3C44B0X_IICSTAT		0x01d60004
+#define S3C44B0X_IICADD			0x01d60008
+#define S3C44B0X_IICDS			0x01d6000c
+
+  /***********/
+  /*** RTC ***/
+  /***********/
+
+#define S3C44B0X_RTCCON			0x01d70040
+#define S3C44B0X_RTCALM			0x01d70050
+#define S3C44B0X_ALMSEC			0x01d70054
+#define S3C44B0X_ALMMIN			0x01d70058
+#define S3C44B0X_ALMHOUR		0x01d7005c
+#define S3C44B0X_ALMDAY			0x01d70060
+#define S3C44B0X_ALMMON			0x01d70064
+#define S3C44B0X_ALMYEAR		0x01d70068
+#define S3C44B0X_RTCRST			0x01d7006c
+#define S3C44B0X_BCDSEC			0x01d70070
+#define S3C44B0X_BCDMIN			0x01d70074
+#define S3C44B0X_BCDHOUR		0x01d70078
+#define S3C44B0X_BCDDAY			0x01d7007c
+#define S3C44B0X_BCDDATE		0x01d70080
+#define S3C44B0X_BCDMON			0x01d70084
+#define S3C44B0X_BCDYEAR		0x01d70088
+#define S3C44B0X_TICINT			0x01d7008c
+
+  /********************************/
+  /*** CLOCK & POWER MANAGEMENT ***/
+  /********************************/
+
+#define S3C44B0X_PLLCON			0x01d80000
+#define S3C44B0X_CLKCON			0x01d80004
+#define S3C44B0X_CLKSLOW		0x01d80008
+#define S3C44B0X_LOCKTIME		0x01d8000c
+
+#define S3C44B0X_CLKCON_IIS		0x4000
+#define S3C44B0X_CLKCON_IIC		0x2000
+#define S3C44B0X_CLKCON_ADC		0x1000
+#define S3C44B0X_CLKCON_RTC		0x0800
+#define S3C44B0X_CLKCON_GPIO		0x0400
+#define S3C44B0X_CLKCON_UART1		0x0200
+#define S3C44B0X_CLKCON_UART0		0x0100
+#define S3C44B0X_CLKCON_BDMA		0x0080
+#define S3C44B0X_CLKCON_LCDC		0x0040
+#define S3C44B0X_CLKCON_SIO		0x0020
+#define S3C44B0X_CLKCON_ZDMA		0x0010
+#define S3C44B0X_CLKCON_PWMTIMER	0x0008
+#define S3C44B0X_CLKCON_IDLE_BIT	0x0004
+#define S3C44B0X_CLKCON_SL_IDLE		0x0002
+#define S3C44B0X_CLKCON_STOP_BIT	0x0001
+
+#define S3C44B0X_CLKSLOW_PLL_OFF	0x00000010
+#define S3C44B0X_CLKSLOW_SLOW_BIT	0x00000008
+#define S3C44B0X_CLKSLOW_VAL_0		0x00000000
+#define S3C44B0X_CLKSLOW_VAL_1		0x00000001
+#define S3C44B0X_CLKSLOW_VAL_2		0x00000002
+#define S3C44B0X_CLKSLOW_VAL_3		0x00000003
+
+  /****************************/
+  /*** INTERRUPT CONTROLLER ***/
+  /****************************/
+
+#define S3C44B0X_INTCON			0x01e00000
+#define S3C44B0X_INTPND			0x01e00004
+#define S3C44B0X_INTMOD			0x01e00008
+#define S3C44B0X_INTMSK			0x01e0000c
+#define S3C44B0X_I_PSLV			0x01e00010
+#define S3C44B0X_I_PMST			0x01e00014
+#define S3C44B0X_I_CSLV			0x01e00018
+#define S3C44B0X_I_CMST			0x01e0001c
+#define S3C44B0X_I_ISPR			0x01e00020
+#define S3C44B0X_I_ISPC			0x01e00024
+#define S3C44B0X_F_ISPR			0x01e00038
+#define S3C44B0X_F_ISPC			0x01e0003c
+
+  /***********/
+  /*** DMA ***/
+  /***********/
+
+#define S3C44B0X_ZDCON0			0x01e80000
+#define S3C44B0X_ZDISRC0		0x01e80004
+#define S3C44B0X_ZDIDES0		0x01e80008
+#define S3C44B0X_ZDICNT0		0x01e8000c
+#define S3C44B0X_ZDCSRC0		0x01e80010
+#define S3C44B0X_ZDCDES0		0x01e80014
+#define S3C44B0X_ZDCCNT0		0x01e80018
+#define S3C44B0X_ZDCON1			0x01e80020
+#define S3C44B0X_ZDISRC1		0x01e80024
+#define S3C44B0X_ZDIDES1		0x01e80028
+#define S3C44B0X_ZDICNT1		0x01e8002c
+#define S3C44B0X_ZDCSRC1		0x01e80030
+#define S3C44B0X_ZDCDES1		0x01e80034
+#define S3C44B0X_ZDCCNT1		0x01e80038
+
+#define S3C44B0X_BDCON0			0x01f80000
+#define S3C44B0X_BDISRC0		0x01f80004
+#define S3C44B0X_BDIDES0		0x01f80008
+#define S3C44B0X_BDICNT0		0x01f8000c
+#define S3C44B0X_BDCSRC0		0x01f80010
+#define S3C44B0X_BDCDES0		0x01f80014
+#define S3C44B0X_BDCCNT0		0x01f80018
+#define S3C44B0X_BDCON1			0x01f80020
+#define S3C44B0X_BDISRC1		0x01f80024
+#define S3C44B0X_BDIDES1		0x01f80028
+#define S3C44B0X_BDICNT1		0x01f8002c
+#define S3C44B0X_BDCSRC1		0x01f80030
+#define S3C44B0X_BDCDES1		0x01f80034
+#define S3C44B0X_BDCCNT1		0x01f80038
+
+#define S3C44B0X_ZDCON_STE_RDY		0x00000000
+#define S3C44B0X_ZDCON_STE_NTC		0x00000040
+#define S3C44B0X_ZDCON_STE_TC		0x00000080
+
+#define S3C44B0X_ZDCON_QDS_EN		0x00000000
+#define S3C44B0X_ZDCON_QDS_DIS		0x0000000c
+
+#define S3C44B0X_ZDCON_CMD_NONE		0x00000000
+#define S3C44B0X_ZDCON_CMD_START	0x00000001
+#define S3C44B0X_ZDCON_CMD_PAUSE	0x00000002
+#define S3C44B0X_ZDCON_CMD_CANCEL	0x00000003
+
+
+/*********************
+ *   LCD controller  *
+ *********************/
+#define S3C44B0X_LCD_MEM		0x0c060000
+
+#define S3C44B0X_LCDCON1                0x01f00000
+#define S3C44B0X_LCDCON2                0x01f00004
+#define S3C44B0X_LCDCON3                0x01f00040
+#define S3C44B0X_LCDSADDR1              0x01f00008
+#define S3C44B0X_LCDSADDR2              0x01f0000c
+#define S3C44B0X_LCDSADDR3              0x01f00010
+
+#define S3C44B0X_REDLUT                 0x01f00014
+#define S3C44B0X_GREENLUT               0x01f00018
+#define S3C44B0X_BLUELUT                0x01f0001c
+#define S3C44B0X_DP1_2                  0x01f00020
+#define S3C44B0X_DP4_7                  0x01f00024
+#define S3C44B0X_DP3_5                  0x01f00028
+#define S3C44B0X_DP2_3                  0x01f0002c
+#define S3C44B0X_DP5_7                  0x01f00030
+#define S3C44B0X_DP3_4                  0x01f00034
+#define S3C44B0X_DP4_5                  0x01f00038
+#define S3C44B0X_DP6_7                  0x01f0003c
+
+#define S3C44B0X_DITHMODE               0x01f00044
+
+/* LCDCON1 */
+#define S3C44B0X_LCDCON1_WLH_4          0x00000000
+#define S3C44B0X_LCDCON1_WLH_8          0x00000400
+#define S3C44B0X_LCDCON1_WLH_12         0x00000800
+#define S3C44B0X_LCDCON1_WLH_16         0x00000c00
+
+#define S3C44B0X_LCDCON1_WDLY_4         0x00000000
+#define S3C44B0X_LCDCON1_WDLY_8         0x00000100
+#define S3C44B0X_LCDCON1_WDLY_12        0x00000200
+#define S3C44B0X_LCDCON1_WDLY_16        0x00000300
+
+#define S3C44B0X_LCDCON1_MMODE          0x00000080
+
+#define S3C44B0X_LCDCON1_DISMODE_4D     0x00000000
+#define S3C44B0X_LCDCON1_DISMODE_4S     0x00000020
+#define S3C44B0X_LCDCON1_DISMODE_8S     0x00000040
+
+#define S3C44B0X_LCDCON1_INVCLK         0x00000010
+#define S3C44B0X_LCDCON1_INVLINE        0x00000008
+#define S3C44B0X_LCDCON1_INVFRAME       0x00000004
+#define S3C44B0X_LCDCON1_INVVD          0x00000002
+#define S3C44B0X_LCDCON1_ENVID          0x00000001
+
+
+/* LCDCON3 */
+#define S3C44B0X_LCDCON3_SELFREFRESH	0x00000001
+
+
+/* LCDSADDR1 */
+#define S3C44B0X_LCDSADDR1_MONO		0x00000000
+#define S3C44B0X_LCDSADDR1_GRAY_4	0x08000000
+#define S3C44B0X_LCDSADDR1_GRAY_16	0x10000000
+#define S3C44B0X_LCDSADDR1_COLOR	0x18000000
+
+/* LCDSADDR2 */
+#define S3C44B0X_LCDSADDR2_BSWP     	0x20000000
+#endif /* _S3C44B0X_H_ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/sizes.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/sizes.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/sizes.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/sizes.h	2005-11-08 09:06:39.000000000 +0900
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/system.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/system.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/system.h	2005-11-08 09:06:40.000000000 +0900
@@ -0,0 +1,25 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/system.h
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+ 	/* machine should reboot */
+ 	mdelay(5000);
+ 	panic("Watchdog timer reset failed!\n");
+ 	printk(" Jump to address 0 \n");
+ 	cpu_reset(0);
+}
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/time.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/time.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/time.h	2005-11-08 09:06:40.000000000 +0900
@@ -0,0 +1,7 @@
+/*
+ *  linux/include/asm-arm/arch-s3c44b0x/time.h
+ */
+
+#ifndef __ASM_ARCH_TIME_H__
+#define __ASM_ARCH_TIME_H__
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/timex.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/timex.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/timex.h	2005-11-08 09:06:40.000000000 +0900
@@ -0,0 +1,10 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/timex.h
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#define CLOCK_TICK_RATE (CONFIG_ARM_CLK)
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/uncompress.c linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/uncompress.c
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/uncompress.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/uncompress.c	2005-11-08 09:06:39.000000000 +0900
@@ -0,0 +1,23 @@
+/*
+ * linux/include/asm/arch-samsung/uncompress.c
+ */
+
+#include <asm/hardware.h>
+
+static int s3c44b0x_decomp_setup()
+{
+}
+
+static int s3c44b0x_putc(char c)
+{
+	while (!(SYSREG_GET(S3C44B0X_UTRSTAT0) & 0x2));
+	SYSREG_SETB(S3C44B0X_UTXH0, c);
+	if(c == '\n')
+		s3c44b0x_putc('\r');
+}
+
+static void s3c44b0x_puts(const char *s)
+{
+	while(*s != '\0')
+		s3c44b0x_putc(*s++);
+}
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/uncompress.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/uncompress.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/uncompress.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/uncompress.h	2005-11-08 09:06:39.000000000 +0900
@@ -0,0 +1,51 @@
+/*
+ * asm/arch/uncompress.c:
+ *         Optional routines to aid in debugging the decompression phase
+ *         of kernel boot.
+ * copyright:
+ *         (C) 2001 RidgeRun, Inc. (http://www.ridgerun.com)
+ * author: Gordon McNutt <gmcnutt@ridgerun.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ * WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ * USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <asm/arch/uncompress.c>
+/*
+ * This is used by arch/armnommu/boot/compressed/misc.c to write progress info
+ * out the serial port so that the user can see debug messages up to the point
+ * where the kernel is decompressed. The STANDALONE_DEBUG macro chooses between
+ * this and the standard printf. Punt.
+ * --gmcnutt
+ */
+#define puts(s)			s3c44b0x_puts(s)
+
+/*
+ * Not sure what this is for. Probably an optional watchdog to check if the
+ * decompress got hung so we can warn the user. Punt.
+ */
+#define arch_decomp_wdog()
+
+/*
+ * If we need to do some setup prior to decompression (like initializing the
+ * UART if we want to use puts() above) then we define it here. Punt.
+ */
+#define arch_decomp_setup()	s3c44b0x_decomp_setup()
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/vmalloc.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/vmalloc.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s3c44b0x/vmalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s3c44b0x/vmalloc.h	2005-11-08 09:06:39.000000000 +0900
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c44b0x/vmalloc.h
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_S3C44B0X_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_S3C44B0X_SDRAM_SIZE)   
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/blkmem.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/blkmem.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/blkmem.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/blkmem.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,25 @@
+/*
+ * linux/include/asm-armnommu/arch-s5c7375/blkmem.h
+ *
+ * Copyright (c) 2003 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ * <hyok.choi@samsung.com>
+ *
+ * Contains configuration settings for the blkmem driver.
+ */
+#ifndef __ASM_ARCH_BLKMEM_H
+#define __ASM_ARCH_BLKMEM_H
+
+#define CAT_ROMARRAY
+
+
+#ifndef HYOK_ROMFS_BOOT	
+    extern char _end[];
+    #define FIXUP_ARENAS \
+	arena[0].address = ((unsigned long)_end + DRAM_BASE + 0x2000);	// ram
+#else
+    extern char __bss_start[];
+    #define FIXUP_ARENAS \
+	arena[0].address = ((unsigned long)__bss_start + FLASH_MEM_BASE); // rom
+#endif
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/dma.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/dma.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/dma.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,141 @@
+/*
+ * linux/include/asm-arm/arch-s5c7375/dma-s5c7375.h
+ * Generic S5C7375  DMA support
+ * Copyright (C) 2002 SW.LEE <hitchcar@sec.samsung.com>
+ * Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_S5C7375_ARCH_DMA_H
+#define __ASM_S5C7375_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ * 
+ */
+#define MAX_DMA_ADDRESS		0x20000000
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+/*
+ * The regular generic DMA interface is inappropriate for the
+ * S5C7375 DMA model.  None of the S5C7375 specific drivers using
+ * DMA are portable anyway so it's pointless to try to twist the
+ * regular DMA API to accommodate them.
+ */
+
+/***************************************************************************/
+/* this means that We will use arch/arm/mach/dma.h i.e generic dma module  */
+#define MAX_DMA_CHANNELS	0
+/****************************************************************************/
+
+/*
+ * The S5C7375 has four internal DMA channels.
+ */
+#define S5C7375_DMA_CHANNELS     6
+
+#define MAX_S5C7375_DMA_CHANNELS S5C7375_DMA_CHANNELS
+
+
+/*
+ * All possible S5C7375 devices the specific DMA channel can be attached to.
+ * I'm sorry for only DMA Device Address
+ * DMA request sources would be controlled by H/W DMA mode selected by DCON register
+ */
+
+typedef enum {
+      DMA0_SOURCE0 ,		/* EXT device 0 */
+      DMA0_SOURCE1 ,		/* UART1  */
+      DMA0_SOURCE2 ,		/* USB  */
+      DMA0_SOURCE3 ,		/* PPIC  */
+      DMA0_SOURCE4 ,		/* UART0 */
+      DMA0_SOURCE5 ,		/* EXT device 1 */
+} dma_device_t;
+
+
+/*
+ * DMA buffer structure
+ */
+
+typedef struct dma_buf_s {
+	int size;		/* buffer size */
+	dma_addr_t dma_start;	/* starting DMA address */
+	dma_addr_t dma_ptr;	/* next DMA pointer to use */
+	int ref;		/* number of DMA references */
+	void *id;		/* to identify buffer from outside */
+	struct dma_buf_s *next;	/* next buffer to process */
+} dma_buf_t;
+
+
+/*
+ * DMA channel structure.
+ */
+
+/*
+ * DMA control register structure
+ * one channel S5C7375 DMA control register is 0x40 byte
+ *
+ */
+ 
+typedef void (*dma_callback_t)( void *buf_id, int size);
+
+typedef struct {
+	volatile u_long DISRC;
+	volatile u_long DISRCC;
+	volatile u_long DIDST;
+	volatile u_long DIDSTC;
+	volatile u_long DCON;
+	volatile u_long DSTAT;
+	volatile u_long DCSRC;
+	volatile u_long DCDST;
+	volatile u_long DMASKTRIG;
+} dma_regs_t;
+
+#define DOUBLE_BUFFER_COUNT 3
+typedef struct {
+	unsigned int in_use;	/* Device is allocated */
+	const char *device_id;	/* Device name */
+	dma_device_t device;	/* ... to which this channel is attached */
+	dma_buf_t *head;	/* where to insert buffers */
+	dma_buf_t *tail;	/* where to remove buffers */
+	dma_buf_t *curr;	/* buffer currently DMA'ed */
+	int stopped;		/* 1 if DMA is stalled */
+	dma_regs_t *regs;	/* points to appropriate DMA registers */
+	int irq;		/* IRQ used by the channel */
+	dma_callback_t callback; /* ... to call when buffers are done */
+
+	unsigned int queueCnt;
+	unsigned int usedQueueCnt;	
+	int	isSleeping;
+	int spin_size;		/* > 0 when DMA should spin when no more buffer */
+	dma_addr_t spin_addr;	/* DMA address to spin onto */
+	int spin_ref;		/* number of spinning references */
+
+        unsigned char already_init;	/* S5C7375 specific  */
+} s5c7375_dma_t;
+
+/* S5C7375 DMA API */
+extern int s5c7375_request_dma( dmach_t channel, const char *device_id,
+			       dma_device_t device );
+extern int s5c7375_dma_set_callback( dmach_t channel, dma_callback_t cb );
+extern int s5c7375_dma_set_spin( dmach_t channel, dma_addr_t addr, int size );
+extern int s5c7375_dma_queue_buffer( dmach_t channel, void *buf_id,
+				    dma_addr_t data, int size );
+extern int s5c7375_dma_get_current( dmach_t channel, void **buf_id, dma_addr_t *addr );
+extern int s5c7375_dma_stop( dmach_t channel );
+extern int s5c7375_dma_resume( dmach_t channel );
+extern int s5c7375_dma_flush_all( dmach_t channel );
+extern void s5c7375_free_dma( dmach_t channel );
+extern int s5c7375_dma_sleep( dmach_t channel );
+extern int s5c7375_dma_wakeup( dmach_t channel );
+extern void s5c7375_dma_done (s5c7375_dma_t *dma);
+
+#endif /* _ASM_S5C7375_ARCH_DMA_H */
+
+
+
+
+
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/entry-macro.S linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/entry-macro.S
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/entry-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/entry-macro.S	2005-11-08 09:06:44.000000000 +0900
@@ -0,0 +1,57 @@
+/*
+ *  arch/armnommu/mach-s5c7375/entry-macro.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  Samsung Electronics Co.,Ltd.
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if defined(CONFIG_ARCH_S5C7375)
+                .macro  disable_fiq
+                .endm
+        #if 1   
+                        /* r0     r6      r5   lr */
+                .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+                ldr    \irqstat, =(rINTBase + 0x3C) @ rIRQISPR
+                ldr    \irqstat,   [\irqstat, #0]   @ load irqstat
+
+                mov    \irqnr, #0 
+1001:           
+                tst       \irqstat, #1
+                bne     1002f
+                add     \irqnr, \irqnr, #1
+                mov    \irqstat, \irqstat, lsr #1
+                cmp    \irqnr, #NR_IRQS 
+                bcc     1001b
+1002:           /* EQ will be set if we reach 32 */
+                .endm   
+                
+        #else     /* for better performance */ 
+                
+                        /* r0     r6      r5   lr */
+                .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+                ldr      \irqstat, =(rINTBase + 0x78) @ rIVEC_ADDR
+                ldr    \irqnr,   [\irqstat]             @ load irqnr * 4
+                mov     \irqnr, \irqnr, lsr #2          @ irqnr >> 2
+                movs   \tmp,  \irqnr
+                .endm
+        #endif
+                .macro  irq_prio_table
+                .endm
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/hardware.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/hardware.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/hardware.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/hardware.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,31 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/hardware.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                   Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+#include <asm/arch/s5c7375.h>
+
+#ifndef __ASSEMBLY__
+
+#define HARD_RESET_NOW()
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()  do { \
+	/* we need to keep the section table for mmu */ \
+	reserve_bootmem_node(pgdat, 0x00004000, 0x4000); \
+	} while(0)
+
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(0)
+
+#endif
+
+#endif  /*   END OF __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/io.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/io.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/io.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,69 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/io.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS
+ *			Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+/*
+ * We have the this routine to use usb host device driver
+ *
+ */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a)			(PCI_IO_VADDR + (a))
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(PCI_MEMORY_VADDR + (unsigned long)(a))
+
+
+/*
+ * Generic virtual read/write
+ */
+#if 0
+#define __arch_getw(a)		(*(volatile unsigned short *)(a))
+#define __arch_putw(v,a)	(*(volatile unsigned short *)(a) = (v))
+#endif
+/*
+ * Validate the pci memory address for ioremap.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+
+/* 
+ * For example, 
+ * CS8900A Net Device Driver
+ * for asm/io.h 
+ */
+/*
+#define __io 
+*/
+
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ */
+#define iomem_to_phys(iomem)	(iomem)
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/irq.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/irq.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/irq.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/irq.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __S5C7375_irq_h
+#define __S5C7375_irq_h
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+/* To understand S5C7375 irq 
+ * Look hard at "fixup_irq definition in irq.c file "
+ */
+extern unsigned  int fixup_irq(int i);
+
+extern void do_IRQ(int irq, struct pt_regs *regs);
+
+extern void s5c7375_init_irq(void);
+
+#define 	irq_init_irq 	s5c7375_init_irq
+
+#endif 
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/irqs.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/irqs.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/irqs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/irqs.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,124 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/irqs.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONIS  
+ *                        Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __S5C7375_irqs_h
+#define __S5C7375_irqs_h                        1
+
+	#define iSRAMBase    0x06000000    // internal SRAM base address
+	#define iSRAMTop     0x06001FFC    // top address of interanl SRAM
+	#define SDRAMBase    0x00000000
+	#define SDRAMTop     0x003FFFFC
+	
+#define SHORTNUMOFINT	
+	/* the number of interrupt source */
+  #ifdef SHORTNUMOFINT
+	#define NumOfInt	16
+  #else
+	#define NumOfInt	32
+  #endif
+	/* for compatibility for linux */
+	#define NR_IRQS (NumOfInt)
+	
+	/* Interrupt Vector table address */
+#ifdef SHORTNUMOFINT
+	#define IntVectorTable          iSRAMTop-(NumOfInt << 3)  //internal SRAM area
+#else
+	#define IntVectorTable          iSRAMTop-(NumOfInt << 2)  //internal SRAM area
+#endif
+	#define IntVectorTableEnd       iSRAMTop
+	//#define IntVectorTable          SDRAMTop-(NumOfInt << 2)  //SDRAM area
+	//#define IntVectorTableEnd       SDRAMTop
+	
+	/*
+	 * Interrupt Vector Table
+	 */
+	
+	#define pIVT_TIMER0     (*(volatile unsigned *)(IntVectorTable))
+	#define pIVT_TIMER2     (*(volatile unsigned *)(IntVectorTable+0x04))
+	#define pIVT_TIMER3     (*(volatile unsigned *)(IntVectorTable+0x08))
+	#define pIVT_USB        (*(volatile unsigned *)(IntVectorTable+0x0C))
+	#define pIVT_TIMER4     (*(volatile unsigned *)(IntVectorTable+0x10))	 // ADD BY HIS
+	#define pIVT_DMA        (*(volatile unsigned *)(IntVectorTable+0x14))
+	#define pIVT_TIMER1     (*(volatile unsigned *)(IntVectorTable+0x18))
+	#define pIVT_I2C        (*(volatile unsigned *)(IntVectorTable+0x1C))
+	#define pIVT_COMMRX     (*(volatile unsigned *)(IntVectorTable+0x20))
+	#define pIVT_COMMTX     (*(volatile unsigned *)(IntVectorTable+0x24))
+	#define pIVT_GPIO       (*(volatile unsigned *)(IntVectorTable+0x28))
+	#define pIVT_EXT0       (*(volatile unsigned *)(IntVectorTable+0x2C))
+	#define pIVT_EXT1       (*(volatile unsigned *)(IntVectorTable+0x30))
+	#define pIVT_EXT2       (*(volatile unsigned *)(IntVectorTable+0x34))
+	#define pIVT_EXT3       (*(volatile unsigned *)(IntVectorTable+0x38))
+	
+	
+	/*
+	 *  define the interrupt source corresponing to each interrupt register bits 
+	 */
+	
+	#define INT_TIMER0      0x00000001
+	#define INT_TIMER2      0x00000002
+	#define INT_TIMER3      0x00000004
+	#define INT_USB	        0x00000008
+	#define INT_TIMER4      0x00000010	
+	#define INT_DMA	        0x00000020
+	#define INT_TIMER1      0x00000040
+	#define INT_I2C	        0x00000080
+	#define INT_COMMRX      0x00000100
+	#define INT_COMMTX      0x00000200
+	#define INT_GPIO        0x00000400
+	#define INT_EXT0        0x00000800
+	#define INT_EXT1        0x00001000
+	#define INT_EXT2        0x00002000
+	#define INT_EXT3        0x00004000
+
+	#define INT_N_TIMER0    	0
+	#define INT_N_TIMER2      1
+	#define INT_N_TIMER3      2
+	#define INT_N_USB	     	3
+	#define INT_N_TIMER4      4
+	#define INT_N_DMA	      	5
+	#define INT_N_TIMER1      6
+	#define INT_N_I2C	      	7
+	#define INT_N_COMMRX    	8
+	#define INT_N_COMMTX   	9
+	#define INT_N_GPIO        	10
+	#define INT_N_EXT0        	11
+	#define INT_N_EXT1        	12
+	#define INT_N_EXT2        	13
+	#define INT_N_EXT3        	14
+
+	
+	
+	#define EnableFIQ()     (rINTCON = ((rINTCON) & (0x0E)))
+	#define DisableFIQ()    (rINTCON = ((rINTCON) | (0x01)))
+	
+	#define EnableIRQ()     (rINTCON = ((rINTCON )& (0x0D)))
+	#define DisableIRQ()    (rINTCON = ((rINTCON) | (0x02)))
+	
+	#define EnableGMask()   (rINTCON = ((rINTCON) | (0x08)))
+	#define DisableGMask()  (rINTCON = ((rINTCON) & (0x07)))
+	
+	#define EnableInt(x)    (rINTMSK = ((rINTMSK) & (~(x))))
+	#define DisableInt(x)   (rINTMSK = ((rINTMSK) | (x)))
+
+
+//	#define OS_TIMER        INT_TIMER4 // used in irq.c?
+
+#endif /* End of __irqs_h */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/memory.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/memory.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/memory.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/memory.h	2005-11-08 09:06:44.000000000 +0900
@@ -0,0 +1,30 @@
+/*
+ * linux/include/asm-arm/arch-s5c7375/memory.h
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *		Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x01a00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((unsigned long) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((unsigned long) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/param.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/param.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/param.h	2005-11-08 09:06:44.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/s5c7375.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/s5c7375.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/s5c7375.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/s5c7375.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,384 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/s5c7375.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+
+#ifndef __S5C7375_H
+#define __S5C7375_H
+
+/* keywoard : ClockParameter */
+#define  FCLK 162000000
+#define ECLK 27000000
+#define  BUSWIDTH (32)
+
+
+/* keywoard : Phy2Vir */
+#define S5C7375_MEM_SIZE     (CONFIG_DRAM_SIZE) 
+#define MEM_SIZE            S5C7375_MEM_SIZE
+
+#define PA_SDRAM_BASE         CONFIG_DRAM_BASE/* used in asm/arch/arch.c     */
+
+#ifndef HYOK_ROMFS_BOOT
+#define ZIP_RAMDISK_SIZE      (256*1024)  /* used in asm/arch/arch.c  */
+#define RAMDISK_DN_ADDR       (PA_SDRAM_BASE + 0x00400000 - ZIP_RAMDISK_SIZE) /* used in asm/arch/arch.c     */
+#else
+#define ZIP_RAMDISK_SIZE	(0x00040000)  /* used in asm/arch/arch.c  */
+#define RAMDISK_DN_ADDR	(0x00400000 - ZIP_RAMDISK_SIZE)
+#endif
+
+/* if CONFIG_BLK_DEV_RAM_SIZE not defined */
+#define BLK_DEV_RAM_SIZE      (256*1024)  
+
+	#define rSCRBase     0x40000000     /* base of the System Configuration register */
+	#define rASICBase    0x0C000000	    /* base of all I/O module register */
+	#define rPTEAKBase   0x08F00000     /* preload TeakLite base address */
+	
+	
+	/* define the base of each I/O devices */
+	#define rARM920T     rASICBase
+	#define rMEMBase     (rASICBase+0x10000) /* Memory controller */
+	#define rDMABase     (rASICBase+0x20000) /* DMA controller */
+	#define rLCDBase     (rASICBase+0x30000) /* LCD controller */
+	#define rEMACBase    (rASICBase+0x40000) /* Ethernet MAC controller */
+	#define rXMEMBase    (rASICBase+0x50000) /* TeakLite X memory(16KB) */
+	#define rYMEMBase    (rASICBase+0x60000) /* TeakLite Y memory(8KB) */
+	#define rPMEMBase    (rASICBase+0x70000) /* TeakLite P memory(32KB) */
+	#define rAPBBase     (rASICBase+0x80000) /* AHB2APB bridge */
+	
+	/* Preload TeakLite address */
+	#define rPPDataArea  (rPTEAKBase+0x00)   /* preload TeakLite P data area */
+	#define rPXDataArea  (rPTEAKBase+0x40000)/* preload TeakLite X data area */
+	#define rPYDataArea  (rPTEAKBase+0x60000)/* preload TeakLite Y data area */
+	
+	/************ AHB2APB bridge I/O device register *************/ 
+	#define rBRIDGEBase  (rAPBBase+0x000)    /* APB Bridge interface */
+	#define rSCIBase     (rAPBBase+0x400)    /* Smart card interface */
+	#define rUSBBase     (rAPBBase+0x5800)    /* USB */
+	#define rPPIBase     (rAPBBase+0xC00)    /* IEE1284, Parallel port */
+	#define rIICBase     (rAPBBase+0x1000)   /* IIC */
+	#define rTIMEBase    (rAPBBase+0x1400)   /* Timer */
+	#define rRTCBase     (rAPBBase+0x1800)   /* Real time clock */
+	#define rWDTBase     (rAPBBase+0x1C00)   /* Watch Dog Timer */
+	#define rIOPBase     (rAPBBase+0x2000)   /* Programmable I/O port */
+	#define rRPCBase     (rAPBBase+0x2400)   /* Memory remap */ 
+	#define rINTBase     (rAPBBase+0x2800)   /* Interrupt controller */
+	#define rSSPBase     (rAPBBase+0x2C00)   /* SSP interface */
+	#define rKMI0Base    (rAPBBase+0x3000)   /* KMI0 */
+	#define rUART0Base   (rAPBBase+0x3400)   /* UART0 */
+	#define rUART1Base   (rAPBBase+0x3800)   /* UART1 */
+	#define rPMBase      (rAPBBase+0x3C00)   /* Power manager */
+	#define rTEAKBase    (rAPBBase+0x4000)   /* Teaklite Z space */
+	#define rKMI1Base    (rAPBBase+0x4800)   /* KMI1 */
+	#define rMISCBase    (rAPBBase+0x4C00)   /* Miscellaneous */
+	#define rEXT0Base    (rAPBBase+0x5000)   /* External 0 */
+	#define rEXT1Base    (rAPBBase+0x5400)   /* External 1 */
+	#define rEXT2Base    (rAPBBase+0x5800)   /* External 2 */
+	#define rEXT3Base    (rAPBBase+0x5C00)   /* External 3 */
+	#define rPCMCIABase  (rAPBBase+0x9000)   /* Programmable I/O port */
+	
+	/* Memory Controller(32bit)*/
+	#define rSDRAMCFG0    (*(volatile unsigned *)(rMEMBase+0x00))	/* SDRAM config0 register */
+	#define rSDRAMCFG1    (*(volatile unsigned *)(rMEMBase+0x04))	/* SDRAM config1 register */
+	#define rSDRAMRefresh (*(volatile unsigned *)(rMEMBase+0x08))	/* SDRAM refresh register */
+	#define rSDRAMWB      (*(volatile unsigned *)(rMEMBase+0x0C))	/* SDRAM WB timeout register */
+	// new static memory controller version
+	#define rSMCBANK0     (*(volatile unsigned *)(rMEMBase+0x10))
+	#define rSMCBANK1     (*(volatile unsigned *)(rMEMBase+0x14))
+	#define rSMCBANK2     (*(volatile unsigned *)(rMEMBase+0x18))
+	#define rSMCBANK3     (*(volatile unsigned *)(rMEMBase+0x1C))
+	
+	/* DMA Controller(32bit)*/ 
+	// DMA control register 
+	#define rDMACON0     (*(volatile unsigned *)(rDMABase+0x00))	
+	#define rDMACON1     (*(volatile unsigned *)(rDMABase+0x40))	
+	#define rDMACON2     (*(volatile unsigned *)(rDMABase+0x80))	
+	#define rDMACON3     (*(volatile unsigned *)(rDMABase+0xC0))	
+	#define rDMACON4     (*(volatile unsigned *)(rDMABase+0x100))	
+	#define rDMACON5     (*(volatile unsigned *)(rDMABase+0x140))	
+	
+	// DMA Source Start address register 
+	#define rDMASAR0     (*(volatile unsigned *)(rDMABase+0x04))	
+	#define rDMASAR1     (*(volatile unsigned *)(rDMABase+0x44))	
+	#define rDMASAR2     (*(volatile unsigned *)(rDMABase+0x84))	
+	#define rDMASAR3     (*(volatile unsigned *)(rDMABase+0xC4))	
+	#define rDMASAR4     (*(volatile unsigned *)(rDMABase+0x104))	
+	#define rDMASAR5     (*(volatile unsigned *)(rDMABase+0x144))	
+	
+	// DMA Destination address register
+	#define rDMADAR0     (*(volatile unsigned *)(rDMABase+0x08))
+	#define rDMADAR1     (*(volatile unsigned *)(rDMABase+0x48))
+	#define rDMADAR2     (*(volatile unsigned *)(rDMABase+0x88))
+	#define rDMADAR3     (*(volatile unsigned *)(rDMABase+0xC8))
+	#define rDMADAR4     (*(volatile unsigned *)(rDMABase+0x108))
+	#define rDMADAR5     (*(volatile unsigned *)(rDMABase+0x148))
+	
+	// DMA Terminal Counter register 
+	#define rDMATCR0     (*(volatile unsigned *)(rDMABase+0x0C))
+	#define rDMATCR1     (*(volatile unsigned *)(rDMABase+0x4C))
+	#define rDMATCR2     (*(volatile unsigned *)(rDMABase+0x8C))
+	#define rDMATCR3     (*(volatile unsigned *)(rDMABase+0xCC))
+	#define rDMATCR4     (*(volatile unsigned *)(rDMABase+0x10C))
+	#define rDMATCR5     (*(volatile unsigned *)(rDMABase+0x14C))
+	
+	// DMA pending & priority register
+	#define rDMAPRI      (*(volatile unsigned *)(rDMABase+0x1F8))
+	#define rDMAPND      (*(volatile unsigned *)(rDMABase+0x1FC))
+	
+	/* LCD(primecell) Controller(32bit)*/
+	
+	/* APB Base register map */ 
+	/* 1.APB pulse width control register */
+	#define rAPBCON0     (*(volatile unsigned *)(rBRIDGEBase+0x00))
+	#define rAPBCON1     (*(volatile unsigned *)(rBRIDGEBase+0x04))
+	#define rAPBCON2     (*(volatile unsigned *)(rBRIDGEBase+0x08))
+	#define rAPBCON3     (*(volatile unsigned *)(rBRIDGEBase+0x0C))
+	
+	/* 2.Smart card interface */
+	
+	
+	/* 3.USB register(8bit)*/
+
+	
+	// Non indexed registers
+	#define USB_R0       (volatile unsigned *)(rUSBBase+0x00)    // 0x00 - Function address register 
+	#define USB_R1       (volatile unsigned *)(rUSBBase+0x04)    // 0x01 - Power management register 
+	
+	#define USB_R2       (volatile unsigned *)(rUSBBase+0x08)    // 0x02 - Endpoint interrupt1 register (EP0-EP7) 
+	#define USB_R3       (volatile unsigned *)(rUSBBase+0x0c)    // 0x03 - Endpoint interrupt2 register (EP8-EP15)
+	#define USB_R4       (volatile unsigned *)(rUSBBase+0x10)    //- Out interrupt register bank1 
+	#define USB_R5       (volatile unsigned *)(rUSBBase+0x14)    //- Out interrupt register bank2
+	#define USB_R6       (volatile unsigned *)(rUSBBase+0x18)    // 0x06 - USB interrpt register 
+	
+	#define USB_R7       (volatile unsigned *)(rUSBBase+0x1C)    // 0x07 - Endpoint interrupt enable1 register (EP0-EP7)
+	#define USB_R8       (volatile unsigned *)(rUSBBase+0x20)    // 0x08 - Endpoint interrupt enable2 register (EP8-EP15) 
+	#define USB_R9       (volatile unsigned *)(rUSBBase+0x24)    //- Out interrupt enable register bank1 
+	#define USB_R10      (volatile unsigned *)(rUSBBase+0x28)    //- Out interrupt enable register bank2 
+	#define USB_R11      (volatile unsigned *)(rUSBBase+0x2C)    // 0x0B - USB interrupt enable register 
+	
+	#define USB_R12      (volatile unsigned *)(rUSBBase+0x30)    // 0x0C - Frame number1 register 
+	#define USB_R13      (volatile unsigned *)(rUSBBase+0x34)    // 0x0D - Frame number2 register 
+	#define USB_R14      (volatile unsigned *)(rUSBBase+0x38)    // 0x0E - Index register 
+	
+	// Common indexed registers
+	#define USB_IR1      (volatile unsigned *)(rUSBBase+0x40)    // 0x10 - Max packet register 
+	
+	// In indexed registers
+	#define USB_IR2      (volatile unsigned *)(rUSBBase+0x44)    // 0x11 - IN CSR1 register (EP0 CSR register)
+	#define USB_IR3      (volatile unsigned *)(rUSBBase+0x48)    // 0x12 - IN CSR2 register 
+	
+	// Out indexed registers 
+	#define USB_OR1      (volatile unsigned *)(rUSBBase+0x4C)    //- OUT max packet register 
+	#define USB_OR2      (volatile unsigned *)(rUSBBase+0x50)    // 0x14 - OUT CSR1 register 
+	#define USB_OR3      (volatile unsigned *)(rUSBBase+0x54)    // 0x15 - OUT CSR2 register 
+	#define USB_OR4      (volatile unsigned *)(rUSBBase+0x58)    // 0x16 - OUT FIFO write Count1 register 
+	#define USB_OR5      (volatile unsigned *)(rUSBBase+0x5c)    // 0x17 - OUT FIFO write Count2 register 
+	
+	// FIFO registers
+	#define EP0_FIFO     (volatile unsigned *)(rUSBBase+0x80)    // 0x20 - EP0 FIFO
+	#define EP1_FIFO     (volatile unsigned *)(rUSBBase+0x84)	 // 0x21 - EP1 FIFO
+	#define EP2_FIFO     (volatile unsigned *)(rUSBBase+0x88)	 // 0x22 - EP2 FIFO
+	#define EP3_FIFO     (volatile unsigned *)(rUSBBase+0x8C)	 // 0x23 - EP3 FIFO
+
+	
+	/* 4.IEEE 1284(PPI)(8bit)*/
+	
+	/* 5.IIC register(8bit)*/
+	/* 6.TIMER register(16bit)*/
+	#define rT0CTR       (*(volatile int *)(rTIMEBase+0x00))
+	#define rT0PSR       (*(volatile int *)(rTIMEBase+0x04))
+	#define rT0LDR       (*(volatile int *)(rTIMEBase+0x08))
+	#define rT0ISR       (*(volatile int *)(rTIMEBase+0x0C))
+	
+	#define rT1CTR       (*(volatile int *)(rTIMEBase+0x10))
+	#define rT1PSR       (*(volatile int *)(rTIMEBase+0x14))
+	#define rT1LDR       (*(volatile int *)(rTIMEBase+0x18))
+	#define rT1ISR       (*(volatile int *)(rTIMEBase+0x1C))
+	
+	#define rT2CTR       (*(volatile int *)(rTIMEBase+0x20))
+	#define rT2PSR       (*(volatile int *)(rTIMEBase+0x24))
+	#define rT2LDR       (*(volatile int *)(rTIMEBase+0x28))
+	#define rT2ISR       (*(volatile int *)(rTIMEBase+0x2C))
+	
+	#define rT3CTR       (*(volatile int *)(rTIMEBase+0x30))
+	#define rT3PSR       (*(volatile int *)(rTIMEBase+0x34))
+	#define rT3LDR       (*(volatile int *)(rTIMEBase+0x38))
+	#define rT3ISR       (*(volatile int *)(rTIMEBase+0x3C))
+	
+	#define rT4CTR       (*(volatile int *)(rTIMEBase+0x40))
+	#define rT4PSR       (*(volatile int *)(rTIMEBase+0x44))
+	#define rT4LDR       (*(volatile int *)(rTIMEBase+0x48))
+	#define rT4ISR       (*(volatile int *)(rTIMEBase+0x4C))
+	
+	#define rTTMR       (*(volatile int *)(rTIMEBase+0x80))
+	#define rTTIR       (*(volatile int *)(rTIMEBase+0x84))
+	#define rTTCR       (*(volatile int *)(rTIMEBase+0x88))
+	
+	
+	/* 7.RTC register(8bit)*/
+	#define rRTCCON	     (*(volatile unsigned *)(rRTCBase+0x00)) /* RTC control register */
+	#define rRTCRST	     (*(volatile unsigned *)(rRTCBase+0x04)) /* RTC round reset register */
+	#define rRTCALM	     (*(volatile unsigned *)(rRTCBase+0x08)) /* RTC alarm register */
+	#define rALMSEC	     (*(volatile unsigned *)(rRTCBase+0x0C)) /* Alarm second data register */
+	#define rALMMIN	     (*(volatile unsigned *)(rRTCBase+0x10))
+	#define rALMHOUR     (*(volatile unsigned *)(rRTCBase+0x14)) /* Alarm hour data register */
+	#define rALMDATE     (*(volatile unsigned *)(rRTCBase+0x18)) /* Alarm date data register */
+	#define rALMDAY	     (*(volatile unsigned *)(rRTCBase+0x1C)) /* Alarm day data register */
+	#define rALMMON	     (*(volatile unsigned *)(rRTCBase+0x20)) /* Alarm mon data register */
+	#define rALMYEAR     (*(volatile unsigned *)(rRTCBase+0x24)) /* Alarm year data register */
+	#define rBCDSEC	     (*(volatile unsigned *)(rRTCBase+0x28)) /* BCD second data register */
+	#define rBCDMIN	     (*(volatile unsigned *)(rRTCBase+0x2C)) /* BCD minute data register */
+	#define rBCDHOUR     (*(volatile unsigned *)(rRTCBase+0x30)) /* BCD hour data register */
+	#define rBCDDATE     (*(volatile unsigned *)(rRTCBase+0x34)) /* BCD day data register */
+	#define rBCDDAY	     (*(volatile unsigned *)(rRTCBase+0x38)) /* BCD day data register */
+	#define rBCDMON	     (*(volatile unsigned *)(rRTCBase+0x3C)) /* BCD month data register */
+	#define rBCDYEAR     (*(volatile unsigned *)(rRTCBase+0x40)) /* BCD year  data register */
+	#define rRTCIM       (*(volatile unsigned *)(rRTCBase+0x44)) /* BCD year  data register */
+	#define rRTCPEND     (*(volatile unsigned *)(rRTCBase+0x48)) /* BCD year  data register */
+	
+	
+	/* 8.Watch Dog Timer register(8bit)*/
+	
+	/* 9.Programmable I/O port */
+	#define rGIOPCON     (*(volatile unsigned *)(rIOPBase+0x00)) /* Port direction register */
+	#define rGIOPDATA    (*(volatile unsigned *)(rIOPBase+0x04)) /* Data register */
+	#define rGIOPINTEN   (*(volatile unsigned *)(rIOPBase+0x08)) /* Interrupt enable register */
+	#define rGIOPLEVEL   (*(volatile unsigned *)(rIOPBase+0x0C)) /* Ative level indication register */
+	#define rGIOPPEND    (*(volatile unsigned *)(rIOPBase+0x10)) /* Interrupt pending register */
+	
+	
+	/* 10.Interrupt controller */		//0xc082800
+	#define rINTCON      (*(volatile unsigned *)(rINTBase+0x00)) /* interrupt control register */
+	#define rINTPND	     (*(volatile unsigned *)(rINTBase+0x04)) /* interrupt pending register */
+	#define rINTMOD	     (*(volatile unsigned *)(rINTBase+0x08)) /* interrupt mode register */
+	#define rINTMSK	     (*(volatile unsigned *)(rINTBase+0x0C)) /* interrupt mask register */
+	#define rINTLEVEL    (*(volatile unsigned *)(rINTBase+0x10)) 
+	#define rIRQPSLV0    (*(volatile unsigned *)(rINTBase+0x14)) /* IRQ priority of slave register0 */
+	#define rIRQPSLV1    (*(volatile unsigned *)(rINTBase+0x18)) /* IRQ priority of slave register1 */
+	#define rIRQPSLV2    (*(volatile unsigned *)(rINTBase+0x1C)) /* IRQ priority of slave register2 */
+	#define rIRQPSLV3    (*(volatile unsigned *)(rINTBase+0x20)) /* IRQ priority of slave register3 */
+	#define rIRQPMST     (*(volatile unsigned *)(rINTBase+0x24)) /* IRQ priority of master register */
+	#define rIRQCSLV0    (*(volatile unsigned *)(rINTBase+0x28)) /* current IRQ priority of slave register0 */
+	#define rIRQCSLV1    (*(volatile unsigned *)(rINTBase+0x2C)) /* current IRQ priority of slave register1 */
+	#define rIRQCSLV2    (*(volatile unsigned *)(rINTBase+0x30)) /* current IRQ priority of slave register2 */
+	#define rIRQCSLV3    (*(volatile unsigned *)(rINTBase+0x34)) /* current IRQ priority of slave register3 */
+	#define rIRQCMST     (*(volatile unsigned *)(rINTBase+0x38)) /* current IRQ priority of master register */
+	#define rIRQISPR     (*(volatile unsigned *)(rINTBase+0x3C)) /* IRQ service pending register */
+	#define rIRQISPC     (*(volatile unsigned *)(rINTBase+0x40)) /* IRQ service clear register */
+	#define rFIQPSLV0    (*(volatile unsigned *)(rINTBase+0x44)) /* FIQ priority of slave register0 */
+	#define rFIQPSLV1    (*(volatile unsigned *)(rINTBase+0x48)) /* FIQ priority of slave register1 */
+	#define rFIQPSLV2    (*(volatile unsigned *)(rINTBase+0x4C)) /* FIQ priority of slave register2 */
+	#define rFIQPSLV3    (*(volatile unsigned *)(rINTBase+0x50)) /* FIQ priority of slave register3 */
+	#define rFIQPMST     (*(volatile unsigned *)(rINTBase+0x54)) /* FIQ priority of master register */
+	#define rFIQCSLV0    (*(volatile unsigned *)(rINTBase+0x58)) /* current FIQ priority of slave register0 */
+	#define rFIQCSLV1    (*(volatile unsigned *)(rINTBase+0x5C)) /* current FIQ priority of slave register1 */
+	#define rFIQCSLV2    (*(volatile unsigned *)(rINTBase+0x60)) /* current FIQ priority of slave register2 */
+	#define rFIQCSLV3    (*(volatile unsigned *)(rINTBase+0x64)) /* current FIQ priority of slave register3 */
+	#define rFIQCMST     (*(volatile unsigned *)(rINTBase+0x68)) /* current FIQ priority of master register */
+	#define rFIQISPR     (*(volatile unsigned *)(rINTBase+0x6C)) /* FIQ service pending register */
+	#define rFIQISPC     (*(volatile unsigned *)(rINTBase+0x70)) /* FIQ service clear register */
+	#define rPOLARITY    (*(volatile unsigned *)(rINTBase+0x74))
+	#define rIVEC_ADDR   (*(volatile unsigned *)(rINTBase+0x78))
+	#define rFVEC_ADDR   (*(volatile unsigned *)(rINTBase+0x7C))
+	
+	/* 11.SSP(prime cell) Synchronous serial port register(16bit) */
+	
+	
+	/* 12.KMI0(prime cell) Keyboard/Mouse interface register(8bit) */
+	
+	/* 13.KMI1(prime cell) Keyboard/Mouse interface register(8bit) */
+	
+	
+	/* 14.UART0(prime cell) register(8bit)*/
+	
+	
+	/* 15.UART1(prime cell) register(8bit)*/
+	
+	
+	/* 16.Power manager register */
+	#define rPLLCON      (*(volatile unsigned *)(rPMBase+0x00)) /* pll configuration register */
+	#define rMODCON      (*(volatile unsigned *)(rPMBase+0x04)) /* mode control register */
+	#define rLOCKCON     (*(volatile unsigned *)(rPMBase+0x08)) /* Lock-up timer */
+	#define rHCLKCON     (*(volatile unsigned *)(rPMBase+0x0C)) /* Normal system clock control register */
+	
+	
+	/* 17.Teak base register */
+	
+	//-    timer register 
+	/*
+	 *	Bits 	Name 	Type 	Function 	 
+	 *	15:12 	-	Read 	Reserved. Read only as zero 	 
+	 *	11:10 	M 	Read/write 	Operating mode :
+	 *				00 : Free running timer mode(default) 	01 : Periodic timer mode. 	 
+	 *				10 : Free running counter mode. 		11 : Periodic counter mode. 	 
+	 *	9:8 	ES 	Read/write 	External input active edge selection. 
+	 *				00 : Positive edge(default). 01 : Negative edge.
+	 *				10 : Both positive and negative edge. 11 : unused. 	 
+	 *	7 	-	Read 	Reserved. Read only as zero 	 
+	 *	6 	OM 	Read/write 	Time output mode. 0 : Toggle mode(default). 1 : Pulse mode. 	 
+	 *	5 	UDS 	Read/write 	Up/down counting control selection. 
+	 *				0 : Up/down is controlled by UD field of TxCTR register(default).
+	 *				1 : Up/down is controlled by EXTUD[4:0]input register. 	 
+	 *	4 	UD 	Read/write 	Up/down counting selection. 
+	 *				0 : Down counting(default). 1 : Up counting. 	 
+	 *				This bit affects the counting of timer only when UDS bit is LOW. 	 
+	 *	3 	-	Read 	Reserved. Read only as zero 	 
+	 *	2 	OE 	Read/write 	Output enable.
+	 *				0 : Disable timer outputs(default). 1 : Enable timer outputs. 	 
+	 *				This bit affects the generation of timer interrupt only when TE bit is HIGH. 	 
+	 *	1 	IE 	Read/write 	Interrupt enable. 0 : Toggle mode(default). 1 : Pulse mode. 	 
+	 *				This bit affects the generation of timer output only when TE bit is HIGH. 	 
+	 *	0 	TE 	Read/write 	Timer enable. 0 : Diable timer(default). 1 : Enable timer. 	 
+	 */
+	#define TMR_TE_DISABLE				0x0000
+	#define TMR_TE_ENABLE				0x0001
+	
+	#define TMR_IE_TOGGLE				0x0000
+	#define TMR_IE_PULSE				0x0002
+	
+	#define TMR_OE_DISABLE				0x0000
+	#define TMR_OE_ENABLE				0x0004
+	
+	#define TMR_UD_DOWN				0x0000
+	#define TMR_UD_UP					0x0010
+	
+	#define TMR_UDS_TxCTR				0x0000
+	#define TMR_UDS_EXTUD				0x0020
+	
+	#define TMR_OM_TOGGLE				0x0000
+	#define TMR_OM_PULSE				0x0040
+	
+	#define TMR_ES_POS					0x0000
+	#define TMR_ES_NEG					0x0100
+	#define TMR_ES_BOTH				0x0200
+	
+	#define TMR_M_FREE_TIMER			0x0000
+	#define TMR_M_PERIODIC_TIMER		0x0400
+	#define TMR_M_FREE_COUNTER		0x0800
+	#define TMR_M_PERIODIC_COUNTER	0x0C00
+
+	
+	/* 18.memory stick Host controller-External Device 1*/
+	#define COMD_REG  (*(volatile unsigned short *)(rEXT1Base+0x0))     /* Command Register */
+	#define STAT_REG  (*(volatile unsigned short *)(rEXT1Base+0x4))  /* Status Register */
+	#define CONT_REG  (*(volatile unsigned short *)(rEXT1Base+0x4))  /* Control Register */
+	#define RECV_REG  (*(volatile unsigned short *)(rEXT1Base+0x8))  /* Receive Data Register */
+	#define SEND_REG  (*(volatile unsigned short *)(rEXT1Base+0x8))  /* Send Data Register */
+	#define INTD_REG  (*(volatile unsigned short *)(rEXT1Base+0xc))  /* Interrupt Data Register */
+	#define INTC_REG  (*(volatile unsigned short *)(rEXT1Base+0xc))  /* Interrupt Control Register */
+	#define PARD_REG  (*(volatile unsigned short *)(rEXT1Base+0x10)) /* Parallel Data Register */
+	#define PARC_REG  (*(volatile unsigned short *)(rEXT1Base+0x10)) /* Parallel Control Register */
+	#define CONT2_REG  (*(volatile unsigned short *)(rEXT1Base+0x14))
+	#define ACD_REG  (*(volatile unsigned short *)(rEXT1Base+0x18))
+
+
+	/* Searching Keyword: OS_Timer */
+	#define SYS_TIMER03_PRESCALER   0x6B      /* for System Timer, 4usec(3.996)  */
+	#define SYS_TIMER03_DIVIDER	0x01
+
+	#define RESCHED_PERIOD          10      /* 10 ms */
+	#define __KERNEL_HZ			100
+
+#endif /* __S5C7375_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/sizes.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/sizes.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/sizes.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/sizes.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/system.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/system.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/system.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,63 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/system.h
+ *
+ *  Copyright (C) 2002 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+/* 
+ * This functions used in arm/kernel/process.c 
+ */
+
+#ifdef CONFIG_LEDS
+extern void Led_Display(int);
+#endif
+
+static void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+#ifndef CONFIG_LEDS
+	cpu_do_idle();
+#else
+	int i;
+	Led_Display(1);
+	rCLKCON |= (1<<2);	/* Enter IDLE Mode */
+	for ( i = 0; i <100;i++);
+	rCLKCON &= ~(1<<2);
+	Led_Display(4);
+#endif
+
+}
+
+static inline void arch_reset(char mode)
+{
+ 	/* machine should reboot..... */
+ 	mdelay(5000);
+ 	panic("Watchdog timer reset failed!\n");
+ 	printk(" Jump to address 0 \n");
+ 	cpu_reset(0);
+}
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/time.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/time.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/time.h	2005-11-08 09:06:44.000000000 +0900
@@ -0,0 +1,88 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/time.h
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *                      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/arch/s5c7375.h>
+/*
+ *	Bits 	Name 	Type 	Function 	 
+ *	15:12 	-	Read 	Reserved. Read only as zero 	 
+ *	11:10 	M 	Read/write 	Operating mode :
+ *				00 : Free running timer mode(default) 	01 : Periodic timer mode. 	 
+ *				10 : Free running counter mode. 		11 : Periodic counter mode. 	 
+ *	9:8 	ES 	Read/write 	External input active edge selection. 
+ *				00 : Positive edge(default). 01 : Negative edge.
+ *				10 : Both positive and negative edge. 11 : unused. 	 
+ *	7 	-	Read 	Reserved. Read only as zero 	 
+ *	6 	OM 	Read/write 	Time output mode. 0 : Toggle mode(default). 1 : Pulse mode. 	 
+ *	5 	UDS 	Read/write 	Up/down counting control selection. 
+ *				0 : Up/down is controlled by UD field of TxCTR register(default).
+ *				1 : Up/down is controlled by EXTUD[4:0]input register. 	 
+ *	4 	UD 	Read/write 	Up/down counting selection. 
+ *				0 : Down counting(default). 1 : Up counting. 	 
+ *				This bit affects the counting of timer only when UDS bit is LOW. 	 
+ *	3 	-	Read 	Reserved. Read only as zero 	 
+ *	2 	OE 	Read/write 	Output enable.
+ *				0 : Disable timer outputs(default). 1 : Enable timer outputs. 	 
+ *				This bit affects the generation of timer interrupt only when TE bit is HIGH. 	 
+ *	1 	IE 	Read/write 	Interrupt enable. 0 : Toggle mode(default). 1 : Pulse mode. 	 
+ *				This bit affects the generation of timer output only when TE bit is HIGH. 	 
+ *	0 	TE 	Read/write 	Timer enable. 0 : Diable timer(default). 1 : Enable timer. 	 
+ */
+
+#define TMR_TE_DISABLE				0x0000
+#define TMR_TE_ENABLE				0x0001
+
+#define TMR_IE_TOGGLE				0x0000
+#define TMR_IE_PULSE				0x0002
+
+#define TMR_OE_DISABLE				0x0000
+#define TMR_OE_ENABLE				0x0004
+
+#define TMR_UD_DOWN				0x0000
+#define TMR_UD_UP					0x0010
+
+#define TMR_UDS_TxCTR				0x0000
+#define TMR_UDS_EXTUD				0x0020
+
+#define TMR_OM_TOGGLE				0x0000
+#define TMR_OM_PULSE				0x0040
+
+#define TMR_ES_POS					0x0000
+#define TMR_ES_NEG					0x0100
+#define TMR_ES_BOTH				0x0200
+
+#define TMR_M_FREE_TIMER			0x0000
+#define TMR_M_PERIODIC_TIMER		0x0400
+#define TMR_M_FREE_COUNTER		0x0800
+#define TMR_M_PERIODIC_COUNTER	0x0C00
+
+
+
+
+/*
+ * simpler new version of gettimeoffset
+ * by Hyok S. Choi
+ */
+#define TICKS_PER_uSEC                  24
+#define CLOCKS_PER_USEC	(2* ECLK/ (SYS_TIMER03_PRESCALER +1))
+							//(ECLK/1000000) /* (ARM_CLK/1000000) */
+							/* this is the newer version */
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/timex.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/timex.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/timex.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/timex.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                           Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/arch/s5c7375.h>
+
+#define CLOCK_TICK_RATE	 (ECLK/ (SYS_TIMER03_PRESCALER +1))
+
+	/*
+	 * 27M / (0x6B +1) = 4usec
+	 */
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/uncompress.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/uncompress.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/uncompress.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/uncompress.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,58 @@
+/*
+ *  linux/include/asm-armnommu/arch-s5c7375/uncompress.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm-armnommu/hardware/dcc.h>
+
+#ifndef __UNCOMPRESS_H__
+#define __UNCOMPRESS_H__
+
+/*
+ * just use DCC JTAG1 port
+ */
+static inline void puts(const char *s)
+{
+	dcc_puts(s);
+}
+
+static void puts_hex(unsigned long i)
+{
+	char lhex_buf[]="0x00000000";
+	unsigned long ii,v;
+
+	for(ii=9;ii>1;ii--)
+	{
+		v=(((0x0000000F << ((9-ii)*4)) & i) >> ((9-ii)*4));
+		if(v>9)
+			lhex_buf[ii]=(char)('A'+v-10);
+		else
+			lhex_buf[ii]=(char)('0'+v);
+	}
+
+	dcc_puts(lhex_buf);
+}
+
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/vmalloc.h linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/vmalloc.h
--- linux-2.6.14-uc0/include/asm-arm/arch-s5c7375/vmalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/arch-s5c7375/vmalloc.h	2005-11-08 09:06:43.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-armnommu/arch-s5c7375/vmalloc.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_S5C7375_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_S5C7375_SDRAM_SIZE)   
diff -Naur linux-2.6.14-uc0/include/asm-arm/bugs.h linux-2.6.14-uc0-hsc0/include/asm-arm/bugs.h
--- linux-2.6.14-uc0/include/asm-arm/bugs.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/bugs.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/bugs.h
  *
  *  Copyright (C) 1995-2003 Russell King
+ *  Modified for uClinux, 2003 Hyok S. Choi
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -10,8 +11,12 @@
 #ifndef __ASM_BUGS_H
 #define __ASM_BUGS_H
 
+#ifdef CONFIG_MMU
 extern void check_writebuffer_bugs(void);
 
 #define check_bugs() check_writebuffer_bugs()
+#else
+#define check_bugs() do { } while(0)
+#endif
 
 #endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/cacheflush.h linux-2.6.14-uc0-hsc0/include/asm-arm/cacheflush.h
--- linux-2.6.14-uc0/include/asm-arm/cacheflush.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/cacheflush.h	2005-11-09 18:54:24.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/cacheflush.h
  *
  *  Copyright (C) 1999-2002 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -43,6 +44,22 @@
 # endif
 #endif
 
+#if defined(CONFIG_CPU_ARM7TDMI) || defined(CONFIG_CPU_ARM9TDMI)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE v4
+# endif
+#endif
+
+#if defined(CONFIG_CPU_S3C4510B)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE s3c4510b
+# endif
+#endif
+
 #if defined(CONFIG_CPU_ARM920T) || defined(CONFIG_CPU_ARM922T) || \
     defined(CONFIG_CPU_ARM925T) || defined(CONFIG_CPU_ARM1020)
 # define MULTI_CACHE 1
@@ -179,7 +196,9 @@
 #define __cpuc_flush_user_all		cpu_cache.flush_user_all
 #define __cpuc_flush_user_range		cpu_cache.flush_user_range
 #define __cpuc_coherent_kern_range	cpu_cache.coherent_kern_range
+#ifdef CONFIG_MMU
 #define __cpuc_coherent_user_range	cpu_cache.coherent_user_range
+#endif
 #define __cpuc_flush_dcache_page	cpu_cache.flush_kern_dcache_page
 
 /*
@@ -198,14 +217,18 @@
 #define __cpuc_flush_user_all		__glue(_CACHE,_flush_user_cache_all)
 #define __cpuc_flush_user_range		__glue(_CACHE,_flush_user_cache_range)
 #define __cpuc_coherent_kern_range	__glue(_CACHE,_coherent_kern_range)
+#ifdef CONFIG_MMU
 #define __cpuc_coherent_user_range	__glue(_CACHE,_coherent_user_range)
+#endif
 #define __cpuc_flush_dcache_page	__glue(_CACHE,_flush_kern_dcache_page)
 
 extern void __cpuc_flush_kern_all(void);
 extern void __cpuc_flush_user_all(void);
 extern void __cpuc_flush_user_range(unsigned long, unsigned long, unsigned int);
 extern void __cpuc_coherent_kern_range(unsigned long, unsigned long);
+#ifdef CONFIG_MMU
 extern void __cpuc_coherent_user_range(unsigned long, unsigned long);
+#endif
 extern void __cpuc_flush_dcache_page(void *);
 
 /*
@@ -224,6 +247,9 @@
 
 #endif
 
+#ifndef CONFIG_MMU
+#include "cacheflush-nommu.h"
+#else
 /*
  * flush_cache_vmap() is used when creating mappings (eg, via vmap,
  * vmalloc, ioremap etc) in kernel space for pages.  Since the
@@ -251,11 +277,13 @@
 		flush_cache_page(vma, vaddr, page_to_pfn(page));\
 		memcpy(dst, src, len);				\
 	} while (0)
+#endif
 
 /*
  * Convert calls to our calling convention.
  */
 #define flush_cache_all()		__cpuc_flush_kern_all()
+#ifdef CONFIG_MMU
 #ifndef CONFIG_CPU_CACHE_VIPT
 static inline void flush_cache_mm(struct mm_struct *mm)
 {
@@ -333,6 +361,8 @@
  */
 #define flush_icache_page(vma,page)	do { } while (0)
 
+#endif /* CONFIG_MMU */
+
 #define __cacheid_present(val)		(val != read_cpuid(CPUID_ID))
 #define __cacheid_vivt(val)		((val & (15 << 25)) != (14 << 25))
 #define __cacheid_vipt(val)		((val & (15 << 25)) == (14 << 25))
diff -Naur linux-2.6.14-uc0/include/asm-arm/cacheflush-nommu.h linux-2.6.14-uc0-hsc0/include/asm-arm/cacheflush-nommu.h
--- linux-2.6.14-uc0/include/asm-arm/cacheflush-nommu.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/cacheflush-nommu.h	2005-11-08 09:06:49.000000000 +0900
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-arm/cacheflush-nommu.h
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_CACHEFLUSH_NOMMU_H
+#define _ASMARM_CACHEFLUSH_NOMMU_H
+
+/*
+ * Convert calls to our calling convention.
+ */
+#define flush_cache_all()	__cpuc_flush_kern_all()
+
+#define flush_cache_mm(mm) __cpuc_flush_kern_all()
+#define flush_cache_range(vma, start, end)	flush_cache_all()
+
+#define flush_dcache_range(start,len)		flush_cache_all()
+#define flush_dcache_page(page)			flush_cache_all()
+#define flush_icache_user_range(vma,page,addr,len) 	flush_cache_all()
+
+/*
+ * Perform necessary cache operations to ensure that data previously
+ * stored within this range of addresses can be executed by the CPU.
+ */
+#define flush_icache_range(s,e)		__cpuc_coherent_kern_range(s,e)
+#define flush_icache_page(vma,pg)		do { } while (0)
+#define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
+#define flush_cache_user_range(vma,s,e)  flush_cache_range(vma,s,e)
+
+
+#define flush_cache_vmap(start, end)		flush_cache_all()
+#define flush_cache_vunmap(start, end)		flush_cache_all()
+
+#define flush_dcache_mmap_lock(mapping) \
+        write_lock_irq(&(mapping)->tree_lock)
+#define flush_dcache_mmap_unlock(mapping) \
+        write_unlock_irq(&(mapping)->tree_lock)
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/cpu-multi32.h linux-2.6.14-uc0-hsc0/include/asm-arm/cpu-multi32.h
--- linux-2.6.14-uc0/include/asm-arm/cpu-multi32.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/cpu-multi32.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/cpu-multi32.h
  *
  *  Copyright (C) 2000 Russell King
+ *  Modified by Hyok S. Choi, 2004
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -49,10 +50,12 @@
 	 * Set the page table
 	 */
 	void (*switch_mm)(unsigned long pgd_phys, struct mm_struct *mm);
+#ifdef CONFIG_MMU
 	/*
 	 * Set a PTE
 	 */
 	void (*set_pte)(pte_t *ptep, pte_t pte);
+#endif
 } processor;
 
 #define cpu_proc_init()			processor._proc_init()
@@ -60,5 +63,7 @@
 #define cpu_reset(addr)			processor.reset(addr)
 #define cpu_do_idle()			processor._do_idle()
 #define cpu_dcache_clean_area(addr,sz)	processor.dcache_clean_area(addr,sz)
+#ifdef CONFIG_MMU
 #define cpu_set_pte(ptep, pte)		processor.set_pte(ptep, pte)
+#endif
 #define cpu_do_switch_mm(pgd,mm)	processor.switch_mm(pgd,mm)
diff -Naur linux-2.6.14-uc0/include/asm-arm/cpu-single.h linux-2.6.14-uc0-hsc0/include/asm-arm/cpu-single.h
--- linux-2.6.14-uc0/include/asm-arm/cpu-single.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/cpu-single.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/cpu-single.h
  *
  *  Copyright (C) 2000 Russell King
+ *  Modified by Hyok S. Choi, 2004
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -28,7 +29,9 @@
 #define cpu_do_idle			__cpu_fn(CPU_NAME,_do_idle)
 #define cpu_dcache_clean_area		__cpu_fn(CPU_NAME,_dcache_clean_area)
 #define cpu_do_switch_mm		__cpu_fn(CPU_NAME,_switch_mm)
+#ifdef CONFIG_MMU
 #define cpu_set_pte			__cpu_fn(CPU_NAME,_set_pte)
+#endif
 
 #include <asm/page.h>
 
@@ -40,5 +43,7 @@
 extern int cpu_do_idle(void);
 extern void cpu_dcache_clean_area(void *, int);
 extern void cpu_do_switch_mm(unsigned long pgd_phys, struct mm_struct *mm);
+#ifdef CONFIG_MMU
 extern void cpu_set_pte(pte_t *ptep, pte_t pte);
+#endif
 extern void cpu_reset(unsigned long addr) __attribute__((noreturn));
diff -Naur linux-2.6.14-uc0/include/asm-arm/domain.h linux-2.6.14-uc0-hsc0/include/asm-arm/domain.h
--- linux-2.6.14-uc0/include/asm-arm/domain.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/domain.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/domain.h
  *
  *  Copyright (C) 1999 Russell King.
+ *  Copyright (C) 2004 Hyok S. Choi
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -32,6 +33,7 @@
 #define domain_val(dom,type)	((type) << (2*(dom)))
 
 #ifndef __ASSEMBLY__
+#ifdef CONFIG_MMU
 #define set_domain(x)					\
 	do {						\
 	__asm__ __volatile__(				\
@@ -48,5 +50,9 @@
 	set_domain(thread->cpu_domain);				\
 	} while (0)
 
+#else
+#define set_domain(x) do {} while(0)
+#define modify_domain(x,y) do {} while(0)
+#endif /* CONFIG_MMU */
 #endif
 #endif /* !__ASSEMBLY__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/flat.h linux-2.6.14-uc0-hsc0/include/asm-arm/flat.h
--- linux-2.6.14-uc0/include/asm-arm/flat.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/flat.h	2005-11-08 09:06:49.000000000 +0900
@@ -0,0 +1,20 @@
+/*
+ * include/asm-armnommu/flat.h -- uClinux flat-format executables
+ *
+ * Copyright (C) 2003, Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+
+#ifndef __ARMNOMMU_FLAT_H__
+#define __ARMNOMMU_FLAT_H__
+
+#define	flat_stack_align(sp)			/* nothing needed */
+#define	flat_argvp_envp_on_stack()		1
+#define	flat_old_ram_flag(flags)		(flags)
+#define	flat_reloc_valid(reloc, size)		((reloc) <= (size))
+#define	flat_get_addr_from_rp(rp, relval, flags)	get_unaligned(rp)
+#define	flat_put_addr_at_rp(rp, val, relval)	put_unaligned(val,rp)
+#define	flat_get_relocate_addr(rel)		(rel)
+
+#endif /* __ARMNOMMU_FLAT_H__ */
+
diff -Naur linux-2.6.14-uc0/include/asm-arm/glue.h linux-2.6.14-uc0-hsc0/include/asm-arm/glue.h
--- linux-2.6.14-uc0/include/asm-arm/glue.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/glue.h	2005-11-09 18:55:45.000000000 +0900
@@ -51,6 +51,22 @@
 # endif
 #endif
 
+#if defined(CONFIG_CPU_ARM7TDMI)
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER cpu_arm7tdmi_data_abort
+# endif
+#endif
+
+#if defined(CONFIG_CPU_S3C4510B)
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER cpu_s3c4510b_data_abort
+# endif
+#endif
+
 #if defined(CONFIG_CPU_ARM710)
 # ifdef CPU_ABORT_HANDLER
 #  define MULTI_ABORT 1
@@ -59,6 +75,14 @@
 # endif
 #endif
 
+#if defined(CONFIG_CPU_ARM9TDMI)
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER cpu_arm9tdmi_data_abort
+# endif
+#endif
+
 #ifdef CONFIG_CPU_ABRT_LV4T
 # ifdef CPU_ABORT_HANDLER
 #  define MULTI_ABORT 1
diff -Naur linux-2.6.14-uc0/include/asm-arm/hardware/dcc.h linux-2.6.14-uc0-hsc0/include/asm-arm/hardware/dcc.h
--- linux-2.6.14-uc0/include/asm-arm/hardware/dcc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/hardware/dcc.h	2005-11-08 09:06:48.000000000 +0900
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-armnommu/hardware/dcc.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __DCC_PUTS__
+#define __DCC_PUTS__
+static void dcc_puts(const char *p)
+{
+#ifndef CONFIG_JTAG_DCC_OUTPUT_DISABLE
+	/*
+		r0 = string	; string address
+		r1 = 2		; state check bit (write)
+		r4 = *string	; character
+	*/
+		__asm__ __volatile__(
+			"	ldrb r4, [%0]			@ load a char\n"
+			"1:	mrc	p14, 0, r3, c0, c0 	@ read comms control reg\n"
+			"	and r3, r3, #2			@ the write buffer status\n"
+			"	cmp r3, #2			@ is it available?\n"
+			"	beq 1b				@ is not, wait till then\n"
+			"	mcr p14, 0, r4, c1, c0		@ write it\n"
+			"	cmp r4, #0x0a			@ is it LF?\n"
+			"	bne 2f				@ if it is not, continue\n"
+			"	mov r4, #0x0d			@ set the CR\n"
+			"	b   1b				@ loop for writing CR\n"			
+			"2:	ldrb r4, [%0, #1]!		@ load a char\n"
+			"	cmp r4, #0x0			@ test is null\n"
+			"	bne 1b				@ if it is not yet, loop"
+			: /* no output register */
+			: "r" (p)
+			: "r3", "r4");
+#endif
+}
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/hardware.h linux-2.6.14-uc0-hsc0/include/asm-arm/hardware.h
--- linux-2.6.14-uc0/include/asm-arm/hardware.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/hardware.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/hardware.h
  *
  *  Copyright (C) 1996 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,4 +16,26 @@
 
 #include <asm/arch/hardware.h>
 
+#ifndef CONFIG_MMU
+
+#ifndef __ASSEMBLY__
+
+/* the machine dependent  bootmem reserve and free routines */
+#ifndef MACH_RESERVE_BOOTMEM
+#define MACH_RESERVE_BOOTMEM()
+#endif
+
+#ifndef MACH_FREE_BOOTMEM
+#define MACH_FREE_BOOTMEM()
+#endif
+
+/* by default, initmem is freed */
+#ifndef DO_FREE_INITMEM
+#define DO_FREE_INITMEM() 	(1)
+#endif
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* !CONFIG_MMU */
+
 #endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/mach/arch.h linux-2.6.14-uc0-hsc0/include/asm-arm/mach/arch.h
--- linux-2.6.14-uc0/include/asm-arm/mach/arch.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/mach/arch.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/mach/arch.h
  *
  *  Copyright (C) 2000 Russell King
+ *  Modified by Hyok S. Choi for uClinux, 2004
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -22,8 +23,10 @@
 	unsigned int		nr;		/* architecture number	*/
 	unsigned int		phys_ram;	/* start of physical ram */
 	unsigned int		phys_io;	/* start of physical io	*/
+#ifdef CONFIG_MMU
 	unsigned int		io_pg_offst;	/* byte offset for io 
 						 * page tabe entry	*/
+#endif
 
 	const char		*name;		/* architecture name	*/
 	unsigned long		boot_params;	/* tagged list		*/
@@ -38,7 +41,9 @@
 	void			(*fixup)(struct machine_desc *,
 					 struct tag *, char **,
 					 struct meminfo *);
+#ifdef CONFIG_MMU
 	void			(*map_io)(void);/* IO mapping function	*/
+#endif
 	void			(*init_irq)(void);
 	struct sys_timer	*timer;		/* system tick timer	*/
 	void			(*init_machine)(void);
diff -Naur linux-2.6.14-uc0/include/asm-arm/memory.h linux-2.6.14-uc0-hsc0/include/asm-arm/memory.h
--- linux-2.6.14-uc0/include/asm-arm/memory.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/memory.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/memory.h
  *
  *  Copyright (C) 2000-2002 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,7 @@
 #include <linux/compiler.h>
 #include <asm/arch/memory.h>
 
+#ifdef CONFIG_MMU
 #ifndef TASK_SIZE
 /*
  * TASK_SIZE - the maximum size of a user space task.
@@ -37,6 +39,33 @@
 #define PAGE_OFFSET		(0xc0000000UL)
 #endif
 
+#else /* CONFIG_MMU */
+
+#ifndef TASK_SIZE
+#define TASK_SIZE		(0x01a00000UL)
+#endif
+#ifndef TASK_UNMAPPED_BASE
+#define TASK_UNMAPPED_BASE	(0x00000000UL)
+#endif
+
+#define TASK_SIZE_26		TASK_SIZE
+
+#ifndef PHYS_OFFSET
+#ifndef CONFIG_DRAM_BASE
+#define PHYS_OFFSET		(0x00000000UL)
+#define END_MEM			(0x00400000UL)
+#else
+#define PHYS_OFFSET 		(CONFIG_DRAM_BASE)
+#define END_MEM     		(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+#endif
+#endif
+
+#ifndef PAGE_OFFSET
+#define PAGE_OFFSET		(PHYS_OFFSET)
+#endif
+
+#endif /* !CONFIG_MMU */
+
 /*
  * Physical vs virtual RAM address space conversion.  These are
  * private definitions which should NOT be used outside memory.h
@@ -47,6 +76,8 @@
 #define __phys_to_virt(x)	((x) - PHYS_OFFSET + PAGE_OFFSET)
 #endif
 
+#ifdef CONFIG_MMU
+
 /*
  * The module space lives between the addresses given by TASK_SIZE
  * and PAGE_OFFSET - it must be within 32MB of the kernel text.
@@ -58,6 +89,8 @@
 #error Top of user space clashes with start of module space
 #endif
 
+#endif /* CONFIG_MMU */
+
 #ifndef __ASSEMBLY__
 
 /*
diff -Naur linux-2.6.14-uc0/include/asm-arm/mmu_context.h linux-2.6.14-uc0-hsc0/include/asm-arm/mmu_context.h
--- linux-2.6.14-uc0/include/asm-arm/mmu_context.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/mmu_context.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/mmu_context.h
  *
  *  Copyright (C) 1996 Russell King.
+ *  Modified by Hyok S. Choi, 2004.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,6 +14,10 @@
 #ifndef __ASM_ARM_MMU_CONTEXT_H
 #define __ASM_ARM_MMU_CONTEXT_H
 
+#include <linux/config.h>
+#ifndef CONFIG_MMU
+#include "nommu_context.h"
+#else /* !CONFIG_MMU */
 #include <asm/proc-fns.h>
 
 #if __LINUX_ARM_ARCH__ >= 6
@@ -93,4 +98,5 @@
 #define deactivate_mm(tsk,mm)	do { } while (0)
 #define activate_mm(prev,next)	switch_mm(prev, next, NULL)
 
+#endif /* CONFIG_MMU */
 #endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/mmu.h linux-2.6.14-uc0-hsc0/include/asm-arm/mmu.h
--- linux-2.6.14-uc0/include/asm-arm/mmu.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/mmu.h	2005-11-09 13:29:38.000000000 +0900
@@ -1,12 +1,20 @@
 #ifndef __ARM_MMU_H
 #define __ARM_MMU_H
 
+#ifndef CONFIG_MMU
+
+#include "nommu.h"
+
+#else /* !CONFIG_MMU */
+
 typedef struct {
 #if __LINUX_ARM_ARCH__ >= 6
 	unsigned int id;
 #endif
 } mm_context_t;
 
+#endif /* CONFIG_MMU */
+
 #if __LINUX_ARM_ARCH__ >= 6
 #define ASID(mm)	((mm)->context.id & 255)
 #else
diff -Naur linux-2.6.14-uc0/include/asm-arm/nommu_context.h linux-2.6.14-uc0-hsc0/include/asm-arm/nommu_context.h
--- linux-2.6.14-uc0/include/asm-arm/nommu_context.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/nommu_context.h	2005-11-09 13:29:38.000000000 +0900
@@ -0,0 +1,46 @@
+/*
+ *  linux/include/asm-arm/nommu_context.h
+ *
+ *  Copyright (C) 2001 RidgRun Inc (www.ridgerun.com)
+ *  Copyright (C) 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   20-02-2001 GJM     Gutted for uClinux
+ *   05-03-2004 HSC     modified for 2.6
+ */
+#ifndef __ASM_ARM_NOMMU_CONTEXT_H
+#define __ASM_ARM_NOMMU_CONTEXT_H
+
+#include <linux/config.h>
+#include <asm/setup.h>
+#include <asm/page.h>
+#include <asm/pgalloc.h>
+
+static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
+{
+}
+
+extern inline int
+init_new_context(struct task_struct *tsk, struct mm_struct *mm)
+{
+	return(0);
+}
+
+#define destroy_context(mm)		do { } while(0)
+
+static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk)
+{
+}
+
+#define deactivate_mm(tsk,mm)	do { } while (0)
+
+extern inline void activate_mm(struct mm_struct *prev_mm,
+			       struct mm_struct *next_mm)
+{
+}
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/nommu.h linux-2.6.14-uc0-hsc0/include/asm-arm/nommu.h
--- linux-2.6.14-uc0/include/asm-arm/nommu.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/nommu.h	2005-11-09 13:29:38.000000000 +0900
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-arm/nommu.h
+ *
+ *  Copyright (C) 2002, David McCullough <davidm@snapgear.com>
+ *  modified for 2.6 by Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ARM_NOMMU_H
+#define __ARM_NOMMU_H
+
+typedef struct {
+	struct vm_list_struct	*vmlist;
+	unsigned long		end_brk;
+#if __LINUX_ARM_ARCH__ >= 6
+	unsigned int id;
+#endif
+} mm_context_t;
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/page.h linux-2.6.14-uc0-hsc0/include/asm-arm/page.h
--- linux-2.6.14-uc0/include/asm-arm/page.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/page.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/page.h
  *
  *  Copyright (C) 1995-2003 Russell King
+ *  Modified by Hyok S. Choi, 2004
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -26,6 +27,9 @@
 
 #include <asm/glue.h>
 
+#ifndef CONFIG_MMU
+#include "page-nommu.h"
+#else
 /*
  *	User Space Model
  *	================
@@ -160,6 +164,8 @@
 
 #endif /* STRICT_MM_TYPECHECKS */
 
+#endif /* CONFIG_MMU */
+
 /* the upper-most page table pointer */
 extern pmd_t *top_pmd;
 
diff -Naur linux-2.6.14-uc0/include/asm-arm/page-nommu.h linux-2.6.14-uc0-hsc0/include/asm-arm/page-nommu.h
--- linux-2.6.14-uc0/include/asm-arm/page-nommu.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/page-nommu.h	2005-11-09 13:29:38.000000000 +0900
@@ -0,0 +1,54 @@
+/*
+ *  linux/include/asm-arm/page-nommu.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PAGE_NOMMU_H
+#define _ASMARM_PAGE_NOMMU_H
+
+#undef _USER
+#undef MULTI_USER
+
+#if !defined(CONFIG_SMALL_TASKS) && PAGE_SHIFT < 13
+#define KTHREAD_SIZE (8192)
+#else
+#define KTHREAD_SIZE PAGE_SIZE
+#endif
+ 
+#define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
+#define free_user_page(page, addr)	free_page(addr)
+
+#define clear_page(page)	memset((page), 0, PAGE_SIZE)
+#define copy_page(to,from)	memcpy((to), (from), PAGE_SIZE)
+
+#define clear_user_page(page, vaddr, pg)	clear_page(page)
+#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef unsigned long pte_t;
+typedef unsigned long pmd_t;
+typedef unsigned long pgd_t[2];
+typedef unsigned long pgprot_t;
+
+#define pte_val(x)      (x)
+#define pmd_val(x)      (x)
+#define pgd_val(x)	((x)[0])
+#define pgprot_val(x)   (x)
+
+#define __pte(x)        (x)
+#define __pmd(x)        (x)
+#define __pgprot(x)     (x)
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+extern unsigned long memory_start;
+extern unsigned long memory_end;
+
+#endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/pgalloc.h linux-2.6.14-uc0-hsc0/include/asm-arm/pgalloc.h
--- linux-2.6.14-uc0/include/asm-arm/pgalloc.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/pgalloc.h	2005-11-09 18:58:52.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/pgalloc.h
  *
  *  Copyright (C) 2000-2001 Russell King
+ *  Modified by Hyok S. Choi, 2004
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -14,6 +15,7 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_MMU
 /*
  * Since we have only two-level page tables, these are trivial
  */
@@ -27,8 +29,11 @@
 #define pgd_alloc(mm)			get_pgd_slow(mm)
 #define pgd_free(pgd)			free_pgd_slow(pgd)
 
+#endif /* CONFIG_MMU */
+
 #define check_pgt_cache()		do { } while (0)
 
+#ifdef CONFIG_MMU
 /*
  * Allocate one PTE table.
  *
@@ -121,4 +126,6 @@
 	__pmd_populate(pmdp, page_to_pfn(ptep) << PAGE_SHIFT | _PAGE_USER_TABLE);
 }
 
+#endif /* CONFIG_MMU */
+
 #endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/pgtable.h linux-2.6.14-uc0-hsc0/include/asm-arm/pgtable.h
--- linux-2.6.14-uc0/include/asm-arm/pgtable.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/pgtable.h	2005-11-09 13:29:38.000000000 +0900
@@ -12,6 +12,12 @@
 
 #include <asm-generic/4level-fixup.h>
 
+#ifndef CONFIG_MMU
+
+#include "pgtable-nommu.h"
+
+#else
+
 #include <asm/memory.h>
 #include <asm/proc-fns.h>
 #include <asm/arch/vmalloc.h>
@@ -459,4 +465,5 @@
 
 #endif /* !__ASSEMBLY__ */
 
+#endif /* CONFIG_MMU */
 #endif /* _ASMARM_PGTABLE_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/pgtable-nommu.h linux-2.6.14-uc0-hsc0/include/asm-arm/pgtable-nommu.h
--- linux-2.6.14-uc0/include/asm-arm/pgtable-nommu.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/pgtable-nommu.h	2005-11-09 13:29:38.000000000 +0900
@@ -0,0 +1,108 @@
+/*
+ *  linux/include/asm-armnommu/pgtable.h
+ *
+ *  Copyright (C) 1995-2002 Russell King
+ *  Modified by Hyok S. Choi, 2004, Samsung Electronics Co.,Ltd.
+ *  (referenced from m68knommu)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PGTABLE_NOMMU_H
+#define _ASMARM_PGTABLE_NOMMU_H
+
+#ifndef __ASSEMBLY__
+
+
+#include <linux/config.h>
+#include <linux/slab.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/io.h>
+
+
+/*
+ * Trivial page table functions.
+ */
+#define pgd_present(pgd)	(1)
+#define pgd_none(pgd)		(0)
+#define pgd_bad(pgd)		(0)
+#define pgd_clear(pgdp)
+#define kern_addr_valid(addr)	(1)
+#define	pmd_offset(a, b)	((void *)0)
+
+/* FIXME */
+/*
+ * PMD_SHIFT determines the size of the area a second-level page table can map
+ * PGDIR_SHIFT determines what a third-level page table entry can map
+ */
+#define PGDIR_SHIFT		21
+
+#define PGDIR_SIZE		(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK		(~(PGDIR_SIZE-1))
+/* FIXME */
+
+#define PAGE_NONE	__pgprot(0)
+#define PAGE_SHARED	__pgprot(0)
+#define PAGE_COPY	__pgprot(0)
+#define PAGE_READONLY	__pgprot(0)
+#define PAGE_KERNEL	__pgprot(0)
+
+//extern void paging_init(struct meminfo *, struct machine_desc *);
+#define swapper_pg_dir ((pgd_t *) 0)
+
+#define __swp_type(x)		(0)
+#define __swp_offset(x)		(0)
+#define __swp_entry(typ,off)	((swp_entry_t) { ((typ) | ((off) << 7)) })
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+
+typedef pte_t *pte_addr_t;
+
+static inline int pte_file(pte_t pte) { return 0; }
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+#define ZERO_PAGE(vaddr)	(virt_to_page(0))
+
+/*
+ * Mark the prot value as uncacheable and unbufferable.
+ */
+#define pgprot_noncached(prot)	__pgprot(0)
+#define pgprot_writecombine(prot) __pgprot(0)
+
+
+/*
+ * These would be in other places but having them here reduces the diffs.
+ */
+extern unsigned int kobjsize(const void *objp);
+extern int is_in_rom(unsigned long);
+
+/*
+ * No page table caches to initialise.
+ */
+#define pgtable_cache_init()	do { } while (0)
+#define io_remap_page_range	remap_page_range
+#define io_remap_pfn_range	remap_pfn_range
+
+#define MK_IOSPACE_PFN(space, pfn)	(pfn)
+#define GET_IOSPACE(pfn)		0
+#define GET_PFN(pfn)			(pfn)
+
+
+/*
+ * All 32bit addresses are effectively valid for vmalloc...
+ * Sort of meaningless for non-VM targets.
+ */
+#define	VMALLOC_START	0
+#define	VMALLOC_END	0xffffffff
+
+#define FIRST_USER_ADDRESS      (0)
+
+#endif /*__ASSEMBLY__*/
+
+#endif /* _ASMARM_PGTABLE_H */
diff -Naur linux-2.6.14-uc0/include/asm-arm/processor.h linux-2.6.14-uc0-hsc0/include/asm-arm/processor.h
--- linux-2.6.14-uc0/include/asm-arm/processor.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/processor.h	2005-11-09 13:29:38.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/processor.h
  *
  *  Copyright (C) 1995-1999 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi, Samsung Electronics Co.,Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -49,6 +50,12 @@
 
 #define INIT_THREAD  {	}
 
+#ifndef CONFIG_MMU
+#define UCLINUX_SET_REG(r,a)	do { r = a; } while (0)
+#else
+#define UCLINUX_SET_REG(r,a)	((void) 0)
+#endif
+
 #define start_thread(regs,pc,sp)					\
 ({									\
 	unsigned long *stack = (unsigned long *)sp;			\
@@ -65,6 +72,7 @@
 	regs->ARM_r2 = stack[2];	/* r2 (envp) */			\
 	regs->ARM_r1 = stack[1];	/* r1 (argv) */			\
 	regs->ARM_r0 = stack[0];	/* r0 (argc) */			\
+	UCLINUX_SET_REG(regs->ARM_r10, current->mm->start_data);	\
 })
 
 /* Forward declaration, a strange C thing */
diff -Naur linux-2.6.14-uc0/include/asm-arm/proc-fns.h linux-2.6.14-uc0-hsc0/include/asm-arm/proc-fns.h
--- linux-2.6.14-uc0/include/asm-arm/proc-fns.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/proc-fns.h	2005-11-09 18:59:41.000000000 +0900
@@ -3,6 +3,7 @@
  *
  *  Copyright (C) 1997-1999 Russell King
  *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) 2003 Hyok S. Choi, Samsung Electronics Co.,Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -34,6 +35,14 @@
 #   define CPU_NAME cpu_arm6
 #  endif
 # endif
+# ifdef CONFIG_CPU_ARM7TDMI
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm7tdmi
+#  endif
+# endif
 # ifdef CONFIG_CPU_ARM710
 #  ifdef CPU_NAME
 #   undef  MULTI_CPU
@@ -42,6 +51,14 @@
 #   define CPU_NAME cpu_arm7
 #  endif
 # endif
+# ifdef CONFIG_CPU_S3C4510B
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_s3c4510b
+#  endif
+# endif
 # ifdef CONFIG_CPU_ARM720T
 #  ifdef CPU_NAME
 #   undef  MULTI_CPU
@@ -50,6 +67,14 @@
 #   define CPU_NAME cpu_arm720
 #  endif
 # endif
+# ifdef CONFIG_CPU_ARM9TDMI
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm9tdmi
+#  endif
+# endif
 # ifdef CONFIG_CPU_ARM920T
 #  ifdef CPU_NAME
 #   undef  MULTI_CPU
@@ -82,6 +107,14 @@
 #   define CPU_NAME cpu_arm926
 #  endif
 # endif
+# ifdef CONFIG_CPU_ARM940T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm940
+#  endif
+# endif
 # ifdef CONFIG_CPU_SA110
 #  ifdef CPU_NAME
 #   undef  MULTI_CPU
@@ -160,6 +193,7 @@
 
 #define cpu_switch_mm(pgd,mm) cpu_do_switch_mm(virt_to_phys(pgd),mm)
 
+#ifdef CONFIG_MMU
 #define cpu_get_pgd()	\
 	({						\
 		unsigned long pg;			\
@@ -168,6 +202,7 @@
 		pg &= ~0x3fff;				\
 		(pgd_t *)phys_to_virt(pg);		\
 	})
+#endif
 
 #endif /* __ASSEMBLY__ */
 #endif /* __KERNEL__ */
diff -Naur linux-2.6.14-uc0/include/asm-arm/procinfo.h linux-2.6.14-uc0-hsc0/include/asm-arm/procinfo.h
--- linux-2.6.14-uc0/include/asm-arm/procinfo.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/procinfo.h	2005-11-09 13:29:41.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/procinfo.h
  *
  *  Copyright (C) 1996-1999 Russell King
+ *  Modified by Hyok S. Choi, 2004
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -12,8 +13,10 @@
 
 #ifndef __ASSEMBLY__
 
+#ifdef CONFIG_MMU
 struct cpu_tlb_fns;
 struct cpu_user_fns;
+#endif
 struct cpu_cache_fns;
 struct processor;
 
@@ -29,15 +32,19 @@
 struct proc_info_list {
 	unsigned int		cpu_val;
 	unsigned int		cpu_mask;
+#ifdef CONFIG_MMU
 	unsigned long		__cpu_mmu_flags;	/* used by head.S */
+#endif
 	unsigned long		__cpu_flush;		/* used by head.S */
 	const char		*arch_name;
 	const char		*elf_name;
 	unsigned int		elf_hwcap;
 	const char		*cpu_name;
 	struct processor	*proc;
+#ifdef CONFIG_MMU
 	struct cpu_tlb_fns	*tlb;
 	struct cpu_user_fns	*user;
+#endif
 	struct cpu_cache_fns	*cache;
 };
 
@@ -45,7 +52,11 @@
 
 #endif	/* __ASSEMBLY__ */
 
+#ifdef CONFIG_MMU
 #define PROC_INFO_SZ	48
+#else
+#define PROC_INFO_SZ	36
+#endif
 
 #define HWCAP_SWP	1
 #define HWCAP_HALF	2
diff -Naur linux-2.6.14-uc0/include/asm-arm/system.h linux-2.6.14-uc0-hsc0/include/asm-arm/system.h
--- linux-2.6.14-uc0/include/asm-arm/system.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/system.h	2005-11-09 13:29:51.000000000 +0900
@@ -47,6 +47,7 @@
 #define CPUID_TCM	2
 #define CPUID_TLBTYPE	3
 
+#ifndef CONFIG_CPU_HAS_NO_CP15
 #define read_cpuid(reg)							\
 	({								\
 		unsigned int __val;					\
@@ -56,6 +57,9 @@
 		    : "cc");						\
 		__val;							\
 	})
+#else
+#define read_cpuid(reg) (0)
+#endif
 
 /*
  * This is used to ensure the compiler did actually allocate the register we
@@ -102,7 +106,9 @@
 
 extern asmlinkage void __backtrace(void);
 extern asmlinkage void c_backtrace(unsigned long fp, int pmode);
+#ifdef CONFIG_MMU
 extern void show_pte(struct mm_struct *mm, unsigned long addr);
+#endif
 extern void __show_regs(struct pt_regs *);
 
 extern int cpu_architecture(void);
diff -Naur linux-2.6.14-uc0/include/asm-arm/tlbflush.h linux-2.6.14-uc0-hsc0/include/asm-arm/tlbflush.h
--- linux-2.6.14-uc0/include/asm-arm/tlbflush.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/tlbflush.h	2005-11-09 13:29:32.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/tlbflush.h
  *
  *  Copyright (C) 1999-2003 Russell King
+ *  Modified for uClinux by Hyok S. Choi, 2004
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,6 +14,12 @@
 #include <linux/config.h>
 #include <asm/glue.h>
 
+#ifndef CONFIG_MMU
+
+#define tlb_flush(tlb)	((void) tlb)
+
+#else
+
 #define TLB_V3_PAGE	(1 << 0)
 #define TLB_V4_U_PAGE	(1 << 1)
 #define TLB_V4_D_PAGE	(1 << 2)
@@ -417,4 +424,6 @@
 
 #endif
 
+#endif	/* CONFIG_MMU */
+
 #endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/tlb.h linux-2.6.14-uc0-hsc0/include/asm-arm/tlb.h
--- linux-2.6.14-uc0/include/asm-arm/tlb.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/tlb.h	2005-11-09 19:02:05.000000000 +0900
@@ -2,6 +2,7 @@
  *  linux/include/asm-arm/tlb.h
  *
  *  Copyright (C) 2002 Russell King
+ *  Modified for uClinux by Hyok S. Choi, 2004
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -19,6 +20,13 @@
 
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
+#ifndef CONFIG_MMU
+
+#include <linux/pagemap.h>
+#include <asm-generic/tlb.h>
+
+#else /* !CONFIG_MMU */
+
 #include <asm/pgalloc.h>
 
 /*
@@ -99,4 +107,5 @@
 
 #define tlb_migrate_finish(mm)		do { } while (0)
 
+#endif	/* CONFIG_MMU */
 #endif
diff -Naur linux-2.6.14-uc0/include/asm-arm/uaccess.h linux-2.6.14-uc0-hsc0/include/asm-arm/uaccess.h
--- linux-2.6.14-uc0/include/asm-arm/uaccess.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/uaccess.h	2005-11-09 13:29:44.000000000 +0900
@@ -40,6 +40,11 @@
 
 extern int fixup_exception(struct pt_regs *regs);
 
+#ifndef CONFIG_MMU
+
+#include "uaccess-nommu.h"
+
+#else
 /*
  * Note that this is actually 0x1,0000,0000
  */
@@ -77,6 +82,8 @@
 
 #define access_ok(type,addr,size)	(__range_ok(addr,size) == 0)
 
+#endif
+
 /*
  * Single-value transfer routines.  They automatically use the right
  * size if we just have the right pointer type.  Note that the functions
diff -Naur linux-2.6.14-uc0/include/asm-arm/uaccess-nommu.h linux-2.6.14-uc0-hsc0/include/asm-arm/uaccess-nommu.h
--- linux-2.6.14-uc0/include/asm-arm/uaccess-nommu.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/asm-arm/uaccess-nommu.h	2005-11-09 13:29:44.000000000 +0900
@@ -0,0 +1,37 @@
+/*
+ *  linux/include/asm-arm/uaccess-nommu.h
+ *
+ *  Copyright (C) 2003 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_UACCESS_NOMMU_H
+#define _ASMARM_UACCESS_NOMMU_H
+
+/*
+ * Note that this is actually 0x1,0000,0000
+ */
+#define KERNEL_DS	0x00000000
+/* uClinux has only one addr space. */
+#define USER_DS		PAGE_OFFSET
+
+#define get_ds()	(KERNEL_DS)
+#define get_fs()	(USER_DS)	/* uClinux has only one addr space. */
+
+static inline void set_fs (mm_segment_t fs)
+{ /* nothing to do here for uClinux */
+}
+
+#define segment_eq(a,b)	((a) == (b))
+
+/*
+ * assuming __range_ok & __addr_ok always succeed.
+ */
+#define __addr_ok(addr) 			1
+#define __range_ok(addr,size) 	0
+
+#define access_ok(type,addr,size)	(__range_ok(addr,size) == 0)
+
+#endif /* _ASMARM_UACCESS-NOMMU_H */
diff -Naur linux-2.6.14-uc0/include/linux/serial_core.h linux-2.6.14-uc0-hsc0/include/linux/serial_core.h
--- linux-2.6.14-uc0/include/linux/serial_core.h	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/include/linux/serial_core.h	2005-11-09 19:17:59.000000000 +0900
@@ -119,6 +119,17 @@
 /*Digi jsm */
 #define PORT_JSM        65
 
+/* DCC(JTAG) emulation port types */
+#define PORT_DCC_JTAG1	71
+
+/* Samsung S3C4510B */
+#define PORT_S3C4510B   72
+
+#define PORT_P2001	73
+
+/* TI TMS320DM270 */
+#define PORT_DM270      74
+
 #ifdef __KERNEL__
 
 #include <linux/config.h>
diff -Naur linux-2.6.14-uc0/init/Kconfig linux-2.6.14-uc0-hsc0/init/Kconfig
--- linux-2.6.14-uc0/init/Kconfig	2005-11-08 11:41:03.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/init/Kconfig	2005-11-09 19:27:40.000000000 +0900
@@ -326,6 +326,7 @@
 config FUTEX
 	bool "Enable futex support" if EMBEDDED
 	default y
+	depends on MMU
 	help
 	  Disabling this option will cause the kernel to be built without
 	  support for "fast userspace mutexes".  The resulting kernel may not
diff -Naur linux-2.6.14-uc0/MAINTAINERS linux-2.6.14-uc0-hsc0/MAINTAINERS
--- linux-2.6.14-uc0/MAINTAINERS	2005-10-28 09:02:08.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/MAINTAINERS	2005-11-10 09:46:29.000000000 +0900
@@ -695,6 +695,13 @@
 M:	g.liakhovetski@gmx.de
 S:	Maintained
 
+DCC(JTAG) Console driver
+P:	Hyok S. Choi
+M:	hyok.choi@samsung.com
+M:	hyok.choi@gmail.com
+W:	http://opensrc.sec.samsung.com/
+S:	Maintained
+
 DCCP PROTOCOL
 P:	Arnaldo Carvalho de Melo
 M:	acme@mandriva.com
@@ -2734,6 +2741,12 @@
 L:	uclinux-dev@uclinux.org  (subscribers-only)
 S:	Maintained
 
+UCLINUX FOR ARM
+P:	Hyok S. Choi
+M:	hyok.choi@samsung.com
+W:	http://opensrc.sec.samsung.com/
+S:	Maintained
+
 UCLINUX FOR NEC V850
 P:	Miles Bader
 M:	uclinux-v850@lsi.nec.co.jp
diff -Naur linux-2.6.14-uc0/Makefile linux-2.6.14-uc0-hsc0/Makefile
--- linux-2.6.14-uc0/Makefile	2005-11-08 11:41:03.000000000 +0900
+++ linux-2.6.14-uc0-hsc0/Makefile	2005-11-09 19:33:39.000000000 +0900
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 14
-EXTRAVERSION = -uc0
+EXTRAVERSION = -hsc0
 NAME=Affluent Albatross
 
 # *DOCUMENTATION*
