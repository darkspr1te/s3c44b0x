diff -Naur linux-2.6.9/arch/armnommu/boot/bootp/bootp.lds linux-2.6.9-uc0/arch/armnommu/boot/bootp/bootp.lds
--- linux-2.6.9/arch/armnommu/boot/bootp/bootp.lds	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/bootp/bootp.lds	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,35 @@
+/*
+ *  linux/arch/armnommu/boot/bootp/bootp.lds
+ *
+ *  Copyright (C) 2000-2002 Russell King
+ *  Modified by Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+ENTRY(_start)
+SECTIONS
+{
+  . = 0;
+  _text = .;
+  .text : {
+   _stext = .;
+   *(.start)
+   arch/armnommu/boot/bootp/kernel.o
+   . = ALIGN(32);
+   initrd_start = .;
+   arch/armnommu/boot/bootp/initrd.o
+   initrd_len = . - initrd_start;
+   . = ALIGN(32);
+   _etext = .;
+  }
+  
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+}
diff -Naur linux-2.6.9/arch/armnommu/boot/bootp/init.S linux-2.6.9-uc0/arch/armnommu/boot/bootp/init.S
--- linux-2.6.9/arch/armnommu/boot/bootp/init.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/bootp/init.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,90 @@
+/*
+ *  linux/arch/armnommu/boot/bootp/init.S
+ *
+ *  Copyright (C) 2000-2003 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  "Header" file for splitting kernel + initrd.  Note that we pass
+ *  r0 through to r3 straight through.
+ *
+ *  This demonstrates how to append code to the start of the kernel
+ *  zImage, and boot the kernel without copying it around.  This
+ *  example would be simpler; if we didn't have an object of unknown
+ *  size immediately following the kernel, we could build this into
+ *  a binary blob, and concatenate the zImage using the cat command.
+ */
+		.section .start,#alloc,#execinstr
+		.type	_start, #function
+		.globl	_start
+
+_start:		adr	r12, kernel_start	@ offset of kernel zImage
+		ldr	r4, [r12, #0x2c]	@ length of zImage
+		adr	r13, data
+		add	r4, r4, r12		@ end of zImage, start of initrd
+		ldmia	r13!, {r5-r6}		@ r5 = dest, r6 = length
+		bl	move			@ move the initrd
+
+/*
+ * Setup the initrd parameters to pass to the kernel.  This can only be
+ * passed in via the tagged list.
+ */
+		ldmia	r13, {r5-r9}		@ get size and addr of initrd
+						@ r5 = ATAG_CORE
+						@ r6 = ATAG_INITRD2
+						@ r7 = initrd start
+						@ r8 = initrd end
+						@ r9 = param_struct address
+
+		ldr	r10, [r9, #4]		@ get first tag
+		teq	r10, r5			@ is it ATAG_CORE?
+/*
+ * If we didn't find a valid tag list, create a dummy ATAG_CORE entry.
+ */
+		movne	r10, #0			@ terminator
+		movne	r4, #2			@ Size of this entry (2 words)
+		stmneia	r8, {r4, r5, r10}	@ Size, ATAG_CORE, terminator
+
+/*
+ * find the end of the tag list, and then add an INITRD tag on the end.
+ * If there is already an INITRD tag, then we ignore it; the last INITRD
+ * tag takes precidence.
+ */
+taglist:	ldr	r10, [r9, #0]		@ tag length
+		teq	r10, #0			@ last tag (zero length)?
+		addne	r9, r9, r10, lsl #2
+		bne	taglist
+
+		mov	r5, #4			@ Size of initrd tag (4 words)
+		stmia	r9, {r5, r6, r7, r8, r10}
+		mov	pc, r12			@ call kernel
+
+/*
+ * Move the block of memory length r6 from address r4 to address r5
+ */
+move:		ldmia	r4!, {r7 - r10}		@ move 32-bytes at a time
+		stmia	r5!, {r7 - r10}
+		ldmia	r4!, {r7 - r10}
+		stmia	r5!, {r7 - r10}
+		subs	r6, r6, #8 * 4
+		bcs	move
+		mov	pc, lr
+
+		.size	_start, . - _start
+
+		.type	data,#object
+data:		.word	initrd_addr		@ destination initrd address
+		.word	initrd_len		@ initrd size
+
+		.word	0x54410001		@ r4 = ATAG_CORE
+		.word	0x54420005		@ r5 = ATAG_INITRD2
+		.word	initrd_addr		@ r6
+		.word	initrd_len		@ r7
+		.word	params			@ r8
+		.size	data, . - _data
+
+		.type	initrd_start,#object
+
+kernel_start:
diff -Naur linux-2.6.9/arch/armnommu/boot/bootp/Makefile linux-2.6.9-uc0/arch/armnommu/boot/bootp/Makefile
--- linux-2.6.9/arch/armnommu/boot/bootp/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/bootp/Makefile	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,22 @@
+#
+# linux/arch/armnommu/boot/bootp/Makefile
+#
+
+ZSYSTEM		= arch/armnommu/boot/zImage
+ZLDFLAGS	=-p -X -T $(obj)/bootp.lds \
+		 --defsym initrd_addr=$(INITRD_PHYS) \
+		 --defsym params=$(PARAMS_PHYS)
+
+extra-y := bootp
+
+# Note that bootp.lds picks up kernel.o and initrd.o
+$(obj)/bootp:	$(addprefix $(obj)/,init.o kernel.o initrd.o bootp.lds)
+		$(LD) $(ZLDFLAGS) -o $@ $(obj)/init.o
+
+$(obj)/kernel.o: $(ZSYSTEM)
+		$(LD) -r -s -o $@ -b binary $(ZSYSTEM)
+
+$(obj)/initrd.o: $(INITRD)
+		$(LD) -r -s -o $@ -b binary $(INITRD)
+
+.PHONY:		$(INITRD) $(ZSYSTEM)
diff -Naur linux-2.6.9/arch/armnommu/boot/compressed/head.S linux-2.6.9-uc0/arch/armnommu/boot/compressed/head.S
--- linux-2.6.9/arch/armnommu/boot/compressed/head.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/compressed/head.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,770 @@
+/*
+ *  linux/arch/armnommu/boot/compressed/head.S
+ *
+ *  Copyright (C) 1996-2002 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi (MPU support)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+
+/*
+ * Debugging stuff
+ *
+ * Note that these macros must not contain any code which is not
+ * 100% relocatable.  Any attempt to do so will result in a crash.
+ * Please select one of the following when turning on debugging.
+ */
+#ifdef DEBUG
+#error no serial architecture defined
+#endif
+
+		.macro	kputc,val
+		mov	r0, \val
+		bl	putc
+		.endm
+
+		.macro	kphex,val,len
+		mov	r0, \val
+		mov	r1, #\len
+		bl	phex
+		.endm
+
+		.macro	debug_reloc_start
+#ifdef DEBUG
+		kputc	#'\n'
+		kphex	r6, 8		/* processor id */
+		kputc	#':'
+		kphex	r7, 8		/* architecture id */
+		kputc	#':'
+		mrc	p15, 0, r0, c1, c0
+		kphex	r0, 8		/* control reg */
+		kputc	#'\n'
+		kphex	r5, 8		/* decompressed kernel start */
+		kputc	#'-'
+		kphex	r8, 8		/* decompressed kernel end  */
+		kputc	#'>'
+		kphex	r4, 8		/* kernel execution address */
+		kputc	#'\n'
+#endif
+		.endm
+
+		.macro	debug_reloc_end
+#ifdef DEBUG
+		kphex	r5, 8		/* end of kernel */
+		kputc	#'\n'
+		mov	r0, r4
+		bl	memdump		/* dump 256 bytes at start of kernel */
+#endif
+		.endm
+
+		.section ".start", #alloc, #execinstr
+/*
+ * sort out different calling conventions
+ */
+		.align
+start:
+		.type	start,#function
+		.rept	8
+		mov	r0, r0
+		.endr
+
+		b	1f
+		.word	0x016f2818		@ Magic numbers to help the loader
+		.word	start			@ absolute load/run zImage address
+		.word	_edata			@ zImage end address
+1:		mov	r7, r1			@ save architecture ID
+		mov	r8, #0			@ save r0
+
+#ifndef __ARM_ARCH_2__
+		/*
+		 * Booting from Angel - need to enter SVC mode and disable
+		 * FIQs/IRQs (numeric definitions from angel arm.h source).
+		 * We only do this if we were in user mode on entry.
+		 */
+		mrs	r2, cpsr		@ get current mode
+		tst	r2, #3			@ not user?
+		bne	not_angel
+		mov	r0, #0x17		@ angel_SWIreason_EnterSVC
+		swi	0x123456		@ angel_SWI_ARM
+not_angel:
+		mrs	r2, cpsr		@ turn off interrupts to
+		orr	r2, r2, #0xc0		@ prevent angel from running
+		msr	cpsr_c, r2
+#else
+		teqp	pc, #0x0c000003		@ turn off interrupts
+#endif
+
+		/*
+		 * Note that some cache flushing and other stuff may
+		 * be needed here - is there an Angel SWI call for this?
+		 */
+
+		/*
+		 * some architecture specific code can be inserted
+		 * by the linker here, but it should preserve r7 and r8.
+		 */
+
+		.text
+		adr	r0, LC0
+		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}
+		subs	r0, r0, r1		@ calculate the delta offset
+
+						@ if delta is zero, we're
+		beq	not_relocated		@ running at the address we
+						@ were linked at.
+
+		/*
+		 * We're running at a different address.  We need to fix
+		 * up various pointers:
+		 *   r5 - zImage base address
+		 *   r6 - GOT start
+		 *   ip - GOT end
+		 */
+		add	r5, r5, r0
+		add	r6, r6, r0
+		add	ip, ip, r0
+
+#ifndef CONFIG_ZBOOT_ROM
+		/*
+		 * If we're running fully PIC === CONFIG_ZBOOT_ROM = n,
+		 * we need to fix up pointers into the BSS region.
+		 *   r2 - BSS start
+		 *   r3 - BSS end
+		 *   sp - stack pointer
+		 */
+		add	r2, r2, r0
+		add	r3, r3, r0
+		add	sp, sp, r0
+
+		/*
+		 * Relocate all entries in the GOT table.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		add	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#else
+
+		/*
+		 * Relocate entries in the GOT table.  We only relocate
+		 * the entries that are outside the (relocated) BSS region.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		cmp	r1, r2			@ entry < bss_start ||
+		cmphs	r3, r1			@ _end < entry
+		addlo	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#endif
+
+not_relocated:	mov	r0, #0
+1:		str	r0, [r2], #4		@ clear bss
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		cmp	r2, r3
+		blo	1b
+
+		/*
+		 * The C runtime environment should now be setup
+		 * sufficiently.  Turn the cache on, set up some
+		 * pointers, and start decompressing.
+		 */
+		bl	cache_clean_flush
+		bl	cache_on
+
+		mov	r1, sp			@ malloc space above stack
+		add	r2, sp, #0x10000	@ 64k max
+
+/*
+ * Check to see if we will overwrite ourselves.
+ *   r4 = final kernel address
+ *   r5 = start of this image
+ *   r2 = end of malloc space (and therefore this image)
+ * We basically want:
+ *   r4 >= r2 -> OK
+ *   r4 + image length <= r5 -> OK
+ */
+		cmp	r4, r2
+		bhs	wont_overwrite
+		add	r0, r4, #4096*1024	@ 4MB largest kernel size
+		cmp	r0, r5
+		bls	wont_overwrite
+
+		mov	r5, r2			@ decompress after malloc space
+		mov	r0, r5
+		mov	r3, r7
+		bl	decompress_kernel
+
+		add	r0, r0, #127
+		bic	r0, r0, #127		@ align the kernel length
+/*
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		add	r1, r5, r0		@ end of decompressed kernel
+		adr	r2, reloc_start
+		ldr	r3, LC1
+		add	r3, r2, r3
+1:		ldmia	r2!, {r8 - r13}		@ copy relocation code
+		stmia	r1!, {r8 - r13}
+		ldmia	r2!, {r8 - r13}
+		stmia	r1!, {r8 - r13}
+		cmp	r2, r3
+		blo	1b
+
+		bl	cache_clean_flush
+		add	pc, r5, r0		@ call relocation code
+
+/*
+ * We're not in danger of overwriting ourselves.  Do this the simple way.
+ *
+ * r4     = kernel execution address
+ * r7     = architecture ID
+ */
+wont_overwrite:	mov	r0, r4
+		mov	r3, r7
+		bl	decompress_kernel
+		b	call_kernel
+
+		.type	LC0, #object
+LC0:		.word	LC0			@ r1
+		.word	__bss_start		@ r2
+		.word	_end			@ r3
+		.word	_load_addr		@ r4
+		.word	_start			@ r5
+		.word	_got_start		@ r6
+		.word	_got_end		@ ip
+		.word	user_stack+4096		@ sp
+LC1:		.word	reloc_end - reloc_start
+		.size	LC0, . - LC0
+
+/*
+ * Turn on the cache.  We need to setup some page tables so that we
+ * can have both the I and D caches on.
+ *
+ * We place the page tables 16k down from the kernel execution address,
+ * and we hope that nothing else is using it.  If we're using it, we
+ * will go pop!
+ *
+ * On entry,
+ *  r4 = kernel execution address
+ *  r6 = processor ID
+ *  r7 = architecture number
+ *  r8 = run-time address of "start"
+ * On exit,
+ *  r1, r2, r3, r8, r9, r12 corrupted
+ * This routine must preserve:
+ *  r4, r5, r6, r7
+ */
+		.align	5
+cache_on:	mov	r3, #8			@ cache_on function
+		b	call_cache_fn
+
+/*
+ * Initialize the the highest priority protection region, PR7
+ * to all 32bit address, cacheable and bufferable.
+ */
+__armv4_mpu_setup:
+		mov	r0, #0x3f		@ 4G, the whole
+		mcr	p15, 0, r0, c6, c7, 0	@ PR7 Area Setting
+		mcr 	p15, 0, r0, c6, c7, 1
+
+		mov	r0, #0x80		@ PR7
+		mcr	p15, 0, r0, c2, c0, 0	@ D-cache on
+		mcr	p15, 0, r0, c2, c0, 1	@ I-cache on
+		mcr	p15, 0, r0, c3, c0, 0	@ write-buffer on
+
+		mov	r0, #0xc000
+		mcr	p15, 0, r0, c5, c0, 1	@ I-access permission
+		mcr	p15, 0, r0, c5, c0, 0	@ D-access permission
+		mov	pc, lr
+
+__armv3_mpu_setup:
+		mov	r0, #0x3f		@ 4G, the whole
+		mcr	p15, 0, r0, c6, c7, 0	@ PR7 Area Setting
+
+		mov	r0, #0x80		@ PR7
+		mcr	p15, 0, r0, c2, c0, 0	@ cache on
+		mcr	p15, 0, r0, c3, c0, 0	@ write-buffer on
+
+		mov	r0, #0xc000
+		mcr	p15, 0, r0, c5, c0, 0	@ access permission
+		mov	pc, lr
+
+
+__armv4_mpu_cache_on:
+		mov	r12, lr
+		bl	__armv4_mpu_setup
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
+		mcr	p15, 0, r0, c7, c6, 0	@ flush D-Cache
+		mcr	p15, 0, r0, c7, c5, 0	@ flush I-Cache
+		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
+						@ ...I .... ..D. WC.M
+		orr	r0, r0, #0x002d		@ .... .... ..1. 11.1
+		orr	r0, r0, #0x1000		@ ...1 .... .... ....
+
+		mcr	p15, 0, r0, c1, c0, 0	@ write control reg
+
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c6, 0	@ flush D-Cache
+		mcr	p15, 0, r0, c7, c5, 0	@ flush I-Cache
+		mov	pc, r12
+
+__armv3_mpu_cache_on:
+		mov	r12, lr
+		bl	__armv3_mpu_setup
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
+		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
+						@ .... .... .... WC.M
+		orr	r0, r0, #0x000d		@ .... .... .... 11.1
+		mov	r0, #0
+		mcr	p15, 0, r0, c1, c0, 0	@ write control reg
+
+		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
+		mov	pc, r12
+
+__setup_mmu:	sub	r3, r4, #16384		@ Page directory size
+		bic	r3, r3, #0xff		@ Align the pointer
+		bic	r3, r3, #0x3f00
+/*
+ * Initialise the page tables, turning on the cacheable and bufferable
+ * bits for the RAM area only.
+ */
+		mov	r0, r3
+		mov	r8, r0, lsr #18
+		mov	r8, r8, lsl #18		@ start of RAM
+		add	r9, r8, #0x10000000	@ a reasonable RAM size
+		mov	r1, #0x12
+		orr	r1, r1, #3 << 10
+		add	r2, r3, #16384
+1:		cmp	r1, r8			@ if virt > start of RAM
+		orrhs	r1, r1, #0x0c		@ set cacheable, bufferable
+		cmp	r1, r9			@ if virt > end of RAM
+		bichs	r1, r1, #0x0c		@ clear cacheable, bufferable
+		str	r1, [r0], #4		@ 1:1 mapping
+		add	r1, r1, #1048576
+		teq	r0, r2
+		bne	1b
+/*
+ * If ever we are running from Flash, then we surely want the cache
+ * to be enabled also for our execution instance...  We map 2MB of it
+ * so there is no map overlap problem for up to 1 MB compressed kernel.
+ * If the execution is in RAM then we would only be duplicating the above.
+ */
+		mov	r1, #0x1e
+		orr	r1, r1, #3 << 10
+		mov	r2, pc, lsr #20
+		orr	r1, r1, r2, lsl #20
+		add	r0, r3, r2, lsl #2
+		str	r1, [r0], #4
+		add	r1, r1, #1048576
+		str	r1, [r0]
+		mov	pc, lr
+
+__armv4_mmu_cache_on:
+		mov	r12, lr
+		bl	__setup_mmu
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
+		mcr	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
+		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
+		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
+		orr	r0, r0, #0x0030
+		bl	__common_mmu_cache_on
+		mov	r0, #0
+		mcr	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
+		mov	pc, r12
+
+__arm6_mmu_cache_on:
+		mov	r12, lr
+		bl	__setup_mmu
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
+		mcr	p15, 0, r0, c5, c0, 0	@ invalidate whole TLB v3
+		mov	r0, #0x30
+		bl	__common_mmu_cache_on
+		mov	r0, #0
+		mcr	p15, 0, r0, c5, c0, 0	@ invalidate whole TLB v3
+		mov	pc, r12
+
+__common_mmu_cache_on:
+#ifndef DEBUG
+		orr	r0, r0, #0x000d		@ Write buffer, mmu
+#endif
+		mov	r1, #-1
+		mcr	p15, 0, r3, c2, c0, 0	@ load page table pointer
+		mcr	p15, 0, r1, c3, c0, 0	@ load domain access control
+		mcr	p15, 0, r0, c1, c0, 0	@ load control register
+		mov	pc, lr
+
+/*
+ * All code following this line is relocatable.  It is relocated by
+ * the above code to the end of the decompressed kernel image and
+ * executed there.  During this time, we have no stacks.
+ *
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		.align	5
+reloc_start:	add	r8, r5, r0
+		debug_reloc_start
+		mov	r1, r4
+1:
+		.rept	4
+		ldmia	r5!, {r0, r2, r3, r9 - r13}	@ relocate kernel
+		stmia	r1!, {r0, r2, r3, r9 - r13}
+		.endr
+
+		cmp	r5, r8
+		blo	1b
+		debug_reloc_end
+
+call_kernel: 	bl	cache_clean_flush
+		bl	cache_off
+		mov	r0, #0
+		mov	r1, r7			@ restore architecture number
+		mov	pc, r4			@ call kernel
+
+/*
+ * Here follow the relocatable cache support functions for the
+ * various processors.  This is a generic hook for locating an
+ * entry and jumping to an instruction at the specified offset
+ * from the start of the block.  Please note this is all position
+ * independent code.
+ *
+ *  r1  = corrupted
+ *  r2  = corrupted
+ *  r3  = block offset
+ *  r6  = corrupted
+ *  r12 = corrupted
+ */
+
+call_cache_fn:	adr	r12, proc_types
+		mrc	p15, 0, r6, c0, c0	@ get processor ID
+1:		ldr	r1, [r12, #0]		@ get value
+		ldr	r2, [r12, #4]		@ get mask
+		eor	r1, r1, r6		@ (real ^ match)
+		tst	r1, r2			@       & mask
+		addeq	pc, r12, r3		@ call cache function
+		add	r12, r12, #4*5
+		b	1b
+
+/*
+ * Table for cache operations.  This is basically:
+ *   - CPU ID match
+ *   - CPU ID mask
+ *   - 'cache on' method instruction
+ *   - 'cache off' method instruction
+ *   - 'cache flush' method instruction
+ *
+ * We match an entry using: ((real_id ^ match) & mask) == 0
+ *
+ * Writethrough caches generally only need 'on' and 'off'
+ * methods.  Writeback caches _must_ have the flush method
+ * defined.
+ */
+		.type	proc_types,#object
+proc_types:
+		.word	0x41560600		@ ARM6/610
+		.word	0xffffffe0
+		b	__arm6_mmu_cache_off	@ works, but slow
+		b	__arm6_mmu_cache_off
+		mov	pc, lr
+@		b	__arm6_mmu_cache_on		@ untested
+@		b	__arm6_mmu_cache_off
+@		b	__armv3_mmu_cache_flush
+
+		.word	0x00000000		@ old ARM ID
+		.word	0x0000f000
+		mov	pc, lr
+		mov	pc, lr
+		mov	pc, lr
+
+		.word	0x41007000		@ ARM7/710
+		.word	0xfff8fe00
+		b	__arm7_mmu_cache_off
+		b	__arm7_mmu_cache_off
+		mov	pc, lr
+
+		.word	0x41807200		@ ARM720T (writethrough)
+		.word	0xffffff00
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		mov	pc, lr
+
+		.word	0x41007400		@ ARM74x
+		.word	0xff00ff00
+		b	__armv3_mpu_cache_on
+		b	__armv3_mpu_cache_off
+		b	__armv3_mpu_cache_flush
+		
+		.word	0x41009400		@ ARM94x
+		.word	0xff00ff00
+		b	__armv4_mpu_cache_on
+		b	__armv4_mpu_cache_off
+		b	__armv4_mpu_cache_flush
+
+		.word	0x00007000		@ ARM7 IDs
+		.word	0x0000f000
+		mov	pc, lr
+		mov	pc, lr
+		mov	pc, lr
+
+		@ Everything from here on will be the new ID system.
+
+		.word	0x4401a100		@ sa110 / sa1100
+		.word	0xffffffe0
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
+
+		.word	0x6901b110		@ sa1110
+		.word	0xfffffff0
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
+
+		@ These match on the architecture ID
+
+		.word	0x00020000		@ ARMv4T
+		.word	0x000f0000
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
+
+		.word	0x00050000		@ ARMv5TE
+		.word	0x000f0000
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
+
+		.word	0x00060000		@ ARMv5TEJ
+		.word	0x000f0000
+		b	__armv4_mmu_cache_on
+		b	__armv4_mmu_cache_off
+		b	__armv4_mmu_cache_flush
+
+		.word	0			@ unrecognised type
+		.word	0
+		mov	pc, lr
+		mov	pc, lr
+		mov	pc, lr
+
+		.size	proc_types, . - proc_types
+
+/*
+ * Turn off the Cache and MMU.  ARMv3 does not support
+ * reading the control register, but ARMv4 does.
+ *
+ * On entry,  r6 = processor ID
+ * On exit,   r0, r1, r2, r3, r12 corrupted
+ * This routine must preserve: r4, r6, r7
+ */
+		.align	5
+cache_off:	mov	r3, #12			@ cache_off function
+		b	call_cache_fn
+
+__armv4_mpu_cache_off:
+		mrc	p15, 0, r0, c1, c0
+		bic	r0, r0, #0x000d
+		mcr	p15, 0, r0, c1, c0	@ turn MPU and cache off
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
+		mcr	p15, 0, r0, c7, c6, 0	@ flush D-Cache
+		mcr	p15, 0, r0, c7, c5, 0	@ flush I-Cache
+		mov	pc, lr
+
+__armv3_mpu_cache_off:
+		mrc	p15, 0, r0, c1, c0
+		bic	r0, r0, #0x000d
+		mcr	p15, 0, r0, c1, c0, 0	@ turn MPU and cache off
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
+		mov	pc, lr
+
+__armv4_mmu_cache_off:
+		mrc	p15, 0, r0, c1, c0
+		bic	r0, r0, #0x000d
+		mcr	p15, 0, r0, c1, c0	@ turn MMU and cache off
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c7	@ invalidate whole cache v4
+		mcr	p15, 0, r0, c8, c7	@ invalidate whole TLB v4
+		mov	pc, lr
+
+__arm6_mmu_cache_off:
+		mov	r0, #0x00000030		@ ARM6 control reg.
+		b	__armv3_mmu_cache_off
+
+__arm7_mmu_cache_off:
+		mov	r0, #0x00000070		@ ARM7 control reg.
+		b	__armv3_mmu_cache_off
+
+__armv3_mmu_cache_off:
+		mcr	p15, 0, r0, c1, c0, 0	@ turn MMU and cache off
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
+		mcr	p15, 0, r0, c5, c0, 0	@ invalidate whole TLB v3
+		mov	pc, lr
+
+/*
+ * Clean and flush the cache to maintain consistency.
+ *
+ * On entry,
+ *  r6 = processor ID
+ * On exit,
+ *  r1, r2, r3, r11, r12 corrupted
+ * This routine must preserve:
+ *  r0, r4, r5, r6, r7
+ */
+		.align	5
+cache_clean_flush:
+		mov	r3, #16
+		b	call_cache_fn
+
+__armv4_mpu_cache_flush:
+		mov	r2, #1
+		mov	r3, #0
+		mcr	p15, 0, ip, c7, c6, 0	@ invalidate D cache
+		mov	r1, #7 << 5		@ 8 segments
+1:		orr	r3, r1, #63 << 26	@ 64 entries
+2:		mcr	p15, 0, r3, c7, c14, 2	@ clean & invalidate D index
+		subs	r3, r3, #1 << 26
+		bcs	2b			@ entries 63 to 0
+		subs 	r1, r1, #1 << 5
+		bcs	1b			@ segments 7 to 0
+
+		teq	r2, #0
+		mcrne	p15, 0, ip, c7, c5, 0	@ invalidate I cache
+		mcr	p15, 0, ip, c7, c10, 4	@ drain WB
+		mov	pc, lr
+		
+__armv4_mmu_cache_flush:
+		mov	r2, #64*1024		@ default: 32K dcache size (*2)
+		mov	r11, #32		@ default: 32 byte line size
+		mrc	p15, 0, r3, c0, c0, 1	@ read cache type
+		teq	r3, r6			@ cache ID register present?
+		beq	no_cache_id
+		mov	r1, r3, lsr #18
+		and	r1, r1, #7
+		mov	r2, #1024
+		mov	r2, r2, lsl r1		@ base dcache size *2
+		tst	r3, #1 << 14		@ test M bit
+		addne	r2, r2, r2, lsr #1	@ +1/2 size if M == 1
+		mov	r3, r3, lsr #12
+		and	r3, r3, #3
+		mov	r11, #8
+		mov	r11, r11, lsl r3	@ cache line size in bytes
+no_cache_id:
+		bic	r1, pc, #63		@ align to longest cache line
+		add	r2, r1, r2
+1:		ldr	r3, [r1], r11		@ s/w flush D cache
+		teq	r1, r2
+		bne	1b
+
+		mcr	p15, 0, r1, c7, c5, 0	@ flush I cache
+		mcr	p15, 0, r1, c7, c6, 0	@ flush D cache
+		mcr	p15, 0, r1, c7, c10, 4	@ drain WB
+		mov	pc, lr
+
+__armv3_mmu_cache_flush:
+__armv3_mpu_cache_flush:
+		mov	r0, #0
+		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
+		mov	pc, lr
+
+/*
+ * Various debugging routines for printing hex characters and
+ * memory, which again must be relocatable.
+ */
+#ifdef DEBUG
+		.type	phexbuf,#object
+phexbuf:	.space	12
+		.size	phexbuf, . - phexbuf
+
+phex:		adr	r3, phexbuf
+		mov	r2, #0
+		strb	r2, [r3, r1]
+1:		subs	r1, r1, #1
+		movmi	r0, r3
+		bmi	puts
+		and	r2, r0, #15
+		mov	r0, r0, lsr #4
+		cmp	r2, #10
+		addge	r2, r2, #7
+		add	r2, r2, #'0'
+		strb	r2, [r3, r1]
+		b	1b
+
+puts:		loadsp	r3
+1:		ldrb	r2, [r0], #1
+		teq	r2, #0
+		moveq	pc, lr
+2:		writeb	r2
+		mov	r1, #0x00020000
+3:		subs	r1, r1, #1
+		bne	3b
+		teq	r2, #'\n'
+		moveq	r2, #'\r'
+		beq	2b
+		teq	r0, #0
+		bne	1b
+		mov	pc, lr
+putc:
+		mov	r2, r0
+		mov	r0, #0
+		loadsp	r3
+		b	2b
+
+memdump:	mov	r12, r0
+		mov	r10, lr
+		mov	r11, #0
+2:		mov	r0, r11, lsl #2
+		add	r0, r0, r12
+		mov	r1, #8
+		bl	phex
+		mov	r0, #':'
+		bl	putc
+1:		mov	r0, #' '
+		bl	putc
+		ldr	r0, [r12, r11, lsl #2]
+		mov	r1, #8
+		bl	phex
+		and	r0, r11, #7
+		teq	r0, #3
+		moveq	r0, #' '
+		bleq	putc
+		and	r0, r11, #7
+		add	r11, r11, #1
+		teq	r0, #7
+		bne	1b
+		mov	r0, #'\n'
+		bl	putc
+		cmp	r11, #64
+		blt	2b
+		mov	pc, r10
+#endif
+
+reloc_end:
+
+		.align
+		.section ".stack", "w"
+user_stack:	.space	4096
diff -Naur linux-2.6.9/arch/armnommu/boot/compressed/head-s3c44b0.S linux-2.6.9-uc0/arch/armnommu/boot/compressed/head-s3c44b0.S
--- linux-2.6.9/arch/armnommu/boot/compressed/head-s3c44b0.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/compressed/head-s3c44b0.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,372 @@
+/*
+ *  linux/arch/armnommu/boot/compressed/head.S
+ *
+ *  Copyright (C) 1996-2002 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi (MPU support)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/mach-types.h>
+
+/*
+ * Debugging stuff
+ *
+ * Note that these macros must not contain any code which is not
+ * 100% relocatable.  Any attempt to do so will result in a crash.
+ * Please select one of the following when turning on debugging.
+ */
+
+		.macro	kputc,val
+		mov	r0, \val
+		bl	putc
+		.endm
+
+		.macro	kphex,val,len
+		mov	r0, \val
+		mov	r1, #\len
+		bl	phex
+		.endm
+
+		.macro	debug_reloc_start
+#ifdef DEBUG
+		kputc	#'\n'
+		kphex	r6, 8		/* processor id */
+		kputc	#':'
+		kphex	r7, 8		/* architecture id */
+		kputc	#':'
+		mrc	p15, 0, r0, c1, c0
+		kphex	r0, 8		/* control reg */
+		kputc	#'\n'
+		kphex	r5, 8		/* decompressed kernel start */
+		kputc	#'-'
+		kphex	r8, 8		/* decompressed kernel end  */
+		kputc	#'>'
+		kphex	r4, 8		/* kernel execution address */
+		kputc	#'\n'
+#endif
+		.endm
+
+		.macro	debug_reloc_end
+#ifdef DEBUG
+		kphex	r5, 8		/* end of kernel */
+		kputc	#'\n'
+		mov	r0, r4
+		bl	memdump		/* dump 256 bytes at start of kernel */
+#endif
+		.endm
+
+		.section ".start", #alloc, #execinstr
+/*
+ * sort out different calling conventions
+ */
+		.align
+start:
+		.type	start,#function
+		.rept	8
+		mov	r0, r0
+		.endr
+
+		b	1f
+		.word	0x016f2818		@ Magic numbers to help the loader
+		.word	start			@ absolute load/run zImage address
+		.word	_edata			@ zImage end address
+1:		mov	r7, r1			@ save architecture ID
+		mov	r8, #0			@ save r0
+
+#ifndef __ARM_ARCH_2__
+		/*
+		 * Booting from Angel - need to enter SVC mode and disable
+		 * FIQs/IRQs (numeric definitions from angel arm.h source).
+		 * We only do this if we were in user mode on entry.
+		 */
+		mrs	r2, cpsr		@ get current mode
+		tst	r2, #3			@ not user?
+		bne	not_angel
+		mov	r0, #0x17		@ angel_SWIreason_EnterSVC
+		swi	0x123456		@ angel_SWI_ARM
+not_angel:
+		mrs	r2, cpsr		@ turn off interrupts to
+		orr	r2, r2, #0xc0		@ prevent angel from running
+		msr	cpsr_c, r2
+#else
+		teqp	pc, #0x0c000003		@ turn off interrupts
+#endif
+
+		/*
+		 * Note that some cache flushing and other stuff may
+		 * be needed here - is there an Angel SWI call for this?
+		 */
+
+		/*
+		 * some architecture specific code can be inserted
+		 * by the linker here, but it should preserve r7 and r8.
+		 */
+
+		.text
+		adr	r0, LC0
+		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}
+		subs	r0, r0, r1		@ calculate the delta offset
+
+						@ if delta is zero, we're
+		beq	not_relocated		@ running at the address we
+						@ were linked at.
+
+		/*
+		 * We're running at a different address.  We need to fix
+		 * up various pointers:
+		 *   r5 - zImage base address
+		 *   r6 - GOT start
+		 *   ip - GOT end
+		 */
+		add	r5, r5, r0
+		add	r6, r6, r0
+		add	ip, ip, r0
+
+#ifndef CONFIG_ZBOOT_ROM
+		/*
+		 * If we're running fully PIC === CONFIG_ZBOOT_ROM = n,
+		 * we need to fix up pointers into the BSS region.
+		 *   r2 - BSS start
+		 *   r3 - BSS end
+		 *   sp - stack pointer
+		 */
+		add	r2, r2, r0
+		add	r3, r3, r0
+		add	sp, sp, r0
+
+		/*
+		 * Relocate all entries in the GOT table.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		add	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#else
+
+		/*
+		 * Relocate entries in the GOT table.  We only relocate
+		 * the entries that are outside the (relocated) BSS region.
+		 */
+1:		ldr	r1, [r6, #0]		@ relocate entries in the GOT
+		cmp	r1, r2			@ entry < bss_start ||
+		cmphs	r3, r1			@ _end < entry
+		addlo	r1, r1, r0		@ table.  This fixes up the
+		str	r1, [r6], #4		@ C references.
+		cmp	r6, ip
+		blo	1b
+#endif
+
+not_relocated:	mov	r0, #0
+1:		str	r0, [r2], #4		@ clear bss
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		str	r0, [r2], #4
+		cmp	r2, r3
+		blo	1b
+
+		/*
+		 * The C runtime environment should now be setup
+		 * sufficiently.  Turn the cache on, set up some
+		 * pointers, and start decompressing.
+		 */
+
+		mov	r1, sp			@ malloc space above stack
+		add	r2, sp, #0x10000	@ 64k max
+
+/*
+ * Check to see if we will overwrite ourselves.
+ *   r4 = final kernel address
+ *   r5 = start of this image
+ *   r2 = end of malloc space (and therefore this image)
+ * We basically want:
+ *   r4 >= r2 -> OK
+ *   r4 + image length <= r5 -> OK
+ */
+		cmp	r4, r2
+		bhs	wont_overwrite
+		add	r0, r4, #4096*1024	@ 4MB largest kernel size
+		cmp	r0, r5
+		bls	wont_overwrite
+
+		mov	r5, r2			@ decompress after malloc space
+		mov	r0, r5
+		mov	r3, r7
+		bl	decompress_kernel
+
+		add	r0, r0, #127
+		bic	r0, r0, #127		@ align the kernel length
+/*
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		add	r1, r5, r0		@ end of decompressed kernel
+		adr	r2, reloc_start
+		ldr	r3, LC1
+		add	r3, r2, r3
+1:		ldmia	r2!, {r8 - r13}		@ copy relocation code
+		stmia	r1!, {r8 - r13}
+		ldmia	r2!, {r8 - r13}
+		stmia	r1!, {r8 - r13}
+		cmp	r2, r3
+		blo	1b
+
+		add	pc, r5, r0		@ call relocation code
+
+/*
+ * We're not in danger of overwriting ourselves.  Do this the simple way.
+ *
+ * r4     = kernel execution address
+ * r7     = architecture ID
+ */
+wont_overwrite:	mov	r0, r4
+		mov	r3, r7
+		bl	decompress_kernel
+		b	call_kernel
+
+		.type	LC0, #object
+LC0:		.word	LC0			@ r1
+		.word	__bss_start		@ r2
+		.word	_end			@ r3
+		.word	_load_addr		@ r4
+		.word	_start			@ r5
+		.word	_got_start		@ r6
+		.word	_got_end		@ ip
+		.word	user_stack+4096		@ sp
+LC1:		.word	reloc_end - reloc_start
+		.size	LC0, . - LC0
+
+/*
+ * All code following this line is relocatable.  It is relocated by
+ * the above code to the end of the decompressed kernel image and
+ * executed there.  During this time, we have no stacks.
+ *
+ * r0     = decompressed kernel length
+ * r1-r3  = unused
+ * r4     = kernel execution address
+ * r5     = decompressed kernel start
+ * r6     = processor ID
+ * r7     = architecture ID
+ * r8-r14 = unused
+ */
+		.align	5
+reloc_start:	add	r8, r5, r0
+		debug_reloc_start
+		mov	r1, r4
+1:
+		.rept	4
+		ldmia	r5!, {r0, r2, r3, r9 - r13}	@ relocate kernel
+		stmia	r1!, {r0, r2, r3, r9 - r13}
+		.endr
+
+		cmp	r5, r8
+		blo	1b
+		debug_reloc_end
+
+call_kernel: 	
+
+#ifdef CONFIG_ARCH_S3C44B0
+		ldr	r2, S3C44B0_PROCESSOR_TYPE
+		str     r2, [r6]
+		ldr     r2, S3C44B0_MACH_TYPE
+		str     r2, [r9]
+        	mov 	fp, #0
+		b 	1f
+S3C44B0_PROCESSOR_TYPE:
+	.long	0x44b07700
+S3C44B0_MACH_TYPE:
+	.long	MACH_TYPE_S3C44B0
+
+1:
+#endif
+
+		mov	r0, #0
+		mov	r1, r7			@ restore architecture number
+		mov	pc, r4			@ call kernel
+
+/*
+ * Various debugging routines for printing hex characters and
+ * memory, which again must be relocatable.
+ */
+#ifdef DEBUG
+		.type	phexbuf,#object
+phexbuf:	.space	12
+		.size	phexbuf, . - phexbuf
+
+phex:		adr	r3, phexbuf
+		mov	r2, #0
+		strb	r2, [r3, r1]
+1:		subs	r1, r1, #1
+		movmi	r0, r3
+		bmi	puts
+		and	r2, r0, #15
+		mov	r0, r0, lsr #4
+		cmp	r2, #10
+		addge	r2, r2, #7
+		add	r2, r2, #'0'
+		strb	r2, [r3, r1]
+		b	1b
+
+puts:		loadsp	r3
+1:		ldrb	r2, [r0], #1
+		teq	r2, #0
+		moveq	pc, lr
+2:		writeb	r2
+		mov	r1, #0x00020000
+3:		subs	r1, r1, #1
+		bne	3b
+		teq	r2, #'\n'
+		moveq	r2, #'\r'
+		beq	2b
+		teq	r0, #0
+		bne	1b
+		mov	pc, lr
+putc:
+		mov	r2, r0
+		mov	r0, #0
+		loadsp	r3
+		b	2b
+
+memdump:	mov	r12, r0
+		mov	r10, lr
+		mov	r11, #0
+2:		mov	r0, r11, lsl #2
+		add	r0, r0, r12
+		mov	r1, #8
+		bl	phex
+		mov	r0, #':'
+		bl	putc
+1:		mov	r0, #' '
+		bl	putc
+		ldr	r0, [r12, r11, lsl #2]
+		mov	r1, #8
+		bl	phex
+		and	r0, r11, #7
+		teq	r0, #3
+		moveq	r0, #' '
+		bleq	putc
+		and	r0, r11, #7
+		add	r11, r11, #1
+		teq	r0, #7
+		bne	1b
+		mov	r0, #'\n'
+		bl	putc
+		cmp	r11, #64
+		blt	2b
+		mov	pc, r10
+#endif
+
+reloc_end:
+
+		.align
+		.section ".stack", "w"
+user_stack:	.space	4096
diff -Naur linux-2.6.9/arch/armnommu/boot/compressed/head-s5c7375.S linux-2.6.9-uc0/arch/armnommu/boot/compressed/head-s5c7375.S
--- linux-2.6.9/arch/armnommu/boot/compressed/head-s5c7375.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/compressed/head-s5c7375.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,17 @@
+/* 
+ * linux/arch/armnommu/boot/compressed/head-s5c7375.S
+ * 
+ * Copyright(C)2004 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ * 
+ * Special startup code for S5C7375.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#include <linux/config.h>
+
+	.section        ".start", "ax"
+/* TODO: bus and hclk adjust codes */
+	/* fall back into head.S */
diff -Naur linux-2.6.9/arch/armnommu/boot/compressed/Makefile linux-2.6.9-uc0/arch/armnommu/boot/compressed/Makefile
--- linux-2.6.9/arch/armnommu/boot/compressed/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/compressed/Makefile	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,54 @@
+#
+# linux/arch/armnommu/boot/compressed/Makefile
+#
+# create a compressed vmlinuz image from the original vmlinux
+#
+# Note! ZTEXTADDR, ZBSSADDR and ZRELADDR are now exported
+# from arch/armnommu/boot/Makefile
+#
+
+HEAD	= head.o
+OBJS	= misc.o
+
+#
+# Architecture dependencies
+#
+ifeq ($(CONFIG_ARCH_S5C7375),y)
+OBJS		+= head-s5c7375.o
+endif
+ifeq ($(CONFIG_ARCH_S3C44B0),y)
+HEAD		= head-s3c44b0.o
+endif
+
+
+SEDFLAGS	= s/TEXT_START/$(ZTEXTADDR)/;s/LOAD_ADDR/$(ZRELADDR)/;s/BSS_START/$(ZBSSADDR)/
+
+targets       := vmlinux vmlinux.lds piggy piggy.gz piggy.o \
+                 font.o $(HEAD) $(OBJS)
+EXTRA_CFLAGS  := $(CFLAGS_BOOT) -fpic
+EXTRA_AFLAGS  := -traditional
+
+LDFLAGS_vmlinux := -p -X \
+	$(shell $(CC) $(CFLAGS) --print-libgcc-file-name) -T
+
+$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/piggy.o \
+	 	$(addprefix $(obj)/, $(OBJS)) FORCE
+	$(call if_changed,ld)
+	@:
+
+
+$(obj)/piggy: vmlinux FORCE
+	$(call if_changed,objcopy)
+
+$(obj)/piggy.gz: $(obj)/piggy FORCE
+	$(call if_changed,gzip)
+
+LDFLAGS_piggy.o := -r -b binary
+$(obj)/piggy.o:  $(obj)/piggy.gz FORCE
+	$(call if_changed,ld)
+
+$(obj)/vmlinux.lds: $(obj)/vmlinux.lds.in Makefile arch/armnommu/boot/Makefile .config
+	@sed "$(SEDFLAGS)" < $< > $@
+
+$(obj)/misc.o: $(obj)/misc.c include/asm/arch/uncompress.h lib/inflate.c
+
diff -Naur linux-2.6.9/arch/armnommu/boot/compressed/misc.c linux-2.6.9-uc0/arch/armnommu/boot/compressed/misc.c
--- linux-2.6.9/arch/armnommu/boot/compressed/misc.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/compressed/misc.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,314 @@
+/*
+ * misc.c
+ * 
+ * This is a collection of several routines from gzip-1.0.3 
+ * adapted for Linux.
+ *
+ * malloc by Hannu Savolainen 1993 and Matthias Urlichs 1994
+ *
+ * Modified for ARM Linux by Russell King
+ *
+ * Nicolas Pitre <nico@visuaide.com>  1999/04/14 :
+ *  For this code to run directly from Flash, all constant variables must
+ *  be marked with 'const' and all other variables initialized at run-time 
+ *  only.  This way all non constant variables will end up in the bss segment,
+ *  which should point to addresses in RAM and cleared to 0 on start.
+ *  This allows for a much quicker boot time.
+ */
+
+unsigned int __machine_arch_type;
+
+#include <linux/kernel.h>
+
+#include <asm/uaccess.h>
+#include <asm/arch/uncompress.h>
+
+#ifdef STANDALONE_DEBUG
+#define puts printf
+#endif
+
+#define __ptr_t void *
+
+/*
+ * Optimised C version of memzero for the ARM.
+ */
+void __memzero (__ptr_t s, size_t n)
+{
+	union { void *vp; unsigned long *ulp; unsigned char *ucp; } u;
+	int i;
+
+	u.vp = s;
+
+	for (i = n >> 5; i > 0; i--) {
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+	}
+
+	if (n & 1 << 4) {
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+	}
+
+	if (n & 1 << 3) {
+		*u.ulp++ = 0;
+		*u.ulp++ = 0;
+	}
+
+	if (n & 1 << 2)
+		*u.ulp++ = 0;
+
+	if (n & 1 << 1) {
+		*u.ucp++ = 0;
+		*u.ucp++ = 0;
+	}
+
+	if (n & 1)
+		*u.ucp++ = 0;
+}
+
+static inline __ptr_t memcpy(__ptr_t __dest, __const __ptr_t __src,
+			    size_t __n)
+{
+	int i = 0;
+	unsigned char *d = (unsigned char *)__dest, *s = (unsigned char *)__src;
+
+	for (i = __n >> 3; i > 0; i--) {
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+	}
+
+	if (__n & 1 << 2) {
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+	}
+
+	if (__n & 1 << 1) {
+		*d++ = *s++;
+		*d++ = *s++;
+	}
+
+	if (__n & 1)
+		*d++ = *s++;
+
+	return __dest;
+}
+
+/*
+ * gzip delarations
+ */
+#define OF(args)  args
+#define STATIC static
+
+typedef unsigned char  uch;
+typedef unsigned short ush;
+typedef unsigned long  ulg;
+
+#define WSIZE 0x8000		/* Window size must be at least 32k, */
+				/* and a power of two */
+
+static uch *inbuf;		/* input buffer */
+static uch window[WSIZE];	/* Sliding window buffer */
+
+static unsigned insize;		/* valid bytes in inbuf */
+static unsigned inptr;		/* index of next byte to be processed in inbuf */
+static unsigned outcnt;		/* bytes in output buffer */
+
+/* gzip flag byte */
+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
+#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
+#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define COMMENT      0x10 /* bit 4 set: file comment present */
+#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
+#define RESERVED     0xC0 /* bit 6,7:   reserved */
+
+#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+
+/* Diagnostic functions */
+#ifdef DEBUG
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}
+#  define Trace(x) fprintf x
+#  define Tracev(x) {if (verbose) fprintf x ;}
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+static int  fill_inbuf(void);
+static void flush_window(void);
+static void error(char *m);
+static void gzip_mark(void **);
+static void gzip_release(void **);
+
+extern char input_data[];
+extern char input_data_end[];
+
+static uch *output_data;
+static ulg output_ptr;
+static ulg bytes_out;
+
+static void *malloc(int size);
+static void free(void *where);
+static void error(char *m);
+static void gzip_mark(void **);
+static void gzip_release(void **);
+
+static void puts(const char *);
+
+extern int end;
+static ulg free_mem_ptr;
+static ulg free_mem_ptr_end;
+
+#define HEAP_SIZE 0x2000
+
+#include "../../../../lib/inflate.c"
+
+#ifndef STANDALONE_DEBUG
+static void *malloc(int size)
+{
+	void *p;
+
+	if (size <0) error("Malloc error");
+	if (free_mem_ptr <= 0) error("Memory error");
+
+	free_mem_ptr = (free_mem_ptr + 3) & ~3;	/* Align */
+
+	p = (void *)free_mem_ptr;
+	free_mem_ptr += size;
+
+	if (free_mem_ptr >= free_mem_ptr_end)
+		error("Out of memory");
+	return p;
+}
+
+static void free(void *where)
+{ /* gzip_mark & gzip_release do the free */
+}
+
+static void gzip_mark(void **ptr)
+{
+	arch_decomp_wdog();
+	*ptr = (void *) free_mem_ptr;
+}
+
+static void gzip_release(void **ptr)
+{
+	arch_decomp_wdog();
+	free_mem_ptr = (long) *ptr;
+}
+#else
+static void gzip_mark(void **ptr)
+{
+}
+
+static void gzip_release(void **ptr)
+{
+}
+#endif
+
+/* ===========================================================================
+ * Fill the input buffer. This is called only when the buffer is empty
+ * and at least one byte is really needed.
+ */
+int fill_inbuf(void)
+{
+	if (insize != 0)
+		error("ran out of input data");
+
+	inbuf = input_data;
+	insize = &input_data_end[0] - &input_data[0];
+
+	inptr = 1;
+	return inbuf[0];
+}
+
+/* ===========================================================================
+ * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+ * (Used for the decompressed data only.)
+ */
+void flush_window(void)
+{
+	ulg c = crc;
+	unsigned n;
+	uch *in, *out, ch;
+
+	in = window;
+	out = &output_data[output_ptr];
+	for (n = 0; n < outcnt; n++) {
+		ch = *out++ = *in++;
+		c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
+	}
+	crc = c;
+	bytes_out += (ulg)outcnt;
+	output_ptr += (ulg)outcnt;
+	outcnt = 0;
+	puts(".");
+}
+
+static void error(char *x)
+{
+	puts("\n\n");
+	puts(x);
+	puts("\n\n -- System halted");
+
+	while(1);	/* Halt */
+}
+
+#ifndef STANDALONE_DEBUG
+
+ulg
+decompress_kernel(ulg output_start, ulg free_mem_ptr_p, ulg free_mem_ptr_end_p,
+		  int arch_id)
+{
+	output_data		= (uch *)output_start;	/* Points to kernel start */
+	free_mem_ptr		= free_mem_ptr_p;
+	free_mem_ptr_end	= free_mem_ptr_end_p;
+	__machine_arch_type	= arch_id;
+
+	arch_decomp_setup();
+
+	makecrc();
+	puts("Uncompressing Linux...");
+	gunzip();
+	puts(" done, booting the kernel.\n");
+	return output_ptr;
+}
+#else
+
+char output_buffer[1500*1024];
+
+int main()
+{
+	output_data = output_buffer;
+
+	makecrc();
+	puts("Uncompressing Linux...");
+	gunzip();
+	puts("done.\n");
+	return 0;
+}
+#endif
+	
diff -Naur linux-2.6.9/arch/armnommu/boot/compressed/vmlinux.lds.in linux-2.6.9-uc0/arch/armnommu/boot/compressed/vmlinux.lds.in
--- linux-2.6.9/arch/armnommu/boot/compressed/vmlinux.lds.in	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/compressed/vmlinux.lds.in	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,60 @@
+/*
+ *  linux/arch/armnommu/boot/compressed/vmlinux.lds.in
+ *
+ *  Copyright (C) 2000 Russell King
+ *  Modified by Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+ENTRY(_start)
+SECTIONS
+{
+  . = LOAD_ADDR;
+  _load_addr = .;
+
+  . = TEXT_START;
+  _text = .;
+
+  .text : {
+    _start = .;
+    *(.start)
+    *(.text)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata)
+    *(.rodata.*)
+    *(.glue_7)
+    *(.glue_7t)
+    input_data = .;
+    arch/armnommu/boot/compressed/piggy.o
+    input_data_end = .;
+    . = ALIGN(4);
+  }
+
+  _etext = .;
+
+  _got_start = .;
+  .got			: { *(.got) }
+  _got_end = .;
+  .got.plt		: { *(.got.plt) }
+  .data			: { *(.data) }
+  _edata = .;
+
+  . = BSS_START;
+  __bss_start = .;
+  .bss			: { *(.bss) }
+  _end = .;
+
+  .stack (NOLOAD)	: { *(.stack) }
+
+  .stab 0		: { *(.stab) }
+  .stabstr 0		: { *(.stabstr) }
+  .stab.excl 0		: { *(.stab.excl) }
+  .stab.exclstr 0	: { *(.stab.exclstr) }
+  .stab.index 0		: { *(.stab.index) }
+  .stab.indexstr 0	: { *(.stab.indexstr) }
+  .comment 0		: { *(.comment) }
+}
+
diff -Naur linux-2.6.9/arch/armnommu/boot/Makefile linux-2.6.9-uc0/arch/armnommu/boot/Makefile
--- linux-2.6.9/arch/armnommu/boot/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/boot/Makefile	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,82 @@
+#
+# arch/armnommu/boot/Makefile
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 1995-2002 Russell King
+# Modified by Hyok S. Choi, 2004
+#
+
+MKIMAGE         := $(srctree)/scripts/mkuboot.sh
+
+# Note: the following conditions must always be true:
+#   ZRELADDR == virt_to_phys(TEXTADDR)
+#   PARAMS_PHYS must be with 4MB of ZRELADDR
+#   INITRD_PHYS must be in RAM
+
+   zreladdr-$(CONFIG_ARCH_S5C7375)	:= 0x00008000
+initrd_phys-$(CONFIG_ARCH_S5C7375)      := 0x00300000
+   zreladdr-$(CONFIG_ARCH_ATMEL)	:= 0x01000000
+initrd_phys-$(CONFIG_ARCH_ATMEL)	:= 0x01300000
+   zreladdr-$(CONFIG_ARCH_S3C44B0)	:= 0x0c008000
+  ztextaddr-$(CONFIG_ARCH_S3C44B0)	:= 0x0c300000
+
+ZRELADDR    := $(zreladdr-y)
+ZTEXTADDR   := $(ztextaddr-y)
+PARAMS_PHYS := $(params_phys-y)
+INITRD_PHYS := $(initrd_phys-y)
+#
+# We now have a PIC decompressor implementation.  Decompressors running
+# from RAM should not define ZTEXTADDR.  Decompressors running directly
+# from ROM or Flash must define ZTEXTADDR (preferably via the config)
+# FIXME: Previous assignment to ztextaddr-y is lost here. See SHARK
+ifeq ($(CONFIG_ZBOOT_ROM),y)
+ZTEXTADDR	:= $(CONFIG_ZBOOT_ROM_TEXT)
+ZBSSADDR	:= $(CONFIG_ZBOOT_ROM_BSS)
+else
+ZTEXTADDR	:= 0
+ZBSSADDR	:= ALIGN(4)
+endif
+
+export	ZTEXTADDR ZBSSADDR ZRELADDR INITRD_PHYS PARAMS_PHYS
+
+targets := Image zImage bootpImage
+
+$(obj)/Image: vmlinux FORCE
+	$(call if_changed,objcopy)
+	@echo '  Kernel: $@ is ready'
+
+$(obj)/zImage:	$(obj)/compressed/vmlinux FORCE
+	$(call if_changed,objcopy)
+	@echo '  Kernel: $@ is ready'
+
+quite_cmd_uimage = UIMAGE $@
+      cmd_uimage = $(CONFIG_SHELL) $(MKIMAGE) -A arm -O linux -T kernel \
+		   -C none -a $(ZRELADDR) -e $(ZRELADDR) \
+		   -n 'Linux-$(KERNELRELEASE)' -d $< $@
+
+targets += uImage
+$(obj)/uImage:	$(obj)/zImage
+	$(call if_changed,uimage)
+	@echo '  Image $@ is ready'
+
+$(obj)/bootpImage: $(obj)/bootp/bootp FORCE
+	$(call if_changed,objcopy)
+	@echo '  Kernel: $@ is ready'
+
+$(obj)/compressed/vmlinux: vmlinux FORCE
+	$(Q)$(MAKE) $(build)=$(obj)/compressed $@
+
+$(obj)/bootp/bootp: $(obj)/zImage initrd FORCE
+	$(Q)$(MAKE) $(build)=$(obj)/bootp $@
+
+.PHONY: initrd
+initrd:
+	@test "$(INITRD_PHYS)" != "" || \
+	(echo This machine does not support INITRD; exit -1)
+	@test "$(INITRD)" != "" || \
+	(echo You must specify INITRD; exit -1)
+
+subdir-	    := bootp compressed
diff -Naur linux-2.6.9/arch/armnommu/configs/atmel_defconfig linux-2.6.9-uc0/arch/armnommu/configs/atmel_defconfig
--- linux-2.6.9/arch/armnommu/configs/atmel_defconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/configs/atmel_defconfig	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,363 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_UCLINUX=y
+# CONFIG_MMU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+CONFIG_ARCH_ATMEL=y
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_S5C7375 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x01000000
+CONFIG_DRAM_SIZE=0x00400000
+CONFIG_FLASH_MEM_BASE=0x01400000
+CONFIG_FLASH_SIZE=0x00400000
+
+#
+# ATMEL Options
+#
+# CONFIG_ARCH_SUPPORTS_BIG_ENDIAN is not set
+CONFIG_ARM_CLK=40000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_MEM16_BASE=0x03000000
+CONFIG_MEM8_BASE=0x03000000
+CONFIG_IO16_BASE=0x02000000
+CONFIG_IO8_BASE=0x02000000
+CONFIG_CPU_AT91X40=y
+# CONFIG_CPU_AT91X63 is not set
+# CONFIG_ATMEL_DEBUG is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM710=y
+CONFIG_CPU_32v3=y
+CONFIG_CPU_CACHE_V3=y
+
+#
+# Processor Features
+#
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+# CONFIG_ISA_DMA is not set
+# CONFIG_FIQ is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# At least one math emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+CONFIG_PREEMPT=y
+CONFIG_CMDLINE="root=/dev/ram initrd=0x01300000,768K keepinitrd"
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_T32 is not set
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_SYSFS is not set
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SLAB=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_WAITQ=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9/arch/armnommu/configs/espd_4510b_defconfig linux-2.6.9-uc0/arch/armnommu/configs/espd_4510b_defconfig
--- linux-2.6.9/arch/armnommu/configs/espd_4510b_defconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/configs/espd_4510b_defconfig	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,485 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_UCLINUX=y
+# CONFIG_MMU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+CONFIG_ARCH_ESPD_4510B=y
+# CONFIG_ARCH_S5C7375 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x00000000
+CONFIG_DRAM_SIZE=0x00800000
+CONFIG_FLASH_MEM_BASE=0x01000000
+CONFIG_FLASH_SIZE=0x00200000
+CONFIG_ARM_CLK=50000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_REMAP_VECTORS_TO_RAM=y
+
+#
+# ESPD_4510B Options
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_S3C4510B=y
+CONFIG_CPU_32v4=y
+
+#
+# Processor Features
+#
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+# CONFIG_ISA_DMA is not set
+# CONFIG_FIQ is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# At least one math emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+CONFIG_CMDLINE=""
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_ETH_S3C4510B=y
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NE2000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_T32 is not set
+CONFIG_SERIAL_S3C4510B=y
+CONFIG_SERIAL_S3C4510B_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SLAB=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9/arch/armnommu/configs/GDB_ARMulator_defconfig linux-2.6.9-uc0/arch/armnommu/configs/GDB_ARMulator_defconfig
--- linux-2.6.9/arch/armnommu/configs/GDB_ARMulator_defconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/configs/GDB_ARMulator_defconfig	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,363 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_UCLINUX=y
+# CONFIG_MMU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+CONFIG_ARCH_ATMEL=y
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_S5C7375 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x01000000
+CONFIG_DRAM_SIZE=0x00400000
+CONFIG_FLASH_MEM_BASE=0x01400000
+CONFIG_FLASH_SIZE=0x00400000
+
+#
+# ATMEL Options
+#
+# CONFIG_ARCH_SUPPORTS_BIG_ENDIAN is not set
+CONFIG_ARM_CLK=40000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_MEM16_BASE=0x03000000
+CONFIG_MEM8_BASE=0x03000000
+CONFIG_IO16_BASE=0x02000000
+CONFIG_IO8_BASE=0x02000000
+CONFIG_CPU_AT91X40=y
+# CONFIG_CPU_AT91X63 is not set
+# CONFIG_ATMEL_DEBUG is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM710=y
+CONFIG_CPU_32v3=y
+CONFIG_CPU_CACHE_V3=y
+
+#
+# Processor Features
+#
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+# CONFIG_ISA_DMA is not set
+# CONFIG_FIQ is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# At least one math emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+CONFIG_PREEMPT=y
+CONFIG_CMDLINE="root=/dev/ram initrd=0x01300000,768K keepinitrd"
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_T32 is not set
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_SYSFS is not set
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SLAB=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_WAITQ=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9/arch/armnommu/configs/s3c3410_defconfig linux-2.6.9-uc0/arch/armnommu/configs/s3c3410_defconfig
--- linux-2.6.9/arch/armnommu/configs/s3c3410_defconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/configs/s3c3410_defconfig	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,349 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_UCLINUX=y
+# CONFIG_MMU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+# CONFIG_EXPERIMENTAL is not set
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+CONFIG_ARCH_S3C3410=y
+# CONFIG_ARCH_S5C7375 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x01000000
+CONFIG_DRAM_SIZE=0x01000000
+CONFIG_FLASH_MEM_BASE=0x00000000
+CONFIG_FLASH_SIZE=0x00200000
+
+#
+# S3C3410 Options
+#
+CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
+CONFIG_ARM_CLK=40000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_REMAP_VECTORS_TO_RAM=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM710=y
+CONFIG_CPU_32v3=y
+CONFIG_CPU_CACHE_V3=y
+CONFIG_CPU_COPY_V3=y
+CONFIG_CPU_TLB_V3=y
+
+#
+# Processor Features
+#
+CONFIG_CPU_BIG_ENDIAN=y
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+# CONFIG_ISA_DMA is not set
+# CONFIG_FIQ is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_HOTPLUG is not set
+
+#
+# At least one math emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_PM is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="ramdisk=8192 initrd=0x01300000,1M keepinitrd root=/dev/ram"
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_LEDMAN is not set
+# CONFIG_RESETSWITCH is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_T32=y
+CONFIG_SERIAL_T32_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+# CONFIG_PROC_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SLAB=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
diff -Naur linux-2.6.9/arch/armnommu/configs/s5c7375_defconfig linux-2.6.9-uc0/arch/armnommu/configs/s5c7375_defconfig
--- linux-2.6.9/arch/armnommu/configs/s5c7375_defconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/configs/s5c7375_defconfig	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,382 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_UCLINUX=y
+# CONFIG_MMU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+CONFIG_ARCH_S5C7375=y
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x00000000
+CONFIG_DRAM_SIZE=0x00400000
+CONFIG_FLASH_MEM_BASE=0x08000000
+CONFIG_FLASH_SIZE=0x00200000
+
+#
+# S5C7375 Options
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+# CONFIG_CPU_ARM710 is not set
+# CONFIG_CPU_S3C4510B is not set
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+CONFIG_CPU_MXU_ENABLE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+CONFIG_ARM_AMBA=y
+# CONFIG_ISA is not set
+# CONFIG_ISA_DMA is not set
+# CONFIG_FIQ is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_CPU_FREQ is not set
+
+#
+# At least one math emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+CONFIG_PREEMPT=y
+CONFIG_CMDLINE="root=/dev/ram initrd=0x00300000,768K keepinitrd"
+# CONFIG_LEDS is not set
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_T32=y
+CONFIG_SERIAL_T32_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_SYSFS is not set
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SLAB=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_WAITQ=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9/arch/armnommu/defconfig linux-2.6.9-uc0/arch/armnommu/defconfig
--- linux-2.6.9/arch/armnommu/defconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/defconfig	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,363 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_UCLINUX=y
+# CONFIG_MMU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+CONFIG_ARCH_ATMEL=y
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_S5C7375 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x01000000
+CONFIG_DRAM_SIZE=0x00400000
+CONFIG_FLASH_MEM_BASE=0x01400000
+CONFIG_FLASH_SIZE=0x00400000
+
+#
+# ATMEL Options
+#
+# CONFIG_ARCH_SUPPORTS_BIG_ENDIAN is not set
+CONFIG_ARM_CLK=40000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_MEM16_BASE=0x03000000
+CONFIG_MEM8_BASE=0x03000000
+CONFIG_IO16_BASE=0x02000000
+CONFIG_IO8_BASE=0x02000000
+CONFIG_CPU_AT91X40=y
+# CONFIG_CPU_AT91X63 is not set
+# CONFIG_ATMEL_DEBUG is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM710=y
+CONFIG_CPU_32v3=y
+CONFIG_CPU_CACHE_V3=y
+
+#
+# Processor Features
+#
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+# CONFIG_ISA_DMA is not set
+# CONFIG_FIQ is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# At least one math emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+CONFIG_PREEMPT=y
+CONFIG_CMDLINE="root=/dev/ram initrd=0x01300000,768K keepinitrd"
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_T32 is not set
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_SYSFS is not set
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SLAB=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_WAITQ=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9/arch/armnommu/Kconfig linux-2.6.9-uc0/arch/armnommu/Kconfig
--- linux-2.6.9/arch/armnommu/Kconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/Kconfig	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,642 @@
+
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+
+mainmenu "uClinux/ARM (w/o MMU) Kernel Configuration"
+
+config ARM
+	bool
+	default y
+config UCLINUX
+	bool
+	default y
+	help
+	  uClinux is the MMU-less version of Linux Kernel.
+
+	  The ARM series is a line of low-power-consumption RISC chip designs
+	  licensed by ARM ltd and targeted at embedded applications and
+	  handhelds such as the Compaq IPAQ.  ARM-based PCs are no longer
+	  manufactured, but  legacy ARM-based PC hardware remains popular in
+	  Europe.
+
+	  There is an ARM(w/MMU) Linux project with a web page at
+	  <http://www.arm.linux.org.uk/>.
+
+	  The recent cores are designed to address a wide variety of applications.
+	  Many cores for application platform have Memory Mangement Unit(MMU),
+	  however, other cores for embedded systems, secure application have
+	  only MPU or even NONE, although heavily used in many SoCs.
+
+	  There is an ARM(w/o MMU) uClinux project with a web page at
+	  <http://adam.kaist.ac.kr/~hschoe/>.
+
+config MMU
+	bool
+	default n
+	help
+	  We don't use paged MMU here. 
+
+config MPU
+	bool
+	help
+	  Some cores of ARM series have Memory Processing Unit(MPU).
+	  Refer your core manual.
+
+	  Say Y here if your ARM core has MPU.
+
+	  Otherwise, say N.
+
+config EISA
+	bool
+	---help---
+	  The Extended Industry Standard Architecture (EISA) bus was
+	  developed as an open alternative to the IBM MicroChannel bus.
+
+	  The EISA bus provided some of the features of the IBM MicroChannel
+	  bus while maintaining backward compatibility with cards made for
+	  the older ISA bus.  The EISA bus saw limited use between 1988 and
+	  1995 when it was made obsolete by the PCI bus.
+
+	  Say Y here if you are building a kernel for an EISA-based machine.
+
+	  Otherwise, say N.
+
+config SBUS
+	bool
+
+config MCA
+	bool
+	help
+	  MicroChannel Architecture is found in some IBM PS/2 machines and
+	  laptops.  It is a bus system similar to PCI or ISA. See
+	  <file:Documentation/mca.txt> (and especially the web page given
+	  there) before attempting to build an MCA bus kernel.
+
+config UID16
+	bool
+	default y
+
+config RWSEM_GENERIC_SPINLOCK
+	bool
+	default y
+
+config RWSEM_XCHGADD_ALGORITHM
+	bool
+
+config GENERIC_BUST_SPINLOCK
+	bool
+
+config GENERIC_ISA_DMA
+	bool
+
+source "init/Kconfig"
+
+
+menu "System Type"
+
+choice
+	prompt "ARM system type"
+	default ARCH_S3C3410
+
+config ARCH_ATMEL
+	bool "Atmel AT91xxx"
+	help
+	  The AT91xxx Series is a subset of the Atmel AT91 16/32-bit
+	  microcontroller family, which is based on the ARM7TDMI
+	  processor core.
+	  refer <http://www.atmel.com>
+
+	  You can also choose this architecture for The GDB/Armulator.
+	  It emulates AT91F40, include ARM7TDMI core and timers/serial.
+	  refer <http://www.uclinux.org/pub/uClinux/utilities/armulator/>.
+
+config ARCH_S3C3410
+	bool "Samsung S3C3410X"
+	help
+	  Samsung's S3C3410X(KS17C40100) 16/32-bit RISC MCU
+	  is a cost-effective and high-performance MCU solution for PDA and
+	  general purpose application. The core is ARM7TDMI. 
+	  
+	  refer <http://www.samsungsemi.com>.
+
+config ARCH_ESPD_4510B
+	bool "ESPD 4510B / Samsung S3C4510B"
+	help
+	  ESPD 4510B evaluation board built on Samsung's
+	  S3C4510B(KS32C50100) 16/32-bit RISC MCU
+	  is a high performance network controller based
+	  on the ARM7TDMI core.
+	  
+	  refer to  <http://www.espd-inc.com/prod01-arm-samsung4510.htm>
+
+config ARCH_S3C44B0
+	bool "Samsung S3C44B0"
+	help
+	  Samsung's S3C44B0X 16/32-bit SOC(ARM7TDMI) without coprocessor 
+ 
+config ARCH_S5C7375
+	bool "Samsung S5C7375"
+	help
+	  Samsung's S5C7375 16/32-bit SOC(ARM920T) for internal use.
+
+endchoice
+
+config SET_MEM_PARAM
+	bool "Set flash/sdram size and base addr"
+	help
+	 Say Y to manually set the base addresses and sizes.
+	 otherwise, the default values are assigned.
+
+config DRAM_BASE
+	hex '(S)DRAM Base Address' if SET_MEM_PARAM
+	default 0x01000000 if ARCH_ATMEL
+	default 0x01000000 if ARCH_S3C3410
+	default 0x0C000000 if ARCH_S3C44B0
+	default 0x00000000 if ARCH_S5C7375
+	default 0x00000000 if ARCH_ESPD_4510B
+	default 0x00800000
+
+config DRAM_SIZE
+	hex '(S)DRAM SIZE' if SET_MEM_PARAM
+	default 0x00600000 if ARCH_ATMEL
+	default 0x01000000 if ARCH_S3C3410
+	default 0x01000000 if ARCH_S3C44B0
+	default 0x00400000 if ARCH_S5C7375
+	default 0x00800000 if ARCH_ESPD_4510B
+	default 0x00800000
+
+config FLASH_MEM_BASE
+	hex 'FLASH Base Address' if SET_MEM_PARAM
+	default 0x01600000 if ARCH_ATMEL
+	default 0x00000000 if ARCH_S3C3410
+	default 0x00000000 if ARCH_S3C44B0
+	default 0x08000000 if ARCH_S5C7375
+	default 0x01000000 if ARCH_ESPD_4510B
+	default 0x00400000
+
+config FLASH_SIZE
+	hex 'FLASH Size' if SET_MEM_PARAM
+	default 0x00200000 if ARCH_ATMEL
+	default 0x00200000 if ARCH_S3C3410
+	default 0x00200000 if ARCH_S3C44B0
+	default 0x00200000 if ARCH_S5C7375
+	default 0x00200000 if ARCH_ESPD_4510B
+	default 0x00400000
+
+source "arch/armnommu/mach-atmel/Kconfig"
+source "arch/armnommu/mach-s3c3410/Kconfig"
+source "arch/armnommu/mach-s3c44b0x/Kconfig"
+source "arch/armnommu/mach-s5c7375/Kconfig"
+source "arch/armnommu/mach-espd_4510b/Kconfig"
+
+source arch/armnommu/mm/Kconfig
+
+endmenu
+
+
+menu "General setup"
+
+# Now handle the bus types
+config PCI
+	bool "PCI support"
+	default n
+	help
+	  Find out whether you have a PCI motherboard. PCI is the name of a
+	  bus system, i.e. the way the CPU talks to the other stuff inside
+	  your box. Other bus systems are ISA, EISA, MicroChannel (MCA) or
+	  VESA. If you have PCI, say Y, otherwise N.
+
+	  The PCI-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>, contains valuable
+	  information about which PCI hardware does work under Linux and which
+	  doesn't.
+
+# Select the host bridge type
+config ARM_AMBA
+	bool
+	depends on ARCH_S5C7375
+	default y
+
+config ISA
+	bool
+	default n
+	help
+	  Find out whether you have ISA slots on your motherboard.  ISA is the
+	  name of a bus system, i.e. the way the CPU talks to the other stuff
+	  inside your box.  Other bus systems are PCI, EISA, MicroChannel
+	  (MCA) or VESA.  ISA is an older system, now being displaced by PCI;
+	  newer boards don't support it.  If you have ISA, say Y, otherwise N.
+
+config ISA_DMA
+	bool
+	default n
+
+config FIQ
+	bool
+	default n
+
+# Compressed boot loader in ROM.  Yes, we really want to ask about
+# TEXT and BSS so we preserve their values in the config files.
+config ZBOOT_ROM
+	bool "Compressed boot loader in ROM/flash"
+	help
+	  Say Y here if you intend to execute your compressed kernel image (zImage)
+	  directly from ROM or flash.  If unsure, say N.
+
+config ZBOOT_ROM_TEXT
+	hex "Compressed ROM boot loader base address"
+	default "0"
+	help
+	  The base address for zImage.  Unless you have special requirements, you
+	  should not change this value.
+
+config ZBOOT_ROM_BSS
+	hex "Compressed ROM boot loader BSS address"
+	default "0"
+	help
+	  The base address of 64KB of read/write memory, which must be available
+	  while the decompressor is running.  Unless you have special requirements,
+	  you should not change this value.
+
+config CPU_FREQ
+	bool "Support CPU clock change (EXPERIMENTAL)"
+	depends on (ARCH_S5C7375) && EXPERIMENTAL
+	help
+	  CPU clock scaling allows you to change the clock speed of the
+	  running CPU on the fly. This is a nice method to save battery power,
+	  because the lower the clock speed, the less power the CPU
+	  consumes. Note that this driver doesn't automatically change the CPU
+	  clock speed, you need some userland tools (which still have to be
+	  written) to implement the policy. If you don't understand what this
+	  is all about, it's safe to say 'N'.
+
+
+source "drivers/pci/Kconfig"
+
+source "drivers/pcmcia/Kconfig"
+
+comment "At least one math emulation must be selected"
+
+config FPE_NWFPE
+	bool "NWFPE math emulation"
+	---help---
+	  Say Y to include the NWFPE floating point emulator in the kernel.
+	  This is necessary to run most binaries. Linux does not currently
+	  support floating point hardware so you need to say Y here even if
+	  your machine has an FPA or floating point co-processor podule.
+
+	  You may say N here if you are going to load the Acorn FPEmulator
+	  early in the bootup.
+
+config FPE_NWFPE_XP
+	bool "Support extended precision"
+	depends on FPE_NWFPE
+	help
+	  Say Y to include 80-bit support in the kernel floating-point
+	  emulator.  Otherwise, only 32 and 64-bit support is compiled in.
+	  Note that gcc does not generate 80-bit operations by default,
+	  so in most cases this option only enlarges the size of the
+	  floating point emulator without any good reason.
+
+	  You almost surely want to say N here.
+
+config FPE_FASTFPE
+	bool "FastFPE math emulation (EXPERIMENTAL)"
+	depends on !CPU_32v3 && EXPERIMENTAL
+	---help---
+	  Say Y here to include the FAST floating point emulator in the kernel.
+	  This is an experimental much faster emulator which now also has full
+	  precision for the mantissa.  It does not support any exceptions.
+	  It is very simple, and approximately 3-6 times faster than NWFPE.
+
+	  It should be sufficient for most programs.  It may be not suitable
+	  for scientific calculations, but you have to check this for yourself.
+	  If you do not feel you need a faster FP emulation you should better
+	  choose NWFPE.
+
+source "fs/Kconfig.binfmt"
+
+source "drivers/base/Kconfig"
+
+config PM
+	bool "Power Management support"
+	---help---
+	  "Power Management" means that parts of your computer are shut
+	  off or put into a power conserving "sleep" mode if they are not
+	  being used.  There are two competing standards for doing this: APM
+	  and ACPI.  If you want to use either one, say Y here and then also
+	  to the requisite support below.
+
+	  Power Management is most important for battery powered laptop
+	  computers; if you have a laptop, check out the Linux Laptop home
+	  page on the WWW at <http://www.linux-on-laptops.com/> or
+	  Tuxmobil - Linux on Mobile Computers at <http://www.tuxmobil.org/>
+	  and the Battery Powered Linux mini-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
+
+	  Note that, even if you say N here, Linux on the x86 architecture
+	  will issue the hlt instruction if nothing is to be done, thereby
+	  sending the processor to sleep and saving power.
+
+config PREEMPT
+	bool "Preemptible Kernel (EXPERIMENTAL)"
+	depends on CPU_32 && EXPERIMENTAL
+	help
+	  This option reduces the latency of the kernel when reacting to
+	  real-time or interactive events by allowing a low priority process to
+	  be preempted even if it is in kernel mode executing a system call.
+	  This allows applications to run more reliably even when the system is
+	  under load.
+
+	  Say Y here if you are building a kernel for a desktop, embedded
+	  or real-time system.  Say N if you are unsure.
+
+config APM
+	tristate "Advanced Power Management Emulation"
+	depends on PM
+	---help---
+	  APM is a BIOS specification for saving power using several different
+	  techniques. This is mostly useful for battery powered laptops with
+	  APM compliant BIOSes. If you say Y here, the system time will be
+	  reset after a RESUME operation, the /proc/apm device will provide
+	  battery status information, and user-space programs will receive
+	  notification of APM "events" (e.g. battery status change).
+
+	  If you select "Y" here, you can disable actual use of the APM
+	  BIOS by passing the "apm=off" option to the kernel at boot time.
+
+	  Note that the APM support is almost completely disabled for
+	  machines with more than one CPU.
+
+	  In order to use APM, you will need supporting software. For location
+	  and more information, read <file:Documentation/pm.txt> and the
+	  Battery Powered Linux mini-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
+
+	  This driver does not spin down disk drives (see the hdparm(8)
+	  manpage ("man 8 hdparm") for that), and it doesn't turn off
+	  VESA-compliant "green" monitors.
+
+	  This driver does not support the TI 4000M TravelMate and the ACER
+	  486/DX4/75 because they don't have compliant BIOSes. Many "green"
+	  desktop machines also don't have compliant BIOSes, and this driver
+	  may cause those machines to panic during the boot phase.
+
+	  Generally, if you don't have a battery in your machine, there isn't
+	  much point in using this driver and you should say N. If you get
+	  random kernel OOPSes or reboots that don't seem to be related to
+	  anything, try disabling/enabling this option (or disabling/enabling
+	  APM in your BIOS).
+
+	  Some other things you should try when experiencing seemingly random,
+	  "weird" problems:
+
+	  1) make sure that you have enough swap space and that it is
+	  enabled.
+	  2) pass the "no-hlt" option to the kernel
+	  3) switch on floating point emulation in the kernel and pass
+	  the "no387" option to the kernel
+	  4) pass the "floppy=nodma" option to the kernel
+	  5) pass the "mem=4M" option to the kernel (thereby disabling
+	  all but the first 4 MB of RAM)
+	  6) make sure that the CPU is not over clocked.
+	  7) read the sig11 FAQ at <http://www.bitwizard.nl/sig11/>
+	  8) disable the cache from your BIOS settings
+	  9) install a fan for the video card or exchange video RAM
+	  10) install a better fan for the CPU
+	  11) exchange RAM chips
+	  12) exchange the motherboard.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called apm.
+
+config CMDLINE
+	string "Default kernel command string"
+	default ""
+	help
+	  On some architectures (EBSA110 and CATS), there is currently no way
+	  for the boot loader to pass arguments to the kernel. For these
+	  architectures, you should supply some command-line options at build
+	  time by entering them here. As a minimum, you should specify the
+	  memory size and the root device (e.g., mem=64M root=/dev/nfs).
+
+config LEDS
+	bool "Timer and CPU usage LEDs"
+	depends on ARCH_S5C7375
+	help
+	  If you say Y here, the LEDs on your machine will be used
+	  to provide useful information about your current system status.
+
+	  If you are compiling a kernel for a NetWinder or EBSA-285, you will
+	  be able to select which LEDs are active using the options below. If
+	  you are compiling a kernel for the EBSA-110 or the LART however, the
+	  red LED will simply flash regularly to indicate that the system is
+	  still functional. It is safe to say Y here if you have a CATS
+	  system, but the driver will do nothing.
+
+config LEDS_TIMER
+	bool "Timer LED" if LEDS && ARCH_S5C7375
+	depends on ARCH_S5C7375
+	help
+	  If you say Y here, one of the system LEDs (the green one on the
+	  NetWinder, the amber one on the EBSA285, or the red one on the LART)
+	  will flash regularly to indicate that the system is still
+	  operational. This is mainly useful to kernel hackers who are
+	  debugging unstable kernels.
+
+	  The LART uses the same LED for both Timer LED and CPU usage LED
+	  functions. You may choose to use both, but the Timer LED function
+	  will overrule the CPU usage LED.
+
+config LEDS_CPU
+	bool "CPU usage LED"
+	depends on LEDS && ARCH_S5C7375
+	help
+	  If you say Y here, the red LED will be used to give a good real
+	  time indication of CPU usage, by lighting whenever the idle task
+	  is not currently executing.
+
+	  The LART uses the same LED for both Timer LED and CPU usage LED
+	  functions. You may choose to use both, but the Timer LED function
+	  will overrule the CPU usage LED.
+
+config ALIGNMENT_TRAP
+	bool "Kernel-mode alignment trap handler"
+	depends on CPU_32
+	default n if ARCH_S3C3410 || ARCH_ATMEL || ARCH_ESPD_4510B
+	help
+	  ARM processors can not fetch/store information which is not
+	  naturally aligned on the bus, i.e., a 4 byte fetch must start at an
+	  address divisible by 4. On 32-bit ARM processors, these non-aligned
+	  fetch/store instructions will be emulated in software if you say
+	  here, which has a severe performance impact. This is necessary for
+	  correct operation of some network protocols. With an IP-only
+	  configuration it is safe to say N, otherwise say Y.
+
+endmenu
+
+source "drivers/parport/Kconfig"
+
+if ALIGNMENT_TRAP
+source "drivers/mtd/Kconfig"
+endif
+
+source "drivers/pnp/Kconfig"
+
+source "drivers/block/Kconfig"
+
+source "drivers/md/Kconfig"
+
+source "net/Kconfig"
+
+source "drivers/ide/Kconfig"
+
+source "drivers/scsi/Kconfig"
+
+source "drivers/message/fusion/Kconfig"
+
+source "drivers/ieee1394/Kconfig"
+
+source "drivers/message/i2o/Kconfig"
+
+source "drivers/isdn/Kconfig"
+
+#
+# input before char - char/joystick depends on it. As does USB.
+#
+source "drivers/input/Kconfig"
+
+source "drivers/char/Kconfig"
+
+source "drivers/i2c/Kconfig"
+
+#source "drivers/l3/Kconfig"
+
+source "drivers/media/Kconfig"
+
+source "fs/Kconfig"
+
+source "drivers/video/Kconfig"
+
+if PCI
+
+source "sound/Kconfig"
+
+endif
+
+source "drivers/misc/Kconfig"
+
+source "drivers/usb/Kconfig"
+
+
+menu "Kernel hacking"
+
+# RMK wants arm kernels compiled with frame pointers so hardwire this to y.
+# If you know what you are doing and are willing to live without stack
+# traces, you can get a slightly smaller kernel by setting this option to
+# n, but then RMK will have to kill you ;).
+config FRAME_POINTER
+	bool "Frame Pointer"
+	default y
+	help
+	  If you say N here, the resulting kernel will be slightly smaller and
+	  faster. However, when a problem occurs with the kernel, the
+	  information that is reported is severely limited. Most people
+	  should say Y here.
+
+config DEBUG_USER
+	bool "Verbose user fault messages"
+	help
+	  When a user program crashes due to an exception, the kernel can
+	  print a brief message explaining what the problem was. This is
+	  sometimes helpful for debugging but serves no purpose on a
+	  production system. Most people should say N here.
+
+config DEBUG_INFO
+	bool "Include GDB debugging information in kernel binary"
+	help
+	  Say Y here to include source-level debugging information in the
+	  `vmlinux' binary image. This is handy if you want to use gdb or
+	  addr2line to debug the kernel. It has no impact on the in-memory
+	  footprint of the running kernel but it can increase the amount of
+	  time and disk space needed for compilation of the kernel. If in
+	  doubt say N.
+
+config DEBUG_KERNEL
+	bool "Kernel debugging"
+	help
+	  Say Y here if you are developing drivers or trying to debug and
+	  identify kernel problems.
+
+config DEBUG_SLAB
+	bool "Debug memory allocations"
+	depends on DEBUG_KERNEL
+	help
+	  Say Y here to have the kernel do limited verification on memory
+	  allocation as well as poisoning memory on free to catch use of freed
+	  memory.
+
+config MAGIC_SYSRQ
+	bool "Magic SysRq key"
+	depends on DEBUG_KERNEL
+	help
+	  If you say Y here, you will have some control over the system even
+	  if the system crashes for example during kernel debugging (e.g., you
+	  will be able to flush the buffer cache to disk, reboot the system
+	  immediately or dump some status information). This is accomplished
+	  by pressing various keys while holding SysRq (Alt+PrintScreen). It
+	  also works on a serial console (on PC hardware at least), if you
+	  send a BREAK and then within 5 seconds a command keypress. The
+	  keys are documented in <file:Documentation/sysrq.txt>. Don't say Y
+	  unless you really know what this hack does.
+
+config DEBUG_SPINLOCK
+	bool "Spinlock debugging"
+	depends on DEBUG_KERNEL
+	help
+	  Say Y here and build SMP to catch missing spinlock initialization
+	  and certain other kinds of spinlock errors commonly made.  This is
+	  best used in conjunction with the NMI watchdog so that spinlock
+	  deadlocks are also debuggable.
+
+config DEBUG_WAITQ
+	bool "Wait queue debugging"
+	depends on DEBUG_KERNEL
+
+config DEBUG_BUGVERBOSE
+	bool "Verbose BUG() reporting (adds 70K)"
+	depends on DEBUG_KERNEL
+	help
+	  Say Y here to make BUG() panics output the file name and line number
+	  of the BUG call as well as the EIP and oops trace.  This aids
+	  debugging but costs about 70-100K of memory.
+
+config DEBUG_ERRORS
+	bool "Verbose kernel error messages"
+	depends on DEBUG_KERNEL
+	help
+	  This option controls verbose debugging information which can be
+	  printed when the kernel detects an internal error. This debugging
+	  information is useful to kernel hackers when tracking down problems,
+	  but mostly meaningless to other people. It's safe to say Y unless
+	  you are concerned with the code size or don't want to see these
+	  messages.
+
+# These options are only for real kernel hackers who want to get their hands dirty. 
+config DEBUG_LL
+	bool "Kernel low-level debugging functions"
+	depends on DEBUG_KERNEL
+	help
+	  Say Y here to include definitions of printascii, printchar, printhex
+	  in the kernel.  This is helpful if you are debugging code that
+	  executes before the console is initialized.
+
+endmenu
+
+source "security/Kconfig"
+
+source "crypto/Kconfig"
+
+source "lib/Kconfig"
+
diff -Naur linux-2.6.9/arch/armnommu/kernel/armksyms.c linux-2.6.9-uc0/arch/armnommu/kernel/armksyms.c
--- linux-2.6.9/arch/armnommu/kernel/armksyms.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/armksyms.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,169 @@
+/*
+ *  linux/arch/arm/kernel/armksyms.c
+ *
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/in6.h>
+#include <linux/syscalls.h>
+
+#include <asm/checksum.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+/*
+ * libgcc functions - functions that are used internally by the
+ * compiler...  (prototypes are not correct though, but that
+ * doesn't really matter since they're not versioned).
+ */
+extern void __ashldi3(void);
+extern void __ashrdi3(void);
+extern void __divsi3(void);
+extern void __lshrdi3(void);
+extern void __modsi3(void);
+extern void __muldi3(void);
+extern void __ucmpdi2(void);
+extern void __udivdi3(void);
+extern void __umoddi3(void);
+extern void __udivmoddi4(void);
+extern void __udivsi3(void);
+extern void __umodsi3(void);
+extern void __do_div64(void);
+
+extern void fpundefinstr(void);
+extern void fp_enter(void);
+
+/*
+ * This has a special calling convention; it doesn't
+ * modify any of the usual registers, except for LR.
+ */
+#define EXPORT_SYMBOL_ALIAS(sym,orig)		\
+ const struct kernel_symbol __ksymtab_##sym	\
+  __attribute__((section("__ksymtab"))) =	\
+    { (unsigned long)&orig, #sym };
+
+/*
+ * floating point math emulator support.
+ * These symbols will never change their calling convention...
+ */
+EXPORT_SYMBOL_ALIAS(kern_fp_enter,fp_enter);
+EXPORT_SYMBOL_ALIAS(fp_printk,printk);
+EXPORT_SYMBOL_ALIAS(fp_send_sig,send_sig);
+
+EXPORT_SYMBOL_NOVERS(__backtrace);
+
+	/* platform dependent support */
+EXPORT_SYMBOL(udelay);
+
+	/* networking */
+EXPORT_SYMBOL(csum_partial);
+EXPORT_SYMBOL(csum_partial_copy_nocheck);
+EXPORT_SYMBOL(__csum_ipv6_magic);
+
+	/* io */
+#ifndef __raw_readsb
+EXPORT_SYMBOL_NOVERS(__raw_readsb);
+#endif
+#ifndef __raw_readsw
+EXPORT_SYMBOL_NOVERS(__raw_readsw);
+#endif
+#ifndef __raw_readsl
+EXPORT_SYMBOL_NOVERS(__raw_readsl);
+#endif
+#ifndef __raw_writesb
+EXPORT_SYMBOL_NOVERS(__raw_writesb);
+#endif
+#ifndef __raw_writesw
+EXPORT_SYMBOL_NOVERS(__raw_writesw);
+#endif
+#ifndef __raw_writesl
+EXPORT_SYMBOL_NOVERS(__raw_writesl);
+#endif
+
+	/* string / mem functions */
+EXPORT_SYMBOL_NOVERS(strcpy);
+EXPORT_SYMBOL_NOVERS(strncpy);
+EXPORT_SYMBOL_NOVERS(strcat);
+EXPORT_SYMBOL_NOVERS(strncat);
+EXPORT_SYMBOL_NOVERS(strcmp);
+EXPORT_SYMBOL_NOVERS(strncmp);
+EXPORT_SYMBOL_NOVERS(strchr);
+EXPORT_SYMBOL_NOVERS(strlen);
+EXPORT_SYMBOL_NOVERS(strnlen);
+EXPORT_SYMBOL_NOVERS(strpbrk);
+EXPORT_SYMBOL_NOVERS(strrchr);
+EXPORT_SYMBOL_NOVERS(strstr);
+EXPORT_SYMBOL_NOVERS(memset);
+EXPORT_SYMBOL_NOVERS(memcpy);
+EXPORT_SYMBOL_NOVERS(memmove);
+EXPORT_SYMBOL_NOVERS(memcmp);
+EXPORT_SYMBOL_NOVERS(memscan);
+EXPORT_SYMBOL_NOVERS(__memzero);
+
+	/* user mem (segment) */
+EXPORT_SYMBOL(__arch_copy_from_user);
+EXPORT_SYMBOL(__arch_copy_to_user);
+EXPORT_SYMBOL(__arch_clear_user);
+EXPORT_SYMBOL(__arch_strnlen_user);
+EXPORT_SYMBOL(__arch_strncpy_from_user);
+
+EXPORT_SYMBOL_NOVERS(__get_user_1);
+EXPORT_SYMBOL_NOVERS(__get_user_2);
+EXPORT_SYMBOL_NOVERS(__get_user_4);
+EXPORT_SYMBOL_NOVERS(__get_user_8);
+
+EXPORT_SYMBOL_NOVERS(__put_user_1);
+EXPORT_SYMBOL_NOVERS(__put_user_2);
+EXPORT_SYMBOL_NOVERS(__put_user_4);
+EXPORT_SYMBOL_NOVERS(__put_user_8);
+
+	/* gcc lib functions */
+EXPORT_SYMBOL_NOVERS(__ashldi3);
+EXPORT_SYMBOL_NOVERS(__ashrdi3);
+EXPORT_SYMBOL_NOVERS(__divsi3);
+EXPORT_SYMBOL_NOVERS(__lshrdi3);
+EXPORT_SYMBOL_NOVERS(__modsi3);
+EXPORT_SYMBOL_NOVERS(__muldi3);
+EXPORT_SYMBOL_NOVERS(__ucmpdi2);
+EXPORT_SYMBOL_NOVERS(__udivdi3);
+EXPORT_SYMBOL_NOVERS(__umoddi3);
+EXPORT_SYMBOL_NOVERS(__udivmoddi4);
+EXPORT_SYMBOL_NOVERS(__udivsi3);
+EXPORT_SYMBOL_NOVERS(__umodsi3);
+EXPORT_SYMBOL_NOVERS(__do_div64);
+
+	/* bitops */
+EXPORT_SYMBOL(_set_bit_le);
+EXPORT_SYMBOL(_test_and_set_bit_le);
+EXPORT_SYMBOL(_clear_bit_le);
+EXPORT_SYMBOL(_test_and_clear_bit_le);
+EXPORT_SYMBOL(_change_bit_le);
+EXPORT_SYMBOL(_test_and_change_bit_le);
+EXPORT_SYMBOL(_find_first_zero_bit_le);
+EXPORT_SYMBOL(_find_next_zero_bit_le);
+
+#ifdef __ARMEB__
+EXPORT_SYMBOL(_set_bit_be);
+EXPORT_SYMBOL(_test_and_set_bit_be);
+EXPORT_SYMBOL(_clear_bit_be);
+EXPORT_SYMBOL(_test_and_clear_bit_be);
+EXPORT_SYMBOL(_change_bit_be);
+EXPORT_SYMBOL(_test_and_change_bit_be);
+EXPORT_SYMBOL(_find_first_zero_bit_be);
+EXPORT_SYMBOL(_find_next_zero_bit_be);
+#endif
+
+	/* syscalls */
+EXPORT_SYMBOL(sys_write);
+EXPORT_SYMBOL(sys_read);
+EXPORT_SYMBOL(sys_lseek);
+EXPORT_SYMBOL(sys_open);
+EXPORT_SYMBOL(sys_exit);
+EXPORT_SYMBOL(sys_wait4);
diff -Naur linux-2.6.9/arch/armnommu/kernel/asm-offsets.c linux-2.6.9-uc0/arch/armnommu/kernel/asm-offsets.c
--- linux-2.6.9/arch/armnommu/kernel/asm-offsets.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/asm-offsets.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 1995-2003 Russell King
+ *               2001-2002 Keith Owens
+ *     
+ * Generate definitions needed by assembly language modules.
+ * This code generates raw asm output which is post-processed to extract
+ * and format the required data.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+
+/*
+ * Make sure that the compiler and target are compatible.
+ */
+#if defined(__APCS_26__)
+#error Sorry, your compiler targets APCS-26 but this kernel requires APCS-32
+#endif
+/*
+ * GCC 2.95.1, 2.95.2: ignores register clobber list in asm().
+ * GCC 3.0, 3.1: general bad code generation.
+ * GCC 3.2.0: incorrect function argument offset calculation.
+ * GCC 3.2.x: miscompiles NEW_AUX_ENT in fs/binfmt_elf.c
+ *            (http://gcc.gnu.org/PR8896) and incorrect structure
+ *	      initialisation in fs/jffs2/erase.c
+ */
+#if __GNUC__ < 2 || \
+   (__GNUC__ == 2 && __GNUC_MINOR__ < 95) || \
+   (__GNUC__ == 2 && __GNUC_MINOR__ == 95 && __GNUC_PATCHLEVEL__ != 0 && \
+					     __GNUC_PATCHLEVEL__ < 3) || \
+   (__GNUC__ == 3 && __GNUC_MINOR__ < 3)
+#error Your compiler is too buggy; it is known to miscompile kernels.
+#error    Known good compilers: 2.95.3, 2.95.4, 2.96, 3.3
+#endif
+
+/* Use marker if you need to separate the values later */
+
+#define DEFINE(sym, val) \
+        asm volatile("\n->" #sym " %0 " #val : : "i" (val))
+
+#define BLANK() asm volatile("\n->" : : )
+
+int main(void)
+{
+  DEFINE(TSK_ACTIVE_MM,		offsetof(struct task_struct, active_mm));
+  BLANK();
+#if __LINUX_ARM_ARCH__ >= 6
+  DEFINE(MM_CONTEXT_ID,		offsetof(struct mm_struct, context.id));
+#endif
+  BLANK();
+  DEFINE(VMA_VM_MM,		offsetof(struct vm_area_struct, vm_mm));
+  DEFINE(VMA_VM_FLAGS,		offsetof(struct vm_area_struct, vm_flags));
+  BLANK();
+  DEFINE(VM_EXEC,	       	VM_EXEC);
+  BLANK();
+  DEFINE(PAGE_SZ,	       	PAGE_SIZE);
+  BLANK();
+  DEFINE(SYS_ERROR0,		0x9f0000);
+  return 0; 
+}
diff -Naur linux-2.6.9/arch/armnommu/kernel/calls.S linux-2.6.9-uc0/arch/armnommu/kernel/calls.S
--- linux-2.6.9/arch/armnommu/kernel/calls.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/calls.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,298 @@
+/*
+ *  linux/arch/arm/kernel/calls.S
+ *
+ *  Copyright (C) 1995-2003 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for nommu version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This file is included twice in entry-common.S
+ */
+#ifndef NR_syscalls
+#define NR_syscalls 288
+#else
+
+__syscall_start:
+/* 0 */		.long	sys_restart_syscall
+		.long	sys_exit
+		.long	sys_ni_syscall		/* was sys_fork_wrapper */
+		.long	sys_read
+		.long	sys_write
+/* 5 */		.long	sys_open
+		.long	sys_close
+		.long	sys_ni_syscall		/* was sys_waitpid */
+		.long	sys_creat
+		.long	sys_link
+/* 10 */	.long	sys_unlink
+		.long	sys_execve_wrapper
+		.long	sys_chdir
+		.long	sys_time		/* used by libc4 */
+		.long	sys_mknod
+/* 15 */	.long	sys_chmod
+		.long	sys_lchown16
+		.long	sys_ni_syscall		/* was sys_break */
+		.long	sys_ni_syscall		/* was sys_stat */
+		.long	sys_lseek
+/* 20 */	.long	sys_getpid
+		.long	sys_mount
+		.long	sys_oldumount		/* used by libc4 */
+		.long	sys_setuid16
+		.long	sys_getuid16
+/* 25 */	.long	sys_stime
+		.long	sys_ptrace
+		.long	sys_alarm		/* used by libc4 */
+		.long	sys_ni_syscall		/* was sys_fstat */
+		.long	sys_pause
+/* 30 */	.long	sys_utime		/* used by libc4 */
+		.long	sys_ni_syscall		/* was sys_stty */
+		.long	sys_ni_syscall		/* was sys_getty */
+		.long	sys_access
+		.long	sys_nice
+/* 35 */	.long	sys_ni_syscall		/* was sys_ftime */
+		.long	sys_sync
+		.long	sys_kill
+		.long	sys_rename
+		.long	sys_mkdir
+/* 40 */	.long	sys_rmdir
+		.long	sys_dup
+		.long	sys_pipe
+		.long	sys_times
+		.long	sys_ni_syscall		/* was sys_prof */
+/* 45 */	.long	sys_brk
+		.long	sys_setgid16
+		.long	sys_getgid16
+		.long	sys_ni_syscall		/* was sys_signal */
+		.long	sys_geteuid16
+/* 50 */	.long	sys_getegid16
+		.long	sys_acct
+		.long	sys_umount
+		.long	sys_ni_syscall		/* was sys_lock */
+		.long	sys_ioctl
+/* 55 */	.long	sys_fcntl
+		.long	sys_ni_syscall		/* was sys_mpx */
+		.long	sys_setpgid
+		.long	sys_ni_syscall		/* was sys_ulimit */
+		.long	sys_ni_syscall		/* was sys_olduname */
+/* 60 */	.long	sys_umask
+		.long	sys_chroot
+		.long	sys_ustat
+		.long	sys_dup2
+		.long	sys_getppid
+/* 65 */	.long	sys_getpgrp
+		.long	sys_setsid
+		.long	sys_sigaction
+		.long	sys_ni_syscall		/* was sys_sgetmask */
+		.long	sys_ni_syscall		/* was sys_ssetmask */
+/* 70 */	.long	sys_setreuid16
+		.long	sys_setregid16
+		.long	sys_sigsuspend_wrapper
+		.long	sys_sigpending
+		.long	sys_sethostname
+/* 75 */	.long	sys_setrlimit
+		.long	sys_old_getrlimit	/* used by libc4 */
+		.long	sys_getrusage
+		.long	sys_gettimeofday
+		.long	sys_settimeofday
+/* 80 */	.long	sys_getgroups16
+		.long	sys_setgroups16
+		.long	old_select		/* used by libc4 */
+		.long	sys_symlink
+		.long	sys_ni_syscall		/* was sys_lstat */
+/* 85 */	.long	sys_readlink
+		.long	sys_uselib
+		.long	sys_swapon
+		.long	sys_reboot
+		.long	old_readdir		/* used by libc4 */
+/* 90 */	.long	old_mmap		/* used by libc4 */
+		.long	sys_munmap
+		.long	sys_truncate
+		.long	sys_ftruncate
+		.long	sys_fchmod
+/* 95 */	.long	sys_fchown16
+		.long	sys_getpriority
+		.long	sys_setpriority
+		.long	sys_ni_syscall		/* was sys_profil */
+		.long	sys_statfs
+/* 100 */	.long	sys_fstatfs
+		.long	sys_ni_syscall
+		.long	sys_socketcall
+		.long	sys_syslog
+		.long	sys_setitimer
+/* 105 */	.long	sys_getitimer
+		.long	sys_newstat
+		.long	sys_newlstat
+		.long	sys_newfstat
+		.long	sys_ni_syscall		/* was sys_uname */
+/* 110 */	.long	sys_ni_syscall		/* was sys_iopl */
+		.long	sys_vhangup
+		.long	sys_ni_syscall
+		.long	sys_syscall		/* call a syscall */
+		.long	sys_wait4
+/* 115 */	.long	sys_swapoff
+		.long	sys_sysinfo
+		.long	sys_ipc
+		.long	sys_fsync
+		.long	sys_sigreturn_wrapper
+/* 120 */	.long	sys_clone_wapper
+		.long	sys_setdomainname
+		.long	sys_newuname
+		.long	sys_ni_syscall
+		.long	sys_adjtimex
+/* 125 */	.long	sys_ni_syscall		/* was sys_mprotect */
+		.long	sys_sigprocmask
+		.long	sys_ni_syscall		/* was sys_create_module */
+		.long	sys_init_module
+		.long	sys_delete_module
+/* 130 */	.long	sys_ni_syscall		/* was sys_get_kernel_syms */
+		.long	sys_quotactl
+		.long	sys_getpgid
+		.long	sys_fchdir
+		.long	sys_bdflush
+/* 135 */	.long	sys_sysfs
+		.long	sys_personality
+		.long	sys_ni_syscall		/* .long	_sys_afs_syscall */
+		.long	sys_setfsuid16
+		.long	sys_setfsgid16
+/* 140 */	.long	sys_llseek
+		.long	sys_getdents
+		.long	sys_select
+		.long	sys_flock
+		.long	sys_ni_syscall		/* was sys_msync */
+/* 145 */	.long	sys_readv
+		.long	sys_writev
+		.long	sys_getsid
+		.long	sys_fdatasync
+		.long	sys_sysctl
+/* 150 */	.long	sys_ni_syscall		/* was sys_mlock */
+		.long	sys_ni_syscall		/* was sys_munlock */
+		.long	sys_ni_syscall		/* was sys_mlockall */
+		.long	sys_ni_syscall		/* was sys_munlockall */
+		.long	sys_sched_setparam
+/* 155 */	.long	sys_sched_getparam
+		.long	sys_sched_setscheduler
+		.long	sys_sched_getscheduler
+		.long	sys_sched_yield
+		.long	sys_sched_get_priority_max
+/* 160 */	.long	sys_sched_get_priority_min
+		.long	sys_sched_rr_get_interval
+		.long	sys_nanosleep
+		.long	sys_ni_syscall		/* was sys_arm_mremap */
+		.long	sys_setresuid16
+/* 165 */	.long	sys_getresuid16
+		.long	sys_ni_syscall
+		.long	sys_ni_syscall		/* was sys_query_module */
+		.long	sys_poll
+		.long	sys_nfsservctl
+/* 170 */	.long	sys_setresgid16
+		.long	sys_getresgid16
+		.long	sys_prctl
+		.long	sys_rt_sigreturn_wrapper
+		.long	sys_rt_sigaction
+/* 175 */	.long	sys_rt_sigprocmask
+		.long	sys_rt_sigpending
+		.long	sys_rt_sigtimedwait
+		.long	sys_rt_sigqueueinfo
+		.long	sys_rt_sigsuspend_wrapper
+/* 180 */	.long	sys_pread64
+		.long	sys_pwrite64
+		.long	sys_chown16
+		.long	sys_getcwd
+		.long	sys_capget
+/* 185 */	.long	sys_capset
+		.long	sys_sigaltstack_wrapper
+		.long	sys_sendfile
+		.long	sys_ni_syscall
+		.long	sys_ni_syscall
+/* 190 */	.long	sys_vfork_wrapper
+		.long	sys_getrlimit
+		.long	sys_mmap2
+		.long	sys_truncate64
+		.long	sys_ftruncate64
+/* 195 */	.long	sys_stat64
+		.long	sys_lstat64
+		.long	sys_fstat64
+		.long	sys_lchown
+		.long	sys_getuid
+/* 200 */	.long	sys_getgid
+		.long	sys_geteuid
+		.long	sys_getegid
+		.long	sys_setreuid
+		.long	sys_setregid
+/* 205 */	.long	sys_getgroups
+		.long	sys_setgroups
+		.long	sys_fchown
+		.long	sys_setresuid
+		.long	sys_getresuid
+/* 210 */	.long	sys_setresgid
+		.long	sys_getresgid
+		.long	sys_chown
+		.long	sys_setuid
+		.long	sys_setgid
+/* 215 */	.long	sys_setfsuid
+		.long	sys_setfsgid
+		.long	sys_getdents64
+		.long	sys_pivot_root
+		.long	sys_ni_syscall		/* was sys_mincore */
+/* 220 */	.long	sys_ni_syscall		/* was sys_madvise */
+		.long	sys_fcntl64
+		.long	sys_ni_syscall /* TUX */
+		.long	sys_ni_syscall
+		.long	sys_gettid
+/* 225 */	.long	sys_readahead
+		.long	sys_setxattr
+		.long	sys_lsetxattr
+		.long	sys_fsetxattr
+		.long	sys_getxattr
+/* 230 */	.long	sys_lgetxattr
+		.long	sys_fgetxattr
+		.long	sys_listxattr
+		.long	sys_llistxattr
+		.long	sys_flistxattr
+/* 235 */	.long	sys_removexattr
+		.long	sys_lremovexattr
+		.long	sys_fremovexattr
+		.long	sys_tkill
+		.long	sys_sendfile64
+/* 240 */	.long	sys_futex
+		.long	sys_sched_setaffinity
+		.long	sys_sched_getaffinity
+		.long	sys_io_setup
+		.long	sys_io_destroy
+/* 245 */	.long	sys_io_getevents
+		.long	sys_io_submit
+		.long	sys_io_cancel
+		.long	sys_exit_group
+		.long	sys_lookup_dcookie
+/* 250 */	.long	sys_epoll_create
+		.long	sys_epoll_ctl
+		.long	sys_epoll_wait
+	 	.long	sys_ni_syscall		/* was sys_remap_file_pages *
+		.long	sys_ni_syscall	/* sys_set_thread_area */
+/* 255 */	.long	sys_ni_syscall	/* sys_get_thread_area */
+ 		.long	sys_ni_syscall	/* sys_set_tid_address */
+		.long	sys_timer_create
+		.long	sys_timer_settime
+		.long	sys_timer_gettime
+/* 260 */	.long	sys_timer_getoverrun
+		.long	sys_timer_delete
+		.long	sys_clock_settime
+		.long	sys_clock_gettime
+		.long	sys_clock_getres
+/* 265 */	.long	sys_clock_nanosleep
+		.long	sys_statfs64
+		.long	sys_fstatfs64
+		.long	sys_tgkill
+		.long	sys_utimes
+/* 270 */	.long	sys_fadvise64_64
+		.long	sys_pciconfig_iobase
+		.long	sys_pciconfig_read
+		.long	sys_pciconfig_write
+__syscall_end:
+
+		.rept	NR_syscalls - (__syscall_end - __syscall_start) / 4
+			.long	sys_ni_syscall
+		.endr
+#endif
diff -Naur linux-2.6.9/arch/armnommu/kernel/entry-common.S linux-2.6.9-uc0/arch/armnommu/kernel/entry-common.S
--- linux-2.6.9/arch/armnommu/kernel/entry-common.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/entry-common.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,255 @@
+/*
+ *  linux/arch/armnommu/kernel/entry-common.S
+ *
+ *  Copyright (C) 2000 Russell King
+
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+
+#include <asm/thread_info.h>
+#include <asm/ptrace.h>
+
+#include "../../arm/kernel/entry-header.S"
+
+/* 
+ * We rely on the fact that R0 is at the bottom of the stack (due to
+ * slow/fast restore user regs).
+ */
+#if S_R0 != 0
+#error "Please fix"
+#endif
+
+	.align	5
+/*
+ * This is the fast syscall return path.  We do as little as
+ * possible here, and this includes saving r0 back into the SVC
+ * stack.
+ */
+ret_fast_syscall:
+	disable_irq r1				@ disable interrupts
+	ldr	r1, [tsk, #TI_FLAGS]
+	tst	r1, #_TIF_WORK_MASK
+	bne	fast_work_pending
+	fast_restore_user_regs
+
+/*
+ * Ok, we need to do extra processing, enter the slow path.
+ */
+fast_work_pending:
+	str	r0, [sp, #S_R0+S_OFF]!		@ returned r0
+work_pending:
+	tst	r1, #_TIF_NEED_RESCHED
+	bne	work_resched
+	tst	r1, #_TIF_NOTIFY_RESUME | _TIF_SIGPENDING
+	beq	no_work_pending
+	mov	r0, sp				@ 'regs'
+	mov	r2, why				@ 'syscall'
+	bl	do_notify_resume
+	disable_irq r1				@ disable interrupts
+	b	no_work_pending
+
+work_resched:
+	bl	schedule
+/*
+ * "slow" syscall return path.  "why" tells us if this was a real syscall.
+ */
+ENTRY(ret_to_user)
+ret_slow_syscall:
+	disable_irq r1				@ disable interrupts
+	ldr	r1, [tsk, #TI_FLAGS]
+	tst	r1, #_TIF_WORK_MASK
+	bne	work_pending
+no_work_pending:
+	slow_restore_user_regs
+
+/*
+ * This is how we return from a fork.
+ */
+ENTRY(ret_from_fork)
+	bl	schedule_tail
+	get_thread_info tsk
+	ldr	r1, [tsk, #TI_FLAGS]		@ check for syscall tracing
+	mov	why, #1
+	tst	r1, #_TIF_SYSCALL_TRACE		@ are we tracing syscalls?
+	beq	ret_slow_syscall
+	mov	r1, sp
+	mov	r0, #1				@ trace exit [IP = 1]
+	bl	syscall_trace
+	b	ret_slow_syscall
+	
+
+#include "calls.S"
+
+/*=============================================================================
+ * SWI handler
+ *-----------------------------------------------------------------------------
+ */
+
+	/* If we're optimising for StrongARM the resulting code won't 
+	   run on an ARM7 and we can save a couple of instructions.  
+								--pb */
+#ifdef CONFIG_CPU_ARM710
+	.macro	arm710_bug_check, instr, temp
+	and	\temp, \instr, #0x0f000000	@ check for SWI
+	teq	\temp, #0x0f000000
+	bne	.Larm700bug
+	.endm
+
+.Larm700bug:
+	ldr	r0, [sp, #S_PSR]		@ Get calling cpsr
+	sub	lr, lr, #4
+	str	lr, [r8]
+	msr	spsr, r0
+	ldmia	sp, {r0 - lr}^			@ Get calling r0 - lr
+	mov	r0, r0
+	ldr	lr, [sp, #S_PC]			@ Get PC
+	add	sp, sp, #S_FRAME_SIZE
+	movs	pc, lr
+#else
+	.macro	arm710_bug_check, instr, temp
+	.endm
+#endif
+
+	.align	5
+ENTRY(vector_swi)
+	save_user_regs
+	zero_fp
+	get_scno
+	arm710_bug_check scno, ip
+
+#ifdef CONFIG_ALIGNMENT_TRAP
+	ldr	ip, __cr_alignment
+	ldr	ip, [ip]
+	mcr	p15, 0, ip, c1, c0		@ update control register
+#endif
+	enable_irq ip
+
+	str	r4, [sp, #-S_OFF]!		@ push fifth arg
+
+	get_thread_info tsk
+	ldr	ip, [tsk, #TI_FLAGS]		@ check for syscall tracing
+	bic	scno, scno, #0xff000000		@ mask off SWI op-code
+	eor	scno, scno, #OS_NUMBER << 20	@ check OS number
+	adr	tbl, sys_call_table		@ load syscall table pointer
+	tst	ip, #_TIF_SYSCALL_TRACE		@ are we tracing syscalls?
+	bne	__sys_trace
+
+	adrsvc	al, lr, ret_fast_syscall	@ return address
+	cmp	scno, #NR_syscalls		@ check upper syscall limit
+	ldrcc	pc, [tbl, scno, lsl #2]		@ call sys_* routine
+
+	add	r1, sp, #S_OFF
+2:	mov	why, #0				@ no longer a real syscall
+	cmp	scno, #ARMSWI_OFFSET
+	eor	r0, scno, #OS_NUMBER << 20	@ put OS number back
+	bcs	arm_syscall	
+	b	sys_ni_syscall			@ not private func
+
+	/*
+	 * This is the really slow path.  We're going to be doing
+	 * context switches, and waiting for our parent to respond.
+	 */
+__sys_trace:
+	add	r1, sp, #S_OFF
+	mov	r0, #0				@ trace entry [IP = 0]
+	bl	syscall_trace
+
+	adrsvc	al, lr, __sys_trace_return	@ return address
+	add	r1, sp, #S_R0 + S_OFF		@ pointer to regs
+	cmp	scno, #NR_syscalls		@ check upper syscall limit
+	ldmccia	r1, {r0 - r3}			@ have to reload r0 - r3
+	ldrcc	pc, [tbl, scno, lsl #2]		@ call sys_* routine
+	b	2b
+
+__sys_trace_return:
+	str	r0, [sp, #S_R0 + S_OFF]!	@ save returned r0
+	mov	r1, sp
+	mov	r0, #1				@ trace exit [IP = 1]
+	bl	syscall_trace
+	b	ret_slow_syscall
+
+	.align	5
+#ifdef CONFIG_ALIGNMENT_TRAP
+	.type	__cr_alignment, #object
+__cr_alignment:
+	.word	cr_alignment
+#endif
+
+	.type	sys_call_table, #object
+ENTRY(sys_call_table)
+#include "calls.S"
+
+/*============================================================================
+ * Special system call wrappers
+ */
+@ r0 = syscall number
+@ r5 = syscall table
+		.type	sys_syscall, #function
+sys_syscall:
+		eor	scno, r0, #OS_NUMBER << 20
+		cmp	scno, #NR_syscalls	@ check range
+		stmleia	sp, {r5, r6}		@ shuffle args
+		movle	r0, r1
+		movle	r1, r2
+		movle	r2, r3
+		movle	r3, r4
+		ldrle	pc, [tbl, scno, lsl #2]
+		b	sys_ni_syscall
+#ifdef CONFIG_MMU
+sys_fork_wrapper:
+		add	r0, sp, #S_OFF
+		b	sys_fork
+#endif
+
+sys_vfork_wrapper:
+		add	r0, sp, #S_OFF
+		b	sys_vfork
+
+sys_execve_wrapper:
+		add	r3, sp, #S_OFF
+		b	sys_execve
+
+sys_clone_wapper:
+		add	r2, sp, #S_OFF
+		b	sys_clone
+
+sys_sigsuspend_wrapper:
+		add	r3, sp, #S_OFF
+		b	sys_sigsuspend
+
+sys_rt_sigsuspend_wrapper:
+		add	r2, sp, #S_OFF
+		b	sys_rt_sigsuspend
+
+sys_sigreturn_wrapper:
+		add	r0, sp, #S_OFF
+		b	sys_sigreturn
+
+sys_rt_sigreturn_wrapper:
+		add	r0, sp, #S_OFF
+		b	sys_rt_sigreturn
+
+sys_sigaltstack_wrapper:
+		ldr	r2, [sp, #S_OFF + S_SP]
+		b	do_sigaltstack
+
+/*
+ * Note: off_4k (r5) is always units of 4K.  If we can't do the requested
+ * offset, we return EINVAL.
+ */
+sys_mmap2:
+#if PAGE_SHIFT > 12
+		tst	r5, #PGOFF_MASK
+		moveq	r5, r5, lsr #PAGE_SHIFT - 12
+		streq	r5, [sp, #4]
+		beq	do_mmap2
+		mov	r0, #-EINVAL
+		RETINSTR(mov,pc, lr)
+#else
+		str	r5, [sp, #4]
+		b	do_mmap2
+#endif
diff -Naur linux-2.6.9/arch/armnommu/kernel/entry.S linux-2.6.9-uc0/arch/armnommu/kernel/entry.S
--- linux-2.6.9/arch/armnommu/kernel/entry.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/entry.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,679 @@
+/*
+ *  linux/arch/armnommu/kernel/entry.S
+ *
+ *  Copyright (C) 1996,1997,1998 Russell King.
+ *  ARM700 fix by Matthew Godbolt (linux-user@willothewisp.demon.co.uk)
+ *  uClinux/ARM fix and clean-up by Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  machine independent low-level vector interface routines, only.
+ *  dependent codes gone to each machine directory, "entry-header.S"
+ *  
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+
+#include <asm/thread_info.h>
+#include <asm/glue.h>
+#include <asm/ptrace.h>
+
+#include "../../arm/kernel/entry-header.S"
+
+/* 
+ * Load-in the machine dependent Macros from:
+ *    arch/armnommu/mach-$(MACHINE)/entry-macro.S
+ *
+ *    disable_fiq		: disable FIQ
+ *    get_irqnr_and_base	: get the irq number(at least), and others.
+ *    irq_prio_table		: irq priority table
+ */
+
+#include "entry-macro.S"
+
+
+/*
+ * Invalid mode handlers
+ */
+__pabt_invalid:	sub	sp, sp, #S_FRAME_SIZE		@ Allocate frame size in one go
+		stmia	sp, {r0 - lr}			@ Save XXX r0 - lr
+		ldr	r4, .LCabt
+		mov	r1, #BAD_PREFETCH
+		b	1f
+
+__dabt_invalid:	sub	sp, sp, #S_FRAME_SIZE
+		stmia	sp, {r0 - lr}			@ Save SVC r0 - lr [lr *should* be intact]
+		ldr	r4, .LCabt
+		mov	r1, #BAD_DATA
+		b	1f
+
+__irq_invalid:	sub	sp, sp, #S_FRAME_SIZE		@ Allocate space on stack for frame
+		stmfd	sp, {r0 - lr}			@ Save r0 - lr
+		ldr	r4, .LCirq
+		mov	r1, #BAD_IRQ
+		b	1f
+
+__und_invalid:	sub	sp, sp, #S_FRAME_SIZE
+		stmia	sp, {r0 - lr}
+		ldr	r4, .LCund
+		mov	r1, #BAD_UNDEFINSTR		@ int reason
+
+1:		zero_fp
+		ldmia	r4, {r5 - r7}			@ Get XXX pc, cpsr, old_r0
+		add	r4, sp, #S_PC
+		stmia	r4, {r5 - r7}			@ Save XXX pc, cpsr, old_r0
+		mov	r0, sp
+		and	r2, r6, #31			@ int mode
+		b	bad_mode
+
+/*
+ * SVC mode handlers
+ */
+		.align	5
+__dabt_svc:	sub	sp, sp, #S_FRAME_SIZE
+		stmia	sp, {r0 - r12}			@ save r0 - r12
+		ldr	r2, .LCabt
+		add	r0, sp, #S_FRAME_SIZE
+		ldmia	r2, {r2 - r4}			@ get pc, cpsr
+		add	r5, sp, #S_SP
+		mov	r1, lr
+		stmia	r5, {r0 - r4}			@ save sp_SVC, lr_SVC, pc, cpsr, old_ro
+		mrs	r9, cpsr			@ Enable interrupts if they were
+		tst	r3, #PSR_I_BIT
+		biceq	r9, r9, #PSR_I_BIT		@ previously
+/*
+ * This routine must not corrupt r9
+ */
+#ifdef MULTI_ABORT
+		ldr	r4, .LCprocfns			@ pass r2, r3 to
+		mov	lr, pc				@ processor code
+		ldr	pc, [r4]			@ call processor specific code
+#else
+		bl	CPU_ABORT_HANDLER
+#endif
+		msr	cpsr_c, r9
+		mov	r2, sp
+		bl	do_DataAbort
+		disable_irq r0
+		ldr	r0, [sp, #S_PSR]
+		msr	spsr, r0
+		ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+
+		.align	5
+__irq_svc:	sub	sp, sp, #S_FRAME_SIZE
+		stmia	sp, {r0 - r12}			@ save r0 - r12
+		ldr	r7, .LCirq
+		add	r5, sp, #S_FRAME_SIZE
+		ldmia	r7, {r7 - r9}
+		add	r4, sp, #S_SP
+		mov	r6, lr
+		stmia	r4, {r5, r6, r7, r8, r9}	@ save sp_SVC, lr_SVC, pc, cpsr, old_ro
+#ifdef CONFIG_PREEMPT
+		get_thread_info r8
+		ldr	r9, [r8, #TI_PREEMPT]		@ get preempt count
+		add	r7, r9, #1			@ increment it
+		str	r7, [r8, #TI_PREEMPT]
+#endif
+1:		get_irqnr_and_base r0, r6, r5, lr
+		movne	r1, sp
+		@
+		@ routine called with r0 = irq number, r1 = struct pt_regs *
+		@
+		adrsvc	ne, lr, 1b
+		bne	asm_do_IRQ
+#ifdef CONFIG_PREEMPT
+		ldr	r0, [r8, #TI_FLAGS]		@ get flags
+		tst	r0, #_TIF_NEED_RESCHED
+		blne	svc_preempt
+preempt_return:
+		ldr	r0, [r8, #TI_PREEMPT]		@ read preempt value
+		teq	r0, r7
+		str	r9, [r8, #TI_PREEMPT]		@ restore preempt count
+		strne	r0, [r0, -r0]			@ bug()
+#endif
+		ldr	r0, [sp, #S_PSR]		@ irqs are already disabled
+		msr	spsr, r0
+		ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+
+		.ltorg
+
+#ifdef CONFIG_PREEMPT
+svc_preempt:	teq	r9, #0				@ was preempt count = 0
+		ldreq	r6, .LCirq_stat
+		movne	pc, lr				@ no
+		ldr	r0, [r6, #4]			@ local_irq_count
+		ldr	r1, [r6, #8]			@ local_bh_count
+		adds	r0, r0, r1
+		movne	pc, lr
+		mov	r7, #PREEMPT_ACTIVE
+		str	r7, [r8, #TI_PREEMPT]		@ set PREEMPT_ACTIVE
+1:		enable_irq r2				@ enable IRQs
+		bl	schedule
+		disable_irq r0				@ disable IRQs
+		ldr	r0, [r8, #TI_FLAGS]		@ get new tasks TI_FLAGS
+		tst	r0, #_TIF_NEED_RESCHED
+		beq	preempt_return			@ go again
+		b	1b
+#endif
+
+		.align	5
+__und_svc:	sub	sp, sp, #S_FRAME_SIZE
+		stmia	sp, {r0 - r12}			@ save r0 - r12
+		ldr	r3, .LCund
+		mov	r4, lr
+		ldmia	r3, {r5 - r7}
+		add	r3, sp, #S_FRAME_SIZE
+		add	r2, sp, #S_SP
+		stmia	r2, {r3 - r7}			@ save sp_SVC, lr_SVC, pc, cpsr, old_ro
+
+		ldr	r0, [r5, #-4]			@ r0 = instruction
+		adrsvc	al, r9, 1f			@ r9 = normal FP return
+		bl	call_fpe			@ lr = undefined instr return
+
+		mov	r0, sp				@ struct pt_regs *regs
+		bl	do_undefinstr
+
+1:		disable_irq r0
+		ldr	lr, [sp, #S_PSR]		@ Get SVC cpsr
+		msr	spsr, lr
+		ldmia	sp, {r0 - pc}^			@ Restore SVC registers
+
+		.align	5
+__pabt_svc:	sub	sp, sp, #S_FRAME_SIZE
+		stmia	sp, {r0 - r12}			@ save r0 - r12
+		ldr	r2, .LCabt
+		add	r0, sp, #S_FRAME_SIZE
+		ldmia	r2, {r2 - r4}			@ get pc, cpsr
+		add	r5, sp, #S_SP
+		mov	r1, lr
+		stmia	r5, {r0 - r4}			@ save sp_SVC, lr_SVC, pc, cpsr, old_ro
+		mrs	r9, cpsr			@ Enable interrupts if they were
+		tst	r3, #PSR_I_BIT
+		biceq	r9, r9, #PSR_I_BIT		@ previously
+		msr	cpsr_c, r9
+		mov	r0, r2				@ address (pc)
+		mov	r1, sp				@ regs
+		bl	do_PrefetchAbort		@ call abort handler
+		disable_irq r0
+		ldr	r0, [sp, #S_PSR]
+		msr	spsr, r0
+		ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+
+		.align	5
+.LCirq:		.word	__temp_irq
+.LCund:		.word	__temp_und
+.LCabt:		.word	__temp_abt
+#ifdef MULTI_ABORT
+.LCprocfns:	.word	processor
+#endif
+.LCfp:		.word	fp_enter
+#ifdef CONFIG_PREEMPT
+.LCirq_stat:	.word	irq_stat
+#endif
+
+		irq_prio_table
+
+/*
+ * User mode handlers
+ */
+		.align	5
+__dabt_usr:	sub	sp, sp, #S_FRAME_SIZE		@ Allocate frame size in one go
+		stmia	sp, {r0 - r12}			@ save r0 - r12
+		ldr	r7, .LCabt
+		add	r5, sp, #S_PC
+		ldmia	r7, {r2 - r4}			@ Get USR pc, cpsr
+		stmia	r5, {r2 - r4}			@ Save USR pc, cpsr, old_r0
+		stmdb	r5, {sp, lr}^
+		alignment_trap r7, r7, __temp_abt
+		zero_fp
+#ifdef MULTI_ABORT
+		ldr	r4, .LCprocfns			@ pass r2, r3 to
+		mov	lr, pc				@ processor code
+		ldr	pc, [r4]			@ call processor specific code
+#else
+		bl	CPU_ABORT_HANDLER
+#endif
+		enable_irq r2				@ Enable interrupts
+		mov	r2, sp
+		adrsvc	al, lr, ret_from_exception
+		b	do_DataAbort
+
+		.align	5
+__irq_usr:	sub	sp, sp, #S_FRAME_SIZE
+		stmia	sp, {r0 - r12}			@ save r0 - r12
+		ldr	r4, .LCirq
+		add	r8, sp, #S_PC
+		ldmia	r4, {r5 - r7}			@ get saved PC, SPSR
+		stmia	r8, {r5 - r7}			@ save pc, psr, old_r0
+		stmdb	r8, {sp, lr}^
+		alignment_trap r4, r7, __temp_irq
+		zero_fp
+#ifdef CONFIG_PREEMPT
+		get_thread_info r8
+		ldr	r9, [r8, #TI_PREEMPT]		@ get preempt count
+		add	r7, r9, #1			@ increment it
+		str	r7, [r8, #TI_PREEMPT]
+#endif
+1:		get_irqnr_and_base r0, r6, r5, lr
+		movne	r1, sp
+		adrsvc	ne, lr, 1b
+		@
+		@ routine called with r0 = irq number, r1 = struct pt_regs *
+		@
+		bne	asm_do_IRQ
+#ifdef CONFIG_PREEMPT
+		ldr	r0, [r8, #TI_PREEMPT]
+		teq	r0, r7
+		str	r9, [r8, #TI_PREEMPT]
+		strne	r0, [r0, -r0]
+		mov	tsk, r8
+#else
+		get_thread_info tsk
+#endif
+		mov	why, #0
+		b	ret_to_user
+
+		.ltorg
+
+		.align	5
+__und_usr:	sub	sp, sp, #S_FRAME_SIZE		@ Allocate frame size in one go
+		stmia	sp, {r0 - r12}			@ Save r0 - r12
+		ldr	r4, .LCund
+		add	r8, sp, #S_PC
+		ldmia	r4, {r5 - r7}
+		stmia	r8, {r5 - r7}			@ Save USR pc, cpsr, old_r0
+		stmdb	r8, {sp, lr}^			@ Save user sp, lr
+		alignment_trap r4, r7, __temp_und
+		zero_fp
+		tst	r6, #PSR_T_BIT			@ Thumb mode?
+		bne	fpundefinstr			@ ignore FP
+		sub	r4, r5, #4
+1:		ldrt	r0, [r4]			@ r0  = instruction
+		adrsvc	al, r9, ret_from_exception	@ r9  = normal FP return
+		adrsvc	al, lr, fpundefinstr		@ lr  = undefined instr return
+
+/*
+ * The out of line fixup for the ldrt above.
+ */
+		.section .fixup, "ax"
+2:		mov	pc, r9
+		.previous
+		.section __ex_table,"a"
+		.long	1b, 2b
+		.previous
+
+/*
+ * r0 = instruction.
+ *
+ * Check whether the instruction is a co-processor instruction.
+ * If yes, we need to call the relevant co-processor handler.
+ *
+ * Note that we don't do a full check here for the co-processor
+ * instructions; all instructions with bit 27 set are well
+ * defined.  The only instructions that should fault are the
+ * co-processor instructions.  However, we have to watch out
+ * for the ARM6/ARM7 SWI bug.
+ *
+ * Emulators may wish to make use of the following registers:
+ *  r0  - instruction opcode.
+ *  r10 - this threads thread_info structure.
+ */
+call_fpe:	enable_irq r10				@ Enable interrupts
+		tst	r0, #0x08000000			@ only CDP/CPRT/LDC/STC have bit 27
+#if defined(CONFIG_CPU_ARM610) || defined(CONFIG_CPU_ARM710)
+		and	r8, r0, #0x0f000000		@ mask out op-code bits
+		teqne	r8, #0x0f000000			@ SWI (ARM6/7 bug)?
+#endif
+		moveq	pc, lr
+		get_thread_info r10			@ get current thread
+		and	r8, r0, #0x00000f00		@ mask out CP number
+		mov	r7, #1
+		add	r6, r10, #TI_USED_CP
+		strb	r7, [r6, r8, lsr #8]		@ set appropriate used_cp[]
+		add	pc, pc, r8, lsr #6
+		mov	r0, r0
+
+		mov	pc, lr				@ CP#0
+		b	do_fpe				@ CP#1 (FPE)
+		b	do_fpe				@ CP#2 (FPE)
+		mov	pc, lr				@ CP#3
+		mov	pc, lr				@ CP#4
+		mov	pc, lr				@ CP#5
+		mov	pc, lr				@ CP#6
+		mov	pc, lr				@ CP#7
+		mov	pc, lr				@ CP#8
+		mov	pc, lr				@ CP#9
+		mov	pc, lr				@ CP#10 (VFP)
+		mov	pc, lr				@ CP#11 (VFP)
+		mov	pc, lr				@ CP#12
+		mov	pc, lr				@ CP#13
+		mov	pc, lr				@ CP#14 (Debug)
+		mov	pc, lr				@ CP#15 (Control)
+
+do_fpe:		ldr	r4, .LCfp
+		add	r10, r10, #TI_FPSTATE		@ r10 = workspace
+		ldr	pc, [r4]			@ Call FP module USR entry point
+
+/*
+ * The FP module is called with these registers set:
+ *  r0  = instruction
+ *  r5  = PC
+ *  r9  = normal "successful" return address
+ *  r10 = FP workspace
+ *  lr  = unrecognised FP instruction return address
+ */
+
+		.data
+ENTRY(fp_enter)
+		.word	fpundefinstr
+		.text
+
+fpundefinstr:	mov	r0, sp
+		adrsvc	al, lr, ret_from_exception
+		b	do_undefinstr
+
+		.align	5
+__pabt_usr:	sub	sp, sp, #S_FRAME_SIZE		@ Allocate frame size in one go
+		stmia	sp, {r0 - r12}			@ Save r0 - r12
+		ldr	r4, .LCabt
+		add	r8, sp, #S_PC
+		ldmia	r4, {r5 - r7}			@ Get USR pc, cpsr
+		stmia	r8, {r5 - r7}			@ Save USR pc, cpsr, old_r0
+		stmdb	r8, {sp, lr}^			@ Save sp_usr lr_usr
+		alignment_trap r4, r7, __temp_abt
+		zero_fp
+		enable_irq r0				@ Enable interrupts
+		mov	r0, r5				@ address (pc)
+		mov	r1, sp				@ regs
+		bl	do_PrefetchAbort		@ call abort handler
+		/* fall through */
+/*
+ * This is the return code to user mode for abort handlers
+ */
+ENTRY(ret_from_exception)
+		get_thread_info tsk
+		mov	why, #0
+		b	ret_to_user
+
+/*
+ * Register switch for ARMv3 and ARMv4 processors
+ * r0 = previous thread_info, r1 = next thread_info
+ * previous and next are guaranteed not to be the same.
+ */
+ENTRY(__switch_to)
+		add	ip, r1, #TI_CPU_SAVE
+		add r2, r2, #TI_CPU_DOMAIN
+		stmia	ip, {r4 - sl, fp, sp, lr}	@ Store most regs on stack
+		ldmib	r2, {r4 - sl, fp, sp, pc}	@ Load all regs saved previously
+
+		__INIT
+/*
+ * Vector stubs.  NOTE that we only align 'vector_IRQ' to a cache line boundary,
+ * and we rely on each stub being exactly 48 (1.5 cache lines) in size.  This
+ * means that we only ever load two cache lines for this code, or one if we're
+ * lucky.  We also copy this code to 0x200 so that we can use branches in the
+ * vectors, rather than ldr's.
+ */
+		.align	5
+__stubs_start:
+/*
+ * Interrupt dispatcher
+ * Enter in IRQ mode, spsr = SVC/USR CPSR, lr = SVC/USR PC
+ */
+vector_IRQ:	@
+		@ save mode specific registers
+		@
+		ldr	r13, .LCsirq
+		sub	lr, lr, #4
+		str	lr, [r13]			@ save lr_IRQ
+		mrs	lr, spsr
+		str	lr, [r13, #4]			@ save spsr_IRQ
+		@
+		@ now branch to the relevant MODE handling routine
+		@
+		mrs	r13, cpsr
+		bic	r13, r13, #MODE_MASK
+		orr	r13, r13, #MODE_SVC
+		msr	spsr, r13			@ switch to SVC_32 mode
+
+		and	lr, lr, #15
+		ldr	lr, [pc, lr, lsl #2]
+		movs	pc, lr				@ Changes mode and branches
+
+.LCtab_irq:	.word	__irq_usr			@  0  (USR_26 / USR_32)
+		.word	__irq_invalid			@  1  (FIQ_26 / FIQ_32)
+		.word	__irq_invalid			@  2  (IRQ_26 / IRQ_32)
+		.word	__irq_svc			@  3  (SVC_26 / SVC_32)
+		.word	__irq_invalid			@  4
+		.word	__irq_invalid			@  5
+		.word	__irq_invalid			@  6
+		.word	__irq_invalid			@  7
+		.word	__irq_invalid			@  8
+		.word	__irq_invalid			@  9
+		.word	__irq_invalid			@  a
+		.word	__irq_invalid			@  b
+		.word	__irq_invalid			@  c
+		.word	__irq_invalid			@  d
+		.word	__irq_invalid			@  e
+		.word	__irq_invalid			@  f
+
+		.align	5
+
+/*
+ * Data abort dispatcher - dispatches it to the correct handler for the processor mode
+ * Enter in ABT mode, spsr = USR CPSR, lr = USR PC
+ */
+vector_data:	@
+		@ save mode specific registers
+		@
+		ldr	r13, .LCsabt
+		sub	lr, lr, #8
+		str	lr, [r13]
+		mrs	lr, spsr
+		str	lr, [r13, #4]
+		@
+		@ now branch to the relevant MODE handling routine
+		@
+		mrs	r13, cpsr
+		bic	r13, r13, #MODE_MASK
+		orr	r13, r13, #MODE_SVC
+		msr	spsr, r13			@ switch to SVC_32 mode
+
+		and	lr, lr, #15
+		ldr	lr, [pc, lr, lsl #2]
+		movs	pc, lr				@ Changes mode and branches
+
+.LCtab_dabt:	.word	__dabt_usr			@  0  (USR_26 / USR_32)
+		.word	__dabt_invalid			@  1  (FIQ_26 / FIQ_32)
+		.word	__dabt_invalid			@  2  (IRQ_26 / IRQ_32)
+		.word	__dabt_svc			@  3  (SVC_26 / SVC_32)
+		.word	__dabt_invalid			@  4
+		.word	__dabt_invalid			@  5
+		.word	__dabt_invalid			@  6
+		.word	__dabt_invalid			@  7
+		.word	__dabt_invalid			@  8
+		.word	__dabt_invalid			@  9
+		.word	__dabt_invalid			@  a
+		.word	__dabt_invalid			@  b
+		.word	__dabt_invalid			@  c
+		.word	__dabt_invalid			@  d
+		.word	__dabt_invalid			@  e
+		.word	__dabt_invalid			@  f
+
+		.align	5
+
+/*
+ * Prefetch abort dispatcher - dispatches it to the correct handler for the processor mode
+ * Enter in ABT mode, spsr = USR CPSR, lr = USR PC
+ */
+vector_prefetch:
+		@
+		@ save mode specific registers
+		@
+		ldr	r13, .LCsabt
+		sub	lr, lr, #4
+		str	lr, [r13]			@ save lr_ABT
+		mrs	lr, spsr
+		str	lr, [r13, #4]			@ save spsr_ABT
+		@
+		@ now branch to the relevant MODE handling routine
+		@
+		mrs	r13, cpsr
+		bic	r13, r13, #MODE_MASK
+		orr	r13, r13, #MODE_SVC
+		msr	spsr, r13			@ switch to SVC_32 mode
+
+		ands	lr, lr, #15
+		ldr	lr, [pc, lr, lsl #2]
+		movs	pc, lr
+
+.LCtab_pabt:	.word	__pabt_usr			@  0 (USR_26 / USR_32)
+		.word	__pabt_invalid			@  1 (FIQ_26 / FIQ_32)
+		.word	__pabt_invalid			@  2 (IRQ_26 / IRQ_32)
+		.word	__pabt_svc			@  3 (SVC_26 / SVC_32)
+		.word	__pabt_invalid			@  4
+		.word	__pabt_invalid			@  5
+		.word	__pabt_invalid			@  6
+		.word	__pabt_invalid			@  7
+		.word	__pabt_invalid			@  8
+		.word	__pabt_invalid			@  9
+		.word	__pabt_invalid			@  a
+		.word	__pabt_invalid			@  b
+		.word	__pabt_invalid			@  c
+		.word	__pabt_invalid			@  d
+		.word	__pabt_invalid			@  e
+		.word	__pabt_invalid			@  f
+
+		.align	5
+
+/*
+ * Undef instr entry dispatcher - dispatches it to the correct handler for the processor mode
+ * Enter in UND mode, spsr = SVC/USR CPSR, lr = SVC/USR PC
+ */
+vector_undefinstr:
+		@
+		@ save mode specific registers
+		@
+		ldr	r13, .LCsund
+		str	lr, [r13]			@ save lr_UND
+		mrs	lr, spsr
+		str	lr, [r13, #4]			@ save spsr_UND
+		@
+		@ now branch to the relevant MODE handling routine
+		@
+		mrs	r13, cpsr
+		bic	r13, r13, #MODE_MASK
+		orr	r13, r13, #MODE_SVC
+		msr	spsr, r13			@ switch to SVC_32 mode
+
+		and	lr, lr, #15
+		ldr	lr, [pc, lr, lsl #2]
+		movs	pc, lr				@ Changes mode and branches
+
+.LCtab_und:	.word	__und_usr			@  0 (USR_26 / USR_32)
+		.word	__und_invalid			@  1 (FIQ_26 / FIQ_32)
+		.word	__und_invalid			@  2 (IRQ_26 / IRQ_32)
+		.word	__und_svc			@  3 (SVC_26 / SVC_32)
+		.word	__und_invalid			@  4
+		.word	__und_invalid			@  5
+		.word	__und_invalid			@  6
+		.word	__und_invalid			@  7
+		.word	__und_invalid			@  8
+		.word	__und_invalid			@  9
+		.word	__und_invalid			@  a
+		.word	__und_invalid			@  b
+		.word	__und_invalid			@  c
+		.word	__und_invalid			@  d
+		.word	__und_invalid			@  e
+		.word	__und_invalid			@  f
+
+		.align	5
+
+/*=============================================================================
+ * Undefined FIQs
+ *-----------------------------------------------------------------------------
+ * Enter in FIQ mode, spsr = ANY CPSR, lr = ANY PC
+ * MUST PRESERVE SVC SPSR, but need to switch to SVC mode to show our msg.
+ * Basically to switch modes, we *HAVE* to clobber one register...  brain
+ * damage alert!  I don't think that we can execute any code in here in any
+ * other mode than FIQ...  Ok you can switch to another mode, but you can't
+ * get out of that mode without clobbering one register.
+ */
+vector_FIQ:	disable_fiq
+		subs	pc, lr, #4
+
+/*=============================================================================
+ * Address exception handler
+ *-----------------------------------------------------------------------------
+ * These aren't too critical.
+ * (they're not supposed to happen, and won't happen in 32-bit data mode).
+ */
+
+vector_addrexcptn:
+		b	vector_addrexcptn
+
+/*
+ * We group all the following data together to optimise
+ * for CPUs with separate I & D caches.
+ */
+		.align	5
+
+.LCvswi:	.word	vector_swi
+
+.LCsirq:	.word	__temp_irq
+.LCsund:	.word	__temp_und
+.LCsabt:	.word	__temp_abt
+
+__stubs_end:
+
+		.equ	__real_stubs_start, .LCvectors + 0x200
+
+.LCvectors:	swi	SYS_ERROR0
+		b	__real_stubs_start + (vector_undefinstr - __stubs_start)
+		ldr	pc, __real_stubs_start + (.LCvswi - __stubs_start)
+		b	__real_stubs_start + (vector_prefetch - __stubs_start)
+		b	__real_stubs_start + (vector_data - __stubs_start)
+		b	__real_stubs_start + (vector_addrexcptn - __stubs_start)
+		b	__real_stubs_start + (vector_IRQ - __stubs_start)
+		b	__real_stubs_start + (vector_FIQ - __stubs_start)
+
+ENTRY(__trap_init)
+		stmfd	sp!, {r4 - r6, lr}
+
+		adr	r1, .LCvectors			@ set up the vectors
+		ldmia	r1, {r1, r2, r3, r4, r5, r6, ip, lr}
+		stmia	r0, {r1, r2, r3, r4, r5, r6, ip, lr}
+
+		add	r2, r0, #0x200
+		adr	r0, __stubs_start		@ copy stubs to 0x200
+		adr	r1, __stubs_end
+1:		ldr	r3, [r0], #4
+		str	r3, [r2], #4
+		cmp	r0, r1
+		blt	1b
+		LOADREGS(fd, sp!, {r4 - r6, pc})
+
+		.data
+
+/*
+ * Do not reorder these, and do not insert extra data between...
+ */
+
+__temp_irq:	.word	0				@ saved lr_irq
+		.word	0				@ saved spsr_irq
+		.word	-1				@ old_r0
+__temp_und:	.word	0				@ Saved lr_und
+		.word	0				@ Saved spsr_und
+		.word	-1				@ old_r0
+__temp_abt:	.word	0				@ Saved lr_abt
+		.word	0				@ Saved spsr_abt
+		.word	-1				@ old_r0
+
+		.globl	cr_alignment
+		.globl	cr_no_alignment
+cr_alignment:
+		.space	4
+cr_no_alignment:
+		.space	4
diff -Naur linux-2.6.9/arch/armnommu/kernel/head.S linux-2.6.9-uc0/arch/armnommu/kernel/head.S
--- linux-2.6.9/arch/armnommu/kernel/head.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/head.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,190 @@
+/*
+ *  linux/arch/armnommu/kernel/head.S
+ *
+ *  Copyright (C) 1994-2002 Russell King
+ *  Copyright (C) 2003,2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Common kernel startup code
+ *    for 32-bit CPUs which has a process ID register.
+ *
+ *  note:
+ *  For the architectures which has NO process ID register (MMU/MPU),
+ *   or which needs some architecture specific setup codes,
+ *   Please create a "head.S" in each machine directories.
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+/*
+ * Kernel startup entry point.
+ * ---------------------------
+ *
+ * This is normally called from the decompressor code.  The requirements
+ * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
+ * r1 = machine nr.
+ *
+ * See linux/arch/arm/tools/mach-types for the complete list of machine
+ * numbers for r1.
+ *
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+	bl	__lookup_processor_type
+	teq	r10, #0				@ invalid processor?
+	moveq	r0, #'p'			@ yes, error 'p'
+	beq	__error
+	bl	__lookup_architecture_type
+	teq	r7, #0				@ invalid architecture?
+	moveq	r0, #'a'			@ yes, error 'a'
+	beq	__error
+
+/*
+ * Set the Control Register and Read the process ID.
+ */
+	mrc	p15, 0, r0, c1, c0, 0		@ write control reg
+#ifdef CONFIG_ALIGNMENT_TRAP
+	orr	r0, r0, #2			@ ...........A.
+#endif
+	mcr	p15, 0, r0, c1, c0, 0		@ write control reg
+	mrc	p15, 0, r3, c0, c0, 0		@ read id reg
+
+/*
+ *  r0  = processor control register
+ *  r1  = machine ID
+ *  r9  = processor ID
+ *  r12 = value of r0 when kernel was called (currently always zero)
+ */
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r7, r8, sp}			@ Setup stack
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r7					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+	str	r9, [r6]			@ Save processor ID
+	str	r1, [r8]			@ Save machine type
+
+	b	start_kernel
+
+LC0:	.long	__bss_start			@ r5
+        .long	processor_id			@ r6
+        .long	_end				@ r7
+	.long   __machine_arch_type		@ r8
+        .long	init_thread_union+8192		@ sp
+
+/*
+ * Exception handling.  Something went wrong and we can't proceed.  We
+ * ought to tell the user, but since we don't have any guarantee that
+ * we're even running on the right architecture, we do virtually nothing.
+ *
+ * r0 = ascii error character:
+ *	a = invalid architecture
+ *	p = invalid processor
+ *	i = invalid calling convention
+ *
+ * Generally, only serious errors cause this.
+ */
+__error:
+#ifdef CONFIG_DEBUG_LL
+	mov	r8, r0				@ preserve r0
+	adr	r0, err_str
+	bl	printascii
+	mov	r0, r8
+	bl	printch
+#endif
+1:	mov	r0, r0
+	b	1b
+
+#ifdef CONFIG_DEBUG_LL
+err_str:
+	.asciz	"\nError: "
+	.align
+#endif
+
+/*
+ * Read processor ID register (CP#15, CR0), and look up in the linker-built
+ * supported processor list.  Note that we can't use the absolute addresses
+ * for the __proc_info lists since we aren't running with the MMU on
+ * (and therefore, we are not in the correct address space).  We have to
+ * calculate the offset.
+ *
+ * Returns:
+ *	r5, r6, r7 corrupted
+ *	r8  = page table flags
+ *	r9  = processor ID
+ *	r10 = pointer to processor structure
+ */
+__lookup_processor_type:
+	adr	r5, 2f
+	ldmia	r5, {r7, r9, r10}
+	sub	r5, r5, r10			@ convert addresses
+	add	r7, r7, r5			@ to our address space
+	add	r10, r9, r5
+	mrc	p15, 0, r9, c0, c0		@ get processor id
+1:	ldmia	r10, {r5, r6}			@ value, mask
+	and	r6, r6, r9			@ mask wanted bits
+	teq	r5, r6
+	moveq	pc, lr
+	add	r10, r10, #PROC_INFO_SZ		@ sizeof(proc_info_list)
+	cmp	r10, r7
+	blt	1b
+	mov	r10, #0				@ unknown processor
+	mov	pc, lr
+
+/*
+ * Look in include/asm-armnommu/procinfo.h and arch/armnommu/kernel/arch.[ch] for
+ * more information about the __proc_info and __arch_info structures.
+ */
+2:	.long	__proc_info_end
+	.long	__proc_info_begin
+	.long	2b
+	.long	__arch_info_begin
+	.long	__arch_info_end
+
+/*
+ * Lookup machine architecture in the linker-build list of architectures.
+ * Note that we can't use the absolute addresses for the __arch_info
+ * lists since we aren't running with the MMU on (and therefore, we are
+ * not in the correct address space).  We have to calculate the offset.
+ *
+ *  r1 = machine architecture number
+ * Returns:
+ *  r2, r3, r4 corrupted
+ *  r5 = physical start address of RAM
+ *  r6 = physical address of IO
+ *  r7 = byte offset into page tables for IO
+ */
+__lookup_architecture_type:
+	adr	r4, 2b
+	ldmia	r4, {r2, r3, r5, r6, r7}	@ throw away r2, r3
+	sub	r5, r4, r5			@ convert addresses
+	add	r4, r6, r5			@ to our address space
+	add	r7, r7, r5
+1:	ldr	r5, [r4]			@ get machine type
+	teq	r5, r1				@ matches loader number?
+	beq	2f				@ found
+	add	r4, r4, #SIZEOF_MACHINE_DESC	@ next machine_desc
+	cmp	r4, r7
+	blt	1b
+	mov	r7, #0				@ unknown architecture
+	mov	pc, lr
+2:	ldmib	r4, {r5, r6, r7}		@ found, get results
+	mov	pc, lr
diff -Naur linux-2.6.9/arch/armnommu/kernel/init_task.c linux-2.6.9-uc0/arch/armnommu/kernel/init_task.c
--- linux-2.6.9/arch/armnommu/kernel/init_task.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/init_task.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,43 @@
+/*
+ *  linux/arch/armnommu/kernel/init_task.c
+ */
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/init_task.h>
+
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+
+static struct fs_struct init_fs = INIT_FS;
+static struct files_struct init_files = INIT_FILES;
+static struct signal_struct init_signals = INIT_SIGNALS(init_signals);
+static struct sighand_struct init_sighand = INIT_SIGHAND(init_sighand);
+struct mm_struct init_mm = INIT_MM(init_mm);
+
+EXPORT_SYMBOL(init_mm);
+
+/*
+ * Initial thread structure.
+ *
+ * We need to make sure that this is 8192-byte aligned due to the
+ * way process stacks are handled. This is done by making sure
+ * the linker maps this in the .text segment right after head.S,
+ * and making head.S ensure the proper alignment.
+ *
+ * The things we do for performance..
+ */
+union thread_union init_thread_union
+	__attribute__((__section__(".init.task"))) =
+		{ INIT_THREAD_INFO(init_task) };
+
+/*
+ * Initial task structure.
+ *
+ * All other task structs will be allocated on slabs in fork.c
+ */
+struct task_struct init_task = INIT_TASK(init_task);
+
+EXPORT_SYMBOL(init_task);
diff -Naur linux-2.6.9/arch/armnommu/kernel/Makefile linux-2.6.9-uc0/arch/armnommu/kernel/Makefile
--- linux-2.6.9/arch/armnommu/kernel/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/Makefile	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,60 @@
+##
+# arch/armnommu/kernel/Makefile
+# modified for uClinux by Hyok S. Choi, 2004
+#
+
+AFLAGS_head.o := -DTEXTADDR=$(TEXTADDR)
+
+# Object file lists.
+
+obj-y		:= compat.o dma.o entry.o entry-common.o irq.o   \
+		   process.o ptrace.o semaphore.o setup.o signal.o sys_arm.o \
+		   time.o traps.o
+
+obj-$(CONFIG_APM)		+= apm.o
+obj-$(CONFIG_MODULES)		+= armksyms.o module.o
+obj-$(CONFIG_ISA_DMA)		+= dma-isa.o
+obj-$(CONFIG_PCI)		+= bios32.o
+
+# test if we don't need to compile the head.S, here.
+ifeq ($(HEADMACH),)
+head-y			:= head.o
+else
+head-y			:= $(HEADMACH)
+endif
+
+extra-y := $(head-y) init_task.o vmlinux.lds.s
+
+# Spell out some dependencies that aren't automatically figured out
+$(obj)/entry.o: 	arch/arm/kernel/entry-header.S include/asm-armnommu/constants.h \
+			$(obj)/../mach-$(MACHINE)/entry-macro.S $(obj)/entry-macro.S
+$(obj)/entry-common.o: 	arch/arm/kernel/entry-header.S include/asm-armnommu/constants.h \
+			$(obj)/calls.S
+$(obj)/entry-macro.S:	$(obj)/../mach-$(MACHINE)/entry-macro.S
+	@echo '  Making $(obj)/entry-macro.S -> ../mach-$(MACHINE)/entry-macro.S symlink'
+	@rm -f entry-macro.S
+	@ln -sf ../mach-$(MACHINE)/entry-macro.S $(obj)/entry-macro.S
+	@touch $@
+$(obj)/apm.o:		arch/arm/kernel/apm.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/bios32.o:	arch/arm/kernel/bios32.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/compat.o:	arch/arm/kernel/compat.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/dma-isa.o:	arch/arm/kernel/dma-isa.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/dma.o:		arch/arm/kernel/dma.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/irq.o:		arch/arm/kernel/irq.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/ptrace.o:	arch/arm/kernel/ptrace.c arch/arm/kernel/ptrace.h FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/semaphore.o:	arch/arm/kernel/semaphore.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/signal.o:	arch/arm/kernel/signal.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/time.o:		arch/arm/kernel/time.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/traps.o:		arch/arm/kernel/traps.c FORCE
+	$(call if_changed_dep,cc_o_c)
+
diff -Naur linux-2.6.9/arch/armnommu/kernel/module.c linux-2.6.9-uc0/arch/armnommu/kernel/module.c
--- linux-2.6.9/arch/armnommu/kernel/module.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/module.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,126 @@
+/*
+ *  linux/arch/armnommu/kernel/module.c
+ *
+ *  Copyright (C) 2002 Russell King.
+ *  Copyright (C) 2004 Hyok S. Choi, for nommu.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Module allocation method suggested by Andi Kleen.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+
+#include <asm/pgtable.h>
+
+#if 0
+#define DEBUGP(x, args...)	printk(KERN_DEBUG x, ## args)
+#else
+#define DEBUGP(x, args...)
+#endif
+
+
+void *module_alloc(unsigned long size)
+{
+	return size == 0 ? NULL : vmalloc(size);
+}
+
+void module_free(struct module *module, void *region)
+{
+	vfree(region);
+}
+
+int module_frob_arch_sections(Elf_Ehdr *hdr,
+			      Elf_Shdr *sechdrs,
+			      char *secstrings,
+			      struct module *mod)
+{
+	return 0;
+}
+
+int
+apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
+	       unsigned int relsec, struct module *me)
+{
+	unsigned int i;
+	Elf32_Rel *rel = (void *)sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	uint32_t *location;
+
+	DEBUGP("Applying relocate section %u to %u\n", relsec,
+			sechdrs[relsec].sh_info);
+
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		s32 offset;
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+				+ rel[i].r_offset;
+		/* This is the symbol it is referring to. Note that all
+		  undefined symbols have been resolved. */
+		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
+				+ ELF32_R_SYM(rel[i].r_info);
+
+		switch (ELF32_R_TYPE(rel[i].r_info)) {
+		case R_ARM_ABS32:
+			/* We add the value into the location given */
+			*location += sym->st_value;
+			break;
+		case R_ARM_PC24:
+			/* Add the value, subtract its position */
+			offset = (*(u32 *)location & 0x00ffffff) << 2;
+			if (offset & 0x02000000)
+				offset -= 0x04000000;
+
+			offset += sym->st_value - (uint32_t)location;
+			if (offset & 3 ||
+			    offset <= (s32)0xfc000000 ||
+			    offset >= (s32)0x04000000) {
+				printk(KERN_ERR
+				       "%s: relocation out of range, section "
+				       "%d reloc %d sym '%s'\n", me->name,
+				       relsec, i, strtab + sym->st_name);
+				return -ENOEXEC;
+			}
+
+			offset >>= 2;
+
+			*(u32 *)location &= 0xff000000;
+			*(u32 *)location |= offset & 0x00ffffff;
+			break;
+
+		default:
+			printk(KERN_ERR "%s: unknown relocation: %u\n",
+			       me->name, ELF32_R_TYPE(rel[i].r_info));
+			return -ENOEXEC;
+		}
+	}
+	return 0;
+}
+
+int
+apply_relocate_add(Elf32_Shdr *sechdrs, const char *strtab,
+		   unsigned int symindex, unsigned int relsec, struct module *module)
+{
+	printk(KERN_ERR "module %s: ADD RELOCATION unsupported\n",
+	       module->name);
+	return -ENOEXEC;
+}
+
+int
+module_finalize(const Elf32_Ehdr *hdr, const Elf_Shdr *sechdrs,
+		struct module *module)
+{
+	return 0;
+}
+
+void
+module_arch_cleanup(struct module *mod)
+{
+}
diff -Naur linux-2.6.9/arch/armnommu/kernel/process.c linux-2.6.9-uc0/arch/armnommu/kernel/process.c
--- linux-2.6.9/arch/armnommu/kernel/process.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/process.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,447 @@
+/*
+ *  linux/arch/armnommu/kernel/process.c
+ *
+ *  Copyright (C) 1996-2000 Russell King - Converted to ARM.
+ *  Copyright (C) 2003 Hyok S. Choi - uClinux changes
+ *
+ *  Original Copyright (C) 1995  Linus Torvalds
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <stdarg.h>
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+#include <linux/interrupt.h>
+#include <linux/kallsyms.h>
+#include <linux/init.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/leds.h>
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+
+extern const char *processor_modes[];
+extern void setup_mm_for_reboot(char mode);
+
+static volatile int hlt_counter;
+
+#include <asm/arch/system.h>
+
+void disable_hlt(void)
+{
+	hlt_counter++;
+}
+
+EXPORT_SYMBOL(disable_hlt);
+
+void enable_hlt(void)
+{
+	hlt_counter--;
+}
+
+EXPORT_SYMBOL(enable_hlt);
+
+static int __init nohlt_setup(char *__unused)
+{
+	hlt_counter = 1;
+	return 1;
+}
+
+static int __init hlt_setup(char *__unused)
+{
+	hlt_counter = 0;
+	return 1;
+}
+
+__setup("nohlt", nohlt_setup);
+__setup("hlt", hlt_setup);
+
+/*
+ * The following aren't currently used.
+ */
+void (*pm_idle)(void);
+EXPORT_SYMBOL(pm_idle);
+
+void (*pm_power_off)(void);
+EXPORT_SYMBOL(pm_power_off);
+
+/*
+ * This is our default idle handler.  We need to disable
+ * interrupts here to ensure we don't miss a wakeup call.
+ */
+void default_idle(void)
+{
+	local_irq_disable();
+	if (!need_resched() && !hlt_counter)
+		arch_idle();
+	local_irq_enable();
+}
+
+/*
+ * The idle thread.  We try to conserve power, while trying to keep
+ * overall latency low.  The architecture specific idle is passed
+ * a value to indicate the level of "idleness" of the system.
+ */
+void cpu_idle(void)
+{
+	/* endless idle loop with no priority at all */
+	while (1) {
+		void (*idle)(void) = pm_idle;
+		if (!idle)
+			idle = default_idle;
+		preempt_disable();
+		leds_event(led_idle_start);
+		while (!need_resched())
+			idle();
+		leds_event(led_idle_end);
+		preempt_enable();
+		schedule();
+	}
+}
+
+static char reboot_mode = 'h';
+
+int __init reboot_setup(char *str)
+{
+	reboot_mode = str[0];
+	return 1;
+}
+
+__setup("reboot=", reboot_setup);
+
+void machine_halt(void)
+{
+}
+
+EXPORT_SYMBOL(machine_halt);
+
+void machine_power_off(void)
+{
+	if (pm_power_off)
+		pm_power_off();
+}
+
+EXPORT_SYMBOL(machine_power_off);
+
+void machine_restart(char * __unused)
+{
+	/*
+	 * Clean and disable cache, and turn off interrupts
+	 */
+	cpu_proc_fin();
+
+	/*
+	 * Tell the mm system that we are going to reboot -
+	 * we may need it to insert some 1:1 mappings so that
+	 * soft boot works.
+	 */
+	setup_mm_for_reboot(reboot_mode);
+
+	/*
+	 * Now call the architecture specific reboot code.
+	 */
+	arch_reset(reboot_mode);
+
+	/*
+	 * Whoops - the architecture was unable to reboot.
+	 * Tell the user!
+	 */
+	mdelay(1000);
+	printk("Reboot failed -- System halted\n");
+	while (1);
+}
+
+EXPORT_SYMBOL(machine_restart);
+
+void show_regs(struct pt_regs * regs)
+{
+	unsigned long flags;
+
+	flags = condition_codes(regs);
+
+	print_symbol("PC is at %s\n", instruction_pointer(regs));
+	print_symbol("LR is at %s\n", regs->ARM_lr);
+	printk("pc : [<%08lx>]    lr : [<%08lx>]    %s\n"
+	       "sp : %08lx  ip : %08lx  fp : %08lx\n",
+		instruction_pointer(regs),
+		regs->ARM_lr, print_tainted(), regs->ARM_sp,
+		regs->ARM_ip, regs->ARM_fp);
+	printk("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
+		regs->ARM_r10, regs->ARM_r9,
+		regs->ARM_r8);
+	printk("r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\n",
+		regs->ARM_r7, regs->ARM_r6,
+		regs->ARM_r5, regs->ARM_r4);
+	printk("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
+		regs->ARM_r3, regs->ARM_r2,
+		regs->ARM_r1, regs->ARM_r0);
+	printk("Flags: %c%c%c%c",
+		flags & PSR_N_BIT ? 'N' : 'n',
+		flags & PSR_Z_BIT ? 'Z' : 'z',
+		flags & PSR_C_BIT ? 'C' : 'c',
+		flags & PSR_V_BIT ? 'V' : 'v');
+	printk("  IRQs o%s  FIQs o%s  Mode %s%s  Segment %s\n",
+		interrupts_enabled(regs) ? "n" : "ff",
+		fast_interrupts_enabled(regs) ? "n" : "ff",
+		processor_modes[processor_mode(regs)],
+		thumb_mode(regs) ? " (T)" : "",
+		get_fs() == get_ds() ? "kernel" : "user");
+#ifdef CONFIG_SKIP_DUMP_CPU_INFO
+	{
+		unsigned int ctrl, transbase, dac;
+		  __asm__ (
+		"	mrc p15, 0, %0, c1, c0\n"
+		"	mrc p15, 0, %1, c2, c0\n"
+		"	mrc p15, 0, %2, c3, c0\n"
+		: "=r" (ctrl), "=r" (transbase), "=r" (dac));
+		printk("Control: %04X  Table: %08X  DAC: %08X\n",
+		  	ctrl, transbase, dac);
+	}
+#endif
+}
+
+void show_fpregs(struct user_fp *regs)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		unsigned long *p;
+		char type;
+
+		p = (unsigned long *)(regs->fpregs + i);
+
+		switch (regs->ftype[i]) {
+			case 1: type = 'f'; break;
+			case 2: type = 'd'; break;
+			case 3: type = 'e'; break;
+			default: type = '?'; break;
+		}
+		if (regs->init_flag)
+			type = '?';
+
+		printk("  f%d(%c): %08lx %08lx %08lx%c",
+			i, type, p[0], p[1], p[2], i & 1 ? '\n' : ' ');
+	}
+			
+
+	printk("FPSR: %08lx FPCR: %08lx\n",
+		(unsigned long)regs->fpsr,
+		(unsigned long)regs->fpcr);
+}
+
+/*
+ * Task structure and kernel stack allocation.
+ */
+static unsigned long *thread_info_head;
+static unsigned int nr_thread_info;
+
+#define EXTRA_TASK_STRUCT	4
+#define ll_alloc_task_struct() ((struct thread_info *) __get_free_pages(GFP_KERNEL,1))
+#define ll_free_task_struct(p) free_pages((unsigned long)(p),1)
+
+struct thread_info *alloc_thread_info(struct task_struct *task)
+{
+	struct thread_info *thread = NULL;
+
+	if (EXTRA_TASK_STRUCT) {
+		unsigned long *p = thread_info_head;
+
+		if (p) {
+			thread_info_head = (unsigned long *)p[0];
+			nr_thread_info -= 1;
+		}
+		thread = (struct thread_info *)p;
+	}
+
+	if (!thread)
+		thread = ll_alloc_task_struct();
+
+#ifdef CONFIG_MAGIC_SYSRQ
+	/*
+	 * The stack must be cleared if you want SYSRQ-T to
+	 * give sensible stack usage information
+	 */
+	if (thread) {
+		char *p = (char *)thread;
+		memzero(p+KERNEL_STACK_SIZE, KERNEL_STACK_SIZE);
+	}
+#endif
+	return thread;
+}
+
+void free_thread_info(struct thread_info *thread)
+{
+	if (EXTRA_TASK_STRUCT && nr_thread_info < EXTRA_TASK_STRUCT) {
+		unsigned long *p = (unsigned long *)thread;
+		p[0] = (unsigned long)thread_info_head;
+		thread_info_head = p;
+		nr_thread_info += 1;
+	} else
+		ll_free_task_struct(thread);
+}
+
+/*
+ * Free current thread data structures etc..
+ */
+void exit_thread(void)
+{
+}
+
+static void default_fp_init(union fp_state *fp)
+{
+	memset(fp, 0, sizeof(union fp_state));
+}
+
+void (*fp_init)(union fp_state *) = default_fp_init;
+EXPORT_SYMBOL(fp_init);
+
+void flush_thread(void)
+{
+	struct thread_info *thread = current_thread_info();
+	struct task_struct *tsk = current;
+
+	memset(thread->used_cp, 0, sizeof(thread->used_cp));
+	memset(&tsk->thread.debug, 0, sizeof(struct debug_info));
+	fp_init(&thread->fpstate);
+}
+
+void release_thread(struct task_struct *dead_task)
+{
+}
+
+asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
+
+int
+copy_thread(int nr, unsigned long clone_flags, unsigned long stack_start,
+	    unsigned long stk_sz, struct task_struct *p, struct pt_regs *regs)
+{
+	struct thread_info *thread = p->thread_info;
+	struct pt_regs *childregs;
+
+	childregs = ((struct pt_regs *)((unsigned long)thread + THREAD_SIZE - 8)) - 1;
+	*childregs = *regs;
+	childregs->ARM_r0 = 0;
+	if (stack_start) childregs->ARM_sp = stack_start;
+
+	memset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));
+	thread->cpu_context.sp = (unsigned long)childregs;
+	thread->cpu_context.pc = (unsigned long)ret_from_fork;
+
+	return 0;
+}
+
+/*
+ * fill in the fpe structure for a core dump...
+ */
+int dump_fpu (struct pt_regs *regs, struct user_fp *fp)
+{
+	struct thread_info *thread = current_thread_info();
+	int used_math = thread->used_cp[1] | thread->used_cp[2];
+
+	if (used_math)
+		memcpy(fp, &thread->fpstate.soft, sizeof (*fp));
+
+	return used_math != 0;
+}
+EXPORT_SYMBOL(dump_fpu);
+
+/*
+ * fill in the user structure for a core dump..
+ */
+void dump_thread(struct pt_regs * regs, struct user * dump)
+{
+	struct task_struct *tsk = current;
+
+	dump->magic = CMAGIC;
+	dump->start_code = tsk->mm->start_code;
+	dump->start_stack = regs->ARM_sp & ~(PAGE_SIZE - 1);
+
+	dump->u_tsize = (tsk->mm->end_code - tsk->mm->start_code) >> PAGE_SHIFT;
+	dump->u_dsize = (tsk->mm->brk - tsk->mm->start_data + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	dump->u_ssize = 0;
+
+	dump->u_debugreg[0] = tsk->thread.debug.bp[0].address;
+	dump->u_debugreg[1] = tsk->thread.debug.bp[1].address;
+	dump->u_debugreg[2] = tsk->thread.debug.bp[0].insn.arm;
+	dump->u_debugreg[3] = tsk->thread.debug.bp[1].insn.arm;
+	dump->u_debugreg[4] = tsk->thread.debug.nsaved;
+
+	if (dump->start_stack < 0x04000000)
+		dump->u_ssize = (0x04000000 - dump->start_stack) >> PAGE_SHIFT;
+
+	dump->regs = *regs;
+	dump->u_fpvalid = dump_fpu (regs, &dump->u_fp);
+}
+EXPORT_SYMBOL(dump_thread);
+
+/*
+ * Shuffle the argument into the correct register before calling the
+ * thread function.  r1 is the thread argument, r2 is the pointer to
+ * the thread function, and r3 points to the exit function.
+ */
+extern void kernel_thread_helper(void);
+asm(	".section .text\n"
+"	.align\n"
+"	.type	kernel_thread_helper, #function\n"
+"kernel_thread_helper:\n"
+"	mov	r0, r1\n"
+"	mov	lr, r3\n"
+"	mov	pc, r2\n"
+"	.size	kernel_thread_helper, . - kernel_thread_helper\n"
+"	.previous");
+
+/*
+ * Create a kernel thread.
+ */
+pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
+{
+	struct pt_regs regs;
+
+	memset(&regs, 0, sizeof(regs));
+
+	regs.ARM_r1 = (unsigned long)arg;
+	regs.ARM_r2 = (unsigned long)fn;
+	regs.ARM_r3 = (unsigned long)do_exit;
+	regs.ARM_pc = (unsigned long)kernel_thread_helper;
+	regs.ARM_cpsr = SVC_MODE;
+
+	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+}
+EXPORT_SYMBOL(kernel_thread);
+
+unsigned long get_wchan(struct task_struct *p)
+{
+	unsigned long fp, lr;
+	unsigned long stack_page;
+	int count = 0;
+	if (!p || p == current || p->state == TASK_RUNNING)
+		return 0;
+
+	stack_page = 4096 + (unsigned long)p->thread_info;
+	fp = thread_saved_fp(p);
+	do {
+		if (fp < stack_page || fp > 4092+stack_page)
+			return 0;
+		lr = pc_pointer (((unsigned long *)fp)[-1]);
+		if (!in_sched_functions(lr))
+			return lr;
+		fp = *(unsigned long *) (fp - 12);
+	} while (count ++ < 16);
+	return 0;
+}
+EXPORT_SYMBOL(get_wchan);
diff -Naur linux-2.6.9/arch/armnommu/kernel/setup.c linux-2.6.9-uc0/arch/armnommu/kernel/setup.c
--- linux-2.6.9/arch/armnommu/kernel/setup.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/setup.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,871 @@
+/*
+ *  linux/arch/armnommu/kernel/setup.c
+ *
+ *  Copyright (C) 1995-2001 Russell King
+ *  Copyright (C) 2003, 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/stddef.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/utsname.h>
+#include <linux/initrd.h>
+#include <linux/console.h>
+#include <linux/bootmem.h>
+#include <linux/seq_file.h>
+#include <linux/tty.h>
+#include <linux/init.h>
+#include <linux/root_dev.h>
+#include <linux/cpu.h>
+
+#include <asm/elf.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/procinfo.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+
+#ifndef MEM_SIZE
+#define MEM_SIZE	(16*1024*1024)
+#endif
+
+#if defined(CONFIG_FPE_NWFPE) || defined(CONFIG_FPE_FASTFPE)
+char fpe_type[8];
+
+static int __init fpe_setup(char *line)
+{
+	memcpy(fpe_type, line, 8);
+	return 1;
+}
+
+__setup("fpe=", fpe_setup);
+#endif
+
+extern unsigned int mem_fclk_21285;
+extern void paging_init(struct meminfo *, struct machine_desc *desc);
+extern void convert_to_tag_list(struct tag *tags);
+extern void squash_mem_tags(struct tag *tag);
+extern void bootmem_init(struct meminfo *);
+extern void reboot_setup(char *str);
+extern int root_mountflags;
+extern int _stext, _text, _etext, _edata, _end;
+
+unsigned int processor_id;
+unsigned int __machine_arch_type;
+EXPORT_SYMBOL(__machine_arch_type);
+
+unsigned int system_rev;
+EXPORT_SYMBOL(system_rev);
+
+unsigned int system_serial_low;
+EXPORT_SYMBOL(system_serial_low);
+
+unsigned int system_serial_high;
+EXPORT_SYMBOL(system_serial_high);
+
+unsigned int elf_hwcap;
+EXPORT_SYMBOL(elf_hwcap);
+
+
+#ifdef MULTI_CPU
+struct processor processor;
+#endif
+#ifdef MULTI_CACHE
+struct cpu_cache_fns cpu_cache;
+#endif
+
+unsigned char aux_device_present;
+
+char elf_platform[ELF_PLATFORM_SIZE];
+EXPORT_SYMBOL(elf_platform);
+
+char saved_command_line[COMMAND_LINE_SIZE];
+unsigned long phys_initrd_start __initdata = 0;
+unsigned long phys_initrd_size __initdata = 0;
+
+static struct meminfo meminfo __initdata = { 0, };
+static const char *cpu_name;
+static const char *machine_name;
+static char command_line[COMMAND_LINE_SIZE];
+
+static char default_command_line[COMMAND_LINE_SIZE] __initdata = CONFIG_CMDLINE;
+static union { char c[4]; unsigned long l; } endian_test __initdata = { { 'l', '?', '?', 'b' } };
+#define ENDIANNESS ((char)endian_test.l)
+
+/*
+ * Standard memory resources
+ */
+static struct resource mem_res[] = {
+	{ "Video RAM",   0,     0,     IORESOURCE_MEM			},
+	{ "Kernel code", 0,     0,     IORESOURCE_MEM			},
+	{ "Kernel data", 0,     0,     IORESOURCE_MEM			}
+};
+
+#define video_ram   mem_res[0]
+#define kernel_code mem_res[1]
+#define kernel_data mem_res[2]
+
+static struct resource io_res[] = {
+	{ "reserved",    0x3bc, 0x3be, IORESOURCE_IO | IORESOURCE_BUSY },
+	{ "reserved",    0x378, 0x37f, IORESOURCE_IO | IORESOURCE_BUSY },
+	{ "reserved",    0x278, 0x27f, IORESOURCE_IO | IORESOURCE_BUSY }
+};
+
+#define lp0 io_res[0]
+#define lp1 io_res[1]
+#define lp2 io_res[2]
+
+#ifndef CONFIG_SKIP_DUMP_CPU_INFO
+static const char *cache_types[16] = {
+	"VIVT write-through",
+	"VIVT write-back",
+	"VIVT write-back",
+	"undefined 3",
+	"undefined 4",
+	"undefined 5",
+	"VIVT write-back",
+	"VIVT write-back",
+	"undefined 8",
+	"undefined 9",
+	"undefined 10",
+	"undefined 11",
+	"undefined 12",
+	"undefined 13",
+	"VIPT write-back",
+	"undefined 15",
+};
+
+static const char *cache_clean[16] = {
+	"not required",
+	"read-block",
+	"cp15 c7 ops",
+	"undefined 3",
+	"undefined 4",
+	"undefined 5",
+	"cp15 c7 ops",
+	"cp15 c7 ops",
+	"undefined 8",
+	"undefined 9",
+	"undefined 10",
+	"undefined 11",
+	"undefined 12",
+	"undefined 13",
+	"cp15 c7 ops",
+	"undefined 15",
+};
+
+static const char *cache_lockdown[16] = {
+	"not supported",
+	"not supported",
+	"not supported",
+	"undefined 3",
+	"undefined 4",
+	"undefined 5",
+	"format A",
+	"format B",
+	"undefined 8",
+	"undefined 9",
+	"undefined 10",
+	"undefined 11",
+	"undefined 12",
+	"undefined 13",
+	"format C",
+	"undefined 15",
+};
+#endif
+
+static const char *proc_arch[] = {
+	"undefined/unknown",
+	"3",
+	"4",
+	"4T",
+	"5",
+	"5T",
+	"5TE",
+	"5TEJ",
+	"6TEJ",
+	"?(10)",
+	"?(11)",
+	"?(12)",
+	"?(13)",
+	"?(14)",
+	"?(15)",
+	"?(16)",
+	"?(17)",
+};
+
+#define CACHE_TYPE(x)	(((x) >> 25) & 15)
+#define CACHE_S(x)	((x) & (1 << 24))
+#define CACHE_DSIZE(x)	(((x) >> 12) & 4095)	/* only if S=1 */
+#define CACHE_ISIZE(x)	((x) & 4095)
+
+#define CACHE_SIZE(y)	(((y) >> 6) & 7)
+#define CACHE_ASSOC(y)	(((y) >> 3) & 7)
+#define CACHE_M(y)	((y) & (1 << 2))
+#define CACHE_LINE(y)	((y) & 3)
+
+/* some architectures go panic. */
+#ifndef CONFIG_SKIP_DUMP_CPU_INFO
+static inline void dump_cache(const char *prefix, unsigned int cache)
+{
+	unsigned int mult = 2 + (CACHE_M(cache) ? 1 : 0);
+
+	printk("%s: %d bytes, associativity %d, %d byte lines, %d sets\n",
+		prefix,
+		mult << (8 + CACHE_SIZE(cache)),
+		(mult << CACHE_ASSOC(cache)) >> 1,
+		8 << CACHE_LINE(cache),
+		1 << (6 + CACHE_SIZE(cache) - CACHE_ASSOC(cache) -
+			CACHE_LINE(cache)));
+}
+
+static void __init dump_cpu_info(void)
+{
+	unsigned int info;
+
+	asm("mrc p15, 0, %0, c0, c0, 1" : "=r" (info));
+
+	if (info != processor_id) {
+		printk("CPU: D %s cache\n", cache_types[CACHE_TYPE(info)]);
+		if (CACHE_S(info)) {
+			dump_cache("CPU: I cache", CACHE_ISIZE(info));
+			dump_cache("CPU: D cache", CACHE_DSIZE(info));
+		} else {
+			dump_cache("CPU: cache", CACHE_ISIZE(info));
+		}
+	}
+}
+#endif
+
+int cpu_architecture(void)
+{
+	int cpu_arch;
+
+	if ((processor_id & 0x0000f000) == 0) {
+		cpu_arch = CPU_ARCH_UNKNOWN;
+	} else if ((processor_id & 0x0000f000) == 0x00007000) {
+		cpu_arch = (processor_id & (1 << 23)) ? CPU_ARCH_ARMv4T : CPU_ARCH_ARMv3;
+	} else {
+		cpu_arch = (processor_id >> 16) & 15;
+		if (cpu_arch)
+			cpu_arch += CPU_ARCH_ARMv3;
+	}
+
+	return cpu_arch;
+}
+
+static void __init setup_processor(void)
+{
+	extern struct proc_info_list __proc_info_begin, __proc_info_end;
+	struct proc_info_list *list;
+
+	/*
+	 * locate processor in the list of supported processor
+	 * types.  The linker builds this table for us from the
+	 * entries in arch/armnommu/mm/proc-*.S
+	 */
+	for (list = &__proc_info_begin; list < &__proc_info_end ; list++)
+		if ((processor_id & list->cpu_mask) == list->cpu_val)
+			break;
+
+	/*
+	 * If processor type is unrecognised, then we
+	 * can do nothing...
+	 */
+	if (list >= &__proc_info_end) {
+		printk("CPU configuration botched (ID %08x), unable "
+		       "to continue.\n", processor_id);
+		while (1);
+	}
+
+	cpu_name = list->cpu_name;
+
+#ifdef MULTI_CPU
+	processor = *list->proc;
+#endif
+#ifdef MULTI_CACHE
+	cpu_cache = *list->cache;
+#endif
+
+	printk("CPU: %s [%08x] revision %d (ARMv%s)\n",
+	       cpu_name, processor_id, (int)processor_id & 15,
+	       proc_arch[cpu_architecture()]);
+#ifndef CONFIG_SKIP_DUMP_CPU_INFO
+	dump_cpu_info();
+#endif
+
+	sprintf(system_utsname.machine, "%s%c", list->arch_name, ENDIANNESS);
+	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);
+	elf_hwcap = list->elf_hwcap;
+
+	cpu_proc_init();
+}
+
+static struct machine_desc * __init setup_machine(unsigned int nr)
+{
+	extern struct machine_desc __arch_info_begin, __arch_info_end;
+	struct machine_desc *list;
+
+	/*
+	 * locate architecture in the list of supported architectures.
+	 */
+	for (list = &__arch_info_begin; list < &__arch_info_end; list++)
+		if (list->nr == nr)
+			break;
+
+	/*
+	 * If the architecture type is not recognised, then we
+	 * can co nothing...
+	 */
+	if (list >= &__arch_info_end) {
+		printk("Architecture configuration botched (nr %d), unable "
+		       "to continue.\n", nr);
+		while (1);
+	}
+
+	printk("Machine: %s\n", list->name);
+
+	return list;
+}
+
+static void __init early_initrd(char **p)
+{
+	unsigned long start, size;
+
+	start = memparse(*p, p);
+	if (**p == ',') {
+		size = memparse((*p) + 1, p);
+
+		phys_initrd_start = start;
+		phys_initrd_size = size;
+	}
+}
+__early_param("initrd=", early_initrd);
+
+/*
+ * Pick out the memory size.  We look for mem=size@start,
+ * where start and size are "size[KkMm]"
+ */
+static void __init early_mem(char **p)
+{
+	static int usermem __initdata = 0;
+	unsigned long size, start;
+
+	/*
+	 * If the user specifies memory size, we
+	 * blow away any automatically generated
+	 * size.
+	 */
+	if (usermem == 0) {
+		usermem = 1;
+		meminfo.nr_banks = 0;
+	}
+
+	start = PHYS_OFFSET;
+	size  = memparse(*p, p);
+	if (**p == '@')
+		start = memparse(*p + 1, p);
+
+	meminfo.bank[meminfo.nr_banks].start = start;
+	meminfo.bank[meminfo.nr_banks].size  = size;
+	meminfo.bank[meminfo.nr_banks].node  = PHYS_TO_NID(start);
+	meminfo.nr_banks += 1;
+}
+__early_param("mem=", early_mem);
+
+/*
+ * Initial parsing of the command line.
+ */
+static void __init parse_cmdline(char **cmdline_p, char *from)
+{
+	char c = ' ', *to = command_line;
+	int len = 0;
+
+	for (;;) {
+		if (c == ' ') {
+			extern struct early_params __early_begin, __early_end;
+			struct early_params *p;
+
+			for (p = &__early_begin; p < &__early_end; p++) {
+				int len = strlen(p->arg);
+
+				if (memcmp(from, p->arg, len) == 0) {
+					if (to != command_line)
+						to -= 1;
+					from += len;
+					p->fn(&from);
+
+					while (*from != ' ' && *from != '\0')
+						from++;
+					break;
+				}
+			}
+		}
+		c = *from++;
+		if (!c)
+			break;
+		if (COMMAND_LINE_SIZE <= ++len)
+			break;
+		*to++ = c;
+	}
+	*to = '\0';
+	*cmdline_p = command_line;
+}
+
+static void __init
+setup_ramdisk(int doload, int prompt, int image_start, unsigned int rd_sz)
+{
+#ifdef CONFIG_BLK_DEV_RAM
+	extern int rd_size, rd_image_start, rd_prompt, rd_doload;
+
+	rd_image_start = image_start;
+	rd_prompt = prompt;
+	rd_doload = doload;
+
+	if (rd_sz)
+		rd_size = rd_sz;
+#endif
+}
+
+static void __init
+request_standard_resources(struct meminfo *mi, struct machine_desc *mdesc)
+{
+	struct resource *res;
+	int i;
+
+	kernel_code.start  = __virt_to_phys(init_mm.start_code);
+	kernel_code.end    = __virt_to_phys(init_mm.end_code - 1);
+	kernel_data.start  = __virt_to_phys(init_mm.end_code);
+	kernel_data.end    = __virt_to_phys(init_mm.brk - 1);
+
+	for (i = 0; i < mi->nr_banks; i++) {
+		unsigned long virt_start, virt_end;
+
+		if (mi->bank[i].size == 0)
+			continue;
+
+		virt_start = __phys_to_virt(mi->bank[i].start);
+		virt_end   = virt_start + mi->bank[i].size - 1;
+
+		res = alloc_bootmem_low(sizeof(*res));
+		res->name  = "System RAM";
+		res->start = __virt_to_phys(virt_start);
+		res->end   = __virt_to_phys(virt_end);
+		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+
+		request_resource(&iomem_resource, res);
+
+		if (kernel_code.start >= res->start &&
+		    kernel_code.end <= res->end)
+			request_resource(res, &kernel_code);
+		if (kernel_data.start >= res->start &&
+		    kernel_data.end <= res->end)
+			request_resource(res, &kernel_data);
+	}
+
+	if (mdesc->video_start) {
+		video_ram.start = mdesc->video_start;
+		video_ram.end   = mdesc->video_end;
+		request_resource(&iomem_resource, &video_ram);
+	}
+
+	/*
+	 * Some machines don't have the possibility of ever
+	 * possessing lp0, lp1 or lp2
+	 */
+	if (mdesc->reserve_lp0)
+		request_resource(&ioport_resource, &lp0);
+	if (mdesc->reserve_lp1)
+		request_resource(&ioport_resource, &lp1);
+	if (mdesc->reserve_lp2)
+		request_resource(&ioport_resource, &lp2);
+}
+
+/*
+ *  Tag parsing.
+ *
+ * This is the new way of passing data to the kernel at boot time.  Rather
+ * than passing a fixed inflexible structure to the kernel, we pass a list
+ * of variable-sized tags to the kernel.  The first tag must be a ATAG_CORE
+ * tag for the list to be recognised (to distinguish the tagged list from
+ * a param_struct).  The list is terminated with a zero-length tag (this tag
+ * is not parsed in any way).
+ */
+static int __init parse_tag_core(const struct tag *tag)
+{
+	if (tag->hdr.size > 2) {
+		if ((tag->u.core.flags & 1) == 0)
+			root_mountflags &= ~MS_RDONLY;
+		ROOT_DEV = old_decode_dev(tag->u.core.rootdev);
+	}
+	return 0;
+}
+
+__tagtable(ATAG_CORE, parse_tag_core);
+
+static int __init parse_tag_mem32(const struct tag *tag)
+{
+	if (meminfo.nr_banks >= NR_BANKS) {
+		printk(KERN_WARNING
+		       "Ignoring memory bank 0x%08x size %dKB\n",
+			tag->u.mem.start, tag->u.mem.size / 1024);
+		return -EINVAL;
+	}
+	meminfo.bank[meminfo.nr_banks].start = tag->u.mem.start;
+	meminfo.bank[meminfo.nr_banks].size  = tag->u.mem.size;
+	meminfo.bank[meminfo.nr_banks].node  = PHYS_TO_NID(tag->u.mem.start);
+	meminfo.nr_banks += 1;
+
+	return 0;
+}
+
+__tagtable(ATAG_MEM, parse_tag_mem32);
+
+#if defined(CONFIG_VGA_CONSOLE) || defined(CONFIG_DUMMY_CONSOLE)
+struct screen_info screen_info = {
+ .orig_video_lines	= 30,
+ .orig_video_cols	= 80,
+ .orig_video_mode	= 0,
+ .orig_video_ega_bx	= 0,
+ .orig_video_isVGA	= 1,
+ .orig_video_points	= 8
+};
+
+static int __init parse_tag_videotext(const struct tag *tag)
+{
+	screen_info.orig_x            = tag->u.videotext.x;
+	screen_info.orig_y            = tag->u.videotext.y;
+	screen_info.orig_video_page   = tag->u.videotext.video_page;
+	screen_info.orig_video_mode   = tag->u.videotext.video_mode;
+	screen_info.orig_video_cols   = tag->u.videotext.video_cols;
+	screen_info.orig_video_ega_bx = tag->u.videotext.video_ega_bx;
+	screen_info.orig_video_lines  = tag->u.videotext.video_lines;
+	screen_info.orig_video_isVGA  = tag->u.videotext.video_isvga;
+	screen_info.orig_video_points = tag->u.videotext.video_points;
+	return 0;
+}
+
+__tagtable(ATAG_VIDEOTEXT, parse_tag_videotext);
+#endif
+
+static int __init parse_tag_ramdisk(const struct tag *tag)
+{
+	setup_ramdisk((tag->u.ramdisk.flags & 1) == 0,
+		      (tag->u.ramdisk.flags & 2) == 0,
+		      tag->u.ramdisk.start, tag->u.ramdisk.size);
+	return 0;
+}
+
+__tagtable(ATAG_RAMDISK, parse_tag_ramdisk);
+
+static int __init parse_tag_initrd(const struct tag *tag)
+{
+	printk(KERN_WARNING "ATAG_INITRD is deprecated; "
+		"please update your bootloader.\n");
+	phys_initrd_start = __virt_to_phys(tag->u.initrd.start);
+	phys_initrd_size = tag->u.initrd.size;
+	return 0;
+}
+
+__tagtable(ATAG_INITRD, parse_tag_initrd);
+
+static int __init parse_tag_initrd2(const struct tag *tag)
+{
+	phys_initrd_start = tag->u.initrd.start;
+	phys_initrd_size = tag->u.initrd.size;
+	return 0;
+}
+
+__tagtable(ATAG_INITRD2, parse_tag_initrd2);
+
+static int __init parse_tag_serialnr(const struct tag *tag)
+{
+	system_serial_low = tag->u.serialnr.low;
+	system_serial_high = tag->u.serialnr.high;
+	return 0;
+}
+
+__tagtable(ATAG_SERIAL, parse_tag_serialnr);
+
+static int __init parse_tag_revision(const struct tag *tag)
+{
+	system_rev = tag->u.revision.rev;
+	return 0;
+}
+
+__tagtable(ATAG_REVISION, parse_tag_revision);
+
+static int __init parse_tag_cmdline(const struct tag *tag)
+{
+	strlcpy(default_command_line, tag->u.cmdline.cmdline, COMMAND_LINE_SIZE);
+	return 0;
+}
+
+__tagtable(ATAG_CMDLINE, parse_tag_cmdline);
+
+/*
+ * Scan the tag table for this tag, and call its parse function.
+ * The tag table is built by the linker from all the __tagtable
+ * declarations.
+ */
+static int __init parse_tag(const struct tag *tag)
+{
+	extern struct tagtable __tagtable_begin, __tagtable_end;
+	struct tagtable *t;
+
+	for (t = &__tagtable_begin; t < &__tagtable_end; t++)
+		if (tag->hdr.tag == t->tag) {
+			t->parse(tag);
+			break;
+		}
+
+	return t < &__tagtable_end;
+}
+
+/*
+ * Parse all tags in the list, checking both the global and architecture
+ * specific tag tables.
+ */
+static void __init parse_tags(const struct tag *t)
+{
+	for (; t->hdr.size; t = tag_next(t))
+		if (!parse_tag(t))
+			printk(KERN_WARNING
+				"Ignoring unrecognised tag 0x%08x\n",
+				t->hdr.tag);
+}
+
+/*
+ * This holds our defaults.
+ */
+static struct init_tags {
+	struct tag_header hdr1;
+	struct tag_core   core;
+	struct tag_header hdr2;
+	struct tag_mem32  mem;
+	struct tag_header hdr3;
+} init_tags __initdata = {
+	{ tag_size(tag_core), ATAG_CORE },
+	{ 1, PAGE_SIZE, 0xff },
+	{ tag_size(tag_mem32), ATAG_MEM },
+	{ MEM_SIZE, PHYS_OFFSET },
+	{ 0, ATAG_NONE }
+};
+
+static void (*init_machine)(void) __initdata;
+
+static int __init customize_machine(void)
+{
+	/* customizes platform devices, or adds new ones */
+	if (init_machine)
+		init_machine();
+	return 0;
+}
+arch_initcall(customize_machine);
+
+void __init setup_arch(char **cmdline_p)
+{
+	struct tag *tags = (struct tag *)&init_tags;
+	struct machine_desc *mdesc;
+	char *from = default_command_line;
+
+	setup_processor();
+	mdesc = setup_machine(machine_arch_type);
+	machine_name = mdesc->name;
+
+	if (mdesc->soft_reboot)
+		reboot_setup("s");
+
+	if (mdesc->param_offset)
+		tags = phys_to_virt(mdesc->param_offset);
+
+	/*
+	 * If we have the old style parameters, convert them to
+	 * a tag list.
+	 */
+	if (tags->hdr.tag != ATAG_CORE)
+		convert_to_tag_list(tags);
+	if (tags->hdr.tag != ATAG_CORE)
+		tags = (struct tag *)&init_tags;
+
+	if (mdesc->fixup)
+		mdesc->fixup(mdesc, tags, &from, &meminfo);
+
+	if (tags->hdr.tag == ATAG_CORE) {
+		if (meminfo.nr_banks != 0)
+			squash_mem_tags(tags);
+		parse_tags(tags);
+	}
+
+	init_mm.start_code = (unsigned long) &_text;
+	init_mm.end_code   = (unsigned long) &_etext;
+	init_mm.end_data   = (unsigned long) &_edata;
+	init_mm.brk	   = (unsigned long) &_end;
+
+	memcpy(saved_command_line, from, COMMAND_LINE_SIZE);
+	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+	parse_cmdline(cmdline_p, from);
+	bootmem_init(&meminfo);
+	paging_init(&meminfo, mdesc);
+	request_standard_resources(&meminfo, mdesc);
+
+	/*
+	 * Set up various architecture-specific pointers
+	 */
+	init_arch_irq = mdesc->init_irq;
+	init_machine = mdesc->init_machine;
+
+#ifdef CONFIG_VT
+#if defined(CONFIG_VGA_CONSOLE)
+	conswitchp = &vga_con;
+#elif defined(CONFIG_DUMMY_CONSOLE)
+	conswitchp = &dummy_con;
+#endif
+#endif
+}
+
+static struct cpu cpu[1];
+
+static int __init topology_init(void)
+{
+	return register_cpu(cpu, 0, NULL);
+}
+
+subsys_initcall(topology_init);
+
+static const char *hwcap_str[] = {
+	"swp",
+	"half",
+	"thumb",
+	"26bit",
+	"fastmult",
+	"fpa",
+	"vfp",
+	"edsp",
+	NULL
+};
+
+#ifndef CONFIG_SKIP_DUMP_CPU_INFO
+static void
+c_show_cache(struct seq_file *m, const char *type, unsigned int cache)
+{
+	unsigned int mult = 2 + (CACHE_M(cache) ? 1 : 0);
+
+	seq_printf(m, "%s size\t\t: %d\n"
+		      "%s assoc\t\t: %d\n"
+		      "%s line length\t: %d\n"
+		      "%s sets\t\t: %d\n",
+		type, mult << (8 + CACHE_SIZE(cache)),
+		type, (mult << CACHE_ASSOC(cache)) >> 1,
+		type, 8 << CACHE_LINE(cache),
+		type, 1 << (6 + CACHE_SIZE(cache) - CACHE_ASSOC(cache) -
+			    CACHE_LINE(cache)));
+}
+#endif
+
+static int c_show(struct seq_file *m, void *v)
+{
+	int i;
+
+	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
+		   cpu_name, (int)processor_id & 15, elf_platform);
+
+	seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
+		   loops_per_jiffy / (500000/HZ),
+		   (loops_per_jiffy / (5000/HZ)) % 100);
+
+	/* dump out the processor features */
+	seq_puts(m, "Features\t: ");
+
+	for (i = 0; hwcap_str[i]; i++)
+		if (elf_hwcap & (1 << i))
+			seq_printf(m, "%s ", hwcap_str[i]);
+
+	seq_printf(m, "\nCPU implementer\t: 0x%02x\n", processor_id >> 24);
+	seq_printf(m, "CPU architecture: %s\n", proc_arch[cpu_architecture()]);
+
+	if ((processor_id & 0x0000f000) == 0x00000000) {
+		/* pre-ARM7 */
+		seq_printf(m, "CPU part\t\t: %07x\n", processor_id >> 4);
+	} else {
+		if ((processor_id & 0x0000f000) == 0x00007000) {
+			/* ARM7 */
+			seq_printf(m, "CPU variant\t: 0x%02x\n",
+				   (processor_id >> 16) & 127);
+		} else {
+			/* post-ARM7 */
+			seq_printf(m, "CPU variant\t: 0x%x\n",
+				   (processor_id >> 20) & 15);
+		}
+		seq_printf(m, "CPU part\t: 0x%03x\n",
+			   (processor_id >> 4) & 0xfff);
+	}
+	seq_printf(m, "CPU revision\t: %d\n", processor_id & 15);
+
+#ifndef CONFIG_SKIP_DUMP_CPU_INFO
+	{
+		unsigned int cache_info;
+
+		asm("mrc p15, 0, %0, c0, c0, 1" : "=r" (cache_info));
+		if (cache_info != processor_id) {
+			seq_printf(m, "Cache type\t: %s\n"
+				      "Cache clean\t: %s\n"
+				      "Cache lockdown\t: %s\n"
+				      "Cache format\t: %s\n",
+				   cache_types[CACHE_TYPE(cache_info)],
+				   cache_clean[CACHE_TYPE(cache_info)],
+				   cache_lockdown[CACHE_TYPE(cache_info)],
+				   CACHE_S(cache_info) ? "Harvard" : "Unified");
+
+			if (CACHE_S(cache_info)) {
+				c_show_cache(m, "I", CACHE_ISIZE(cache_info));
+				c_show_cache(m, "D", CACHE_DSIZE(cache_info));
+			} else {
+				c_show_cache(m, "Cache", CACHE_ISIZE(cache_info));
+			}
+		}
+	}
+#endif
+
+	seq_puts(m, "\n");
+
+	seq_printf(m, "Hardware\t: %s\n", machine_name);
+	seq_printf(m, "Revision\t: %04x\n", system_rev);
+	seq_printf(m, "Serial\t\t: %08x%08x\n",
+		   system_serial_high, system_serial_low);
+
+	return 0;
+}
+
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	return *pos < 1 ? (void *)1 : NULL;
+}
+
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	return NULL;
+}
+
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+
+struct seq_operations cpuinfo_op = {
+	.start	= c_start,
+	.next	= c_next,
+	.stop	= c_stop,
+	.show	= c_show
+};
diff -Naur linux-2.6.9/arch/armnommu/kernel/sys_arm.c linux-2.6.9-uc0/arch/armnommu/kernel/sys_arm.c
--- linux-2.6.9/arch/armnommu/kernel/sys_arm.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/sys_arm.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,312 @@
+/*
+ *  linux/arch/armnommu/kernel/sys_arm.c
+ *
+ *  Copyright (C) People who wrote linux/arch/i386/kernel/sys_i386.c
+ *  Copyright (C) 1995, 1996 Russell King.
+ *  Copyright (C) 2003, 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This file contains various random system calls that
+ *  have a non-standard calling sequence on the Linux/arm
+ *  platform.
+ */
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/sem.h>
+#include <linux/msg.h>
+#include <linux/shm.h>
+#include <linux/stat.h>
+#include <linux/syscalls.h>
+#include <linux/mman.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/utsname.h>
+
+#include <asm/uaccess.h>
+#include <asm/ipc.h>
+
+extern unsigned long do_mremap(unsigned long addr, unsigned long old_len,
+			       unsigned long new_len, unsigned long flags,
+			       unsigned long new_addr);
+
+/*
+ * sys_pipe() is the normal C calling standard for creating
+ * a pipe. It's not the way unix traditionally does this, though.
+ */
+asmlinkage int sys_pipe(unsigned long __user *fildes)
+{
+	int fd[2];
+	int error;
+
+	error = do_pipe(fd);
+	if (!error) {
+		if (copy_to_user(fildes, fd, 2*sizeof(int)))
+			error = -EFAULT;
+	}
+	return error;
+}
+
+/* common code for old and new mmaps */
+inline long do_mmap2(
+	unsigned long addr, unsigned long len,
+	unsigned long prot, unsigned long flags,
+	unsigned long fd, unsigned long pgoff)
+{
+	int error = -EINVAL;
+	struct file * file = NULL;
+
+	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+
+	/*
+	 * If we are doing a fixed mapping, and address < PAGE_SIZE,
+	 * then deny it.
+	 */
+	if (flags & MAP_FIXED && addr < PAGE_SIZE && vectors_base() == 0)
+		goto out;
+
+	error = -EBADF;
+	if (!(flags & MAP_ANONYMOUS)) {
+		file = fget(fd);
+		if (!file)
+			goto out;
+	}
+
+	down_write(&current->mm->mmap_sem);
+	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	up_write(&current->mm->mmap_sem);
+
+	if (file)
+		fput(file);
+out:
+	return error;
+}
+
+struct mmap_arg_struct {
+	unsigned long addr;
+	unsigned long len;
+	unsigned long prot;
+	unsigned long flags;
+	unsigned long fd;
+	unsigned long offset;
+};
+
+asmlinkage int old_mmap(struct mmap_arg_struct __user *arg)
+{
+	int error = -EFAULT;
+	struct mmap_arg_struct a;
+
+	if (copy_from_user(&a, arg, sizeof(a)))
+		goto out;
+
+	error = -EINVAL;
+	if (a.offset & ~PAGE_MASK)
+		goto out;
+
+	error = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
+out:
+	return error;
+}
+
+asmlinkage unsigned long
+sys_arm_mremap(unsigned long addr, unsigned long old_len,
+	       unsigned long new_len, unsigned long flags,
+	       unsigned long new_addr)
+{
+	unsigned long ret = -EINVAL;
+	return ret;
+}
+
+/*
+ * Perform the select(nd, in, out, ex, tv) and mmap() system
+ * calls.
+ */
+
+struct sel_arg_struct {
+	unsigned long n;
+	fd_set __user *inp, *outp, *exp;
+	struct timeval __user *tvp;
+};
+
+asmlinkage int old_select(struct sel_arg_struct __user *arg)
+{
+	struct sel_arg_struct a;
+
+	if (copy_from_user(&a, arg, sizeof(a)))
+		return -EFAULT;
+	/* sys_select() does the appropriate kernel locking */
+	return sys_select(a.n, a.inp, a.outp, a.exp, a.tvp);
+}
+
+/*
+ * sys_ipc() is the de-multiplexer for the SysV IPC calls..
+ *
+ * This is really horribly ugly.
+ */
+asmlinkage int sys_ipc(uint call, int first, int second, int third,
+		       void __user *ptr, long fifth)
+{
+	int version, ret;
+
+	version = call >> 16; /* hack for backward compatibility */
+	call &= 0xffff;
+
+	switch (call) {
+	case SEMOP:
+		return sys_semop(first, (struct sembuf __user *)ptr, second);
+	case SEMGET:
+		return sys_semget (first, second, third);
+	case SEMCTL: {
+		union semun fourth;
+		if (!ptr)
+			return -EINVAL;
+		if (get_user(fourth.__pad, (void __user **) ptr))
+			return -EFAULT;
+		return sys_semctl (first, second, third, fourth);
+	}
+
+	case MSGSND:
+		return sys_msgsnd(first, (struct msgbuf __user *) ptr, 
+				   second, third);
+	case MSGRCV:
+		switch (version) {
+		case 0: {
+			struct ipc_kludge tmp;
+			if (!ptr)
+				return -EINVAL;
+			if (copy_from_user(&tmp,(struct ipc_kludge __user *)ptr,
+					   sizeof (tmp)))
+				return -EFAULT;
+			return sys_msgrcv (first, tmp.msgp, second,
+					   tmp.msgtyp, third);
+		}
+		default:
+			return sys_msgrcv (first,
+					   (struct msgbuf __user *) ptr,
+					   second, fifth, third);
+		}
+	case MSGGET:
+		return sys_msgget ((key_t) first, second);
+	case MSGCTL:
+		return sys_msgctl(first, second, (struct msqid_ds __user *)ptr);
+
+	case SHMAT:
+		switch (version) {
+		default: {
+			ulong raddr;
+			ret = do_shmat(first, (char __user *)ptr, second, &raddr);
+			if (ret)
+				return ret;
+			return put_user(raddr, (ulong __user *)third);
+		}
+		case 1:	/* iBCS2 emulator entry point */
+			if (!segment_eq(get_fs(), get_ds()))
+				return -EINVAL;
+			return do_shmat(first, (char __user *) ptr,
+					second, (ulong __user *) third);
+		}
+	case SHMDT: 
+		return sys_shmdt ((char __user *)ptr);
+	case SHMGET:
+		return sys_shmget (first, second, third);
+	case SHMCTL:
+		return sys_shmctl (first, second,
+				   (struct shmid_ds __user *) ptr);
+	default:
+		return -ENOSYS;
+	}
+}
+
+/* Fork a new task - this creates a new program thread.
+ * This is called indirectly via a small wrapper
+ */
+asmlinkage int sys_fork(struct pt_regs *regs)
+{
+	return do_fork(SIGCHLD, regs->ARM_sp, regs, 0, NULL, NULL);
+}
+
+/* Clone a task - this clones the calling program thread.
+ * This is called indirectly via a small wrapper
+ */
+asmlinkage int sys_clone(unsigned long clone_flags, unsigned long newsp, struct pt_regs *regs)
+{
+	/*
+	 * We don't support SETTID / CLEARTID
+	 */
+	if (clone_flags & (CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID))
+		return -EINVAL;
+
+	if (!newsp)
+		newsp = regs->ARM_sp;
+
+	return do_fork(clone_flags & ~CLONE_IDLETASK, newsp, regs, 0, NULL, NULL);
+}
+
+asmlinkage int sys_vfork(struct pt_regs *regs)
+{
+	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->ARM_sp, regs, 0, NULL, NULL);
+}
+
+/* sys_execve() executes a new program.
+ * This is called indirectly via a small wrapper
+ */
+asmlinkage int sys_execve(char __user *filenamei, char __user * __user *argv,
+			  char __user * __user *envp, struct pt_regs *regs)
+{
+	int error;
+	char * filename;
+
+	filename = getname(filenamei);
+	error = PTR_ERR(filename);
+	if (IS_ERR(filename))
+		goto out;
+	error = do_execve(filename, argv, envp, regs);
+	putname(filename);
+out:
+	return error;
+}
+
+long execve(const char *filename, char **argv, char **envp)
+{
+	struct pt_regs regs;
+	int ret;
+
+	memset(&regs, 0, sizeof(struct pt_regs));
+	ret = do_execve((char *)filename, (char __user * __user *)argv,
+			(char __user * __user *)envp, &regs);
+	if (ret < 0)
+		goto out;
+
+	/*
+	 * Save argc to the register structure for userspace.
+	 */
+	regs.ARM_r0 = ret;
+
+	/*
+	 * We were successful.  We won't be returning to our caller, but
+	 * instead to user space by manipulating the kernel stack.
+	 */
+	asm(	"add	r0, %0, %1\n\t"
+		"mov	r1, %2\n\t"
+		"mov	r2, %3\n\t"
+		"bl	memmove\n\t"	/* copy regs to top of stack */
+		"mov	r8, #0\n\t"	/* not a syscall */
+		"mov	r9, %0\n\t"	/* thread structure */
+		"mov	sp, r0\n\t"	/* reposition stack pointer */
+		"b	ret_to_user"
+		:
+		: "r" (current_thread_info()),
+		  "Ir" (THREAD_SIZE - 8 - sizeof(regs)),
+		  "r" (&regs),
+		  "Ir" (sizeof(regs))
+		: "r0", "r1", "r2", "r3", "ip", "memory");
+
+out:
+	return ret;
+}
+EXPORT_SYMBOL(execve);
diff -Naur linux-2.6.9/arch/armnommu/kernel/vmlinux.lds.S linux-2.6.9-uc0/arch/armnommu/kernel/vmlinux.lds.S
--- linux-2.6.9/arch/armnommu/kernel/vmlinux.lds.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/kernel/vmlinux.lds.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,141 @@
+/* ld script to make Linux kernel
+ * modified for armnommu by Hyok S. Choi
+ * taken from the i386 version by Russell King
+ * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>
+ */
+
+#include <asm-generic/vmlinux.lds.h>
+	
+ENTRY(stext)
+#ifndef __ARMEB__
+jiffies = jiffies_64;
+#else
+jiffies = jiffies_64 + 4;
+#endif
+SECTIONS
+{
+	. = TEXTADDR;
+	.init : {			/* Init code and data		*/
+		_stext = .;
+		__init_begin = .;
+			_sinittext = .;
+			*(.init.text)
+			_einittext = .;
+		__proc_info_begin = .;
+			*(.proc.info)
+		__proc_info_end = .;
+		__arch_info_begin = .;
+			*(.arch.info)
+		__arch_info_end = .;
+		__tagtable_begin = .;
+			*(.taglist)
+		__tagtable_end = .;
+			*(.init.data)
+		. = ALIGN(16);
+		__setup_start = .;
+			*(.init.setup)
+		__setup_end = .;
+		__early_begin = .;
+			*(__early_param)
+		__early_end = .;
+		__start___param = .;
+			*(__param)
+		__stop___param = .;
+		__initcall_start = .;
+			*(.initcall1.init)
+			*(.initcall2.init)
+			*(.initcall3.init)
+			*(.initcall4.init)
+			*(.initcall5.init)
+			*(.initcall6.init)
+			*(.initcall7.init)
+		__initcall_end = .;
+		__con_initcall_start = .;
+			*(.con_initcall.init)
+		__con_initcall_end = .;
+		__security_initcall_start = .;
+			*(.security_initcall.init)
+		__security_initcall_end = .;
+		. = ALIGN(32);
+		__initramfs_start = .;
+			usr/built-in.o(.init.ramfs)
+		__initramfs_end = .;
+		. = ALIGN(4096);
+		__init_end = .;
+	}
+
+	/DISCARD/ : {			/* Exit code and data		*/
+		*(.exit.text)
+		*(.exit.data)
+		*(.exitcall.exit)
+	}
+
+	.text : {			/* Real text segment		*/
+		_text = .;		/* Text and read-only data	*/
+			*(.text)
+			SCHED_TEXT
+			*(.fixup)
+			*(.gnu.warning)
+			*(.rodata)
+			*(.rodata.*)
+			*(.glue_7)
+			*(.glue_7t)
+		*(.got)			/* Global offset table		*/
+
+		_etext = .;		/* End of text section		*/
+	}
+
+	. = ALIGN(16);
+	__ex_table : {			/* Exception table		*/
+		__start___ex_table = .;
+			*(__ex_table)
+		__stop___ex_table = .;
+	}
+
+	RODATA
+
+	. = ALIGN(8192);
+
+	.data : {
+		/*
+		 * first, the init task union, aligned
+		 * to an 8192 byte boundary.
+		 */
+		*(.init.task)
+
+		. = ALIGN(4096);
+		__nosave_begin = .;
+		*(.data.nosave)
+		. = ALIGN(4096);
+		__nosave_end = .;
+
+		/*
+		 * then the cacheline aligned data
+		 */
+		. = ALIGN(32);
+		*(.data.cacheline_aligned)
+
+		/*
+		 * and the usual data section
+		 */
+		*(.data)
+		CONSTRUCTORS
+
+		_edata = .;
+	}
+
+	.bss : {
+		__bss_start = .;	/* BSS				*/
+		*(.bss)
+		*(COMMON)
+		_end = . ;
+	}
+					/* Stabs debugging sections.	*/
+	.stab 0 : { *(.stab) }
+	.stabstr 0 : { *(.stabstr) }
+	.stab.excl 0 : { *(.stab.excl) }
+	.stab.exclstr 0 : { *(.stab.exclstr) }
+	.stab.index 0 : { *(.stab.index) }
+	.stab.indexstr 0 : { *(.stab.indexstr) }
+	.comment 0 : { *(.comment) }
+}
diff -Naur linux-2.6.9/arch/armnommu/mach-atmel/arch.c linux-2.6.9-uc0/arch/armnommu/mach-atmel/arch.c
--- linux-2.6.9/arch/armnommu/mach-atmel/arch.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-atmel/arch.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,49 @@
+/*
+ *  linux/arch/arm/mach-atmel/arch.c
+ *
+ *  Copyright (C) 2004 SAMSUNG ELECTRONICS Co.,Ltd.
+ *			      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+extern void __init atmel_init_irq(void);
+
+MACHINE_START(ATMEL, "ATMEL EB01")
+	MAINTAINER("Hyok S. Choi <hyok.choi@samsung.com>")
+	INITIRQ(atmel_init_irq)
+MACHINE_END
diff -Naur linux-2.6.9/arch/armnommu/mach-atmel/entry-macro.S linux-2.6.9-uc0/arch/armnommu/mach-atmel/entry-macro.S
--- linux-2.6.9/arch/armnommu/mach-atmel/entry-macro.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-atmel/entry-macro.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,39 @@
+/*
+ *  arch/armnommu/mach-atmel/entry-macro.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  Samsung Electronics Co.,Ltd.
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if defined(CONFIG_ARCH_ATMEL)
+                .macro  disable_fiq
+                .endm
+                        /* r0     r6      r5   lr */
+                .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	r4, =AIC_IVR
+		ldr	\irqnr, [r4]		@ignore value
+		ldr	r4, =AIC_ISR		@read interrupt nr.
+		ldr	\irqnr, [r4]
+		teq	\irqnr, #0
+                .endm   
+                
+                .macro  irq_prio_table
+                .endm
+#endif
diff -Naur linux-2.6.9/arch/armnommu/mach-atmel/head.S linux-2.6.9-uc0/arch/armnommu/mach-atmel/head.S
--- linux-2.6.9/arch/armnommu/mach-atmel/head.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-atmel/head.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,76 @@
+/*
+ *  linux/arch/armnommu/mach-s5c7375/head.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *  <hyok.choi@samsung.com>
+ *
+ *  uClinux kernel startup code for s5c7375
+ *  which has no proper bootloader for linux startup
+ *  because of XIP.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r8, r9, sp}			@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+	ldr	r2, L_AT91_SF_CIDR
+	ldr	r2, [r2]		@ read processor id
+
+	str     r2, [r6]
+	mov     r2, #MACH_TYPE_ATMEL
+	str     r2, [r9]
+
+        mov fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start
+        .long	processor_id
+        .long	_end
+	.long   __machine_arch_type
+        .long	init_thread_union+8192
+
+L_AT91_SF_CIDR:
+	.long	0xfff00000
diff -Naur linux-2.6.9/arch/armnommu/mach-atmel/irq.c linux-2.6.9-uc0/arch/armnommu/mach-atmel/irq.c
--- linux-2.6.9/arch/armnommu/mach-atmel/irq.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-atmel/irq.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,215 @@
+/*
+ *  linux/arch/armnommu/mach-atmel/irq.c
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+ /* Internal Sources */
+#define LevelSensitive              (0<<5)
+#define EdgeTriggered               (1<<5)
+
+ /* External Sources */
+#define LowLevel                    (0<<5)
+#define NegativeEdge                (1<<5)
+#define HighLevel                   (2<<5)
+#define PositiveEdge                (3<<5)
+
+static unsigned char eb01_irq_prtable[32] = {
+        7 << 5, /* FIQ */
+        0 << 5, /* SWIRQ */
+        0 << 5, /* US0IRQ */
+        0 << 5, /* US1IRQ */
+        2 << 5, /* TC0IRQ */
+        2 << 5, /* TC1IRQ */
+        2 << 5, /* TC2IRQ */
+        0 << 5, /* WDIRQ */
+        0 << 5, /* PIOAIRQ */
+        0 << 5, /* reserved */
+        0 << 5, /* reserved */
+        0 << 5, /* reserved */
+        0 << 5, /* reserved */
+        0 << 5, /* reserved */
+        0 << 5, /* reserved */
+        0 << 5, /* reserved */
+        1 << 5, /* IRQ0 */
+	0 << 5, /* IRQ1 */
+        0 << 5, /* IRQ2 */
+};
+
+static unsigned char eb01_irq_type[32] = {
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+
+        EdgeTriggered,	/* IRQ0 = neg. edge */
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+        EdgeTriggered,
+};
+
+void __inline__ at91_mask_irq(unsigned int irq)
+{
+	unsigned long mask = 1 << (irq);
+	__raw_writel(mask, AIC_IDCR);
+}	
+
+void __inline__ at91_unmask_irq(unsigned int irq)
+{
+	unsigned long mask = 1 << (irq);
+	__raw_writel(mask, AIC_IECR);
+}
+
+void __inline__ at91_mask_ack_irq(unsigned int irq)
+{
+	at91_mask_irq(irq);
+}
+
+void __inline__ at91_end_of_isr(void)
+{
+	/* Indicates end of ISR to AIC */
+	__raw_writel(0x1L, AIC_EOICR); /* AIC don't care the value */
+}
+
+void __inline__ at91_unmask_and_eoi(unsigned int irq)
+{
+        at91_unmask_irq(irq);
+        at91_end_of_isr();
+}
+
+static struct irqchip at91_chip = {
+	.ack	= at91_mask_ack_irq,
+	.mask	= at91_mask_irq,
+	.unmask = at91_unmask_and_eoi,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init atmel_init_irq(void)
+{
+	int irq;
+
+        /* Disable all interrupts */
+        __raw_writel(0xFFFFFFFF, AIC_IDCR);
+
+        /* Clear all interrupts	*/
+        __raw_writel(0xFFFFFFFF, AIC_ICCR);
+
+        for ( irq = 0 ; irq < 32 ; irq++ )
+        {
+                __raw_writel(irq, AIC_EOICR);
+        }
+
+        for ( irq = 0 ; irq < 32 ; irq++ )
+        {
+            __raw_writel((eb01_irq_prtable[irq] >> 5) | eb01_irq_type[irq],
+		 AIC_SMR(irq));
+        }
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+	        if (!VALID_IRQ(irq)) continue;
+		set_irq_chip(irq, &at91_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+}
+
diff -Naur linux-2.6.9/arch/armnommu/mach-atmel/Kconfig linux-2.6.9-uc0/arch/armnommu/mach-atmel/Kconfig
--- linux-2.6.9/arch/armnommu/mach-atmel/Kconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-atmel/Kconfig	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,61 @@
+menu "ATMEL Options"
+	depends on ARCH_ATMEL
+
+config ARCH_SUPPORTS_BIG_ENDIAN
+        bool "big endian mode"
+        default n
+	help
+	AT91 core supports both of little and big endian.
+
+config ARM_CLK
+	int 'Arm Core Clock'
+	default 40000000
+	help
+	the default host clock of EB01 is 40MHz.
+	otherwise, change the value in clock.
+
+config SKIP_DUMP_CPU_INFO
+	bool
+	default y
+	help
+	AT91(ARM7TDMI) core does not support cache size
+	recognition instructions which uses MMU features.
+
+config MEM16_BASE
+	hex 'Memory mapped 16-bit io base'
+	default 0x03000000
+
+config MEM8_BASE
+	hex 'Memory mapped 8-bit io base'
+	default 0x03000000
+
+config IO16_BASE
+	hex '16-bit io base'
+	default 0x02000000
+
+config IO8_BASE
+	hex '8-bit io base'
+	default 0x02000000
+
+choice
+	prompt " Atmel CPU"
+	default CPU_AT91X40
+
+config CPU_AT91X40
+	bool "AT91x40"
+
+config CPU_AT91X63
+	bool "AT91X63"
+
+endchoice
+
+config ATMEL_DEBUG
+        bool "Atmel Kernel-Debug hack"
+        default n
+
+config AT91_DEBUG_BASE
+	depends on ATMEL_DEBUG
+	hex 'Debug buffer address'
+	default 0x01400000
+
+endmenu
diff -Naur linux-2.6.9/arch/armnommu/mach-atmel/Makefile linux-2.6.9-uc0/arch/armnommu/mach-atmel/Makefile
--- linux-2.6.9/arch/armnommu/mach-atmel/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-atmel/Makefile	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		+= arch.o irq.o
diff -Naur linux-2.6.9/arch/armnommu/mach-espd_4510b/arch.c linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/arch.c
--- linux-2.6.9/arch/armnommu/mach-espd_4510b/arch.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/arch.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,42 @@
+/*
+ *  linux/arch/arm/mach-espd_4510b/arch.c
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *			      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  Architecture specific fixups.  This is where any
+ *  parameters in the params struct are fixed up, or
+ *  any additional architecture specific information
+ *  is pulled from the params struct.
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+extern void __init s3c4510b_init_irq(void);
+
+void __init s3c4510b_init_machine(void) {
+	/* enable LED 0 */
+	outl( 0xFE, REG_IOPDATA);
+}
+
+MACHINE_START(ESPD_4510B, "ESPD 4510B(S3C4510B)")
+	MAINTAINER("Curt Brune <curt@cucy.com>")
+	INITIRQ( s3c4510b_init_irq)
+	INIT_MACHINE( s3c4510b_init_machine)
+	BOOT_PARAMS(0x00000800)
+MACHINE_END
diff -Naur linux-2.6.9/arch/armnommu/mach-espd_4510b/dma.c linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/dma.c
--- linux-2.6.9/arch/armnommu/mach-espd_4510b/dma.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/dma.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/arch-espd_4510b/dma.c
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS Co., Ltd. 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *     
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+
+void arch_dma_init(dma_t *dma)
+{
+}
diff -Naur linux-2.6.9/arch/armnommu/mach-espd_4510b/entry-macro.S linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/entry-macro.S
--- linux-2.6.9/arch/armnommu/mach-espd_4510b/entry-macro.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/entry-macro.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,27 @@
+/*
+ *  arch/armnommu/mach-espd_4510b/entry-macro.S
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ */
+
+#if defined(CONFIG_ARCH_ESPD_4510B)
+
+		.macro disable_fiq
+		.endm
+
+		.macro get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =REG_INTOSET_IRQ
+		ldr	\irqnr, [\base]
+		mov	\irqnr, \irqnr, lsr #2
+		teq	\irqnr, #NR_IRQS
+		.endm
+
+		.macro irq_prio_table
+		.endm
+
+#endif
diff -Naur linux-2.6.9/arch/armnommu/mach-espd_4510b/head.S linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/head.S
--- linux-2.6.9/arch/armnommu/mach-espd_4510b/head.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/head.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,67 @@
+/*
+ *  linux/arch/armnommu/mach-espd_4510b/head.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *  <hyok.choi@samsung.com>
+ *
+ *  uClinux kernel startup code for s3c4510b
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r8, r9, sp}			@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+	ldr	r5, =REG_IOPDATA
+	ldr     r4, =0xFE
+	str     r4, [r5]
+	
+	ldr	r2, S3C4510B_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, ESPD_4510B_MACH_TYPE
+	str     r2, [r9]
+
+        mov fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start
+        .long	processor_id
+        .long	_end
+	.long   __machine_arch_type
+        .long	init_thread_union+8192
+	
+S3C4510B_PROCESSOR_TYPE:
+	.long	0x36807001
+ESPD_4510B_MACH_TYPE:
+	.long	MACH_TYPE_ESPD_4510B
+
diff -Naur linux-2.6.9/arch/armnommu/mach-espd_4510b/irq.c linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/irq.c
--- linux-2.6.9/arch/armnommu/mach-espd_4510b/irq.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/irq.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,123 @@
+/*
+ *  linux/arch/armnommu/mach-espd_4510b/irq.c
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ * based the codes by
+ *     2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ *
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+static void __s3c4510b_mask_irq(unsigned int irq)
+{
+	INT_DISABLE( irq);
+}
+
+static void __s3c4510b_unmask_irq(unsigned int irq)
+{
+	INT_ENABLE( irq);
+}
+
+static void __s3c4510b_ack_irq(unsigned int irq)
+{
+	/* Acknowledge, clear _AND_ disable the interrupt. */
+	INT_DISABLE( irq);
+	CLEAR_PEND_INT( irq);
+}
+
+static struct irqchip s3c4510b_chip = {
+	.ack	= __s3c4510b_ack_irq,
+	.mask	= __s3c4510b_mask_irq,
+	.unmask = __s3c4510b_unmask_irq,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init s3c4510b_init_irq(void)
+{
+        int irq;
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &s3c4510b_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	/* mask and disable all further interrupts */
+	outl(INT_MASK_DIS, REG_INTMASK);
+
+	/* set all to IRQ mode, not FIQ */
+	outl(INT_MODE_IRQ, REG_INTMODE);
+
+	/* Clear Intrerrupt pending register	*/
+	outl( 0x1FFFFF, REG_INTPEND);
+
+	/*
+	 * enable the gloabal interrupt flag, this should be
+	 * safe now, all sources are masked out and acknowledged
+	 */
+	INT_ENABLE( INT_GLOBAL);
+}
+
diff -Naur linux-2.6.9/arch/armnommu/mach-espd_4510b/Kconfig linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/Kconfig
--- linux-2.6.9/arch/armnommu/mach-espd_4510b/Kconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/Kconfig	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,26 @@
+menu "ESPD_4510B Options"
+	depends on ARCH_ESPD_4510B
+
+config ARM_CLK
+	int 'Arm Core Clock'
+	default 50000000
+	help
+	the default host clock of S3C4510B is 50MHz.
+	otherwise, change the value in clock.
+
+config SKIP_DUMP_CPU_INFO
+	bool
+	default y
+	help
+	S3C4510B(ARM7TDMI) core does not support cache size
+	recognition instructions which uses MMU features.
+
+config REMAP_VECTORS_TO_RAM
+	bool
+	default y
+	help
+	S3C4510B core does not support ROM and RAM remap
+	function. we set the trap_init to be initialized
+	at the begining of DRAM_BASE.
+
+endmenu
diff -Naur linux-2.6.9/arch/armnommu/mach-espd_4510b/Makefile linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/Makefile
--- linux-2.6.9/arch/armnommu/mach-espd_4510b/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/Makefile	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		+= arch.o irq.o mm.o dma.o
diff -Naur linux-2.6.9/arch/armnommu/mach-espd_4510b/mm.c linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/mm.c
--- linux-2.6.9/arch/armnommu/mach-espd_4510b/mm.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/mm.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,17 @@
+/*
+ *  linux/arch/armnommu/mach-espd_4510b/mm.c
+ *
+ *  Copyright(C)2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+ 
+#include <asm/mach/map.h>
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c3410/arch.c linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/arch.c
--- linux-2.6.9/arch/armnommu/mach-s3c3410/arch.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/arch.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,53 @@
+/*
+ *  linux/arch/arm/mach-s5c7375/arch.c
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *			      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  Architecture specific fixups.  This is where any
+ *  parameters in the params struct are fixed up, or
+ *  any additional architecture specific information
+ *  is pulled from the params struct.
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+#include <linux/tty.h>
+#include <asm/elf.h>
+#include <linux/root_dev.h>
+#include <linux/initrd.h>
+
+
+extern void __init s3c3410_init_irq(void);
+
+static void __init
+fixup_s3c3410(struct machine_desc *desc, struct param_struct *params,
+        char **cmdline, struct meminfo *mi)
+{
+}
+
+MACHINE_START(S3C3410, "S3C3410, SAMSUNG ELECTRONICS Co., Ltd.")
+	MAINTAINER("Hyok S. Choi <hyok.choi@samsung.com>")
+	FIXUP(fixup_s3c3410)
+	INITIRQ(s3c3410_init_irq)
+MACHINE_END
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c3410/dma.c linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/dma.c
--- linux-2.6.9/arch/armnommu/mach-s3c3410/dma.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/dma.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/arch-s3c3410/dma.c
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS Co., Ltd. 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *     
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+
+void arch_dma_init(dma_t *dma)
+{
+}
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c3410/entry-macro.S linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/entry-macro.S
--- linux-2.6.9/arch/armnommu/mach-s3c3410/entry-macro.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/entry-macro.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,38 @@
+/*
+ *  arch/armnommu/mach-s3c3410/entry-macro.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  Samsung Electronics Co.,Ltd.
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ */
+
+#if defined(CONFIG_ARCH_S3C3410)
+                .macro  disable_fiq
+                .endm
+
+		.macro get_irqnr_and_base, irqnr, irqstat, base, tmp
+		
+		ldr	\irqstat, =(S3C3410X_INTPND)	@ load address of interrupt pending
+@		ldr	\irqstat, [\irqstat]	@ register INTPND
+		ldr	\irqnr, [\irqstat]	@ \irqnr = INTPND
+		add	\irqstat, \irqstat, #(S3C3410X_INTMSK-S3C3410X_INTPND)
+		ldr	\irqstat, [\irqstat]	@ \irqstat = INTMSK
+		and	\irqstat, \irqnr, \irqstat @ \irqstat = (INTPND & INTMSK)
+
+		mov     \irqnr, #0
+1001:
+		tst     \irqstat, #1
+		bne     1002f
+		add     \irqnr, \irqnr, #1
+		mov     \irqstat, \irqstat, lsr #1
+		cmp     \irqnr, #NR_IRQS
+		bcc     1001b
+1002:		/* EQ will be set if we reach 32 */
+		.endm
+
+		.macro irq_prio_table
+		.endm
+#endif
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c3410/head.S linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/head.S
--- linux-2.6.9/arch/armnommu/mach-s3c3410/head.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/head.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,64 @@
+/*
+ *  linux/arch/armnommu/mach-s5c7375/head.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *  <hyok.choi@samsung.com>
+ *
+ *  uClinux kernel startup code for s5c7375
+ *  which has no proper bootloader for linux startup
+ *  because of XIP.
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r8, r9, sp}			@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+	ldr	r2, S3C3410_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, S3C3410_MACH_TYPE
+	str     r2, [r9]
+
+        mov fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start
+        .long	processor_id
+        .long	_end
+	.long   __machine_arch_type
+        .long	init_thread_union+8192
+	
+S3C3410_PROCESSOR_TYPE:
+	.long	0x34107700
+S3C3410_MACH_TYPE:
+	.long	MACH_TYPE_S3C3410
+
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c3410/irq.c linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/irq.c
--- linux-2.6.9/arch/armnommu/mach-s3c3410/irq.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/irq.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,131 @@
+/*
+ *  linux/arch/arm/mach-s5c7375/irq.c
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ * based the codes by
+ *     2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ *
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+void __inline__ s3c3410_mask_irq(unsigned int irq)
+{
+	outl( inl(S3C3410X_INTMSK) & ~( 1 << irq ), S3C3410X_INTMSK);
+}
+
+void __inline__ s3c3410_unmask_irq(unsigned int irq)
+{
+	outl( inl(S3C3410X_INTMSK) | ( 1 << irq ), S3C3410X_INTMSK);
+}
+
+void __inline__ s3c3410_mask_ack_irq(unsigned int irq)
+{
+	s3c3410_mask_irq(irq);
+}
+
+/* Clear pending bit */
+void __inline__ s3c3410_clear_pb(unsigned int irq)
+{
+     outl( ~(1 << irq), S3C3410X_INTPND);}
+
+
+/* YOU CAN CHANGE THIS ROUTINE FOR SPEED UP */
+__inline__ unsigned int fixup_irq (int irq )
+{
+	s3c3410_clear_pb(irq);
+	return(irq);
+}
+
+static struct irqchip s3c3410_chip = {
+	.ack	= s3c3410_clear_pb,
+	.mask	= s3c3410_mask_irq,
+	.unmask = s3c3410_unmask_irq,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init s3c3410_init_irq(void)
+{
+        int irq;
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &s3c3410_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	/* mask and disable all further interrupts */
+	outl(0x00000000, S3C3410X_INTMSK);
+
+	/* set all to IRQ mode, not FIQ */
+	outl(0x00000000, S3C3410X_INTMOD);
+
+	/* Clear Intrerrupt pending register	*/
+	outl(0x00000000, S3C3410X_INTPND);
+
+	/*
+	 * enable the gloabal interrupt flag, this should be
+	 * safe now, all sources are masked out and acknowledged
+	 */
+	outb(inb(S3C3410X_SYSCON) | S3C3410X_SYSCON_GIE, S3C3410X_SYSCON);
+}
+
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c3410/Kconfig linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/Kconfig
--- linux-2.6.9/arch/armnommu/mach-s3c3410/Kconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/Kconfig	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,33 @@
+menu "S3C3410 Options"
+	depends on ARCH_S3C3410
+
+config ARCH_SUPPORTS_BIG_ENDIAN
+        bool
+        default y
+	help
+	S3C3410 core supports BIG-ENDIAN only,
+	both for CPU core and the external memory access.
+
+config ARM_CLK
+	int 'Arm Core Clock'
+	default 40000000
+	help
+	the default host clock of SMDK40100 is 40MHz.
+	otherwise, change the value in clock.
+
+config SKIP_DUMP_CPU_INFO
+	bool
+	default y
+	help
+	S3C3410(ARM7TDMI) core does not support cache size
+	recognition instructions which uses MMU features.
+
+config REMAP_VECTORS_TO_RAM
+	bool
+	default y
+	help
+	S3C3410 core does not support ROM and RAM remap
+	function. we set the trap_init to be initialized
+	at the begining of DRAM_BASE.
+
+endmenu
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c3410/Makefile linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/Makefile
--- linux-2.6.9/arch/armnommu/mach-s3c3410/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/Makefile	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		+= arch.o irq.o mm.o dma.o
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c3410/mm.c linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/mm.c
--- linux-2.6.9/arch/armnommu/mach-s3c3410/mm.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/mm.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,21 @@
+/*
+ *  linux/arch/armnommu/mach-s3c3410/mm.c
+ *
+ *  Copyright(C)2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+ 
+#include <asm/mach/map.h>
+
+static void __init s3c3410_map_io(void)
+{
+}
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/arch.c linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/arch.c
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/arch.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/arch.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,105 @@
+/*
+ *  linux/arch/arm/mach-s3c44b0x/arch.c
+ *  	nickmit_zheng@eastday.com
+ *  		based on
+ *	Hyok S. Choi (hyok.choi@samsung.com)
+ * 	linux 2.6 armnommu porting
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+#include <linux/tty.h>
+#include <asm/elf.h>
+#include <linux/root_dev.h>
+#include <linux/initrd.h>
+
+// used by sysctl
+#define DEFAULT_MAX_MAP_COUNT	65536
+int sysctl_max_map_count = DEFAULT_MAX_MAP_COUNT;
+
+int s3c44b0x_fMHZ 	= CONFIG_ARM_CLK / 1000000;
+int s3c44b0x_finMHZ	= CONFIG_ARM_CLK_FIN / 1000000;
+
+extern void __init s3c44b0x_init_irq(void);
+
+void __init s3c44b0x_init_machine(void)
+{
+}
+
+#if CONFIG_DEBUG_NICKMIT
+// char my_cmdline[] = "root=/dev/ram rw initrd=0x0c700000,512K";
+char my_cmdline[1024] = "root=/dev/nfs "
+	"nfsroot=192.168.1.24:/armboot "
+	"ip=192.168.1.8:192.168.1.24:192.168.1.1:255.255.255.0:arm:eth0:off";
+	
+void __init change_cmdline(char **cmdline)
+{
+	int magic_addr[] = {0xcf00000, 0xce000000, 0x1e0000};
+	char magic_head[] = "Kernel cmdline:";
+	int i;
+	int cnt = sizeof (magic_addr) / sizeof (int);
+	char *p, *d;
+	for(i=0;i<cnt;i++) {
+		p = (char *) magic_addr[i];
+		if (strncmp(p, magic_head, (sizeof magic_head) - 1) != 0)
+			continue;
+		p += sizeof magic_head - 1;
+		d = my_cmdline;
+		while (*p != '\r' && *p != '\n' && (d - my_cmdline - sizeof my_cmdline))
+			*d++ = *p++;
+
+		*d = 0;
+		*cmdline = my_cmdline;
+		return;
+	}
+	*cmdline = my_cmdline;
+}
+
+void __init load_initrd(void *src, void *dst, size_t count)
+{
+	int verify = 1;
+	printk("Load initrd image from flash(%08x) to SDRAM(%08x), Length = %d ...", src, dst, count);
+	memmove(dst, src, count);
+	if (verify) {
+		printk("Verify ...");
+		printk("%s\n", memcmp(src, dst, count) == 0 ? "Done" : "Failed");
+	} else {
+		printk("Done\n");
+	}
+}
+#endif
+
+void __init s3c44b0x_fixup(struct machine_desc *desc, struct param_struct *params, char **cmdline, struct meminfo *mi)
+{
+#if CONFIG_NICKMIT_DEBUG
+	change_cmdline(cmdline);
+//	load_initrd(0x1000, 0x0c700000, 0x100000);
+#endif
+}
+
+MACHINE_START(S3C44B0, "S3C44B0X Development Board")
+	MAINTAINER("nickmit <nickmit_zheng@eastday.com>")
+	FIXUP(s3c44b0x_fixup)
+	INITIRQ(s3c44b0x_init_irq)
+	INIT_MACHINE(s3c44b0x_init_machine)
+MACHINE_END
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/cache.S linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/cache.S
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/cache.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/cache.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,35 @@
+/*
+ *  linux/arch/arm/mm/cache-s3c44b0.S
+ *
+ *  caution: s3c44b0x DONT have a coprocessor!
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/page.h>
+
+ENTRY(v3_flush_user_cache_all)
+ENTRY(v3_flush_kern_cache_all)
+ENTRY(v3_flush_user_cache_range)
+
+ENTRY(v3_coherent_kern_range)
+
+ENTRY(v3_flush_kern_dcache_page)
+ENTRY(v3_dma_inv_range)
+ENTRY(v3_dma_flush_range)
+ENTRY(v3_dma_clean_range)
+	mov	pc, lr
+
+	__INITDATA
+
+	.type	v3_cache_fns, #object
+ENTRY(v3_cache_fns)
+	.long	v3_flush_kern_cache_all
+	.long	v3_flush_user_cache_all
+	.long	v3_flush_user_cache_range
+	.long	v3_coherent_kern_range
+	.long	v3_flush_kern_dcache_page
+	.long	v3_dma_inv_range
+	.long	v3_dma_clean_range
+	.long	v3_dma_flush_range
+	.size	v3_cache_fns, . - v3_cache_fns
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/dma.c linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/dma.c
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/dma.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/dma.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/arch-s3c44b0x/dma.c
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+
+void arch_dma_init(dma_t *dma)
+{
+}
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/console.c linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/console.c
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/console.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/console.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,41 @@
+#include <linux/init.h>
+#include <linux/console.h>
+#include <asm/arch/hardware.h>
+
+void s3c44b0x_uart_putc(const char c)
+{
+	while(!(SYSREG_GET(S3C44B0X_UTRSTAT0) & 0x2));
+	SYSREG_SETB(S3C44B0X_UTXH0, c);
+}
+
+void s3c44b0x_console_write(struct console *co, const char *b, unsigned count)
+{
+	while(count) {
+		s3c44b0x_uart_putc(*b);
+		if (*b == '\n')
+			s3c44b0x_uart_putc('\r');
+		++b;
+		--count;
+	}
+}
+
+static int __init s3c44b0x_console_setup(struct console *co, char *options)
+{       
+	return 0;
+}
+
+struct console s3c44b0x_con_driver = {
+	.name           = "S3C44B0X",
+	.write          = s3c44b0x_console_write,
+	.setup          = s3c44b0x_console_setup,
+	.flags          = CON_PRINTBUFFER,
+	.index          = -1,
+};      
+
+static int __init s3c44b0x_console_init(void) 
+{                               
+	register_console(&s3c44b0x_con_driver);
+	return 0;       
+}                               
+
+console_initcall(s3c44b0x_console_init);
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/Kconfig linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/Kconfig
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/Kconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/Kconfig	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,23 @@
+menu "S3C44B0X Board Driver Options" 
+
+config SERIAL_S3C44B0X
+	bool 'S3C44B0X Serial Support'
+	default y
+	help
+	Samsung S3C44B0X Chips has built-in serial controler
+
+config SERIAL_S3C44B0X_CONSOLE
+	bool 'S3C44B0X Serial Console Support'
+	depends on SERIAL_S3C44B0X
+	help
+	use serial port 0 as console
+	
+config ETH_RTL8019AS
+	bool 'Realtek 8019AS NIC support'
+	default n
+
+config S3C44B0X_GPIO_LED
+	bool 'Use onboard led'
+	default n
+
+endmenu
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/led.c linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/led.c
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/led.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/led.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,28 @@
+#include <asm/arch/hardware.h>
+
+void s3c44b0x_led_off(int bit)
+{
+	SYSREG_OR_SET(S3C44B0X_PDATE, 1<<(4+bit));
+}
+
+void s3c44b0x_led_on(int bit)
+{	
+	SYSREG_CLR(S3C44B0X_PDATE, 1<<(4+bit));
+}
+
+void s3c44b0x_led_disp(int data)
+{
+	data = (data << 12) >> 8;
+	data = (~data) & 0x1ff;
+	SYSREG_AND_SET(S3C44B0X_PDATE, ~data);
+}
+
+void s3c44b0x_led_init(void)
+{
+	SYSREG_AND_SET(S3C44B0X_PCONE, 0xffff556b);
+	SYSREG_SET(S3C44B0X_PUPE, 0x6);
+	SYSREG_SET(S3C44B0X_PDATE, 0x3f7);
+	s3c44b0x_led_disp(15);
+}
+
+
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/Makefile linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/Makefile
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/Makefile	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+# obj-$(CONFIG_SERIAL_S3C44B0X)	+= serial_core_44b0x.o s3c44b0.o
+obj-$(CONFIG_SERIAL_S3C44B0X)	+= console.o
+obj-$(CONFIG_ETH_RTL8019AS)	+= rtl8019.o
+obj-$(CONFIG_S3C44B0X_GPIO_LED)	+= led.o
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/rtl8019.c linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/rtl8019.c
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/rtl8019.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/rtl8019.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,419 @@
+/*
+ * port to 16bit/8bit remote dma mode lq@cdgwbn.com.cn 
+ * linux/deriver/net/Rtl8019as.c
+ * Ethernet driver for Samsung 44B0
+ * Copyright (C) 2003 antiscle <hzh12@163.net>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>		// kmalloc()
+#include <linux/errno.h>	// error codes
+#include <linux/types.h>	// size_t
+#include <linux/interrupt.h>	// mark_bh
+#include <linux/in.h>
+#include <linux/netdevice.h>    // net_device
+#include <linux/etherdevice.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <asm/irq.h>
+#include "rtl8019.h"
+
+#define RTL8019_OP_16   1
+
+#undef  DEBUG
+#define DEBUG	1
+#ifdef	DEBUG
+#define TRACE(str, args...)	printk(str, ## args)
+#else
+#define TRACE(str, args...)
+#endif
+
+
+#define	outportb(port, data)	*((volatile u8 *)(port)) = (u8)(data)
+#define	inportb(port)		*((volatile u8 *)(port))
+
+
+#define	outportw(port, data)	*((volatile u16 *)(port)) = (u16)(data)
+#define	inportw(port)		*((volatile u16 *)(port))
+
+#define	ETH_FRAME_LEN		1514
+
+#define	RPSTART			0x4c
+#define	RPSTOP			0x80
+#define	SPSTART			0x40
+
+static int timeout = 100;	// tx watchdog ticks 100 = 1s
+static char *version = "Samsung S3C44B0 Rtl8019as driver version 0.1 (2002-02-20) <hzh12@163.net>\n";
+
+/*
+ * This structure is private to each device. It is used to pass
+ * packets in and out, so there is place for a packet
+ */
+struct nic_8019_priv {
+	struct net_device_stats stats;	
+	spinlock_t lock;
+	struct sk_buff *skb;
+};
+
+/*****************************************************************************/
+static u8 rBNRY;
+static u8 SrcMacID[ETH_ALEN] = {0x12,0x34,0x56,0x78,0x90,0xAB,};
+
+static void SetRegPage( u8 PageIdx)
+{
+	u8 temp;
+
+	temp = inportb(BaseAddr);	
+	temp = (temp&0x3b)|(PageIdx<<6);						
+	outportb(BaseAddr, temp);
+}
+
+
+irqreturn_t nic_8019_rx(int irq, void *dev_id, struct pt_regs *regs)
+{
+	u8 RxPageBeg, RxPageEnd;
+	u8 RxNextPage;
+	u8 RxStatus;
+	u16 *data,temp;
+	u16 i, RxLength,RxLen;
+
+	struct sk_buff *skb;	
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct nic_8019_priv *priv = (struct nic_8019_priv *) dev->priv;
+
+	TRACE("TX/RX Interupt!\n");
+	spin_lock(&priv->lock);
+	SetRegPage(0);
+	outportb(BNRY, rBNRY);		//???
+	RxStatus = inportb(ISR);
+	if (RxStatus & 2) {
+		outportb(ISR, 0x2);		//clr TX interupt
+		priv->stats.tx_packets++;	
+		TRACE("transmit one packet complete!\n");
+	}
+	
+	if (RxStatus & 1) {
+		TRACE("Receivex packet....\n");		
+		outportb(ISR, 0x1);	         //clr Rx interupt	
+		SetRegPage(1);
+		RxPageEnd = inportb(CURR);
+
+		SetRegPage(0);	
+		RxPageBeg = rBNRY+1;
+		if(RxPageBeg>=RPSTOP)
+			RxPageBeg = RPSTART;		
+		outportb(BaseAddr, 0x22);	// stop	remote dma
+
+		//outport(RSAR0, RxPageBeg<<8);
+		//outport(RBCR0, 256);		
+		outportb(RSAR0, 0);
+		outportb(RSAR1, RxPageBeg);
+		outportb(RBCR0, 4);
+		outportb(RBCR1, 0);	
+		outportb(BaseAddr, 0xa);
+
+#ifdef RTL8019_OP_16
+		temp       = inportw(RWPORT);
+		RxNextPage = temp>>8;
+		RxStatus   = temp&0xff;
+		RxLength   = inportw(RWPORT);
+#else
+		RxStatus   = inportb(RWPORT);
+		RxNextPage = inportb(RWPORT);	
+		RxLength   = inportb(RWPORT);
+		RxLength  |= inportb(RWPORT)<<8;
+#endif		
+		TRACE("\nRxBeg = %x, RxEnd = %x,  nextpage = %x,  size = %i\n", RxPageBeg, RxPageEnd, RxNextPage, RxLength);		
+		RxLength -= 4;
+		if (RxLength>ETH_FRAME_LEN) {
+			if (RxPageEnd==RPSTART)
+				rBNRY = RPSTOP-1;
+			else
+				rBNRY = RxPageEnd-1;
+				
+			outportb(BNRY, rBNRY);
+			TRACE("RxLength more long than %x\n", ETH_FRAME_LEN);
+			return IRQ_HANDLED;
+		}
+
+		skb = dev_alloc_skb(RxLength+2);
+		if (!skb) {
+			TRACE("Rtl8019as eth: low on mem - packet dropped\n");
+			priv->stats.rx_dropped++;
+			return IRQ_HANDLED;
+		}
+
+		skb->dev = dev;		
+		skb_reserve(skb, 2);
+		skb_put(skb, RxLength);
+		data = ( u16 *)skb->data;
+
+		//		eth_copy_and_sum(skb, data, len, 0);
+		outportb(RSAR0, 4);
+		outportb(RSAR1, RxPageBeg);
+		outportb(RBCR0, RxLength);
+		outportb(RBCR1, RxLength>>8);	
+		outportb(BaseAddr, 0xa);
+#ifdef RTL8019_OP_16
+		i = 2;
+		data -= 2;
+		RxLen=(RxLength+1)/2;	
+#else 
+		i = 4;
+		data -= 4;
+		RxLen=RxLength;
+#endif
+		for(; RxLen--;) {
+#ifdef RTL8019_OP_16
+			static const int cmp_val = 0x7f;
+#else
+			static const int cmp_val = 0xff;
+#endif
+			if (!(i & cmp_val)) {
+				outportb(BNRY, RxPageBeg);				
+				RxPageBeg++;
+				if(RxPageBeg>=RPSTOP)
+					RxPageBeg = RPSTART;					
+			}
+#ifdef RTL8019_OP_16
+			data[i++] = inportw(RWPORT);		
+			TRACE("%2X,%2X,", data[i-1]&0xff,data[i-1]>>8);
+#else
+			data[i++] = inportb(RWPORT);		
+			TRACE("%2X,", data[i-1]);
+#endif
+		}
+
+		TRACE("\n");
+		outportb(BNRY, RxPageBeg);	
+		rBNRY = RxPageBeg;
+
+		skb->protocol = eth_type_trans(skb, dev);
+		TRACE("\nprotocol=%x\n", skb->protocol);
+		priv->stats.rx_packets++;
+		priv->stats.rx_bytes +=RxLength;
+		netif_rx(skb);
+	} else {
+		outportb(ISR, 0xfe);	
+	}
+
+	spin_unlock(&priv->lock);
+	return IRQ_HANDLED;
+}
+
+
+/*
+ * Open and Close
+ */
+static int nic_8019_open(struct net_device *dev)
+{
+	int i,j;
+
+	MOD_INC_USE_COUNT;
+	TRACE("open\n");
+	// Disable irqs
+	disable_irq(dev->irq);
+	// register rx isr
+	if (request_irq(dev->irq, &nic_8019_rx, SA_INTERRUPT, "eth rx isr", dev)) {
+		printk(KERN_ERR "Rtl8019: Can't get irq %d\n", dev->irq);
+		return -EAGAIN;
+	}
+
+	// wake up Rtl8019as
+	SetRegPage(3);	
+	outportb(CR9346, 0xcf);		//set eem1-0, 11 ,enable write config register
+	outportb(CONFIG3, 0x60);	//clear pwrdn, sleep mode, set led0 as led_col, led1 as led_crs	
+	outportb(CR9346, 0x3f); 	//disable write config register
+	
+	// initialize
+	outportb(RstAddr, 0x5a);
+	i = 20000;
+	while(i--);
+
+
+	SetRegPage(0);
+	inportb(ISR);				
+	outportb(BaseAddr, 0x21);	/* set page 0 and stop */
+	outportb(Pstart, RPSTART);	/* set Pstart 0x4c */
+	outportb(Pstop, RPSTOP);	/* set Pstop 0x80 */
+	outportb(BNRY, RPSTART);	/* BNRY-> the last page has been read */	
+	outportb(TPSR, SPSTART);	/* SPSTART page start register, 0x40 */
+	outportb(RCR, 0xcc);		/* set RCR 0xcc */	
+	outportb(TCR, 0xe0);		/* set TCR 0xe0 */
+	outportb(DCR, 0xc9);		/* set DCR 0xc9, 16bit DMA */	
+
+	outportb(IMR, 0x03);		/* set IMR 0x03, enable tx rx int */
+	outportb(ISR, 0xff);		/* clear ISR */
+
+	SetRegPage(1);
+	for(i=0; i<6; i++)
+		outportb(BaseAddr+(1+i)*2, dev->dev_addr[i]);	// set mac id
+		
+	outportb(CURR, RPSTART+1);	
+	outportb(MAR0, 0x00);
+	outportb(MAR1, 0x41);
+	outportb(MAR2, 0x00);
+	outportb(MAR3, 0x80);
+	outportb(MAR4, 0x00);
+	outportb(MAR5, 0x00);
+	outportb(MAR6, 0x00);
+	outportb(MAR7, 0x00);
+	outportb(BaseAddr, 0x22);		/* set page 0 and start */	
+	rBNRY = RPSTART;
+	enable_irq(dev->irq);		
+	// Start the transmit queue
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int nic_8019_stop(struct net_device *dev)
+{
+	TRACE("stop\n");
+	SetRegPage(3);	
+	outportb(CR9346, 0xcf);		// set eem1-0, 11 ,enable write config register
+	outportb(CONFIG3, 0x66);	// enter pwrdn, sleep mode, set led0 as led_col, led1 as led_crs	
+	outportb(CR9346, 0x3f); 	// disable write config register
+
+	free_irq(dev->irq, dev);	
+	netif_stop_queue(dev);
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static int nic_8019_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int i;
+	u16 len,TxLen;
+	u16 *data;
+	struct nic_8019_priv *priv = (struct nic_8019_priv *) dev->priv;
+
+	TRACE("start_xmit\n");
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	TRACE("\nTx Length = %i,%x,%x\n", len, skb->data[12], skb->data[13]);
+	data =(u16*) skb->data;
+
+	outportb(BaseAddr,0x22);  	//switch to page 0 and stop remote dma
+	if (inportb(BaseAddr)&4)	// last remote dma not complete,return 1 echo busy(error),retransmit next
+		return 1;
+#ifdef bug_fix_for_write
+	//read page 42,0,42,0 before write if you have problem
+#endif
+	outportb(RSAR0, 0);
+	outportb(RSAR1, SPSTART);
+	outportb(RBCR0, len&0xff);	
+	outportb(RBCR1, len>>8);			
+	outportb(BaseAddr, 0x12);	//begin remote write
+	dev->trans_start = jiffies;	
+#ifdef RTL8019_OP_16
+	TxLen=(len+1)/2;
+#else
+	TxLen=len;
+#endif
+	for(i=0; i<TxLen; i++) {				
+#ifdef RTL8019_OP_16		
+		outportw(RWPORT, data[i]);		// copy data to nic ram
+		TRACE("%2X,%2X,",data[i]&0xff,data[i]>>8);
+#else
+		outportb(RWPORT, data[i]);		// copy data to nic ram
+		TRACE("%2X,",skb->data[i]);
+#endif
+	}	
+
+	TRACE("\n");
+	outportb(TPSR,  SPSTART);       // transmit begin page 0x40
+	outportb(TBCR0, len&0xff);	
+	outportb(TBCR1, len>>8);				
+	outportb(BaseAddr, 0x1e);	// begin to send packet	
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+static struct net_device_stats *nic_8019_get_stats(struct net_device *dev)
+{
+	struct nic_8019_priv *priv = (struct nic_8019_priv *) dev->priv;
+	TRACE("get_stats\n");
+	return &priv->stats;
+}
+
+/******************************************************************************/
+static int nic_8019_init(struct net_device *dev)
+{
+	int i;
+	TRACE("init\n");
+	ether_setup(dev);	// Assign some of the fields
+
+	// set net_device methods
+	dev->open = nic_8019_open;
+	dev->stop = nic_8019_stop;
+	dev->get_stats = nic_8019_get_stats;
+	dev->hard_start_xmit = nic_8019_start_xmit;
+
+	// set net_device data members
+	dev->watchdog_timeo = timeout;
+	dev->irq = 22;
+	dev->dma = 0;
+
+	// set MAC address manually
+	printk(KERN_INFO "%s: ", dev->name);
+	for(i=0; i<6; i++) {
+		dev->dev_addr[i] = SrcMacID[i];		
+		printk("%2.2x%c", dev->dev_addr[i], (i==5) ? ' ' : ':');
+	}
+	printk("\n");
+
+	SET_MODULE_OWNER(dev);
+
+	dev->priv = kmalloc(sizeof(struct nic_8019_priv), GFP_KERNEL);
+	if(dev->priv == NULL)
+		return -ENOMEM;
+
+	memset(dev->priv, 0, sizeof(struct nic_8019_priv));
+	spin_lock_init(&((struct nic_8019_priv *) dev->priv)->lock);
+	return 0;
+}
+
+static struct net_device nic_8019_netdevs = {
+	init: nic_8019_init,
+};
+
+/*
+ * Finally, the module stuff
+ */
+int __init nic_8019_init_module(void)
+{
+	int result;
+	TRACE("init_module\n");
+
+	//Print version information
+	printk(KERN_INFO "%s", version);
+
+	//register_netdev will call nic_8019_init()
+	if((result = register_netdev(&nic_8019_netdevs)))
+		printk("Rtl8019as eth: Error %i registering device \"%s\"\n", result, nic_8019_netdevs.name);
+		
+	return result ? 0 : -ENODEV;
+}
+
+void __exit nic_8019_cleanup(void)
+{
+	TRACE("cleanup\n");
+	kfree(nic_8019_netdevs.priv);
+	unregister_netdev(&nic_8019_netdevs);
+	return;
+}
+
+module_init(nic_8019_init_module);
+module_exit(nic_8019_cleanup);
+
+MODULE_DESCRIPTION("Rtl8019as ethernet driver");
+MODULE_AUTHOR("antiscle <hzh12@163.net>");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/rtl8019.h linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/rtl8019.h
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/driver/rtl8019.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/driver/rtl8019.h	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,55 @@
+
+#define SHIFT(x)	(x<<1)
+
+#define	BaseAddr	0x6000000
+#define	RWPORT	(BaseAddr+SHIFT(0x10))	/* dma read write address, form 0x10 - 0x17 */
+#define	RstAddr (BaseAddr+SHIFT(0x18))	/* reset register, 0x18, 0x1a, 0x1c, 0x1e even address is recommanded */
+
+/* page 0 */
+#define	Pstart	(BaseAddr+SHIFT(1))	/* page start */
+#define	Pstop	(BaseAddr+SHIFT(2))	/* page stop */
+#define	BNRY	(BaseAddr+SHIFT(3))	
+#define	TPSR	(BaseAddr+SHIFT(4))	/* transmit page start */
+#define	TBCR0	(BaseAddr+SHIFT(5))
+#define	TBCR1	(BaseAddr+SHIFT(6))
+#define	ISR	(BaseAddr+SHIFT(7))	/* interrupt status register */
+
+#define	RSAR0	(BaseAddr+SHIFT(8))	/* dma read address */
+#define	RSAR1	(BaseAddr+SHIFT(9))
+#define	RBCR0	(BaseAddr+SHIFT(10))	/* dma read byte count */
+#define	RBCR1	(BaseAddr+SHIFT(11))
+
+#define	RCR	(BaseAddr+SHIFT(12))	/* receive config */
+#define	TCR	(BaseAddr+SHIFT(13))	/* transmit config */
+#define	DCR	(BaseAddr+SHIFT(14))	/* data config */
+#define	IMR	(BaseAddr+SHIFT(15))	/* interrupt mask */
+
+#define	ID8019L	(BaseAddr+SHIFT(10))
+#define	ID8019H	(BaseAddr+SHIFT(11))
+
+/* page 1 */
+#define	PAR0	(BaseAddr+SHIFT(1))
+#define	PAR1	(BaseAddr+SHIFT(2))
+#define	PAR2	(BaseAddr+SHIFT(3))
+#define	PAR3	(BaseAddr+SHIFT(4))
+#define	PAR4	(BaseAddr+SHIFT(5))
+#define	PAR6	(BaseAddr+SHIFT(6))
+
+#define	CURR	(BaseAddr+SHIFT(7))		
+#define	MAR0	(BaseAddr+SHIFT(8))
+#define	MAR1	(BaseAddr+SHIFT(9))
+#define	MAR2	(BaseAddr+SHIFT(10))
+#define	MAR3	(BaseAddr+SHIFT(11))
+#define	MAR4	(BaseAddr+SHIFT(12))
+#define	MAR5	(BaseAddr+SHIFT(13))
+#define	MAR6	(BaseAddr+SHIFT(14))
+#define	MAR7	(BaseAddr+SHIFT(15))
+
+/* page 2 */
+
+/* page 3 */
+#define	CR9346	(BaseAddr+SHIFT(1))
+#define	CONFIG0	(BaseAddr+SHIFT(3))
+#define	CONFIG1	(BaseAddr+SHIFT(4))
+#define	CONFIG2	(BaseAddr+SHIFT(5))
+#define	CONFIG3	(BaseAddr+SHIFT(6))
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/entry-macro.S linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/entry-macro.S
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/entry-macro.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/entry-macro.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,31 @@
+/*
+ *  arch/armnommu/mach-s3c44b0x/entry-macro.S
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ */
+
+#ifndef CONFIG_ARCH_S3C44B0
+#error
+#endif
+                .macro  disable_fiq
+		/* FIXME */
+                .endm
+
+		.macro get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr     \base, =S3C44B0X_I_ISPR
+		ldr     \base, [\base]
+		mov     \irqnr, #0
+2222:           
+		tst     \base, #1 
+		bne     1111f
+		add     \irqnr, \irqnr, #1      
+		mov     \base, \base, lsr #1
+		cmp     \irqnr, #NR_IRQS
+		bcc     2222b
+1111:           
+		.endm
+
+		.macro irq_prio_table
+		/* FIXME */
+		.endm
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/head.S linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/head.S
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/head.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/head.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,67 @@
+/*
+ *  linux/arch/armnommu/mach-s3c44b0x/head.S
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+#include <asm/arch/hardware.h>
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	/*
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	*/
+	mov	r0, #PSR_I_BIT | MODE_SVC		@ make sure svc mode
+	msr	cpsr_c, r0				@ and all irqs disabled
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r8, r9, sp}		@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+	/* handle CPU Cache */
+	ldr	r4, =S3C44B0X_SYSCFG
+	mov	r5, #0x0e
+	str	r5, [r4]
+	
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+
+	ldr	r2, S3C44B0_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, S3C44B0_MACH_TYPE
+	str     r2, [r9]
+
+        mov 	fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start
+        .long	processor_id
+        .long	_end
+	.long   __machine_arch_type
+        .long	init_thread_union+8192
+	
+S3C44B0_PROCESSOR_TYPE:
+	.long	0x44b07700
+S3C44B0_MACH_TYPE:
+	.long	MACH_TYPE_S3C44B0
+
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/irq.c linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/irq.c
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/irq.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/irq.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,143 @@
+/*
+ *  linux/arch/arm/mach-s3c44b0x/irq.c
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+void __inline__ s3c44b0x_mask_irq(unsigned int irq)
+{
+	SYSREG_OR_SET(S3C44B0X_INTMSK, 1<<irq);
+}
+
+void __inline__ s3c44b0x_unmask_irq(unsigned int irq)
+{
+	SYSREG_CLR(S3C44B0X_INTMSK, 1<<irq);
+}
+
+void __inline__ s3c44b0x_mask_ack_irq(unsigned int irq)
+{
+	s3c44b0x_mask_irq(irq);
+}
+
+/* Clear pending bit */
+void __inline__ s3c44b0x_clear_pb(unsigned int irq)
+{
+	SYSREG_OR_SET(S3C44B0X_I_ISPC, 1<<irq);
+}
+
+
+/* YOU CAN CHANGE THIS ROUTINE FOR SPEED UP */
+__inline__ unsigned int fixup_irq (int irq )
+{
+	s3c44b0x_clear_pb(irq);
+	return(irq);
+}
+
+static struct irqchip s3c44b0x_chip = {
+	.ack	= s3c44b0x_clear_pb,
+	.mask	= s3c44b0x_mask_irq,
+	.unmask = s3c44b0x_unmask_irq,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+
+void __init s3c44b0x_init_irq(void)
+{
+        int irq;
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &s3c44b0x_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	/* Note: in Samsung s3c44b0x um
+	
+	"1. INTMSK register can be masked only when it is sure that the corresponding interrupt does not be
+	requested. If your application should mask any interrupt mask bit(INTMSK) just when the
+	corresponding interrupt is issued, please contact our FAE (field application engineer).
+	
+	2. If you need that all interrupt is masked, we recommend that I/F bits in CPSR are set using MRS, MSR
+	instructions. The I, F bit in CPSR can be masked even when any interrupt is issued."
+	
+	*/
+	/* at this moment, the I/F bits should has been set, so it's safe to use rINTMAK */
+	
+	/* mask and disable all further interrupts */
+	SYSREG_SET(S3C44B0X_INTMSK, 0x07ffffff);
+
+	/* set all to IRQ mode, not FIQ */
+
+	SYSREG_SET(S3C44B0X_INTCON, 0x5);	 // Vectored & IRQ & !FIQ
+	SYSREG_SET(S3C44B0X_INTMOD, 0x00000000); // All IRQ mode
+
+	/* Clear Intrerrupt pending register */
+
+	SYSREG_OR_SET(S3C44B0X_I_ISPC, 0x7fffffff);
+
+	/*
+	 * enable the gloabal interrupt flag, this should be
+	 * safe now, all sources are masked out and acknowledged
+	 */
+	SYSREG_CLR(S3C44B0X_INTMSK, 1<<26);
+}
+
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/Kconfig linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/Kconfig
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/Kconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/Kconfig	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,45 @@
+menu "S3C44B0X Board Options" 
+	depends on ARCH_S3C44B0
+
+config DEBUG_NICKMIT
+	bool 'DEBUG_NICKMIT'
+	default n
+
+config SKIP_DUMP_CPU_INFO
+	bool 'Skip Dump CPU Info'
+	default y
+	help
+	S3C44B0X(ARM7TDMI) core does not support cache size
+	recognition instructions which uses MMU features.
+
+config REMAP_VECTORS_TO_RAM
+	bool 'Remap Vectors To Ram'
+	default y
+	help
+	S3C44B0X core does not support ROM and RAM remap
+	function. we set the trap_init to be initialized
+	at the begining of DRAM_BASE.
+
+config ARM_CLK
+	int 'Arm Core Clock'
+	default 60000000
+	help
+	the default host clock of 51EDA-S3C44B0X Board is 60MHz.
+	otherwise, change the value in clock.
+	
+config ARM_CLK_ADJUST
+	bool "Arm Core Clock Adjust(EXPERIMENTAL)"
+	default n && EXPERIMENTAL
+	help
+	use this option to adjust the CPU frequence
+
+config ARM_CLK_FIN
+	int 'External OSC Clock Frequence' 
+	default 8000000
+	depends on ARM_CLK_ADJUST && EXPERIMENTAL
+	help
+	this is the input frequence of system clock
+
+source "arch/armnommu/mach-s3c44b0x/driver/Kconfig"
+
+endmenu
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/Makefile linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/Makefile
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/Makefile	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,8 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		+= arch.o irq.o mm.o dma.o time.o cache.o
+obj-y		+= driver/
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/mm.c linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/mm.c
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/mm.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/mm.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,18 @@
+/*
+ *  linux/arch/armnommu/mach-s3c44b0x/mm.c
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+ 
+#include <asm/mach/map.h>
+
+static void __init s3c44b0x_map_io(void)
+{
+	return;
+}
diff -Naur linux-2.6.9/arch/armnommu/mach-s3c44b0x/time.c linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/time.c
--- linux-2.6.9/arch/armnommu/mach-s3c44b0x/time.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/time.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,42 @@
+/*
+ * linux/arch/arm/mach-s3c44b0x/time.c
+ */
+
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+
+#define S3C44B0X_SYSTIMER_DIVIDER	2
+extern int s3c44b0x_fMHZ;
+extern int s3c44b0x_finMHZ;
+
+/* the system clock is in MHz unit, here I use the prescale value for 1 us resolution */
+
+#if	CONFIG_ARM_CLK_ADJUST
+void s3c44b0x_systimer_setup(void)
+#else
+void __init s3c44b0x_systimer_setup(void)
+#endif
+{
+	int prescale = s3c44b0x_fMHZ / S3C44B0X_SYSTIMER_DIVIDER;
+	int cnt = s3c44b0x_fMHZ * 1000000 / prescale / S3C44B0X_SYSTIMER_DIVIDER / HZ;
+	
+	SYSREG_CLR	(S3C44B0X_TCON,0x7<<24);			// stop timer 5			
+	SYSREG_SET	(S3C44B0X_TCNTB5, cnt);
+	SYSREG_OR_SET	(S3C44B0X_TCON, 2<<24);				// update timer5 counter
+	
+	SYSREG_OR_SET	(S3C44B0X_TCFG0, (prescale - 1) << 16);		// set prescale, bit 16-23
+	SYSREG_AND_SET	(S3C44B0X_TCFG1, 0xff0fffff);			// set timer5 divider, bit 20-23.  0 for 1/2 
+}
+
+void __inline__ s3c44b0x_systimer_start(void)
+{
+	SYSREG_CLR	(S3C44B0X_TCON, 0x02<<24);
+	SYSREG_OR_SET	(S3C44B0X_TCON, 0x05<<24);
+}
+
+
diff -Naur linux-2.6.9/arch/armnommu/mach-s5c7375/arch.c linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/arch.c
--- linux-2.6.9/arch/armnommu/mach-s5c7375/arch.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/arch.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,50 @@
+/*
+ *  linux/arch/arm/mach-s5c7375/arch.c
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS Co.,Ltd.
+ *			      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+
+extern void __init s5c7375_init_irq(void);
+
+MACHINE_START(S5C7375, "S5C7375, SAMSUNG ELECTRONICS Co., Ltd.")
+	MAINTAINER("Hyok S. Choi <hyok.choi@samsung.com>")
+	INITIRQ(s5c7375_init_irq)
+MACHINE_END
diff -Naur linux-2.6.9/arch/armnommu/mach-s5c7375/dma.c linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/dma.c
--- linux-2.6.9/arch/armnommu/mach-s5c7375/dma.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/dma.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,39 @@
+/*
+ * arch/arm/arch-s5c7375/dma-s5c7375.c
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS Co., Ltd. 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *     
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+
+void arch_dma_init(dma_t *dma)
+{
+}
diff -Naur linux-2.6.9/arch/armnommu/mach-s5c7375/entry-macro.S linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/entry-macro.S
--- linux-2.6.9/arch/armnommu/mach-s5c7375/entry-macro.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/entry-macro.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,57 @@
+/*
+ *  arch/armnommu/mach-s5c7375/entry-macro.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  Samsung Electronics Co.,Ltd.
+ *
+ *  defines machine dependent entry macros.
+ *  included in the arch/armnommu/kernel/entry.S
+ *  
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if defined(CONFIG_ARCH_S5C7375)
+                .macro  disable_fiq
+                .endm
+        #if 1   
+                        /* r0     r6      r5   lr */
+                .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+                ldr    \irqstat, =(rINTBase + 0x3C) @ rIRQISPR
+                ldr    \irqstat,   [\irqstat, #0]   @ load irqstat
+
+                mov    \irqnr, #0 
+1001:           
+                tst       \irqstat, #1
+                bne     1002f
+                add     \irqnr, \irqnr, #1
+                mov    \irqstat, \irqstat, lsr #1
+                cmp    \irqnr, #NR_IRQS 
+                bcc     1001b
+1002:           /* EQ will be set if we reach 32 */
+                .endm   
+                
+        #else     /* for better performance */ 
+                
+                        /* r0     r6      r5   lr */
+                .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+                ldr      \irqstat, =(rINTBase + 0x78) @ rIVEC_ADDR
+                ldr    \irqnr,   [\irqstat]             @ load irqnr * 4
+                mov     \irqnr, \irqnr, lsr #2          @ irqnr >> 2
+                movs   \tmp,  \irqnr
+                .endm
+        #endif
+                .macro  irq_prio_table
+                .endm
+#endif
diff -Naur linux-2.6.9/arch/armnommu/mach-s5c7375/head.S linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/head.S
--- linux-2.6.9/arch/armnommu/mach-s5c7375/head.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/head.S	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,155 @@
+/*
+ *  linux/arch/armnommu/mach-s5c7375/head.S
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *  <hyok.choi@samsung.com>
+ *
+ *  uClinux kernel startup code for s5c7375
+ *  which has no proper bootloader for linux startup
+ *  because of XIP.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+/*
+ * ARM920T need MMU enable for D-cache.
+ * we just make the identical table before the MMU enabling.
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	/* Write domain id (cp15_r3) */
+	mvn	r0, #0			/* Domains 0, 1 = client */
+	mcr	p15, 0, r0, c3, c0, 0	/* load domain access register */
+	/* Set control register v4 */
+
+	mov	r0, #0
+	mcr	p15, 0, r0, c13, c0, 0	/* zero PID */
+	mcr	p15, 0, r0, c7, c7, 0	/* invalidate I,D caches */
+	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
+	mcr	p15, 0, r0, c8, c7, 0	/* invalidate I,D TLBs */
+	mrc	p15, 0, r0, c1, c0, 0	/* get control register */
+	bic	r0, r0, #0x0001		/* disable MMU */
+	mcr	p15, 0, r0, c1, c0, 0	/* write control register */
+init_ttb:
+        ldr     r0,=0x00004000         @ set start of Translation Table base (16k Boundary)
+        mcr     p15, 0, r0, c2, c0, 0      @ write to CP15 register 2
+	/* 
+	 *
+	 * Create translation table for flat mapping
+	 * Top 12 bits of VA is pointer into table
+	 * Create 4096 entries from 000xxxxx to fffxxxxx
+	 *
+	 */
+	mov		r1, #0x1000
+	subs 	r1,r1,#1
+        mov     r2,#0b110000000000           @ set access permissions (AP) for full access SVC/USR (11:10)
+        orr     r2,r2,#0b000111100000       @ set for domain 15 (8:5)
+        orr     r2,r2,#0b000000010000       @ must be 1 (4)
+        orr     r2,r2,#0b000000000000       @ set non cachable non bufferable (CB) (3:2)
+        orr     r2,r2,#0b000000000010       @ set for 1Mb section (1:0)
+init_ttb_1:
+        orr     r3,r2,r1,lsl#20             @ use loop counter to create individual table entries
+        str     r3,[r0,r1,lsl#2]            @ str r3 at TTB base + loopcount*4
+        subs    r1,r1,#1                    @ decrement loop counter
+        bpl     init_ttb_1
+
+	/* resetting the SDRAM area to cacheable*/
+	mov	r1, #0x003				@ loop counter
+
+	mov     r2,#0b110000000000           @ set access permissions (AP) for full access SVC/USR (11:10)
+	orr     r2,r2,#0b000111100000       @ set for domain 15 (8:5)
+	orr     r2,r2,#0b000000010000       @ must be 1 (4)
+	orr     r2,r2,#0b000000001100       @ set cachable but unbufferable (CB) (3:2)
+	orr     r2,r2,#0b000000000010       @ set for 1Mb section (1:0)
+
+init_ttb_2:
+        orr     r3,r2,r1,lsl#20             @ use loop counter to create individual table entries
+	str     r3,[r0,r1,lsl#2]            @ str r3 at TTB base + loopcount*4
+	subs    r1,r1,#1                    @ decrement loop counter
+	bpl     init_ttb_2
+	@init_domains : we define all domains are manager. so no access permission check is occured.
+	mvn     r0, #0				@ trick. 0 -1 == 0xFFFFFFFF
+	mcr     p15, 0, r0, c3, c0, 0       @ write to CP15 register 5
+/*
+ * set global core configurations
+ */
+        mrc     p15, 0, r0, c1, c0, 0       @ read CP15 register 1 into r0
+        
+        orr     r0, r0, #(0x1 <<12)         @ enable I Cache
+        orr     r0, r0, #(0x1 <<2)          @ enable D Cache
+        orr     r0, r0, #(0b11 <<30)        @ enable asynchronous clocking mode
+        orr     r0, r0, #0x1                @ enable MMU
+
+        mcr     p15, 0, r0, c1, c0, 0       @ write cp15 register 1
+
+#endif
+
+/*
+ * stuffs for cache are done.
+ * Now we setup the stack and machine id, and start the kernel!
+ */
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r8, r9, sp}			@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+	ldr	r2, S5C7375_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, S5C7375_MACH_TYPE
+	str     r2, [r9]
+
+        mov fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start
+        .long	processor_id
+        .long	_end
+	.long   __machine_arch_type
+        .long	init_thread_union+8192
+	
+S5C7375_PROCESSOR_TYPE:
+	.long	0x41129200
+S5C7375_MACH_TYPE:
+	.long	MACH_TYPE_S5C7375
+
diff -Naur linux-2.6.9/arch/armnommu/mach-s5c7375/irq.c linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/irq.c
--- linux-2.6.9/arch/armnommu/mach-s5c7375/irq.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/irq.c	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,148 @@
+/*
+ *  linux/arch/armnommu/mach-s5c7375/irq.c
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *	      Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+
+void __inline__ s5c7375_mask_irq(unsigned int irq)
+{
+        rINTMSK |= ((unsigned long) 1 << irq);
+}
+
+void __inline__ s5c7375_unmask_irq(unsigned int irq)
+{
+        rINTMSK &= ~((unsigned long)1 << irq);
+}
+
+void __inline__ s5c7375_mask_ack_irq(unsigned int irq)
+{
+	s5c7375_mask_irq(irq);
+}
+
+void __inline__ s5c7375_clear_pb(unsigned int irq)
+{
+     rIRQISPC = (0x00000001<<irq);	/* Clear pending bit */
+     rIRQISPC;  /* WriteBack */
+}
+
+
+/* YOU CAN CHANGE THIS ROUTINE FOR SPEED UP */
+__inline__ unsigned int fixup_irq (int irq )
+{
+	s5c7375_clear_pb(irq);
+	return(irq);
+}
+
+static struct irqchip s5c7375_chip = {
+	.ack	= s5c7375_clear_pb,
+	.mask	= s5c7375_mask_irq,
+	.unmask = s5c7375_unmask_irq,
+};
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+	return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+	/* disable all irq sources */
+	return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+	set_kset_name("irq"),
+	.suspend	= irq_suspend,
+	.resume		= irq_resume,
+};
+
+static struct sys_device irq_device = {
+	.id	= 0,
+	.cls	= &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+	int ret = sysdev_class_register(&irq_class);
+	if (ret == 0)
+		ret = sysdev_register(&irq_device);
+	return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init s5c7375_init_irq(void)
+{
+        int irq;
+
+        /* Disable all IRQs */
+
+        rINTMSK = 0xffffffff; /* all masked */
+        /****************
+         * All IRQs are IRQ, not FIQ 
+         * Write only one register,
+         * 0 : IRQ mode
+         * 1 : FIQ mode
+         *******************************************/
+        rINTMOD = 0x00000000; 
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		set_irq_chip(irq, &s5c7375_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+	rINTCON = 0x0; // all interrupt is disabled
+//	rINTCON = 0xD; // vectored mode
+	DisableFIQ();	// fiq is disabled
+#ifndef CONFIG_S5C7375VM
+	EnableIRQ();		// irq is enabled
+#else
+	DisableIRQ();
+#endif
+	DisableGMask();	// global mask is disabled
+}
+
diff -Naur linux-2.6.9/arch/armnommu/mach-s5c7375/Kconfig linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/Kconfig
--- linux-2.6.9/arch/armnommu/mach-s5c7375/Kconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/Kconfig	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,3 @@
+menu "S5C7375 Options"
+	depends on ARCH_S5C7375
+endmenu
diff -Naur linux-2.6.9/arch/armnommu/mach-s5c7375/Makefile linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/Makefile
--- linux-2.6.9/arch/armnommu/mach-s5c7375/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/Makefile	2004-10-28 11:11:17.000000000 +1000
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		+= arch.o irq.o dma.o
diff -Naur linux-2.6.9/arch/armnommu/Makefile linux-2.6.9-uc0/arch/armnommu/Makefile
--- linux-2.6.9/arch/armnommu/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/Makefile	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,194 @@
+#
+# arch/armnommu/Makefile
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 2004 by Hyok S. Choi (for uClinux/ARM 2.6)
+# Copyright (C) 1995-2001 by Russell King
+
+LDFLAGS_vmlinux	:=-p -X
+LDFLAGS_BLOB	:=--format binary
+AFLAGS_vmlinux.lds.o = -DTEXTADDR=$(TEXTADDR) -DDATAADDR=$(DATAADDR)
+OBJCOPYFLAGS	:=-O binary -R .note -R .comment -S
+GZFLAGS		:=-9
+CFLAGS		+=-fno-builtin -D__linux__
+
+CFLAGS		:=$(CFLAGS:-O2=-Os)
+
+ifeq ($(CONFIG_FRAME_POINTER),y)
+CFLAGS		+=-fno-omit-frame-pointer -mapcs -mno-sched-prolog
+endif
+
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+CFLAGS		+= -mbig-endian
+AS		+= -EB
+LD		+= -EB
+AFLAGS		+= -mbig-endian
+else
+CFLAGS		+= -mlittle-endian
+AS		+= -EL
+LD		+= -EL
+AFLAGS		+= -mlittle-endian
+endif
+
+comma = ,
+
+# This selects which instruction set is used.
+# Note that GCC does not numerically define an architecture version
+# macro, but instead defines a whole series of macros which makes
+# testing for a specific architecture or later rather impossible.
+arch-$(CONFIG_CPU_32v6)		:=-D__LINUX_ARM_ARCH__=6 -march=armv5t -Wa,-march=armv6
+arch-$(CONFIG_CPU_32v5)		:=-D__LINUX_ARM_ARCH__=5 $(call check_gcc,-march=armv5te,-march=armv4)
+arch-$(CONFIG_CPU_32v4)		:=-D__LINUX_ARM_ARCH__=4 -march=armv4
+arch-$(CONFIG_CPU_32v3)		:=-D__LINUX_ARM_ARCH__=3 -march=armv3
+
+# This selects how we optimise for the processor.
+tune-$(CONFIG_CPU_ARM7V3)	:=-mtune=arm610
+tune-$(CONFIG_CPU_ARM610)	:=-mtune=arm610
+tune-$(CONFIG_CPU_ARM710)	:=-mtune=arm7tdmi
+tune-$(CONFIG_CPU_S3C4510B)	:=-mtune=arm7tdmi
+tune-$(CONFIG_CPU_ARM720T)	:=-mtune=arm7tdmi
+tune-$(CONFIG_CPU_ARM740T)	:=-mtune=arm7tdmi
+tune-$(CONFIG_CPU_ARM920T)	:=-mtune=arm9tdmi
+tune-$(CONFIG_CPU_ARM922T)	:=-mtune=arm9tdmi
+tune-$(CONFIG_CPU_ARM926T)	:=-mtune=arm9tdmi
+tune-$(CONFIG_CPU_ARM940T)	:=-mtune=arm9tdmi
+
+# Need -Uarm for gcc < 3.x
+CFLAGS_BOOT	:=-mapcs-32 $(arch-y) $(tune-y) -mshort-load-bytes -msoft-float -Wa,-mno-fpu -Uarm
+CFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -mshort-load-bytes -msoft-float -Wa,-mno-fpu -Uarm
+AFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -msoft-float -Wa,-mno-fpu
+
+# settings for endian
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+  LDFLAGS_BLOB  += --oformat elf32-bigarm
+else
+  LDFLAGS_BLOB  += --oformat elf32-littlearm
+endif
+
+# These are the default values for independt
+DATAADDR	:= .
+PROCESSOR	:= armv
+head-y		:= arch/armnommu/kernel/head.o 	# default head
+textaddr-y	:= 0x00008000			# default text address
+
+# setup the machine name and the machine dependent settings
+#   in alphabetical order.
+machine-$(CONFIG_ARCH_ATMEL)		:= atmel
+	textaddr-$(CONFIG_ARCH_ATMEL)		:= 0x01000000
+machine-$(CONFIG_ARCH_ESPD_4510B)	:= espd_4510b
+	textaddr-$(CONFIG_ARCH_ESPD_4510B)	:= 0x00008000
+machine-$(CONFIG_ARCH_S3C3410)		:= s3c3410
+	textaddr-$(CONFIG_ARCH_S3C3410)		:= 0x01020000
+machine-$(CONFIG_ARCH_S3C44B0)		:= s3c44b0x
+	textaddr-$(CONFIG_ARCH_S3C44B0)		:= 0x0c008000
+machine-$(CONFIG_ARCH_S5C7375) 		:= s5c7375
+	textaddr-$(CONFIG_ARCH_S5C7375) 	:= 0x00008000
+
+# set the environment variables and export
+MACHINE  := $(machine-y)
+TEXTADDR := $(textaddr-y)
+ifeq ($(incdir-y),)
+incdir-y := $(MACHINE)
+endif
+INCDIR   := $(incdir-y)
+  
+export	MACHINE PROCESSOR TEXTADDR GZFLAGS CFLAGS_BOOT
+
+# Does the machine has its own head.S ?
+HEADMACH 	:= arch/armnommu/mach-$(MACHINE)/head.S
+ifeq ($(HEADMACH), $(wildcard $(HEADMACH)))
+head-y		:= arch/armnommu/mach-$(MACHINE)/head.o
+HEADMACH	:= ../mach-$(MACHINE)/head.o
+else
+HEADMACH 	:=
+endif
+export HEADMACH
+
+# add the init_task to head
+head-y		+= arch/armnommu/kernel/init_task.o
+
+# Do we have FASTFPE?
+FASTFPE		:=arch/arm/fastfpe
+ifeq ($(FASTFPE),$(wildcard $(FASTFPE)))
+FASTFPE_OBJ	:=$(FASTFPE)/
+endif
+
+# If we have a machine-specific directory, then include it in the build.
+core-y				+= arch/armnommu/kernel/ arch/armnommu/mm/ arch/arm/common/
+ifneq ($(MACHINE),)
+core-y				+= arch/armnommu/mach-$(MACHINE)/
+endif
+core-$(CONFIG_FPE_NWFPE)	+= arch/arm/nwfpe/
+core-$(CONFIG_FPE_FASTFPE)	+= $(FASTFPE_OBJ)
+
+libs-y				+= arch/arm/lib/
+
+# Default target when executing plain make
+all: uCImage
+
+boot := arch/armnommu/boot
+
+#	Update machine arch and proc symlinks if something which affects
+#	them changed.  We use .arch and .proc to indicate when they were
+#	updated last, otherwise make uses the target directory mtime.
+
+include/asm-armnommu/.arch: $(wildcard include/config/arch/*.h)
+	@echo '  Making asm-armnommu/arch -> asm-armnommu/arch-$(INCDIR) symlink'
+	@rm -f include/asm-armnommu/arch
+	@ln -sf arch-$(INCDIR) include/asm-armnommu/arch
+	@touch $@
+
+prepare: maketools
+
+.PHONY: maketools FORCE
+maketools: include/asm-armnommu/.arch \
+	   include/asm-armnommu/constants.h include/linux/version.h FORCE
+	$(Q)$(MAKE) $(build)=arch/arm/tools include/asm-arm/mach-types.h
+
+# Convert bzImage to zImage
+bzImage: vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(boot)/zImage
+
+zImage Image bootpImage uImage: vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
+
+uCImage: vmlinux linux.bin
+
+linux.bin: vmlinux FORCE
+	@$(OBJCOPY) $(OBJCOPYFLAGS) vmlinux $@
+	@echo '  Kernel: $@ is ready'
+	
+zinstall install: vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $@
+
+CLEAN_FILES += include/asm-armnommu/constants.h* include/asm-arm/mach-types.h
+CLEAN_FILES += linux.bin linux arch/armnommu/kernel/entry-macro.S
+CLEAN_FILES += include/asm-armnommu/arch include/asm-armnommu/.arch
+
+# We use MRPROPER_FILES and CLEAN_FILES now
+archclean:
+	$(Q)$(MAKE) $(clean)=$(boot)
+
+# My testing targets (that short circuit a few dependencies)
+zImg:;	$(Q)$(MAKE) $(build)=$(boot) $(boot)/zImage
+Img:;	$(Q)$(MAKE) $(build)=$(boot) $(boot)/Image
+bp:;	$(Q)$(MAKE) $(build)=$(boot) $(boot)/bootpImage
+i:;	$(Q)$(MAKE) $(build)=$(boot) install
+zi:;	$(Q)$(MAKE) $(build)=$(boot) zinstall
+
+arch/$(ARCH)/kernel/asm-offsets.s: include/asm include/linux/version.h \
+				   include/asm-armnommu/.arch \
+				   include/config/MARKER
+
+include/asm-$(ARCH)/constants.h: arch/$(ARCH)/kernel/asm-offsets.s
+	$(call filechk,gen-asm-offsets)
+
+define archhelp
+  echo  '* zImage        - Compressed kernel image (arch/$(ARCH)/boot/zImage)'
+  echo  '  Image         - Uncompressed kernel image (arch/$(ARCH)/boot/Image)'
+  echo  '  uCImage	 - Uncompressed kernel and the stripped binary (linux.bin)'
+  echo  '  bootpImage    - Combined zImage and initial RAM disk' 
+endef
diff -Naur linux-2.6.9/arch/armnommu/mm/extable.c linux-2.6.9-uc0/arch/armnommu/mm/extable.c
--- linux-2.6.9/arch/armnommu/mm/extable.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/extable.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,16 @@
+/*
+ *  linux/arch/armnommu/mm/extable.c
+ */
+#include <linux/module.h>
+#include <asm/uaccess.h>
+
+int fixup_exception(struct pt_regs *regs)
+{
+	const struct exception_table_entry *fixup;
+
+	fixup = search_exception_tables(instruction_pointer(regs));
+	if (fixup)
+		regs->ARM_pc = fixup->fixup;
+
+	return fixup != NULL;
+}
diff -Naur linux-2.6.9/arch/armnommu/mm/fault.c linux-2.6.9-uc0/arch/armnommu/mm/fault.c
--- linux-2.6.9/arch/armnommu/mm/fault.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/fault.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,131 @@
+/*
+ *  linux/arch/armnommu/mm/fault.c
+ *
+ *  Copyright (C) 1995  Linus Torvalds
+ *  Modifications for ARM processor (c) 1995-2002 Russell King
+ *  Modifications for nommu or non-paged, Hyok S. Choi, 2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mm.h>
+#include <linux/bitops.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/pgalloc.h>
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
+
+#include "fault.h"
+
+/*
+ * Some section permission faults need to be handled gracefully.
+ * They can happen due to a __{get,put}_user during an oops.
+ */
+static int
+do_sect_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
+{
+	struct task_struct *tsk = current;
+	do_bad_area(tsk, tsk->active_mm, addr, fsr, regs);
+	return 0;
+}
+
+/*
+ * This abort handler always returns "fault".
+ */
+static int
+do_bad(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
+{
+	return 1;
+}
+
+static struct fsr_info {
+	int	(*fn)(unsigned long addr, unsigned int fsr, struct pt_regs *regs);
+	int	sig;
+	const char *name;
+} fsr_info[] = {
+	/*
+	 * The following are the standard ARMv3 and ARMv4 aborts.  ARMv5
+	 * defines these to be "precise" aborts.
+	 */
+	{ do_bad,		SIGSEGV, "vector exception"		   },
+	{ do_bad,		SIGILL,	 "alignment exception"		   },
+	{ do_bad,		SIGKILL, "terminal exception"		   },
+	{ do_bad,		SIGILL,	 "alignment exception"		   },
+	{ do_bad,		SIGBUS,	 "external abort on linefetch"	   },
+	{ do_translation_fault,	SIGSEGV, "section translation fault"	   },
+	{ do_bad,		SIGBUS,	 "external abort on linefetch"	   },
+	{ do_page_fault,	SIGSEGV, "page translation fault"	   },
+	{ do_bad,		SIGBUS,	 "external abort on non-linefetch" },
+	{ do_bad,		SIGSEGV, "section domain fault"		   },
+	{ do_bad,		SIGBUS,	 "external abort on non-linefetch" },
+	{ do_bad,		SIGSEGV, "page domain fault"		   },
+	{ do_bad,		SIGBUS,	 "external abort on translation"   },
+	{ do_sect_fault,	SIGSEGV, "section permission fault"	   },
+	{ do_bad,		SIGBUS,	 "external abort on translation"   },
+	{ do_page_fault,	SIGSEGV, "page permission fault"	   },
+	/*
+	 * The following are "imprecise" aborts, which are signalled by bit
+	 * 10 of the FSR, and may not be recoverable.  These are only
+	 * supported if the CPU abort handler supports bit 10.
+	 */
+	{ do_bad,		SIGBUS,  "unknown 16"			   },
+	{ do_bad,		SIGBUS,  "unknown 17"			   },
+	{ do_bad,		SIGBUS,  "unknown 18"			   },
+	{ do_bad,		SIGBUS,  "unknown 19"			   },
+	{ do_bad,		SIGBUS,  "lock abort"			   }, /* xscale */
+	{ do_bad,		SIGBUS,  "unknown 21"			   },
+	{ do_bad,		SIGBUS,  "imprecise external abort"	   }, /* xscale */
+	{ do_bad,		SIGBUS,  "unknown 23"			   },
+	{ do_bad,		SIGBUS,  "dcache parity error"		   }, /* xscale */
+	{ do_bad,		SIGBUS,  "unknown 25"			   },
+	{ do_bad,		SIGBUS,  "unknown 26"			   },
+	{ do_bad,		SIGBUS,  "unknown 27"			   },
+	{ do_bad,		SIGBUS,  "unknown 28"			   },
+	{ do_bad,		SIGBUS,  "unknown 29"			   },
+	{ do_bad,		SIGBUS,  "unknown 30"			   },
+	{ do_bad,		SIGBUS,  "unknown 31"			   }
+};
+
+void __init
+hook_fault_code(int nr, int (*fn)(unsigned long, unsigned int, struct pt_regs *),
+		int sig, const char *name)
+{
+	if (nr >= 0 && nr < ARRAY_SIZE(fsr_info)) {
+		fsr_info[nr].fn   = fn;
+		fsr_info[nr].sig  = sig;
+		fsr_info[nr].name = name;
+	}
+}
+
+/*
+ * Dispatch a data abort to the relevant handler.
+ */
+asmlinkage void
+do_DataAbort(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
+{
+	const struct fsr_info *inf = fsr_info + (fsr & 15) + ((fsr & (1 << 10)) >> 6);
+
+	if (!inf->fn(addr, fsr, regs))
+		return;
+
+	printk(KERN_ALERT "Unhandled fault: %s (0x%03x) at 0x%08lx\n",
+		inf->name, fsr, addr);
+	force_sig(inf->sig, current);
+	die_if_kernel("Oops", regs, 0);
+}
+
+asmlinkage void
+do_PrefetchAbort(unsigned long addr, struct pt_regs *regs)
+{
+	do_translation_fault(addr, 0, regs);
+}
+
diff -Naur linux-2.6.9/arch/armnommu/mm/fault-common.c linux-2.6.9-uc0/arch/armnommu/mm/fault-common.c
--- linux-2.6.9/arch/armnommu/mm/fault-common.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/fault-common.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,114 @@
+/*
+ *  linux/arch/armnommu/mm/fault-common.c
+ *
+ *  Copyright (C) 1995  Linus Torvalds
+ *  Modifications for ARM processor (c) 1995-2001 Russell King
+ *  Modifications for nommu or non-paged, Hyok S. Choi, 2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
+#include <asm/uaccess.h>
+
+#include "fault.h"
+
+/*
+ * "code" is actually the FSR register.  Bit 11 set means the
+ * instruction was performing a write.
+ */
+#define DO_COW(code)		((code) & (1 << 11))
+#define READ_FAULT(code)	(!DO_COW(code))
+
+/*
+ * Oops.  The kernel tried to access some page that wasn't present.
+ */
+static void
+__do_kernel_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,
+		  struct pt_regs *regs)
+{
+	/*
+	 * Are we prepared to handle this kernel fault?
+	 */
+	if (fixup_exception(regs))
+		return;
+
+	/*
+	 * No handler, we'll have to terminate things with extreme prejudice.
+	 */
+	bust_spinlocks(1);
+	printk(KERN_ALERT
+		"Unable to handle kernel %s at virtual address %08lx\n",
+		(addr < PAGE_SIZE) ? "NULL pointer dereference" :
+		"paging request", addr);
+
+	die("Oops", regs, fsr);
+	bust_spinlocks(0);
+	do_exit(SIGKILL);
+}
+
+/*
+ * Something tried to access memory that isn't in our memory map..
+ * User mode accesses just cause a SIGSEGV
+ */
+static void
+__do_user_fault(struct task_struct *tsk, unsigned long addr,
+		unsigned int fsr, int code, struct pt_regs *regs)
+{
+	struct siginfo si;
+
+#ifdef CONFIG_DEBUG_USER
+	printk(KERN_DEBUG "%s: unhandled page fault at 0x%08lx, code 0x%03x\n",
+	       tsk->comm, addr, fsr);
+	show_regs(regs);
+#endif
+
+	tsk->thread.address = addr;
+	tsk->thread.error_code = fsr;
+	tsk->thread.trap_no = 14;
+	si.si_signo = SIGSEGV;
+	si.si_errno = 0;
+	si.si_code = code;
+	si.si_addr = (void *)addr;
+	force_sig_info(SIGSEGV, &si, tsk);
+}
+
+void
+do_bad_area(struct task_struct *tsk, struct mm_struct *mm, unsigned long addr,
+	    unsigned int fsr, struct pt_regs *regs)
+{
+	/*
+	 * If we are in kernel mode at this point, we
+	 * have no context to handle this fault with.
+	 */
+	if (user_mode(regs))
+		__do_user_fault(tsk, addr, fsr, SEGV_MAPERR, regs);
+	else
+		__do_kernel_fault(mm, addr, fsr, regs);
+}
+
+int do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
+{
+	printk("do_page_fault? : %s %d\n",__FILE__,__LINE__);
+	return 0;
+}
+
+int do_translation_fault(unsigned long addr, unsigned int fsr,
+			 struct pt_regs *regs)
+{
+	printk("do_translation_fault? : %s %d\n",__FILE__,__LINE__);
+	return 0;
+}
diff -Naur linux-2.6.9/arch/armnommu/mm/fault.h linux-2.6.9-uc0/arch/armnommu/mm/fault.h
--- linux-2.6.9/arch/armnommu/mm/fault.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/fault.h	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,8 @@
+void do_bad_area(struct task_struct *tsk, struct mm_struct *mm,
+		 unsigned long addr, unsigned int fsr, struct pt_regs *regs);
+
+int do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs);
+
+int do_translation_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs);
+
+unsigned long search_exception_table(unsigned long addr);
diff -Naur linux-2.6.9/arch/armnommu/mm/init.c linux-2.6.9-uc0/arch/armnommu/mm/init.c
--- linux-2.6.9/arch/armnommu/mm/init.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/init.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,615 @@
+/*
+ *  linux/arch/armnommu/mm/init.c
+ *
+ *  Copyright (C) 1995-2002 Russell King
+ *  for uClinux, 2003,  Hyok S. Choi <hyok.choi@samsung.com>
+ *    machine dependent bootmem and initmem reserve/free
+ *    codes are gone to hardware.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/signal.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+#include <linux/initrd.h>
+
+#include <asm/segment.h>
+#include <asm/mach-types.h>
+#include <asm/pgalloc.h>
+#include <asm/dma.h>
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/tlb.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+extern char _stext, _text, _etext, _end, __init_begin, __init_end;
+extern unsigned long phys_initrd_start;
+extern unsigned long phys_initrd_size;
+
+/*
+ * The sole use of this is to pass memory configuration
+ * data from paging_init to mem_init.
+ */
+static struct meminfo meminfo __initdata = { 0, };
+
+/*
+ * empty_zero_page is a special page that is used for
+ * zero-initialized data and COW.
+ */
+struct page *empty_zero_page;
+
+void show_mem(void)
+{
+	int free = 0, total = 0, reserved = 0;
+	int shared = 0, cached = 0, slab = 0, node;
+
+	printk("Mem-info:\n");
+	show_free_areas();
+	printk("Free swap:       %6dkB\n",nr_swap_pages<<(PAGE_SHIFT-10));
+
+	for (node = 0; node < numnodes; node++) {
+		struct page *page, *end;
+
+		page = NODE_MEM_MAP(node);
+		end  = page + NODE_DATA(node)->node_spanned_pages;
+
+		do {
+			total++;
+			if (PageReserved(page))
+				reserved++;
+			else if (PageSwapCache(page))
+				cached++;
+			else if (PageSlab(page))
+				slab++;
+			else if (!page_count(page))
+				free++;
+			else
+				shared += page_count(page) - 1;
+			page++;
+		} while (page < end);
+	}
+
+	printk("%d pages of RAM\n", total);
+	printk("%d free pages\n", free);
+	printk("%d reserved pages\n", reserved);
+	printk("%d slab pages\n", slab);
+	printk("%d pages shared\n", shared);
+	printk("%d pages swap cached\n", cached);
+}
+
+struct node_info {
+	unsigned int start;
+	unsigned int end;
+	int bootmap_pages;
+};
+
+#define O_PFN_DOWN(x)	((x) >> PAGE_SHIFT)
+#define V_PFN_DOWN(x)	O_PFN_DOWN(__pa(x))
+
+#define O_PFN_UP(x)	(PAGE_ALIGN(x) >> PAGE_SHIFT)
+#define V_PFN_UP(x)	O_PFN_UP(__pa(x))
+
+#define PFN_SIZE(x)	((x) >> PAGE_SHIFT)
+#define PFN_RANGE(s,e)	PFN_SIZE(PAGE_ALIGN((unsigned long)(e)) - \
+				(((unsigned long)(s)) & PAGE_MASK))
+
+/*
+ * FIXME: We really want to avoid allocating the bootmap bitmap
+ * over the top of the initrd.  Hopefully, this is located towards
+ * the start of a bank, so if we allocate the bootmap bitmap at
+ * the end, we won't clash.
+ */
+static unsigned int __init
+find_bootmap_pfn(int node, struct meminfo *mi, unsigned int bootmap_pages)
+{
+	unsigned int start_pfn, bank, bootmap_pfn;
+
+	start_pfn   = V_PFN_UP(&_end);
+	bootmap_pfn = 0;
+
+	for (bank = 0; bank < mi->nr_banks; bank ++) {
+		unsigned int start, end;
+
+		if (mi->bank[bank].node != node)
+			continue;
+
+		start = O_PFN_UP(mi->bank[bank].start);
+		end   = O_PFN_DOWN(mi->bank[bank].size +
+				   mi->bank[bank].start);
+
+		if (end < start_pfn)
+			continue;
+
+		if (start < start_pfn)
+			start = start_pfn;
+
+		if (end <= start)
+			continue;
+
+		if (end - start >= bootmap_pages) {
+			bootmap_pfn = start;
+			break;
+		}
+	}
+
+	if (bootmap_pfn == 0)
+		BUG();
+
+	return bootmap_pfn;
+}
+
+/*
+ * Scan the memory info structure and pull out:
+ *  - the end of memory
+ *  - the number of nodes
+ *  - the pfn range of each node
+ *  - the number of bootmem bitmap pages
+ */
+static unsigned int __init
+find_memend_and_nodes(struct meminfo *mi, struct node_info *np)
+{
+	unsigned int i, bootmem_pages = 0, memend_pfn = 0;
+
+	for (i = 0; i < MAX_NUMNODES; i++) {
+		np[i].start = -1U;
+		np[i].end = 0;
+		np[i].bootmap_pages = 0;
+	}
+
+	for (i = 0; i < mi->nr_banks; i++) {
+		unsigned long start, end;
+		int node;
+
+		if (mi->bank[i].size == 0) {
+			/*
+			 * Mark this bank with an invalid node number
+			 */
+			mi->bank[i].node = -1;
+			continue;
+		}
+
+		node = mi->bank[i].node;
+
+		if (node >= numnodes) {
+			numnodes = node + 1;
+
+			/*
+			 * Make sure we haven't exceeded the maximum number
+			 * of nodes that we have in this configuration.  If
+			 * we have, we're in trouble.  (maybe we ought to
+			 * limit, instead of bugging?)
+			 */
+			if (numnodes > MAX_NUMNODES)
+				BUG();
+		}
+
+		/*
+		 * Get the start and end pfns for this bank
+		 */
+		start = O_PFN_UP(mi->bank[i].start);
+		end   = O_PFN_DOWN(mi->bank[i].start + mi->bank[i].size);
+
+		if (np[node].start > start)
+			np[node].start = start;
+
+		if (np[node].end < end)
+			np[node].end = end;
+
+		if (memend_pfn < end)
+			memend_pfn = end;
+	}
+
+	/*
+	 * Calculate the number of pages we require to
+	 * store the bootmem bitmaps.
+	 */
+	for (i = 0; i < numnodes; i++) {
+		if (np[i].end == 0)
+			continue;
+
+		np[i].bootmap_pages = bootmem_bootmap_pages(np[i].end -
+							    np[i].start);
+		bootmem_pages += np[i].bootmap_pages;
+	}
+
+	high_memory = __va(memend_pfn << PAGE_SHIFT);
+
+	/*
+	 * This doesn't seem to be used by the Linux memory
+	 * manager any more.  If we can get rid of it, we
+	 * also get rid of some of the stuff above as well.
+	 */
+	max_low_pfn = memend_pfn - O_PFN_DOWN(PHYS_OFFSET);
+	max_pfn = memend_pfn - O_PFN_DOWN(PHYS_OFFSET);
+
+	return bootmem_pages;
+}
+
+static int __init check_initrd(struct meminfo *mi)
+{
+	int initrd_node = -2;
+#ifdef CONFIG_BLK_DEV_INITRD
+	unsigned long end = phys_initrd_start + phys_initrd_size;
+
+	/*
+	 * Make sure that the initrd is within a valid area of
+	 * memory.
+	 */
+	if (phys_initrd_size) {
+		unsigned int i;
+
+		initrd_node = -1;
+
+		for (i = 0; i < mi->nr_banks; i++) {
+			unsigned long bank_end;
+
+			bank_end = mi->bank[i].start + mi->bank[i].size;
+
+			if (mi->bank[i].start <= phys_initrd_start &&
+			    end <= bank_end)
+				initrd_node = mi->bank[i].node;
+		}
+	}
+
+	if (initrd_node == -1) {
+		printk(KERN_ERR "initrd (0x%08lx - 0x%08lx) extends beyond "
+		       "physical memory - disabling initrd\n",
+		       phys_initrd_start, end);
+		phys_initrd_start = phys_initrd_size = 0;
+	}
+#endif
+
+	return initrd_node;
+}
+
+/*
+ * Reserve the various regions of node 0
+ */
+static __init void reserve_node_zero(unsigned int bootmap_pfn, unsigned int bootmap_pages)
+{
+	pg_data_t *pgdat = NODE_DATA(0);
+
+	/*
+	 * Register the kernel text and data with bootmem.
+	 * Note that this can only be in node 0.
+	 */
+	reserve_bootmem_node(pgdat, __pa(&_stext), &_end - &_stext);
+
+#if defined (PA_SDRAM_BASE) && !defined(CONFIG_MMU)
+	/*
+	 * Register the exception vector page.
+	 * some architectures which the DRAM is the exception vector to trap,
+	 * alloc_page breaks with error, although it is not NULL, but "0."
+	 */
+	reserve_bootmem_node(pgdat, PA_SDRAM_BASE, PAGE_SIZE);
+#endif
+
+	/*
+	 * And don't forget to reserve the allocator bitmap,
+	 * which will be freed later.
+	 */
+	reserve_bootmem_node(pgdat, bootmap_pfn << PAGE_SHIFT,
+			     bootmap_pages << PAGE_SHIFT);
+
+	/*
+	 * the machine/platform dependent bootmem reserve codes
+	 * define it in include/asm-armnommu/arch/hardware.h
+	 */
+	MACH_RESERVE_BOOTMEM();
+
+}
+
+/*
+ * Register all available RAM in this node with the bootmem allocator.
+ */
+static inline void free_bootmem_node_bank(int node, struct meminfo *mi)
+{
+	pg_data_t *pgdat = NODE_DATA(node);
+	int bank;
+
+	for (bank = 0; bank < mi->nr_banks; bank++)
+		if (mi->bank[bank].node == node)
+			free_bootmem_node(pgdat, mi->bank[bank].start,
+					  mi->bank[bank].size);
+}
+
+/*
+ * Initialise the bootmem allocator for all nodes.  This is called
+ * early during the architecture specific initialisation.
+ */
+void __init bootmem_init(struct meminfo *mi)
+{
+	struct node_info node_info[MAX_NUMNODES], *np = node_info;
+	unsigned int bootmap_pages, bootmap_pfn, map_pg;
+	int node, initrd_node;
+
+	bootmap_pages = find_memend_and_nodes(mi, np);
+	bootmap_pfn   = find_bootmap_pfn(0, mi, bootmap_pages);
+	initrd_node   = check_initrd(mi);
+
+	map_pg = bootmap_pfn;
+
+	/*
+	 * Initialise the bootmem nodes.
+	 *
+	 * What we really want to do is:
+	 *
+	 *   unmap_all_regions_except_kernel();
+	 *   for_each_node_in_reverse_order(node) {
+	 *     map_node(node);
+	 *     allocate_bootmem_map(node);
+	 *     init_bootmem_node(node);
+	 *     free_bootmem_node(node);
+	 *   }
+	 *
+	 * but this is a 2.5-type change.  For now, we just set
+	 * the nodes up in reverse order.
+	 *
+	 * (we could also do with rolling bootmem_init and paging_init
+	 * into one generic "memory_init" type function).
+	 */
+	np += numnodes - 1;
+	for (node = numnodes - 1; node >= 0; node--, np--) {
+		/*
+		 * If there are no pages in this node, ignore it.
+		 * Note that node 0 must always have some pages.
+		 */
+		if (np->end == 0) {
+			if (node == 0)
+				BUG();
+			continue;
+		}
+
+		/*
+		 * Initialise the bootmem allocator.
+		 */
+		init_bootmem_node(NODE_DATA(node), map_pg, np->start, np->end);
+		free_bootmem_node_bank(node, mi);
+		map_pg += np->bootmap_pages;
+
+		/*
+		 * If this is node 0, we need to reserve some areas ASAP -
+		 * we may use bootmem on node 0 to setup the other nodes.
+		 */
+		if (node == 0)
+			reserve_node_zero(bootmap_pfn, bootmap_pages);
+	}
+
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (phys_initrd_size && initrd_node >= 0) {
+		reserve_bootmem_node(NODE_DATA(initrd_node), phys_initrd_start,
+				     phys_initrd_size);
+		initrd_start = __phys_to_virt(phys_initrd_start);
+		initrd_end = initrd_start + phys_initrd_size;
+	}
+#endif
+
+	if (map_pg != bootmap_pfn + bootmap_pages)
+		BUG();
+
+}
+
+/*
+ * paging_init() sets up the page tables, initialises the zone memory
+ * maps, and sets up the zero page, bad page and bad page tables.
+ */
+void __init paging_init(struct meminfo *mi, struct machine_desc *mdesc)
+{
+	void *zero_page;
+	memcpy(&meminfo, mi, sizeof(meminfo));
+
+	/*
+	 * allocate the zero page.  Note that we count on this going ok.
+	 */
+#if defined (PA_SDRAM_BASE) && !defined(CONFIG_MMU)
+	/*
+	 * hyok: some architecture has 0 based SDRAM memory map.
+	 *       we should check if the ptr was not "NULL" but the exact address "0".
+	 *       for that, we do that in reserve_node_zero.
+	 */
+	zero_page = (void *)PA_SDRAM_BASE;
+#else
+	zero_page = alloc_bootmem_low_pages(PAGE_SIZE);
+#endif
+
+	{
+	  unsigned long zone_size[MAX_NR_ZONES] = {0,0,0};
+	  void *zero_page;
+	  int node;
+	  
+	  zone_size[ZONE_DMA] = 0;
+	  zone_size[ZONE_NORMAL] = (END_MEM - PAGE_OFFSET) >> PAGE_SHIFT;
+#ifdef CONFIG_HIGHMEM
+	  zone_size[ZONE_HIGHMEM] = 0;
+#endif
+#ifndef CONFIG_DISCONTIGMEM
+	  free_area_init(zone_size);
+#else
+	  for (node = 0; node < numnodes; node++) {
+	    unsigned long zone_size[MAX_NR_ZONES];
+	    unsigned long zhole_size[MAX_NR_ZONES];
+	    struct bootmem_data *bdata;
+	    pg_data_t *pgdat;
+	    int i;
+	    
+	    /*
+	     * Initialise the zone size information.
+	     */
+	    for (i = 0; i < MAX_NR_ZONES; i++) {
+	      zone_size[i]  = 0;
+	      zhole_size[i] = 0;
+	    }
+	    
+	    pgdat = NODE_DATA(node);
+	    bdata = pgdat->bdata;
+	    
+	    /*
+	     * The size of this node has already been determined.
+	     * If we need to do anything fancy with the allocation
+	     * of this memory to the zones, now is the time to do
+	     * it.
+	     */
+	    zone_size[0] = bdata->node_low_pfn -
+	      (bdata->node_boot_start >> PAGE_SHIFT);
+	    
+	    /*
+	     * If this zone has zero size, skip it.
+	     */
+	    if (!zone_size[0])
+	      continue;
+	    
+	    /*
+	     * For each bank in this node, calculate the size of the
+	     * holes.  holes = node_size - sum(bank_sizes_in_node)
+	     */
+	    zhole_size[0] = zone_size[0];
+	    for (i = 0; i < mi->nr_banks; i++) {
+	      if (mi->bank[i].node != node)
+		continue;
+	      
+	      zhole_size[0] -= mi->bank[i].size >> PAGE_SHIFT;
+	    }
+	    
+	    /*
+	     * Adjust the sizes according to any special
+	     * requirements for this machine type.
+	     */
+	    arch_adjust_zones(node, zone_size, zhole_size);
+	    
+	    free_area_init_node(node, pgdat, 0, zone_size,
+				bdata->node_boot_start >> PAGE_SHIFT, zhole_size);
+	  }
+#endif
+	}
+
+}
+
+static inline void free_area(unsigned long addr, unsigned long end, char *s)
+{
+	unsigned int size = (end - addr) >> 10;
+
+	for (; addr < end; addr += PAGE_SIZE) {
+		struct page *page = virt_to_page(addr);
+		ClearPageReserved(page);
+		set_page_count(page, 1);
+		free_page(addr);
+		totalram_pages++;
+	}
+
+	if (size && s)
+		printk(KERN_INFO "Freeing %s memory: %dK\n", s, size);
+}
+
+/*
+ * mem_init() marks the free areas in the mem_map and tells us how much
+ * memory is free.  This is done after various parts of the system have
+ * claimed their memory after the kernel image.
+ */
+void __init mem_init(void)
+{
+	unsigned int codepages, datapages, initpages;
+	int i, node;
+
+	codepages = &_etext - &_text;
+	datapages = &_end - &_etext;
+	initpages = &__init_end - &__init_begin;
+
+#ifndef CONFIG_DISCONTIGMEM
+	max_mapnr   = virt_to_page(high_memory) - mem_map;
+#endif
+
+	/*
+	 * We may have non-contiguous memory.
+	 */
+	if (meminfo.nr_banks != 1)
+		create_memmap_holes(&meminfo);
+
+	/* this will put all unused low memory onto the freelists */
+	for (node = 0; node < numnodes; node++) {
+		pg_data_t *pgdat = NODE_DATA(node);
+
+		if (pgdat->node_spanned_pages != 0)
+			totalram_pages += free_all_bootmem_node(pgdat);
+	}
+
+	/*
+	 * the machine/platform dependent bootmem free code.
+	 * define it in include/asm-armnommu/arch/hardware.h
+	 */
+	MACH_FREE_BOOTMEM();
+
+	/*
+	 * Since our memory may not be contiguous, calculate the
+	 * real number of pages we have in this system
+	 */
+	printk(KERN_INFO "Memory:");
+
+	num_physpages = 0;
+	for (i = 0; i < meminfo.nr_banks; i++) {
+		num_physpages += meminfo.bank[i].size >> PAGE_SHIFT;
+		printk(" %ldMB", meminfo.bank[i].size >> 20);
+	}
+
+	printk(" = %luMB total\n", num_physpages >> (20 - PAGE_SHIFT));
+	printk(KERN_NOTICE "Memory: %luKB available (%dK code, "
+		"%dK data, %dK init)\n",
+		(unsigned long) nr_free_pages() << (PAGE_SHIFT-10),
+		codepages >> 10, datapages >> 10, initpages >> 10);
+
+	if (PAGE_SIZE >= 16384 && num_physpages <= 128) {
+		extern int sysctl_overcommit_memory;
+		/*
+		 * On a machine this small we won't get
+		 * anywhere without overcommit, so turn
+		 * it on by default.
+		 */
+		sysctl_overcommit_memory = 1;
+	}
+}
+
+void free_initmem(void)
+{
+	/*
+	 * machine depend decision, if initmem is safe to free.
+	 * it is defiened in hardware.h by default, true.
+	 */
+	if (DO_FREE_INITMEM()) {
+		free_area((unsigned long)(&__init_begin),
+			  (unsigned long)(&__init_end),
+			  "init");
+	}
+}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+
+static int keep_initrd;
+
+void free_initrd_mem(unsigned long start, unsigned long end)
+{
+	if (!keep_initrd)
+		free_area(start, end, "initrd");
+}
+
+static int __init keepinitrd_setup(char *__unused)
+{
+	keep_initrd = 1;
+	return 1;
+}
+
+__setup("keepinitrd", keepinitrd_setup);
+#endif
diff -Naur linux-2.6.9/arch/armnommu/mm/ioremap.c linux-2.6.9-uc0/arch/armnommu/mm/ioremap.c
--- linux-2.6.9/arch/armnommu/mm/ioremap.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/ioremap.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,32 @@
+/*
+ *  linux/arch/armnommu/mm/ioremap.c
+ *
+ * Re-map IO memory to kernel address space so that we can access it.
+ *
+ * (C) Copyright 1995 1996 Linus Torvalds
+ *
+ * Hacked for ARM by Phil Blundell <philb@gnu.org>
+ * Hacked to allow all architectures to build, and various cleanups
+ * by Russell King
+ * Hacked for uClinux/ARM by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include <asm/page.h>
+#include <asm/pgalloc.h>
+#include <asm/io.h>
+#include <asm/tlbflush.h>
+void *
+__ioremap(unsigned long phys_addr, size_t size, unsigned long flags,
+	  unsigned long align)
+{
+	return (void *) (phys_addr);
+}
+
+void __iounmap(void *addr)
+{
+}
diff -Naur linux-2.6.9/arch/armnommu/mm/Kconfig linux-2.6.9-uc0/arch/armnommu/mm/Kconfig
--- linux-2.6.9/arch/armnommu/mm/Kconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/Kconfig	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,324 @@
+comment "Processor Type"
+
+config CPU_32
+	bool
+	default y
+
+# Select CPU types depending on the architecture selected.  This selects
+# which CPUs we support in the kernel image, and the compiler instruction
+# optimiser behaviour.
+
+# ARM610
+config CPU_ARM610
+	bool "Support ARM610 processor"
+	depends on ARCH_RPC
+	select CPU_32v3
+	select CPU_CACHE_V3
+	help
+	  The ARM610 is the successor to the ARM3 processor
+	  and was produced by VLSI Technology Inc.
+
+	  Say Y if you want support for the ARM610 processor.
+	  Otherwise, say N.
+
+# ARM710
+config CPU_ARM710
+	bool "Support ARM710 processor" if !ARCH_S3C3410 && !ARCH_ATMEL && !ARCH_ESPD_4510B  && !ARCH_S3C44B0
+	default y if ARCH_S3C3410 || ARCH_ATMEL || ARCH_S3C44B0
+	select CPU_32v3
+	select CPU_CACHE_V3
+	help
+	  A 32-bit RISC microprocessor based on the ARM7 processor core
+	  designed by Advanced RISC Machines Ltd. The ARM710 is the
+	  successor to the ARM610 processor. It was released in
+	  July 1994 by VLSI Technology Inc.
+
+	  Say Y if you want support for the ARM710 processor.
+	  Otherwise, say N.
+
+# S3C4510B
+config CPU_S3C4510B
+	bool "Support S3C4510B/ARM7TDMI processor" if !ARCH_ESPD_4510B
+	default y if ARCH_ESPD_4510B
+	select CPU_32v4
+
+	help
+	  A Samsung 32-bit RISC microprocessor based on the ARM7TDMI processor 
+	  core designed by Advanced RISC Machines Ltd. 
+
+	  Say Y if you want support for the S3C4510B/ARM7TDMI processor.
+	  Otherwise, say N.
+
+# ARM720T
+config CPU_ARM720T
+	bool "Support ARM720T processor" if ARCH_INTEGRATOR
+	select CPU_32v4
+	select CPU_ABRT_LV4T
+	select CPU_CACHE_V4
+	help
+	  A 32-bit RISC processor with 8kByte Cache, Write Buffer and
+	  MMU built around an ARM7TDMI core.
+
+	  Say Y if you want support for the ARM720T processor.
+	  Otherwise, say N.
+
+# ARM740
+config CPU_ARM740
+	bool "Support ARM740 processor" if ARCH_INTEGRATOR
+	select CPU_32v4
+	select CPU_CACHE_V4
+	help
+	  A 32-bit RISC processor with 8KB cache or 4KB variants,
+	  write buffer and MPU(Protection Unit) built around
+	  an ARM7TDMI core.
+
+	  Say Y if you want support for the ARM740T process.
+	  Otherwise, say N.
+
+# ARM920T
+config CPU_ARM920T
+	bool "Support ARM920T processor"
+	depends on ARCH_INTEGRATOR || ARCH_S5C7375
+	select CPU_32v4
+	select CPU_ABRT_EV4T
+	select CPU_CACHE_V4WT
+	help
+	  The ARM920T is licensed to be produced by numerous vendors,
+	  and is used in the Maverick EP9312.  More information at
+	  <http://linuxdevices.com/products/PD2382866068.html>.
+
+	  Say Y if you want support for the ARM920T processor.
+	  Otherwise, say N.
+
+# ARM922T
+config CPU_ARM922T
+	bool
+	depends on ARCH_CAMELOT
+	default y
+	select CPU_32v4
+	select CPU_ABRT_EV4T
+	select CPU_CACHE_V4WT
+	help
+	  The ARM922T is a version of the ARM920T, but with smaller
+	  instruction and data caches. It is used in Altera's
+	  Excalibur XA device family.
+
+	  Say Y if you want support for the ARM922T processor.
+	  Otherwise, say N.
+
+# ARM925T
+config CPU_ARM925T
+ 	bool
+ 	depends on ARCH_OMAP1510
+ 	default y
+	select CPU_32v4
+	select CPU_ABRT_EV4T
+	select CPU_CACHE_V4WT
+ 	help
+ 	  The ARM925T is a mix between the ARM920T and ARM926T, but with
+	  different instruction and data caches. It is used in TI's OMAP
+ 	  device family.
+
+ 	  Say Y if you want support for the ARM925T processor.
+ 	  Otherwise, say N.
+
+# ARM926T
+config CPU_ARM926T
+	bool "Support ARM926T processor"
+	depends on ARCH_INTEGRATOR || ARCH_OMAP1610
+	select CPU_32v5
+	select CPU_ABRT_EV5TJ
+	help
+	  This is a variant of the ARM920.  It has slightly different
+	  instruction sequences for cache and TLB operations.  Curiously,
+	  there is no documentation on it at the ARM corporate website.
+
+	  Say Y if you want support for the ARM926T processor.
+	  Otherwise, say N.
+
+# ARM940T
+config CPU_ARM940T
+	bool "Support ARM940T processor"
+	depends on ARCH_S3C2500 || ARCH_S5H5002
+	select CPU_32v4
+	select CPU_ABRT_EV4T
+	select CPU_CACHE_V4WT
+	help
+	  This is ARM9TDMI based RISC processor with MPU. 
+	  It has 4kByte I-Cache and 4kByte D-Cache, Write Buffer.
+
+	  Say Y if you want support for the ARM940T processor.
+	  Otherwise, say N.
+
+# ARM946T
+config CPU_ARM946E
+	bool "Support ARM946E processor"
+	depends on ARCH_ST501X0
+	select CPU_32v5
+	select CPU_ABRT_EV5T
+	select CPU_CACHE_V4WT
+	help
+	  ARM946E-S is a synthesizable macrocell combining an ARM
+	  process. It is a member of the ARM9 Thumb family of
+	  high-performance, 32-bit system-on-chip processor solutions.
+	
+	  Say Y if you want support for the ARM946E-S processor.
+	  Otherwise, say N.
+
+# ARM1020 - needs validating
+config CPU_ARM1020
+	bool "Support ARM1020T (rev 0) processor"
+	depends on ARCH_INTEGRATOR
+	select CPU_32v5
+	select CPU_ABRT_EV4T
+	select CPU_CACHE_V4WT
+	help
+	  The ARM1020 is the 32K cached version of the ARM10 processor,
+	  with an addition of a floating-point unit.
+
+	  Say Y if you want support for the ARM1020 processor.
+	  Otherwise, say N.
+
+# ARM1020E - needs validating
+config CPU_ARM1020E
+	bool "Support ARM1020E processor"
+	depends on ARCH_INTEGRATOR
+	select CPU_32v5
+	select CPU_ABRT_EV4T
+	select CPU_CACHE_V4WT
+	depends on n
+
+# ARM1022E
+config CPU_ARM1022
+	bool "Support ARM1022E processor"
+	depends on ARCH_INTEGRATOR
+	select CPU_32v5
+	select CPU_ABRT_EV4T
+	help
+	  The ARM1022E is an implementation of the ARMv5TE architecture
+	  based upon the ARM10 integer core with a 16KiB L1 Harvard cache,
+	  embedded trace macrocell, and a floating-point unit.
+
+	  Say Y if you want support for the ARM1022E processor.
+	  Otherwise, say N.
+
+# ARM1026EJ-S
+config CPU_ARM1026
+	bool "Support ARM1026EJ-S processor"
+	depends on ARCH_INTEGRATOR
+	select CPU_32v5
+	select CPU_ABRT_EV5T # But need Jazelle, but EV5TJ ignores bit 10
+	help
+	  The ARM1026EJ-S is an implementation of the ARMv5TEJ architecture
+	  based upon the ARM10 integer core.
+
+	  Say Y if you want support for the ARM1026EJ-S processor.
+	  Otherwise, say N.
+
+# Figure out what processor architecture version we should be using.
+# This defines the compiler instruction set which depends on the machine type.
+config CPU_32v3
+	bool
+
+config CPU_32v4
+	bool
+
+config CPU_32v5
+	bool
+
+# The abort model
+config CPU_ABRT_EV4
+	bool
+
+config CPU_ABRT_EV4T
+	bool
+
+config CPU_ABRT_LV4T
+	bool
+
+config CPU_ABRT_EV5T
+	bool
+
+config CPU_ABRT_EV5TJ
+	bool
+
+# The cache model
+config CPU_CACHE_V3
+	bool
+
+config CPU_CACHE_V4
+	bool
+
+config CPU_CACHE_V4WT
+	bool
+
+config CPU_CACHE_V4WB
+	bool
+
+comment "Processor Features"
+
+config ARM_THUMB
+	bool "Support Thumb user binaries"
+	depends on CPU_ARM720T || CPU_ARM740T || CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM940T || CPU_ARM946E || CPU_ARM1020 || CPU_ARM1020E || CPU_ARM1022 || CPU_ARM1026
+	default y
+	help
+	  Say Y if you want to include kernel support for running user space
+	  Thumb binaries.
+
+	  The Thumb instruction set is a compressed form of the standard ARM
+	  instruction set resulting in smaller binaries at the expense of
+	  slightly less efficient code.
+
+	  If you don't know what this all is, saying Y is a safe choice.
+
+config CPU_BIG_ENDIAN
+	bool "Build big-endian kernel"
+	depends on ARCH_SUPPORTS_BIG_ENDIAN
+	default y if ARCH_S3C3410
+	help
+	  Say Y if you plan on running a kernel in big-endian mode.
+	  Note that your board must be properly built and your board
+	  port must properly enable any big-endian related features
+	  of your chipset/board/processor.
+
+#ifdef CONFIG_CPU_MXU_ENABLE
+config CPU_MXU_ENABLE
+	bool "Enable the MMU/MPU"
+	depends on CPU_ARM720T ||CPU_ARM740T || CPU_ARM920T || CPU_ARM922T ||  CPU_ARM925T || CPU_ARM926T || CPU_ARM940T || CPU_ARM946E || CPU_ARM1020
+	help
+	  Say Y here to enable the memory control unit like: MMU/MPU,
+	  on non-paged memory management mode.
+
+config CPU_ICACHE_DISABLE
+	bool "Disable I-Cache"
+	depends on CPU_ARM920T || CPU_ARM922T ||  CPU_ARM925T || CPU_ARM926T || CPU_ARM1020
+	help
+	  Say Y here to disable the processor instruction cache. Unless
+	  you have a reason not to or are unsure, say N.
+
+config CPU_DCACHE_DISABLE
+	bool "Disable D-Cache"
+	depends on CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM1020
+	help
+	  Say Y here to disable the processor data cache. Unless
+	  you have a reason not to or are unsure, say N.
+
+config CPU_DCACHE_WRITETHROUGH
+	bool "Force write through D-cache"
+	depends on (CPU_ARM920T || CPU_ARM922T ||  CPU_ARM925T || CPU_ARM926T || CPU_ARM1020) && !CPU_DISABLE_DCACHE
+	help
+	  Say Y here to use the data cache in writethough mode. Unless you
+	  specifically require this or are unsure, say N.
+
+config CPU_CACHE_ROUND_ROBIN
+	bool "Round robin I and D cache replacement algorithm"
+	depends on (CPU_ARM926T || CPU_ARM1020) && (!CPU_ICACHE_DISABLE || !CPU_DCACHE_DISABLE)
+	help
+	  Say Y here to use the predictable round-robin cache replacement
+	  policy.  Unless you specifically require this or are unsure, say N.
+
+config CPU_BPREDICT_DISABLE
+	bool "Disable branch prediction"
+	depends on CPU_ARM1020
+	help
+	  Say Y here to disable branch prediction.  If unsure, say N.
diff -Naur linux-2.6.9/arch/armnommu/mm/Makefile linux-2.6.9-uc0/arch/armnommu/mm/Makefile
--- linux-2.6.9/arch/armnommu/mm/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/Makefile	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,62 @@
+#
+# Makefile for the linux armnommu-specific parts of the memory manager.
+#
+
+obj-y				:= extable.o fault.o \
+				   fault-common.o init.o ioremap.o mm.o
+
+obj-$(CONFIG_MODULES)		+= proc-syms.o
+
+obj-$(CONFIG_ALIGNMENT_TRAP)	+= alignment.o
+
+abrt-$(CONFIG_CPU_ABRT_EV4)	:= abort-ev4
+abrt-$(CONFIG_CPU_ABRT_EV4T)	:= abort-ev4t
+abrt-$(CONFIG_CPU_ABRT_LV4T)	:= abort-lv4t
+abrt-$(CONFIG_CPU_ABRT_EV5T)	:= abort-ev5t
+abrt-$(CONFIG_CPU_ABRT_EV5TJ)	:= abort-ev5tj
+# test if the abort handler defined.
+ifneq ($(abrt-y),)
+obj-y				+= $(abrt-y).o
+endif
+
+ifneq ($(CONFIG_ARCH_S3C44B0),y) 
+cache-$(CONFIG_CPU_CACHE_V3)	:= cache-v3
+endif
+cache-$(CONFIG_CPU_CACHE_V4)	:= cache-v4
+cache-$(CONFIG_CPU_CACHE_V4WT)	:= cache-v4wt
+cache-$(CONFIG_CPU_CACHE_V4WB)	:= cache-v4wb
+# test if the cache handler defiend.
+ifneq ($(cache-y),)
+obj-y				+= $(cache-y).o
+endif
+
+obj-$(CONFIG_CPU_S3C4510B)	+= proc-s3c4510b.o
+obj-$(CONFIG_CPU_ARM610)	+= proc-arm6_7.o
+obj-$(CONFIG_CPU_ARM710)	+= proc-arm6_7.o
+obj-$(CONFIG_CPU_ARM720T)	+= proc-arm720.o
+obj-$(CONFIG_CPU_ARM740T)	+= proc-arm740.o
+obj-$(CONFIG_CPU_ARM920T)	+= proc-arm920.o
+obj-$(CONFIG_CPU_ARM922T)	+= proc-arm922.o
+obj-$(CONFIG_CPU_ARM925T)	+= proc-arm925.o
+obj-$(CONFIG_CPU_ARM926T)	+= proc-arm926.o
+obj-$(CONFIG_CPU_ARM940T)	+= proc-arm940.o
+obj-$(CONFIG_CPU_ARM946E)	+= proc-arm946.o
+obj-$(CONFIG_CPU_ARM1020)	+= proc-arm1020.o
+obj-$(CONFIG_CPU_ARM1020E)	+= proc-arm1020e.o
+obj-$(CONFIG_CPU_ARM1022)	+= proc-arm1022.o
+obj-$(CONFIG_CPU_ARM1026)	+= proc-arm1026.o
+
+# Spell out some dependencies that aren't automatically figured out
+ifneq ($(abrt-y),)
+$(obj)/$(abrt-y).o:		arch/arm/mm/$(abrt-y).S FORCE
+	$(call if_changed_dep,as_o_S) 
+endif
+ifneq ($(cache-y),)
+$(obj)/$(cache-y).o:		arch/arm/mm/$(cache-y).S FORCE
+	$(call if_changed_dep,as_o_S)
+endif
+$(obj)/alignment.o:		arch/arm/mm/alignment.c FORCE
+	$(call if_changed_dep,cc_o_c)
+$(obj)/discontig.o:		arch/arm/mm/discontig.c FORCE
+	$(call if_changed_dep,cc_o_c)
+
diff -Naur linux-2.6.9/arch/armnommu/mm/mm.c linux-2.6.9-uc0/arch/armnommu/mm/mm.c
--- linux-2.6.9/arch/armnommu/mm/mm.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/mm.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,112 @@
+/*
+ *  linux/arch/armnommu/mm/mm.c
+ *
+ *  Copyright (C) 1998-2002 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi for nommu
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Page table sludge for ARM v3 and v4 processor architectures.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+#include <linux/highmem.h>
+
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#include <asm/page.h>
+#include <asm/rmap.h>
+#include <asm/io.h>
+#include <asm/setup.h>
+#include <asm/tlbflush.h>
+
+#include <asm/mach/map.h>
+
+/*
+ * In order to soft-boot, we need to insert a 1:1 mapping in place of
+ * the user-mode pages.  This will then ensure that we have predictable
+ * results when turning the mmu off
+ */
+void setup_mm_for_reboot(char mode)
+{
+	printk("FIXME: setup_mm_for_reboot %s %i\n",__FILE__,__LINE__);
+
+}
+
+
+static inline void
+free_memmap(int node, unsigned long start_pfn, unsigned long end_pfn)
+{
+	struct page *start_pg, *end_pg;
+	unsigned long pg, pgend;
+
+	/*
+	 * Convert start_pfn/end_pfn to a struct page pointer.
+	 */
+	start_pg = pfn_to_page(start_pfn);
+	end_pg = pfn_to_page(end_pfn);
+
+	/*
+	 * Convert to physical addresses, and
+	 * round start upwards and end downwards.
+	 */
+	pg = PAGE_ALIGN(__pa(start_pg));
+	pgend = __pa(end_pg) & PAGE_MASK;
+
+	/*
+	 * If there are free pages between these,
+	 * free the section of the memmap array.
+	 */
+	if (pg < pgend)
+		free_bootmem_node(NODE_DATA(node), pg, pgend - pg);
+}
+
+static inline void free_unused_memmap_node(int node, struct meminfo *mi)
+{
+	unsigned long bank_start, prev_bank_end = 0;
+	unsigned int i;
+
+	/*
+	 * [FIXME] This relies on each bank being in address order.  This
+	 * may not be the case, especially if the user has provided the
+	 * information on the command line.
+	 */
+	for (i = 0; i < mi->nr_banks; i++) {
+		if (mi->bank[i].size == 0 || mi->bank[i].node != node)
+			continue;
+
+		bank_start = mi->bank[i].start >> PAGE_SHIFT;
+		if (bank_start < prev_bank_end) {
+			printk(KERN_ERR "MEM: unordered memory banks.  "
+				"Not freeing memmap.\n");
+			break;
+		}
+
+		/*
+		 * If we had a previous bank, and there is a space
+		 * between the current bank and the previous, free it.
+		 */
+		if (prev_bank_end && prev_bank_end != bank_start)
+			free_memmap(node, prev_bank_end, bank_start);
+
+		prev_bank_end = PAGE_ALIGN(mi->bank[i].start +
+					   mi->bank[i].size) >> PAGE_SHIFT;
+	}
+}
+
+/*
+ * The mem_map array can get very big.  Free
+ * the unused area of the memory map.
+ */
+void __init create_memmap_holes(struct meminfo *mi)
+{
+	int node;
+
+	for (node = 0; node < numnodes; node++)
+		free_unused_memmap_node(node, mi);
+}
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm1020e.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1020e.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm1020e.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1020e.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,467 @@
+/*
+ *  linux/arch/armnommu/mm/proc-arm1020e.S: MMU functions for ARM1020
+ *
+ *  Copyright (C) 2000 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * These are the low level assembler for performing cache
+ * functions on the arm1020e.
+ *
+ *  CONFIG_CPU_ARM1020_CPU_IDLE -> nohlt
+ */
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/hardware.h>
+
+/*
+ * This is the maximum size of an area which will be invalidated
+ * using the single invalidate entry instructions.  Anything larger
+ * than this, and we go for the whole cache.
+ *
+ * This value should be chosen such that we choose the cheapest
+ * alternative.
+ */
+#define MAX_AREA_SIZE	32768
+
+/*
+ * The size of one data cache line.
+ */
+#define CACHE_DLINESIZE	32
+
+/*
+ * The number of data cache segments.
+ */
+#define CACHE_DSEGMENTS	16
+
+/*
+ * The number of lines in a cache segment.
+ */
+#define CACHE_DENTRIES	64
+
+/*
+ * This is the size at which it becomes more efficient to
+ * clean the whole cache, rather than using the individual
+ * cache line maintainence instructions.
+ */
+#define CACHE_DLIMIT	32768
+
+	.text
+/*
+ * cpu_arm1020e_proc_init()
+ */
+ENTRY(cpu_arm1020e_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm1020e_proc_fin()
+ */
+ENTRY(cpu_arm1020e_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+	bl	arm1020e_flush_kern_cache_all
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000 		@ ...i............
+	bic	r0, r0, #0x000e 		@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm1020e_reset(loc)
+ *
+ * Perform a soft reset of the system.	Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+	.align	5
+ENTRY(cpu_arm1020e_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f 		@ ............wcam
+	bic	ip, ip, #0x1100 		@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * cpu_arm1020e_do_idle()
+ */
+	.align	5
+ENTRY(cpu_arm1020e_do_idle)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+	mov	pc, lr
+
+/* ================================= CACHE ================================ */
+
+	.align	5
+/*
+ *	flush_user_cache_all()
+ *
+ *	Invalidate all cache entries in a particular address
+ *	space.
+ */
+ENTRY(arm1020e_flush_user_cache_all)
+	/* FALLTHROUGH */
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(arm1020e_flush_kern_cache_all)
+	mov	r2, #VM_EXEC
+	mov	ip, #0
+__flush_whole_cache:
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	r1, #(CACHE_DSEGMENTS - 1) << 5	@ 16 segments
+1:	orr	r3, r1, #(CACHE_DENTRIES - 1) << 26 @ 64 entries
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean+invalidate D index
+	subs	r3, r3, #1 << 26
+	bcs	2b				@ entries 63 to 0
+	subs	r1, r1, #1 << 5
+	bcs	1b				@ segments 15 to 0
+#endif
+	tst	r2, #VM_EXEC
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Invalidate a range of cache entries in the specified
+ *	address space.
+ *
+ *	- start	- start address (inclusive)
+ *	- end	- end address (exclusive)
+ *	- flags	- vm_flags for this space
+ */
+ENTRY(arm1020e_flush_user_cache_range)
+	mov	ip, #0
+	sub	r3, r1, r0			@ calculate total size
+	cmp	r3, #CACHE_DLIMIT
+	bhs	__flush_whole_cache
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	tst	r2, #VM_EXEC
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm1020e_coherent_kern_range)
+	mov	ip, #0
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+#endif
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- page	- page aligned address
+ */
+ENTRY(arm1020e_flush_kern_dcache_page)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	add	r1, r0, #PAGE_SZ
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm1020e_dma_inv_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	tst	r0, #CACHE_DLINESIZE - 1
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
+1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm1020e_dma_clean_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm1020e_dma_flush_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+ENTRY(arm1020e_cache_fns)
+	.long	arm1020e_flush_kern_cache_all
+	.long	arm1020e_flush_user_cache_all
+	.long	arm1020e_flush_user_cache_range
+	.long	arm1020e_coherent_kern_range
+	.long	arm1020e_flush_kern_dcache_page
+	.long	arm1020e_dma_inv_range
+	.long	arm1020e_dma_clean_range
+	.long	arm1020e_dma_flush_range
+
+	.align	5
+ENTRY(cpu_arm1020e_dcache_clean_area)
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mov	ip, #0
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+#endif
+	mov	pc, lr
+
+/* =============================== PageTable ============================== */
+
+/*
+ * cpu_arm1020e_switch_mm(pgd)
+ *
+ * Set the translation base pointer to be as described by pgd.
+ *
+ * pgd: new page tables
+ */
+	.align	5
+ENTRY(cpu_arm1020e_switch_mm)
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mcr	p15, 0, r3, c7, c10, 4
+	mov	r1, #0xF			@ 16 segments
+1:	mov	r3, #0x3F			@ 64 entries
+2:	mov	ip, r3, LSL #26 		@ shift up entry
+	orr	ip, ip, r1, LSL #5		@ shift in/up index
+	mcr	p15, 0, ip, c7, c14, 2		@ Clean & Inval DCache entry
+	mov	ip, #0
+	subs	r3, r3, #1
+	cmp	r3, #0
+	bge	2b				@ entries 3F to 0
+	subs	r1, r1, #1
+	cmp	r1, #0
+	bge	1b				@ segments 15 to 0
+
+#endif
+	mov	r1, #0
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, r1, c7, c5, 0		@ invalidate I cache
+#endif
+	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
+	mov	pc, lr
+        
+
+	__INIT
+
+	.type	__arm1020e_setup, #function
+__arm1020e_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+	mrc	p15, 0, r0, c1, c0		@ get control register v4
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+	bic	r0, r0, #0x1e00 		@ i...??r.........
+	bic	r0, r0, #0x000e 		@ ............wca.
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+						@ ..........DP...M
+	orr	r0, r0, #0x0031			@ if we need MMU on for
+						@ d-cache, it would be
+#else						@ enabled.
+	orr	r0, r0, #0x0030
+#endif
+	orr	r0, r0, #0x0100 		@ .......S........
+
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	orr	r0, r0, #0x4000 		@ .R..............
+#endif
+#ifndef CONFIG_CPU_BPREDICT_DISABLE
+	orr	r0, r0, #0x0800 		@ ....Z...........
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	orr	r0, r0, #0x0004 		@ Enable D cache
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	orr	r0, r0, #0x1000 		@ I Cache on
+#endif
+	mov	pc, lr
+	.size	__arm1020e_setup, . - __arm1020e_setup
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm1020e_processor_functions, #object
+arm1020e_processor_functions:
+	.word	v4t_early_abort
+	.word	cpu_arm1020e_proc_init
+	.word	cpu_arm1020e_proc_fin
+	.word	cpu_arm1020e_reset
+	.word	cpu_arm1020e_do_idle
+	.word	cpu_arm1020e_dcache_clean_area
+	.word	cpu_arm1020e_switch_mm
+	.size	arm1020e_processor_functions, . - arm1020e_processor_functions
+
+	.section ".rodata"
+
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv5te"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v5"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm1020e_name, #object
+cpu_arm1020e_name:
+	.ascii	"ARM1020E"
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	.ascii	"i"
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	.ascii	"d"
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.ascii	"(wt)"
+#else
+	.ascii	"(wb)"
+#endif
+#endif
+#ifndef CONFIG_CPU_BPREDICT_DISABLE
+	.ascii	"B"
+#endif
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	.ascii	"RR"
+#endif
+	.ascii	"\0"
+	.size	cpu_arm1020e_name, . - cpu_arm1020e_name
+
+	.align
+
+	.section ".proc.info", #alloc, #execinstr
+
+	.type	__arm1020e_proc_info,#object
+__arm1020e_proc_info:
+	.long	0x4105a200			@ ARM 1020TE (Architecture v5TE)
+	.long	0xff0ffff0
+	.long	0x00000c12			@ mmuflags
+	b	__arm1020e_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
+	.long	cpu_arm1020e_name
+	.long	arm1020e_processor_functions
+	.long	arm1020e_cache_fns
+	.size	__arm1020e_proc_info, . - __arm1020e_proc_info
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm1020.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1020.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm1020.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1020.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,482 @@
+/*
+ *  linux/arch/armnommu/mm/proc-arm1020.S: MMU functions for ARM1020
+ *
+ *  Copyright (C) 2000 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * These are the low level assembler for performing cache
+ * functions on the arm1020.
+ *
+ *  CONFIG_CPU_ARM1020_CPU_IDLE -> nohlt
+ */
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/hardware.h>
+
+/*
+ * This is the maximum size of an area which will be invalidated
+ * using the single invalidate entry instructions.  Anything larger
+ * than this, and we go for the whole cache.
+ *
+ * This value should be chosen such that we choose the cheapest
+ * alternative.
+ */
+#define MAX_AREA_SIZE	32768
+
+/*
+ * The size of one data cache line.
+ */
+#define CACHE_DLINESIZE	32
+
+/*
+ * The number of data cache segments.
+ */
+#define CACHE_DSEGMENTS	16
+
+/*
+ * The number of lines in a cache segment.
+ */
+#define CACHE_DENTRIES	64
+
+/*
+ * This is the size at which it becomes more efficient to
+ * clean the whole cache, rather than using the individual
+ * cache line maintainence instructions.
+ */
+#define CACHE_DLIMIT	32768
+
+	.text
+/*
+ * cpu_arm1020_proc_init()
+ */
+ENTRY(cpu_arm1020_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm1020_proc_fin()
+ */
+ENTRY(cpu_arm1020_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+	bl	arm1020_flush_kern_cache_all
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000 		@ ...i............
+	bic	r0, r0, #0x000e 		@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm1020_reset(loc)
+ *
+ * Perform a soft reset of the system.	Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+	.align	5
+ENTRY(cpu_arm1020_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f 		@ ............wcam
+	bic	ip, ip, #0x1100 		@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * cpu_arm1020_do_idle()
+ */
+	.align	5
+ENTRY(cpu_arm1020_do_idle)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+	mov	pc, lr
+
+/* ================================= CACHE ================================ */
+
+	.align	5
+/*
+ *	flush_user_cache_all()
+ *
+ *	Invalidate all cache entries in a particular address
+ *	space.
+ */
+ENTRY(arm1020_flush_user_cache_all)
+	/* FALLTHROUGH */
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(arm1020_flush_kern_cache_all)
+	mov	r2, #VM_EXEC
+	mov	ip, #0
+__flush_whole_cache:
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	r1, #(CACHE_DSEGMENTS - 1) << 5	@ 16 segments
+1:	orr	r3, r1, #(CACHE_DENTRIES - 1) << 26 @ 64 entries
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean+invalidate D index
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	subs	r3, r3, #1 << 26
+	bcs	2b				@ entries 63 to 0
+	subs	r1, r1, #1 << 5
+	bcs	1b				@ segments 15 to 0
+#endif
+	tst	r2, #VM_EXEC
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Invalidate a range of cache entries in the specified
+ *	address space.
+ *
+ *	- start	- start address (inclusive)
+ *	- end	- end address (exclusive)
+ *	- flags	- vm_flags for this space
+ */
+ENTRY(arm1020_flush_user_cache_range)
+	mov	ip, #0
+	sub	r3, r1, r0			@ calculate total size
+	cmp	r3, #CACHE_DLIMIT
+	bhs	__flush_whole_cache
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mcr	p15, 0, ip, c7, c10, 4
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	tst	r2, #VM_EXEC
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm1020_coherent_kern_range)
+	mov	ip, #0
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+	mcr	p15, 0, ip, c7, c10, 4
+1:
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+#endif
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- page	- page aligned address
+ */
+ENTRY(arm1020_flush_kern_dcache_page)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	add	r1, r0, #PAGE_SZ
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm1020_dma_inv_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	tst	r0, #CACHE_DLINESIZE - 1
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, ip, c7, c10, 4
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, ip, c7, c10, 4
+	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm1020_dma_clean_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm1020_dma_flush_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+	mcr	p15, 0, ip, c7, c10, 4
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+ENTRY(arm1020_cache_fns)
+	.long	arm1020_flush_kern_cache_all
+	.long	arm1020_flush_user_cache_all
+	.long	arm1020_flush_user_cache_range
+	.long	arm1020_coherent_kern_range
+	.long	arm1020_flush_kern_dcache_page
+	.long	arm1020_dma_inv_range
+	.long	arm1020_dma_clean_range
+	.long	arm1020_dma_flush_range
+
+	.align	5
+ENTRY(cpu_arm1020_dcache_clean_area)
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mov	ip, #0
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+#endif
+	mov	pc, lr
+
+/* =============================== PageTable ============================== */
+
+/*
+ * cpu_arm1020_switch_mm(pgd)
+ *
+ * Set the translation base pointer to be as described by pgd.
+ *
+ * pgd: new page tables
+ */
+	.align	5
+ENTRY(cpu_arm1020_switch_mm)
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mcr	p15, 0, r3, c7, c10, 4
+	mov	r1, #0xF			@ 16 segments
+1:	mov	r3, #0x3F			@ 64 entries
+2:	mov	ip, r3, LSL #26 		@ shift up entry
+	orr	ip, ip, r1, LSL #5		@ shift in/up index
+	mcr	p15, 0, ip, c7, c14, 2		@ Clean & Inval DCache entry
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c10, 4
+	subs	r3, r3, #1
+	cmp	r3, #0
+	bge	2b				@ entries 3F to 0
+	subs	r1, r1, #1
+	cmp	r1, #0
+	bge	1b				@ segments 15 to 0
+
+#endif
+	mov	r1, #0
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, r1, c7, c5, 0		@ invalidate I cache
+#endif
+	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
+	mov	pc, lr
+        
+
+	__INIT
+
+	.type	__arm1020_setup, #function
+__arm1020_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+	mrc	p15, 0, r0, c1, c0		@ get control register v4
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+	bic	r0, r0, #0x1e00 		@ i...??r.........
+	bic	r0, r0, #0x000e 		@ ............wca.
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+						@ ..........DP...M
+	orr	r0, r0, #0x0031			@ if we need MMU on for
+						@ d-cache, it would be
+#else						@ enabled.
+	orr	r0, r0, #0x0030
+#endif
+	orr	r0, r0, #0x0100 		@ .......S........
+
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	orr	r0, r0, #0x4000 		@ .R..............
+#endif
+#ifndef CONFIG_CPU_BPREDICT_DISABLE
+	orr	r0, r0, #0x0800 		@ ....Z...........
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	orr	r0, r0, #0x0004 		@ Enable D cache
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	orr	r0, r0, #0x1000 		@ I Cache on
+#endif
+	mov	pc, lr
+	.size	__arm1020_setup, . - __arm1020_setup
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm1020_processor_functions, #object
+arm1020_processor_functions:
+	.word	v4t_early_abort
+	.word	cpu_arm1020_proc_init
+	.word	cpu_arm1020_proc_fin
+	.word	cpu_arm1020_reset
+	.word	cpu_arm1020_do_idle
+	.word	cpu_arm1020_dcache_clean_area
+	.word	cpu_arm1020_switch_mm
+	.size	arm1020_processor_functions, . - arm1020_processor_functions
+
+	.section ".rodata"
+
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv5t"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v5"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm1020_name, #object
+cpu_arm1020_name:
+	.ascii	"ARM1020"
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	.ascii	"i"
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	.ascii	"d"
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.ascii	"(wt)"
+#else
+	.ascii	"(wb)"
+#endif
+#endif
+#ifndef CONFIG_CPU_BPREDICT_DISABLE
+	.ascii	"B"
+#endif
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	.ascii	"RR"
+#endif
+	.ascii	"\0"
+	.size	cpu_arm1020_name, . - cpu_arm1020_name
+
+	.align
+
+	.section ".proc.info", #alloc, #execinstr
+
+	.type	__arm1020_proc_info,#object
+__arm1020_proc_info:
+	.long	0x4104a200			@ ARM 1020T (Architecture v5T)
+	.long	0xff0ffff0
+	.long	0x00000c02			@ mmuflags
+	b	__arm1020_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
+	.long	cpu_arm1020_name
+	.long	arm1020_processor_functions
+	.long	arm1020_cache_fns
+	.size	__arm1020_proc_info, . - __arm1020_proc_info
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm1022.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1022.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm1022.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1022.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,447 @@
+/*
+ *  linux/arch/armnommu/mm/proc-arm1022.S: MMU functions for ARM1022E
+ *
+ *  Copyright (C) 2000 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *
+ * These are the low level assembler for performing cache
+ * functions on the ARM1022E.
+ */
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+
+/*
+ * This is the maximum size of an area which will be invalidated
+ * using the single invalidate entry instructions.  Anything larger
+ * than this, and we go for the whole cache.
+ *
+ * This value should be chosen such that we choose the cheapest
+ * alternative.
+ */
+#define MAX_AREA_SIZE	32768
+
+/*
+ * The size of one data cache line.
+ */
+#define CACHE_DLINESIZE	32
+
+/*
+ * The number of data cache segments.
+ */
+#define CACHE_DSEGMENTS	16
+
+/*
+ * The number of lines in a cache segment.
+ */
+#define CACHE_DENTRIES	64
+
+/*
+ * This is the size at which it becomes more efficient to
+ * clean the whole cache, rather than using the individual
+ * cache line maintainence instructions.
+ */
+#define CACHE_DLIMIT	32768
+
+	.text
+/*
+ * cpu_arm1022_proc_init()
+ */
+ENTRY(cpu_arm1022_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm1022_proc_fin()
+ */
+ENTRY(cpu_arm1022_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+	bl	arm1022_flush_kern_cache_all
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000 		@ ...i............
+	bic	r0, r0, #0x000e 		@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm1022_reset(loc)
+ *
+ * Perform a soft reset of the system.	Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+	.align	5
+ENTRY(cpu_arm1022_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f 		@ ............wcam
+	bic	ip, ip, #0x1100 		@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * cpu_arm1022_do_idle()
+ */
+	.align	5
+ENTRY(cpu_arm1022_do_idle)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+	mov	pc, lr
+
+/* ================================= CACHE ================================ */
+
+	.align	5
+/*
+ *	flush_user_cache_all()
+ *
+ *	Invalidate all cache entries in a particular address
+ *	space.
+ */
+ENTRY(arm1022_flush_user_cache_all)
+	/* FALLTHROUGH */
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(arm1022_flush_kern_cache_all)
+	mov	r2, #VM_EXEC
+	mov	ip, #0
+__flush_whole_cache:
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mov	r1, #(CACHE_DSEGMENTS - 1) << 5	@ 16 segments
+1:	orr	r3, r1, #(CACHE_DENTRIES - 1) << 26 @ 64 entries
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean+invalidate D index
+	subs	r3, r3, #1 << 26
+	bcs	2b				@ entries 63 to 0
+	subs	r1, r1, #1 << 5
+	bcs	1b				@ segments 15 to 0
+#endif
+	tst	r2, #VM_EXEC
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Invalidate a range of cache entries in the specified
+ *	address space.
+ *
+ *	- start	- start address (inclusive)
+ *	- end	- end address (exclusive)
+ *	- flags	- vm_flags for this space
+ */
+ENTRY(arm1022_flush_user_cache_range)
+	mov	ip, #0
+	sub	r3, r1, r0			@ calculate total size
+	cmp	r3, #CACHE_DLIMIT
+	bhs	__flush_whole_cache
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	tst	r2, #VM_EXEC
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm1022_coherent_kern_range)
+	mov	ip, #0
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+#endif
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- page	- page aligned address
+ */
+ENTRY(arm1022_flush_kern_dcache_page)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	add	r1, r0, #PAGE_SZ
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm1022_dma_inv_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	tst	r0, #CACHE_DLINESIZE - 1
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
+1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm1022_dma_clean_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm1022_dma_flush_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+ENTRY(arm1022_cache_fns)
+	.long	arm1022_flush_kern_cache_all
+	.long	arm1022_flush_user_cache_all
+	.long	arm1022_flush_user_cache_range
+	.long	arm1022_coherent_kern_range
+	.long	arm1022_flush_kern_dcache_page
+	.long	arm1022_dma_inv_range
+	.long	arm1022_dma_clean_range
+	.long	arm1022_dma_flush_range
+
+	.align	5
+ENTRY(cpu_arm1022_dcache_clean_area)
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mov	ip, #0
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+#endif
+	mov	pc, lr
+
+/* =============================== PageTable ============================== */
+
+/*
+ * cpu_arm1022_switch_mm(pgd)
+ *
+ * Set the translation base pointer to be as described by pgd.
+ *
+ * pgd: new page tables
+ */
+	.align	5
+ENTRY(cpu_arm1022_switch_mm)
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mov	r1, #(CACHE_DSEGMENTS - 1) << 5	@ 16 segments
+1:	orr	r3, r1, #(CACHE_DENTRIES - 1) << 26 @ 64 entries
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean+invalidate D index
+	subs	r3, r3, #1 << 26
+	bcs	2b				@ entries 63 to 0
+	subs	r1, r1, #1 << 5
+	bcs	1b				@ segments 15 to 0
+#endif
+	mov	r1, #0
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, r1, c7, c5, 0		@ invalidate I cache
+#endif
+	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
+	mov	pc, lr
+        
+
+	__INIT
+
+	.type	__arm1022_setup, #function
+__arm1022_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+	mrc	p15, 0, r0, c1, c0		@ get control register v4
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+	bic	r0, r0, #0x1e00 		@ ...i??r.........
+	bic	r0, r0, #0x000e 		@ ............wca.
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+						@ ..........DP...M
+	orr	r0, r0, #0x0031			@ if we need MMU on for
+						@ d-cache, it would be
+#else						@ enabled.
+	orr	r0, r0, #0x0030
+#endif
+	orr	r0, r0, #0x2100 		@ ..V....S........
+
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	orr	r0, r0, #0x4000 		@ .R..............
+#endif
+#ifndef CONFIG_CPU_BPREDICT_DISABLE
+	orr	r0, r0, #0x0800 		@ ....Z...........
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	orr	r0, r0, #0x0004 		@ .............C..
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	orr	r0, r0, #0x1000 		@ ...I............
+#endif
+	mov	pc, lr
+	.size	__arm1022_setup, . - __arm1022_setup
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm1022_processor_functions, #object
+arm1022_processor_functions:
+	.word	v4t_early_abort
+	.word	cpu_arm1022_proc_init
+	.word	cpu_arm1022_proc_fin
+	.word	cpu_arm1022_reset
+	.word	cpu_arm1022_do_idle
+	.word	cpu_arm1022_dcache_clean_area
+	.word	cpu_arm1022_switch_mm
+	.size	arm1022_processor_functions, . - arm1022_processor_functions
+
+	.section ".rodata"
+
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv5te"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v5"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm1022_name, #object
+cpu_arm1022_name:
+	.ascii	"arm1022"
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	.ascii	"i"
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	.ascii	"d"
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.ascii	"(wt)"
+#else
+	.ascii	"(wb)"
+#endif
+#endif
+#ifndef CONFIG_CPU_BPREDICT_DISABLE
+	.ascii	"B"
+#endif
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	.ascii	"RR"
+#endif
+	.ascii	"\0"
+	.size	cpu_arm1022_name, . - cpu_arm1022_name
+
+	.align
+
+	.section ".proc.info", #alloc, #execinstr
+
+	.type	__arm1022_proc_info,#object
+__arm1022_proc_info:
+	.long	0x4105a220			@ ARM 1022E (v5TE)
+	.long	0xff0ffff0
+	.long	0x00000c12			@ mmuflags
+	b	__arm1022_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
+	.long	cpu_arm1022_name
+	.long	arm1022_processor_functions
+	.long	arm1022_cache_fns
+	.size	__arm1022_proc_info, . - __arm1022_proc_info
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm1026.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1026.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm1026.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1026.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,442 @@
+/*
+ *  linux/arch/armnommu/mm/proc-arm1026.S: MMU functions for ARM1026EJ-S
+ *
+ *  Copyright (C) 2000 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *
+ * These are the low level assembler for performing cache
+ * functions on the ARM1026EJ-S.
+ */
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+
+/*
+ * This is the maximum size of an area which will be invalidated
+ * using the single invalidate entry instructions.  Anything larger
+ * than this, and we go for the whole cache.
+ *
+ * This value should be chosen such that we choose the cheapest
+ * alternative.
+ */
+#define MAX_AREA_SIZE	32768
+
+/*
+ * The size of one data cache line.
+ */
+#define CACHE_DLINESIZE	32
+
+/*
+ * The number of data cache segments.
+ */
+#define CACHE_DSEGMENTS	16
+
+/*
+ * The number of lines in a cache segment.
+ */
+#define CACHE_DENTRIES	64
+
+/*
+ * This is the size at which it becomes more efficient to
+ * clean the whole cache, rather than using the individual
+ * cache line maintainence instructions.
+ */
+#define CACHE_DLIMIT	32768
+
+	.text
+/*
+ * cpu_arm1026_proc_init()
+ */
+ENTRY(cpu_arm1026_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm1026_proc_fin()
+ */
+ENTRY(cpu_arm1026_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+	bl	arm1026_flush_kern_cache_all
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000 		@ ...i............
+	bic	r0, r0, #0x000e 		@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm1026_reset(loc)
+ *
+ * Perform a soft reset of the system.	Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+	.align	5
+ENTRY(cpu_arm1026_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f 		@ ............wcam
+	bic	ip, ip, #0x1100 		@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * cpu_arm1026_do_idle()
+ */
+	.align	5
+ENTRY(cpu_arm1026_do_idle)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+	mov	pc, lr
+
+/* ================================= CACHE ================================ */
+
+	.align	5
+/*
+ *	flush_user_cache_all()
+ *
+ *	Invalidate all cache entries in a particular address
+ *	space.
+ */
+ENTRY(arm1026_flush_user_cache_all)
+	/* FALLTHROUGH */
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(arm1026_flush_kern_cache_all)
+	mov	r2, #VM_EXEC
+	mov	ip, #0
+__flush_whole_cache:
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+1:	mrc	p15, 0, r15, c7, c14, 3		@ test, clean, invalidate
+	bne	1b
+#endif
+	tst	r2, #VM_EXEC
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Invalidate a range of cache entries in the specified
+ *	address space.
+ *
+ *	- start	- start address (inclusive)
+ *	- end	- end address (exclusive)
+ *	- flags	- vm_flags for this space
+ */
+ENTRY(arm1026_flush_user_cache_range)
+	mov	ip, #0
+	sub	r3, r1, r0			@ calculate total size
+	cmp	r3, #CACHE_DLIMIT
+	bhs	__flush_whole_cache
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	tst	r2, #VM_EXEC
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+#endif
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm1026_coherent_kern_range)
+	mov	ip, #0
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+#endif
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- page	- page aligned address
+ */
+ENTRY(arm1026_flush_kern_dcache_page)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	add	r1, r0, #PAGE_SZ
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm1026_dma_inv_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	tst	r0, #CACHE_DLINESIZE - 1
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
+1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm1026_dma_clean_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm1026_dma_flush_range)
+	mov	ip, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+ENTRY(arm1026_cache_fns)
+	.long	arm1026_flush_kern_cache_all
+	.long	arm1026_flush_user_cache_all
+	.long	arm1026_flush_user_cache_range
+	.long	arm1026_coherent_kern_range
+	.long	arm1026_flush_kern_dcache_page
+	.long	arm1026_dma_inv_range
+	.long	arm1026_dma_clean_range
+	.long	arm1026_dma_flush_range
+
+	.align	5
+ENTRY(cpu_arm1026_dcache_clean_area)
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	mov	ip, #0
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+#endif
+	mov	pc, lr
+
+/* =============================== PageTable ============================== */
+
+/*
+ * cpu_arm1026_switch_mm(pgd)
+ *
+ * Set the translation base pointer to be as described by pgd.
+ *
+ * pgd: new page tables
+ */
+	.align	5
+ENTRY(cpu_arm1026_switch_mm)
+	mov	r1, #0
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+1:	mrc	p15, 0, r15, c7, c14, 3		@ test, clean, invalidate
+	bne	1b
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	mcr	p15, 0, r1, c7, c5, 0		@ invalidate I cache
+#endif
+	mcr	p15, 0, r1, c7, c10, 4		@ drain WB
+	mov	pc, lr
+        
+
+	__INIT
+
+	.type	__arm1026_setup, #function
+__arm1026_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mov	r0, #4				@ explicitly disable writeback
+	mcr	p15, 7, r0, c15, c0, 0
+#endif
+	mrc	p15, 0, r0, c1, c0		@ get control register v4
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+	bic	r0, r0, #0x1e00 		@ ...i??r.........
+	bic	r0, r0, #0x000e 		@ ............wca.
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+						@ ..........DP...M
+	orr	r0, r0, #0x0031			@ if we need MMU on for
+						@ d-cache, it would be
+#else						@ enabled.
+	orr	r0, r0, #0x0030
+#endif
+	orr	r0, r0, #0x2100 		@ ..V....S........
+
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	orr	r0, r0, #0x4000 		@ .R..............
+#endif
+#ifndef CONFIG_CPU_BPREDICT_DISABLE
+	orr	r0, r0, #0x0800 		@ ....Z...........
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	orr	r0, r0, #0x0004 		@ .............C..
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	orr	r0, r0, #0x1000 		@ ...I............
+#endif
+	mov	pc, lr
+	.size	__arm1026_setup, . - __arm1026_setup
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm1026_processor_functions, #object
+arm1026_processor_functions:
+	.word	v5t_early_abort
+	.word	cpu_arm1026_proc_init
+	.word	cpu_arm1026_proc_fin
+	.word	cpu_arm1026_reset
+	.word	cpu_arm1026_do_idle
+	.word	cpu_arm1026_dcache_clean_area
+	.word	cpu_arm1026_switch_mm
+	.size	arm1026_processor_functions, . - arm1026_processor_functions
+
+	.section .rodata
+
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv5tej"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v5"
+	.size	cpu_elf_name, . - cpu_elf_name
+	.align
+
+	.type	cpu_arm1026_name, #object
+cpu_arm1026_name:
+	.ascii	"ARM1026EJ-S"
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	.ascii	"i"
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	.ascii	"d"
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.ascii	"(wt)"
+#else
+	.ascii	"(wb)"
+#endif
+#endif
+#ifndef CONFIG_CPU_BPREDICT_DISABLE
+	.ascii	"B"
+#endif
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	.ascii	"RR"
+#endif
+	.ascii	"\0"
+	.size	cpu_arm1026_name, . - cpu_arm1026_name
+
+	.align
+
+	.section ".proc.info", #alloc, #execinstr
+
+	.type	__arm1026_proc_info,#object
+__arm1026_proc_info:
+	.long	0x4106a260			@ ARM 1026EJ-S (v5TEJ)
+	.long	0xff0ffff0
+	.long	0x00000c12			@ mmuflags
+	b	__arm1026_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB | HWCAP_FAST_MULT
+	.long	cpu_arm1026_name
+	.long	arm1026_processor_functions
+	.long	arm1026_cache_fns
+	.size	__arm1026_proc_info, . - __arm1026_proc_info
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm6_7.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm6_7.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm6_7.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm6_7.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,498 @@
+/*
+ *  linux/arch/armnommu/mm/proc-arm6_7.S
+ *
+ *  Copyright (C) 1997-2000 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for nommu version
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  These are the low level assembler for performing cache
+ *  functions on the ARM610, ARM710, ARM7TDMI and the compatibles.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/errno.h>
+
+ENTRY(cpu_arm6_dcache_clean_area)
+ENTRY(cpu_arm7_dcache_clean_area)
+		mov	pc, lr
+
+/*
+ * Function: arm6_7_data_abort ()
+ *
+ * Params  : r2 = address of aborted instruction
+ *	   : sp = pointer to registers
+ *
+ * Purpose : obtain information about current aborted instruction
+ *
+ * Returns : r0 = address of abort
+ *	   : r1 = FSR
+ */
+
+ENTRY(cpu_arm7_data_abort)
+@FIXME
+	ldr     r8, [r2]                        @ read arm instruction
+	tst     r8, #1 << 20                    @ L = 1 -> write?
+	and	r7, r8, #15 << 24
+	orr	r1, r7, #1
+	orreq   r1, r1, #1 << 8                 @ yes.
+	add	pc, pc, r7, lsr #22		@ Now branch to the relevant processing routine
+	nop
+
+/* 0 */	b	.data_unknown
+/* 1 */	mov	pc, lr				@ swp
+/* 2 */	b	.data_unknown
+/* 3 */	b	.data_unknown
+/* 4 */	b	.data_arm_lateldrpostconst	@ ldr	rd, [rn], #m
+/* 5 */	b	.data_arm_lateldrpreconst	@ ldr	rd, [rn, #m]
+/* 6 */	b	.data_arm_lateldrpostreg	@ ldr	rd, [rn], rm
+/* 7 */	b	.data_arm_lateldrprereg		@ ldr	rd, [rn, rm]
+/* 8 */	b	.data_arm_ldmstm		@ ldm*a	rn, <rlist>
+/* 9 */	b	.data_arm_ldmstm		@ ldm*b	rn, <rlist>
+/* a */	b	.data_unknown
+/* b */	b	.data_unknown
+/* c */	mov	pc, lr				@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
+/* d */	mov	pc, lr				@ ldc	rd, [rn, #m]
+/* e */	b	.data_unknown
+/* f */
+.data_unknown:	@ Part of jumptable
+	mov	r0, r2
+	mov	r1, r8
+	mov	r2, sp
+	bl	baddataabort
+	b	ret_from_exception
+
+ENTRY(cpu_arm6_data_abort)
+@FIXME
+	ldr	r8, [r2]			@ read arm instruction
+	tst	r8, #1 << 20			@ L = 1 -> write?
+	orreq	r1, r1, #1 << 8			@ yes.
+	and	r7, r8, #14 << 24
+	teq	r7, #8 << 24			@ was it ldm/stm
+	movne	pc, lr
+
+.data_arm_ldmstm:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+	mov	r7, #0x11
+	orr	r7, r7, #0x1100
+	and	r6, r8, r7
+	and	r2, r8, r7, lsl #1
+	add	r6, r6, r2, lsr #1
+	and	r2, r8, r7, lsl #2
+	add	r6, r6, r2, lsr #2
+	and	r2, r8, r7, lsl #3
+	add	r6, r6, r2, lsr #3
+	add	r6, r6, r6, lsr #8
+	add	r6, r6, r6, lsr #4
+	and	r6, r6, #15			@ r6 = no. of registers to transfer.
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6, lsl #2		@ Undo increment
+	addeq	r7, r7, r6, lsl #2		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_apply_r6_and_rn:
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6			@ Undo incrmenet
+	addeq	r7, r7, r6			@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrpreconst:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostconst:
+	movs	r2, r8, lsl #20			@ Get offset
+	moveq	pc, lr				@ zero -> no fixup
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r2, lsr #20		@ Undo increment
+	addeq	r7, r7, r2, lsr #20		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrprereg:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostreg:
+	and	r7, r8, #15			@ Extract 'm' from instruction
+	ldr	r6, [sp, r7, lsl #2]		@ Get register 'Rm'
+	mov	r5, r8, lsr #7			@ get shift count
+	ands	r5, r5, #31
+	and	r7, r8, #0x70			@ get shift type
+	orreq	r7, r7, #8			@ shift count = 0
+	add	pc, pc, r7
+	nop
+
+	mov	r6, r6, lsl r5			@ 0: LSL #!0
+	b	.data_arm_apply_r6_and_rn
+	b	.data_arm_apply_r6_and_rn	@ 1: LSL #0
+	nop
+	b	.data_unknown			@ 2: MUL?
+	nop
+	b	.data_unknown			@ 3: MUL?
+	nop
+	mov	r6, r6, lsr r5			@ 4: LSR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, lsr #32			@ 5: LSR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ 6: MUL?
+	nop
+	b	.data_unknown			@ 7: MUL?
+	nop
+	mov	r6, r6, asr r5			@ 8: ASR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, asr #32			@ 9: ASR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ A: MUL?
+	nop
+	b	.data_unknown			@ B: MUL?
+	nop
+	mov	r6, r6, ror r5			@ C: ROR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, rrx			@ D: RRX
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ E: MUL?
+	nop
+	b	.data_unknown			@ F: MUL?
+
+/*
+ * Function: arm6_7_proc_init (void)
+ *	   : arm6_7_proc_fin (void)
+ *
+ * Notes   : This processor does not require these
+ */
+ENTRY(cpu_arm6_proc_init)
+ENTRY(cpu_arm7_proc_init)
+		mov	pc, lr
+
+ENTRY(cpu_arm6_proc_fin)
+ENTRY(cpu_arm7_proc_fin)
+		mov	r0, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+		msr	cpsr_c, r0
+		mov	r0, #0x30			@ .......DP....
+		mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+		mov	pc, lr
+
+ENTRY(cpu_arm6_do_idle)
+ENTRY(cpu_arm7_do_idle)
+		mov	r0, #-EINVAL
+		mov	pc, lr
+
+/*
+ * Function: arm6_7_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, saving the old processes state, and restoring
+ *	     the new.
+ */
+ENTRY(cpu_arm6_switch_mm)
+ENTRY(cpu_arm7_switch_mm)
+		mov	r1, #0
+		mcr	p15, 0, r1, c7, c0, 0		@ flush cache
+		mov	pc, lr
+
+/*
+ * Function: _arm6_7_reset
+ * Params  : r0 = address to jump to
+ * Notes   : This sets up everything for a reset
+ */
+ENTRY(cpu_arm6_reset)
+ENTRY(cpu_arm7_reset)
+		mov	r1, #0
+		mcr	p15, 0, r1, c7, c0, 0		@ flush cache
+		mov	r1, #0x30
+		mcr	p15, 0, r1, c1, c0, 0		@ turn off MMU etc
+		mov	pc, r0
+
+		__INIT
+
+		.type	__arm6_setup, #function
+__arm6_setup:	mov	r0, #0
+		mcr	p15, 0, r0, c7, c0		@ flush caches on v3
+		mov	r0, #0x3c			@ .......DPWC..
+		mov	pc, lr
+		.size	__arm6_setup, . - __arm6_setup
+
+		.type	__arm7_setup, #function
+__arm7_setup:	mov	r0, #0
+		mcr	p15, 0, r0, c7, c0		@ flush caches on v3
+		mov	r0, #0x7c			@ ......LDPWC..
+		mov	pc, lr
+		.size	__arm7_setup, . - __arm7_setup
+
+		__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+		.type	arm6_processor_functions, #object
+ENTRY(arm6_processor_functions)
+		.word	cpu_arm6_data_abort
+		.word	cpu_arm6_proc_init
+		.word	cpu_arm6_proc_fin
+		.word	cpu_arm6_reset
+		.word	cpu_arm6_do_idle
+		.word	cpu_arm6_dcache_clean_area
+		.word	cpu_arm6_switch_mm
+		.size	arm6_processor_functions, . - arm6_processor_functions
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+		.type	arm7_processor_functions, #object
+ENTRY(arm7_processor_functions)
+		.word	cpu_arm7_data_abort
+		.word	cpu_arm7_proc_init
+		.word	cpu_arm7_proc_fin
+		.word	cpu_arm7_reset
+		.word	cpu_arm7_do_idle
+		.word	cpu_arm7_dcache_clean_area
+		.word	cpu_arm7_switch_mm
+		.size	arm7_processor_functions, . - arm7_processor_functions
+
+		.section ".rodata"
+
+		.type	cpu_arch_name, #object
+cpu_arch_name:	.asciz	"armv3"
+		.size	cpu_arch_name, . - cpu_arch_name
+
+		.type	cpu_elf_name, #object
+cpu_elf_name:	.asciz	"v3"
+		.size	cpu_elf_name, . - cpu_elf_name
+
+		.type	cpu_arm6_name, #object
+cpu_arm6_name:	.asciz	"ARM6"
+		.size	cpu_arm6_name, . - cpu_arm6_name
+
+		.type	cpu_arm610_name, #object
+cpu_arm610_name:
+		.asciz	"ARM610"
+		.size	cpu_arm610_name, . - cpu_arm610_name
+
+		.type	cpu_arm7_name, #object
+cpu_arm7_name:	.asciz	"ARM7"
+		.size	cpu_arm7_name, . - cpu_arm7_name
+
+		.type	cpu_arm710_name, #object
+cpu_arm710_name:
+		.asciz	"ARM710"
+		.size	cpu_arm710_name, . - cpu_arm710_name
+
+		.type	cpu_arm7tdmi_name, #object
+cpu_arm7tdmi_name:
+		.asciz	"ARM7TDMI"
+		.size	cpu_arm7tdmi_name, . - cpu_arm7tdmi_name
+
+		.type	cpu_triscenda7_name, #object
+cpu_triscenda7_name:
+#if defined(CONFIG_ARCH_TA7S)
+		.asciz	"Triscend-A7S"
+#elif defined(CONFIG_ARCH_TA7V)
+		.asciz	"Triscend-A7V"
+#endif
+		.size	cpu_triscenda7_name, . - cpu_triscenda7_name
+
+		.type	cpu_at91_name, #object
+cpu_at91_name:
+		.asciz	"Atmel-AT91M40xxx"
+		.size	cpu_at91_name, . - cpu_at91_name
+
+		.type	cpu_s3c3410_name, #object
+cpu_s3c3410_name:
+		.asciz	"Samsung-S3C3410"
+		.size	cpu_s3c3410_name, . - cpu_s3c3410_name
+
+		.type	cpu_s3c44b0x_name, #object
+cpu_s3c44b0x_name:
+		.asciz	"Samsung-S3C44B0x"
+		.size	cpu_s3c44b0x_name, . - cpu_s3c44b0x_name
+
+		.type	cpu_s3c4510b, #object
+cpu_s3c4510b_name:
+		.asciz	"Samsung-S3C4510B"
+		.size	cpu_s3c4510b_name, . - cpu_s3c4510b_name
+
+		.type	cpu_s3c4530_name, #object
+cpu_s3c4530_name:
+		.asciz	"Samsung-S3C4530"
+		.size	cpu_s3c4530_name, . - cpu_s3c4530_name
+
+		.type	cpu_netarm_name, #object
+cpu_netarm_name:
+		.asciz	"NETARM"
+		.size	cpu_netarm_name, . - cpu_netarm_name
+
+		.align
+
+		.section ".proc.info", #alloc, #execinstr
+
+		.type	__arm6_proc_info, #object
+__arm6_proc_info:
+		.long	0x41560600
+		.long	0xfffffff0
+		.long	0x00000c1e
+		b	__arm6_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_arm6_name
+		.long	arm6_processor_functions
+		.long	v3_cache_fns
+		.size	__arm6_proc_info, . - __arm6_proc_info
+
+		.type	__arm610_proc_info, #object
+__arm610_proc_info:
+		.long	0x41560610
+		.long	0xfffffff0
+		.long	0x00000c1e
+		b	__arm6_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_arm610_name
+		.long	arm6_processor_functions
+		.long	v3_cache_fns
+		.size	__arm610_proc_info, . - __arm610_proc_info
+
+		.type	__arm7_proc_info, #object
+__arm7_proc_info:
+		.long	0x41007000
+		.long	0xffffff00
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_arm7_name
+		.long	arm7_processor_functions
+		.long	v3_cache_fns
+		.size	__arm7_proc_info, . - __arm7_proc_info
+
+		.type	__arm710_proc_info, #object
+__arm710_proc_info:
+		.long	0x41007100
+		.long	0xfff8ff00
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_arm710_name
+		.long	arm7_processor_functions
+		.long	v3_cache_fns
+		.size	__arm710_proc_info, . - __arm710_proc_info
+
+		.type	__arm7tdmi_proc_info, #object
+__arm7tdmi_proc_info:
+		.long	0x41007700
+		.long	0xfff8ff00
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_arm7tdmi_name
+		.long	arm7_processor_functions
+		.long	v3_cache_fns
+		.size	__arm7tdmi_proc_info, . - __arm7dmi_proc_info
+
+		.type	__triscenda7_proc_info, #object
+__triscenda7_proc_info:
+		.long	0x0001d2ff
+		.long	0x0001ffff
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_triscenda7_name
+		.long	arm7_processor_functions
+		.long	v3_cache_fns
+		.size	__triscenda7_proc_info, . - __triscenda7_proc_info
+
+		.type	__at91_proc_info, #object
+__at91_proc_info:
+		.long	0x14000040
+		.long	0xfff000e0
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_at91_name
+		.long	arm7_processor_functions
+		.long	v3_cache_fns
+		.size	__at91_proc_info, . - __at91_proc_info
+
+		.type	__s3c4510b_proc_info, #object
+__s3c4510b_proc_info:
+		.long	0x36365000
+		.long	0xfffff000
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_s3c4510b_name
+		.long	arm7_processor_functions
+		.long	v3_cache_fns
+		.size	__s3c4510b_proc_info, . - __s3c4510b_proc_info
+
+		.type	__s3c4530_proc_info, #object
+__s3c4530_proc_info:
+		.long	0x4c000000
+		.long	0xfff000e0
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_s3c4530_name
+		.long	arm7_processor_functions
+		.long	v3_cache_fns
+		.size	__s3c4530_proc_info, . - __s3c4530_proc_info
+
+		.type	__s3c3410_proc_info, #object
+__s3c3410_proc_info:
+		.long	0x34100000
+		.long	0xffff0000
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_s3c3410_name
+		.long	arm7_processor_functions
+		.long	v3_cache_fns
+		.size	__s3c3410_proc_info, . - __s3c3410_proc_info
+
+		.type	__s3c44b0x_proc_info, #object
+__s3c44b0x_proc_info:
+		.long	0x44b00000
+		.long	0xffff0000
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_s3c44b0x_name
+		.long	arm7_processor_functions
+		.long	v3_cache_fns
+		.size	__s3c44b0x_proc_info, . - __s3c44b0x_proc_info
+
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm720.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm720.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm720.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm720.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,194 @@
+/*
+ *  linux/arch/armnommu/mm/proc-arm720.S: MMU functions for ARM720
+ *
+ *  Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *                     Rob Scott (rscott@mtrob.fdns.net)
+ *  Copyright (C) 2000 ARM Limited, Deep Blue Solutions Ltd.
+ *  Copyright (C) 2004 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * These are the low level assembler for performing cache
+ * functions on the ARM720T.  The ARM720T has a writethrough IDC
+ * cache, so we don't need to clean it.
+ *
+ *  Changelog:
+ *   05-09-2000 SJH	Created by moving 720 specific functions
+ *			out of 'proc-arm6,7.S' per RMK discussion
+ *   07-25-2000 SJH	Added idle function.
+ *   08-25-2000	DBS	Updated for integration of ARM Ltd version.
+ *   04-20-2004 HSC     copied and modified for non-paged mmu version.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/hardware.h>
+
+/*
+ * Function: arm720_proc_init (void)
+ *	   : arm720_proc_fin (void)
+ *
+ * Notes   : This processor does not require these
+ */
+ENTRY(cpu_arm720_dcache_clean_area)
+ENTRY(cpu_arm720_proc_init)
+		mov	pc, lr
+
+ENTRY(cpu_arm720_proc_fin)
+		stmfd	sp!, {lr}
+		mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+		msr	cpsr_c, ip
+		mrc	p15, 0, r0, c1, c0, 0
+		bic	r0, r0, #0x1000			@ ...i............
+		bic	r0, r0, #0x000e			@ ............wca.
+		mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+		mcr	p15, 0, r1, c7, c7, 0		@ invalidate cache
+		ldmfd	sp!, {pc}
+
+/*
+ * Function: arm720_proc_do_idle(void)
+ * Params  : r0 = unused
+ * Purpose : put the processer in proper idle mode
+ */
+ENTRY(cpu_arm720_do_idle)
+		mov	pc, lr
+
+/*
+ * Function: arm720_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, saving the old process' state and restoring
+ *	     the new.
+ */
+ENTRY(cpu_arm720_switch_mm)
+		mov	r1, #0
+		mcr	p15, 0, r1, c7, c7, 0		@ invalidate cache
+		mov	pc, lr
+
+/*
+ * Function: arm720_reset
+ * Params  : r0 = address to jump to
+ * Notes   : This sets up everything for a reset
+ */
+ENTRY(cpu_arm720_reset)
+		mov	ip, #0
+		mcr	p15, 0, ip, c7, c7, 0		@ invalidate cache
+		mrc	p15, 0, ip, c1, c0, 0		@ get ctrl register
+		bic	ip, ip, #0x000f			@ ............wcam
+		bic	ip, ip, #0x2100			@ ..v....s........
+		mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+		mov	pc, r0
+
+		__INIT
+
+		.type	__arm710_setup, #function
+__arm710_setup:	mov	r0, #0
+		mcr	p15, 0, r0, c7, c7, 0		@ invalidate caches
+
+		mrc	p15, 0, r0, c1, c0		@ get control register
+		bic	r0, r0, #0x0e00			@ ..V. ..RS BLDP WCAM
+		orr	r0, r0, #0x0100			@ .... .... .111 .... (old)
+		orr	r0, r0, #0x003d			@ .... ..01 ..11 1101 (new)
+		mov	pc, lr				@ __ret (head.S)
+		.size	__arm710_setup, . - __arm710_setup
+
+		.type	__arm720_setup, #function
+__arm720_setup:	mov	r0, #0
+		mcr	p15, 0, r0, c7, c7, 0		@ invalidate caches
+
+		mrc	p15, 0, r0, c1, c0		@ get control register
+		bic	r0, r0, #0x0e00			@ ..V. ..RS BLDP WCAM
+		orr	r0, r0, #0x2100			@ .... .... .111 .... (old)
+		orr	r0, r0, #0x003d			@ ..1. ..01 ..11 1101 (new)
+		mov	pc, lr				@ __ret (head.S)
+		.size	__arm720_setup, . - __arm720_setup
+
+		__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+		.type	arm720_processor_functions, #object
+ENTRY(arm720_processor_functions)
+		.word	v4t_late_abort
+		.word	cpu_arm720_proc_init
+		.word	cpu_arm720_proc_fin
+		.word	cpu_arm720_reset
+		.word	cpu_arm720_do_idle
+		.word	cpu_arm720_dcache_clean_area
+		.word	cpu_arm720_switch_mm
+		.size	arm720_processor_functions, . - arm720_processor_functions
+
+		.section ".rodata"
+
+		.type	cpu_arch_name, #object
+cpu_arch_name:	.asciz	"armv4t"
+		.size	cpu_arch_name, . - cpu_arch_name
+
+		.type	cpu_elf_name, #object
+cpu_elf_name:	.asciz	"v4"
+		.size	cpu_elf_name, . - cpu_elf_name
+
+		.type	cpu_arm710_name, #object
+cpu_arm710_name:
+		.asciz	"ARM710T"
+		.size	cpu_arm710_name, . - cpu_arm710_name
+
+		.type	cpu_arm720_name, #object
+cpu_arm720_name:
+		.asciz	"ARM720T"
+		.size	cpu_arm720_name, . - cpu_arm720_name
+
+		.align
+
+/*
+ * See linux/include/asm-armnommu/procinfo.h for a definition of this structure.
+ */
+	
+		.section ".proc.info", #alloc, #execinstr
+
+		.type	__arm710_proc_info, #object
+__arm710_proc_info:
+		.long	0x41807100				@ cpu_val
+		.long	0xffffff00				@ cpu_mask
+		.long	0x00000c1e				@ section_mmu_flags
+		b	__arm710_setup				@ cpu_flush
+		.long	cpu_arch_name				@ arch_name
+		.long	cpu_elf_name				@ elf_name
+		.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB	@ elf_hwcap
+		.long	cpu_arm710_name				@ name
+		.long	arm720_processor_functions
+		.long	v4_cache_fns
+		.size	__arm710_proc_info, . - __arm710_proc_info
+
+		.type	__arm720_proc_info, #object
+__arm720_proc_info:
+		.long	0x41807200				@ cpu_val
+		.long	0xffffff00				@ cpu_mask
+		.long	0x00000c1e				@ section_mmu_flags
+		b	__arm720_setup				@ cpu_flush
+		.long	cpu_arch_name				@ arch_name
+		.long	cpu_elf_name				@ elf_name
+		.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB	@ elf_hwcap
+		.long	cpu_arm720_name				@ name
+		.long	arm720_processor_functions
+		.long	v4_cache_fns
+		.size	__arm720_proc_info, . - __arm720_proc_info
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm740.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm740.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm740.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm740.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,333 @@
+/*
+ *  linux/arch/armnommu/mm/arm740.S: MPU functions for ARM740
+ * 
+ *  Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *                     Rob Scott (rscott@mtrob.fdns.net)
+ *  Copyright (C) 2000 ARM Limited, Deep Blue Solutions Ltd.
+ *  Copyright 2004, Hyok S. Choi, for 2.6.
+ */
+	
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>	
+#include <asm/assembler.h>
+#include <asm/pgtable.h>	
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>	
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+
+/*
+ * cpu_arm740_data_abort()
+ *
+ * obtain information about current aborted instruction
+ *
+ * r0 = address of aborted instruction
+ *
+ * Returns:
+ *  r0 = address of abort
+ *  r1 != 0 if writing
+ *  r3 = FSR
+ */
+	.align	5
+Ldata_ldmstm:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+	mov	r7, #0x11
+	orr	r7, r7, r7, lsl #8
+	and	r0, r4, r7
+	and	r2, r4, r7, lsl #1
+	add	r0, r0, r2, lsr #1
+	and	r2, r4, r7, lsl #2
+	add	r0, r0, r2, lsr #2
+	and	r2, r4, r7, lsl #3
+	add	r0, r0, r2, lsr #3
+	add	r0, r0, r0, lsr #8
+	add	r0, r0, r0, lsr #4
+	and	r7, r0, #15			@ r7 = no. of registers to transfer.
+	and	r5, r4, #15 << 16		@ Get Rn
+	ldr	r0, [sp, r5, lsr #14]		@ Get register
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r7, lsl #2
+	addeq	r7, r0, r7, lsl #2		@ Do correction (signed)
+Ldata_saver7:
+	str	r7, [sp, r5, lsr #14]		@ Put register
+Ldata_simple:
+	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
+	mrc	p15, 0, r3, c5, c0, 0		@ get FSR
+	and	r3, r3, #255
+	mov	pc, lr
+
+ENTRY(cpu_arm740_data_abort)
+	ldr	r4, [r0]			@ read instruction causing problem
+	tst	r4, r4, lsr #21			@ C = bit 20
+	sbc	r1, r1, r1			@ r1 = C - 1
+	and	r2, r4, #15 << 24
+	add	pc, pc, r2, lsr #22		@ Now branch to the relevent processing routine
+	movs	pc, lr
+
+	b	Ldata_lateldrhpost		@ ldrh	rd, [rn], #m/rm
+	b	Ldata_lateldrhpre		@ ldrh	rd, [rn, #m/rm]
+	b	Ldata_unknown
+	b	Ldata_unknown
+	b	Ldata_lateldrpostconst		@ ldr	rd, [rn], #m
+	b	Ldata_lateldrpreconst		@ ldr	rd, [rn, #m] 
+	b	Ldata_lateldrpostreg		@ ldr	rd, [rn], rm
+	b	Ldata_lateldrprereg		@ ldr	rd, [rn, rm]
+	b	Ldata_ldmstm			@ ldm*a	rn, <rlist>
+	b	Ldata_ldmstm			@ ldm*b	rn, <rlist>
+	b	Ldata_unknown
+	b	Ldata_unknown
+	b	Ldata_simple			@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
+	b	Ldata_simple			@ ldc	rd, [rn, #m]
+	b	Ldata_unknown
+
+Ldata_unknown:	@ Part of jumptable
+	mov	r0, r2
+	mov	r1, r4
+	mov	r2, r3
+	bl	baddataabort
+	b	ret_from_exception
+
+Ldata_lateldrhpre:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+Ldata_lateldrhpost:
+	and	r5, r4, #0x00f			@ get Rm / low nibble of immediate value
+	tst	r4, #1 << 22			@ if (immediate offset)
+	andne	r2, r4, #0xf00			@ { immediate high nibble
+	orrne	r2, r5, r2, lsr #4		@   combine nibbles } else
+	ldreq	r2, [sp, r5, lsl #2]		@ { load Rm value }
+	and	r5, r4, #15 << 16		@ get Rn
+	ldr	r0, [sp, r5, lsr #14]		@ load Rn value
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r2
+	addeq	r7, r0, r2
+	b	Ldata_saver7
+
+Ldata_lateldrpreconst:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+Ldata_lateldrpostconst:
+	movs	r2, r4, lsl #20			@ Get offset
+	beq	Ldata_simple
+	and	r5, r4, #15 << 16		@ Get Rn
+	ldr	r0, [sp, r5, lsr #14]
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r2, lsr #20
+	addeq	r7, r0, r2, lsr #20
+	b	Ldata_saver7
+
+Ldata_lateldrprereg:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+Ldata_lateldrpostreg:
+	and	r5, r4, #15
+	ldr	r2, [sp, r5, lsl #2]		@ Get Rm
+	mov	r3, r4, lsr #7
+	ands	r3, r3, #31
+	and	r6, r4, #0x70
+	orreq	r6, r6, #8
+	add	pc, pc, r6
+	mov	r0, r0
+
+	mov	r2, r2, lsl r3			@ 0: LSL #!0
+	b	1f
+	b	1f				@ 1: LSL #0
+	mov	r0, r0
+	b	1f				@ 2: MUL?
+	mov	r0, r0
+	b	1f				@ 3: MUL?
+	mov	r0, r0
+	mov	r2, r2, lsr r3			@ 4: LSR #!0
+	b	1f
+	mov	r2, r2, lsr #32			@ 5: LSR #32
+	b	1f
+	b	1f				@ 6: MUL?
+	mov	r0, r0
+	b	1f				@ 7: MUL?
+	mov	r0, r0
+	mov	r2, r2, asr r3			@ 8: ASR #!0
+	b	1f
+	mov	r2, r2, asr #32			@ 9: ASR #32
+	b	1f
+	b	1f				@ A: MUL?
+	mov	r0, r0
+	b	1f				@ B: MUL?
+	mov	r0, r0
+	mov	r2, r2, ror r3			@ C: ROR #!0
+	b	1f
+	mov	r2, r2, rrx			@ D: RRX
+	b	1f
+	mov	r0, r0				@ E: MUL?
+	mov	r0, r0
+	mov	r0, r0				@ F: MUL?
+
+
+1:	and	r5, r4, #15 << 16		@ Get Rn
+	ldr	r0, [sp, r5, lsr #14]
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r2
+	addeq	r7, r0, r2
+	b	Ldata_saver7
+
+
+/*
+ * cpu_arm740_check_bugs()
+ */
+ENTRY(cpu_arm740_check_bugs)
+	mrs	ip, cpsr
+	bic	ip, ip, #PSR_F_BIT
+	msr	cpsr, ip
+	mov	pc, lr
+
+/*
+ * cpu_arm740_proc_init()
+ */
+ENTRY(cpu_arm740_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm740_proc_fin()
+ */
+ENTRY(cpu_arm740_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	mcr	p15, 0, r1, c7, c7, 0		@ invalidate cache
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm740_reset(loc)
+ * Params  : r0 = address to jump to
+ * Notes   : This sets up everything for a reset
+ */
+ENTRY(cpu_arm740_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate cache
+	mrc	p15, 0, ip, c1, c0, 0		@ get ctrl register
+	bic	ip, ip, #0x000e				@ ............wcam
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * idle mode processing 
+ */
+ENTRY(cpu_arm740_do_idle)  
+	mov	pc, lr
+
+/* 
+ * *FIXME* 
+ */ 	
+ENTRY(cpu_arm740_dcache_clean_area)
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7, 0		@ flush cache
+	mov	pc, lr
+	
+/*
+ * Function: arm740_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, 
+ */	
+ENTRY(cpu_arm740_switch_mm)
+	mov	pc, lr	
+
+	
+	/* .section ".text.init", #alloc, #execinstr */ 
+	__INIT
+	
+__arm740_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7, 0		@ invalidate caches
+
+	mov r0, #0x0					@disable region 3-7
+	mcr p15, 0, r0, c6, c3
+	mcr p15, 0, r0, c6, c4
+	mcr p15, 0, r0, c6, c5
+	mcr p15, 0, r0, c6, c6
+	mcr p15, 0, r0, c6, c7
+
+	mov r0, #0x0000003F			@ (base = 0, size = 4GB, non cacheable, no write buffer)
+	mcr p15, 0, r0, c6,	c0		@ enable region 0, default
+	mov r0, #0x00000037			@ (base = 0, size = 256MB, cacheable, write buffered)
+	mcr p15, 0, r0, c6,	c1		@enable region 1, RAM
+	mov r0, #0x20000000
+	add r0, r0, #0x37			@ (base = 512MB, size = 256MB, cacheable, write buffered)
+	mcr p15, 0, r0, c6,	c2		@enable region 2, ROM/Flash
+
+	mov r0, #0x06				
+	mcr p15, 0, r0, c2, c0		@ Region 1&2 cacheable
+	mov r0, #0x02			
+	mcr p15, 0, r0, c3, c0		@ Region 1 write buferred
+
+	mov r0, #0xff00
+	add r0, r0, #0x00ff
+	mcr p15, 0, r0, c5, c0		@ all read/write access
+
+	mrc	p15, 0, r0, c1, c0		@ get control register
+	orr r0, r0, #0x00030000		@ Split cache mode
+	orr	r0, r0, #0x0000000d		@ MPU, Cache, Write Buffer on
+	
+	mov	pc, lr				@ __ret (head-armv.S)
+		
+	.size	__arm740_setup, . - __arm740_setup	
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm740_processor_functions, #object
+ENTRY(arm740_processor_functions)
+	.word	cpu_arm740_data_abort
+	.word	cpu_arm740_proc_init
+	.word	cpu_arm740_proc_fin
+	.word	cpu_arm740_reset
+	.word   cpu_arm740_do_idle
+
+	.word	cpu_arm740_dcache_clean_area
+	.word	cpu_arm740_switch_mm
+	.size	arm740_processor_functions, . - arm740_processor_functions
+
+	.section ".rodata"	
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv4"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v4"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm740_name, #object
+cpu_arm740_name:
+	.ascii	"ARM740T"
+	.size	cpu_arm740_name, . - cpu_arm740_name
+
+	.align
+
+
+	.section ".proc.info", #alloc, #execinstr
+	.type	__arm740_proc_info,#object
+__arm740_proc_info:
+	.long	0x41807400
+	.long	0xfffffff0
+	.long	0x00000c1e			@ mmuflags
+	b	__arm740_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT
+	.long	cpu_arm740_name  
+	.long	arm740_processor_functions 
+	.long	v4_cache_fns			@ cache model
+	.size	__arm740_proc_info, . - __arm740_proc_info
+
+
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm920.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm920.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm920.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm920.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,430 @@
+/*
+ *  linux/arch/armnommu/mm/proc-arm920.S: MMU functions for ARM920
+ *
+ *  Copyright (C) 1999,2000 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * These are the low level assembler for performing cache
+ * functions on the arm920.
+ *
+ *  CONFIG_CPU_ARM920_CPU_IDLE -> nohlt
+ */
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+/*
+ * The size of one data cache line.
+ */
+#define CACHE_DLINESIZE	32
+
+/*
+ * The number of data cache segments.
+ */
+#define CACHE_DSEGMENTS	8
+
+/*
+ * The number of lines in a cache segment.
+ */
+#define CACHE_DENTRIES	64
+
+/*
+ * This is the size at which it becomes more efficient to
+ * clean the whole cache, rather than using the individual
+ * cache line maintainence instructions.
+ */
+#define CACHE_DLIMIT	65536
+
+
+	.text
+/*
+ * cpu_arm920_proc_init()
+ */
+ENTRY(cpu_arm920_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm920_proc_fin()
+ */
+ENTRY(cpu_arm920_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	bl	arm920_flush_kern_cache_all
+#else
+	bl	v4wt_flush_kern_cache_all
+#endif
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm920_reset(loc)
+ *
+ * Perform a soft reset of the system.  Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+	.align	5
+ENTRY(cpu_arm920_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+ 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f			@ ............wcam
+	bic	ip, ip, #0x1100			@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * cpu_arm920_do_idle()
+ */
+	.align	5
+ENTRY(cpu_arm920_do_idle)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+	mov	pc, lr
+
+
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+
+/*
+ *	flush_user_cache_all()
+ *
+ *	Invalidate all cache entries in a particular address
+ *	space.
+ */
+ENTRY(arm920_flush_user_cache_all)
+	/* FALLTHROUGH */
+
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(arm920_flush_kern_cache_all)
+	mov	r2, #VM_EXEC
+	mov	ip, #0
+__flush_whole_cache:
+	mov	r1, #(CACHE_DSEGMENTS - 1) << 5	@ 8 segments
+1:	orr	r3, r1, #(CACHE_DENTRIES - 1) << 26 @ 64 entries
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean+invalidate D index
+	subs	r3, r3, #1 << 26
+	bcs	2b				@ entries 63 to 0
+	subs	r1, r1, #1 << 5
+	bcs	1b				@ segments 7 to 0
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Invalidate a range of cache entries in the specified
+ *	address space.
+ *
+ *	- start	- start address (inclusive)
+ *	- end	- end address (exclusive)
+ *	- flags	- vm_flags for address space
+ */
+ENTRY(arm920_flush_user_cache_range)
+	mov	ip, #0
+	sub	r3, r1, r0			@ calculate total size
+	cmp	r3, #CACHE_DLIMIT
+	bhs	__flush_whole_cache
+
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start, end.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm920_coherent_kern_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- addr	- page aligned address
+ */
+ENTRY(arm920_flush_kern_dcache_page)
+	add	r1, r0, #PAGE_SZ
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm920_dma_inv_range)
+	tst	r0, #CACHE_DLINESIZE - 1
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
+1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm920_dma_clean_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm920_dma_flush_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+ENTRY(arm920_cache_fns)
+	.long	arm920_flush_kern_cache_all
+	.long	arm920_flush_user_cache_all
+	.long	arm920_flush_user_cache_range
+	.long	arm920_coherent_kern_range
+	.long	arm920_flush_kern_dcache_page
+	.long	arm920_dma_inv_range
+	.long	arm920_dma_clean_range
+	.long	arm920_dma_flush_range
+
+#endif
+
+
+ENTRY(cpu_arm920_dcache_clean_area)
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+	mov	pc, lr
+
+/* =============================== PageTable ============================== */
+
+/*
+ * cpu_arm920_switch_mm(pgd)
+ *
+ * Set the translation base pointer to be as described by pgd.
+ *
+ * pgd: new page tables
+ */
+	.align	5
+ENTRY(cpu_arm920_switch_mm)
+	mov	ip, #0
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
+#else
+@ && 'Clean & Invalidate whole DCache'
+@ && Re-written to use Index Ops.
+@ && Uses registers r1, r3 and ip
+
+	mov	r1, #(CACHE_DSEGMENTS - 1) << 5	@ 8 segments
+1:	orr	r3, r1, #(CACHE_DENTRIES - 1) << 26 @ 64 entries
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean & invalidate D index
+	subs	r3, r3, #1 << 26
+	bcs	2b				@ entries 63 to 0
+	subs	r1, r1, #1 << 5
+	bcs	1b				@ segments 7 to 0
+#endif
+	mcr	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+ 	mov	pc, lr
+
+
+	__INIT
+
+	.type	__arm920_setup, #function
+__arm920_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+ 	mrc	p15, 0, r0, c1, c0		@ get control register v4
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+						@   VI ZFRS BLDP WCAM
+	bic	r0, r0, #0x0e00
+	bic	r0, r0, #0x0002
+	bic	r0, r0, #0x000c
+	bic	r0, r0, #0x1000			@ ...0 000. .... 000.
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	orr	r0, r0, #0x0031			@ if we need MMU on for
+						@ d-cache, it would be
+#else						@ enabled.
+	orr	r0, r0, #0x0030
+#endif
+	orr	r0, r0, #0x2100			@ ..1. ...1 ..11 ...1
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	orr	r0, r0, #0x0004			@ .... .... .... .1..
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	orr	r0, r0, #0x1000			@ ...1 .... .... ....
+#endif
+	mov	pc, lr
+	.size	__arm920_setup, . - __arm920_setup
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm920_processor_functions, #object
+arm920_processor_functions:
+	.word	v4t_early_abort
+	.word	cpu_arm920_proc_init
+	.word	cpu_arm920_proc_fin
+	.word	cpu_arm920_reset
+	.word   cpu_arm920_do_idle
+	.word	cpu_arm920_dcache_clean_area
+	.word	cpu_arm920_switch_mm
+	.size	arm920_processor_functions, . - arm920_processor_functions
+
+	.section ".rodata"
+
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv4t"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v4"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm920_name, #object
+cpu_arm920_name:
+	.ascii	"ARM920T"
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	.ascii	"i"
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	.ascii	"d"
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.ascii	"(wt)"
+#else
+	.ascii	"(wb)"
+#endif
+#endif
+	.ascii	"\0"
+	.size	cpu_arm920_name, . - cpu_arm920_name
+
+	.align
+
+	.section ".proc.info", #alloc, #execinstr
+
+	.type	__arm920_proc_info,#object
+__arm920_proc_info:
+	.long	0x41009200
+	.long	0xff00fff0
+	.long	0x00000c1e			@ mmuflags
+	b	__arm920_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
+	.long	cpu_arm920_name
+	.long	arm920_processor_functions
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.long	arm920_cache_fns
+#else
+	.long	v4wt_cache_fns
+#endif
+	.size	__arm920_proc_info, . - __arm920_proc_info
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm922.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm922.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm922.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm922.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,434 @@
+/*
+ *  linux/arch/armnommu/mm/proc-arm922.S: MMU functions for ARM922
+ *
+ *  Copyright (C) 1999,2000 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2001 Altera Corporation
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * These are the low level assembler for performing cache
+ * functions on the arm922.
+ *
+ *  CONFIG_CPU_ARM922_CPU_IDLE -> nohlt
+ */
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+/*
+ * The size of one data cache line.
+ */
+#define CACHE_DLINESIZE	32
+
+/*
+ * The number of data cache segments.
+ */
+#define CACHE_DSEGMENTS	4
+
+/*
+ * The number of lines in a cache segment.
+ */
+#define CACHE_DENTRIES	64
+
+/*
+ * This is the size at which it becomes more efficient to
+ * clean the whole cache, rather than using the individual
+ * cache line maintainence instructions.  (I think this should
+ * be 32768).
+ */
+#define CACHE_DLIMIT	8192
+
+
+	.text
+/*
+ * cpu_arm922_proc_init()
+ */
+ENTRY(cpu_arm922_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm922_proc_fin()
+ */
+ENTRY(cpu_arm922_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	bl	arm922_flush_kern_cache_all
+#else
+	bl	v4wt_flush_kern_cache_all
+#endif
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm922_reset(loc)
+ *
+ * Perform a soft reset of the system.  Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+	.align	5
+ENTRY(cpu_arm922_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f			@ ............wcam
+	bic	ip, ip, #0x1100			@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * cpu_arm922_do_idle()
+ */
+	.align	5
+ENTRY(cpu_arm922_do_idle)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+	mov	pc, lr
+
+
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+
+/*
+ *	flush_user_cache_all()
+ *
+ *	Clean and invalidate all cache entries in a particular
+ *	address space.
+ */
+ENTRY(arm922_flush_user_cache_all)
+	/* FALLTHROUGH */
+
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(arm922_flush_kern_cache_all)
+	mov	r2, #VM_EXEC
+	mov	ip, #0
+__flush_whole_cache:
+	mov	r1, #(CACHE_DSEGMENTS - 1) << 5	@ 8 segments
+1:	orr	r3, r1, #(CACHE_DENTRIES - 1) << 26 @ 64 entries
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean+invalidate D index
+	subs	r3, r3, #1 << 26
+	bcs	2b				@ entries 63 to 0
+	subs	r1, r1, #1 << 5
+	bcs	1b				@ segments 7 to 0
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Clean and invalidate a range of cache entries in the
+ *	specified address range.
+ *
+ *	- start	- start address (inclusive)
+ *	- end	- end address (exclusive)
+ *	- flags	- vm_flags describing address space
+ */
+ENTRY(arm922_flush_user_cache_range)
+	mov	ip, #0
+	sub	r3, r1, r0			@ calculate total size
+	cmp	r3, #CACHE_DLIMIT
+	bhs	__flush_whole_cache
+
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start, end.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm922_coherent_kern_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- addr	- page aligned address
+ */
+ENTRY(arm922_flush_kern_dcache_page)
+	add	r1, r0, #PAGE_SZ
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm922_dma_inv_range)
+	tst	r0, #CACHE_DLINESIZE - 1
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
+1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm922_dma_clean_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm922_dma_flush_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+ENTRY(arm922_cache_fns)
+	.long	arm922_flush_kern_cache_all
+	.long	arm922_flush_user_cache_all
+	.long	arm922_flush_user_cache_range
+	.long	arm922_coherent_kern_range
+	.long	arm922_flush_kern_dcache_page
+	.long	arm922_dma_inv_range
+	.long	arm922_dma_clean_range
+	.long	arm922_dma_flush_range
+
+#endif
+
+
+ENTRY(cpu_arm922_dcache_clean_area)
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+#endif
+	mov	pc, lr
+
+/* =============================== PageTable ============================== */
+
+/*
+ * cpu_arm922_switch_mm(pgd)
+ *
+ * Set the translation base pointer to be as described by pgd.
+ *
+ * pgd: new page tables
+ */
+	.align	5
+ENTRY(cpu_arm922_switch_mm)
+	mov	ip, #0
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
+#else
+@ && 'Clean & Invalidate whole DCache'
+@ && Re-written to use Index Ops.
+@ && Uses registers r1, r3 and ip
+
+	mov	r1, #(CACHE_DSEGMENTS - 1) << 5	@ 4 segments
+1:	orr	r3, r1, #(CACHE_DENTRIES - 1) << 26 @ 64 entries
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean & invalidate D index
+	subs	r3, r3, #1 << 26
+	bcs	2b				@ entries 63 to 0
+	subs	r1, r1, #1 << 5
+	bcs	1b				@ segments 7 to 0
+#endif
+	mcr	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+
+	__INIT
+
+	.type	__arm922_setup, #function
+__arm922_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+	mrc	p15, 0, r0, c1, c0		@ get control register v4
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+						@   VI ZFRS BLDP WCAM
+	bic	r0, r0, #0x0e00
+	bic	r0, r0, #0x0002
+	bic	r0, r0, #0x000c
+	bic	r0, r0, #0x1000			@ ...0 000. .... 000.
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	orr	r0, r0, #0x0031			@ if we need MMU on for
+						@ d-cache, it would be
+#else						@ enabled.
+	orr	r0, r0, #0x0030
+#endif
+	orr	r0, r0, #0x2100			@ ..1. ...1 ..11 ...1
+
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	orr	r0, r0, #0x0004			@ .... .... .... .1..
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	orr	r0, r0, #0x1000			@ ...1 .... .... ....
+#endif
+	mov	pc, lr
+	.size	__arm922_setup, . - __arm922_setup
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm922_processor_functions, #object
+arm922_processor_functions:
+	.word	v4t_early_abort
+	.word	cpu_arm922_proc_init
+	.word	cpu_arm922_proc_fin
+	.word	cpu_arm922_reset
+	.word   cpu_arm922_do_idle
+	.word	cpu_arm922_dcache_clean_area
+	.word	cpu_arm922_switch_mm
+	.size	arm922_processor_functions, . - arm922_processor_functions
+
+	.section ".rodata"
+
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv4t"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v4"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm922_name, #object
+cpu_arm922_name:
+	.ascii	"ARM922T"
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	.ascii	"i"
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	.ascii	"d"
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.ascii	"(wt)"
+#else
+	.ascii	"(wb)"
+#endif
+#endif
+	.ascii	"\0"
+	.size	cpu_arm922_name, . - cpu_arm922_name
+
+	.align
+
+	.section ".proc.info", #alloc, #execinstr
+
+	.type	__arm922_proc_info,#object
+__arm922_proc_info:
+	.long	0x41009220
+	.long	0xff00fff0
+	.long	0x00000c1e			@ mmuflags
+	b	__arm922_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
+	.long	cpu_arm922_name
+	.long	arm922_processor_functions
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.long	arm922_cache_fns
+#else
+	.long	v4wt_cache_fns
+#endif
+	.size	__arm922_proc_info, . - __arm922_proc_info
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm925.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm925.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm925.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm925.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,510 @@
+/*
+ *  linux/arch/arm/mm/arm925.S: MMU functions for ARM925
+ *
+ *  Copyright (C) 1999,2000 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2002 RidgeRun, Inc.
+ *  Copyright (C) 2002-2003 MontaVista Software, Inc.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
+ *
+ *  Update for Linux-2.6 and cache flush improvements
+ *  Copyright (C) 2004 Nokia Corporation by Tony Lindgren <tony@atomide.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * These are the low level assembler for performing cache
+ * functions on the arm925.
+ *
+ *  CONFIG_CPU_ARM925_CPU_IDLE -> nohlt
+ *
+ * Some additional notes based on deciphering the TI TRM on OMAP-5910:
+ *
+ * NOTE1: The TI925T Configuration Register bit "D-cache clean and flush
+ *	  entry mode" must be 0 to flush the entries in both segments
+ *	  at once. This is the default value. See TRM 2-20 and 2-24 for
+ *	  more information.
+ *
+ * NOTE2: Default is the "D-cache clean and flush entry mode". It looks
+ *	  like the "Transparent mode" must be on for partial cache flushes
+ *	  to work in this mode. This mode only works with 16-bit external
+ *	  memory. See TRM 2-24 for more information.
+ *
+ * NOTE3: Write-back cache flushing seems to be flakey with devices using
+ *        direct memory access, such as USB OHCI. The workaround is to use
+ *        write-through cache with CONFIG_CPU_DCACHE_WRITETHROUGH (this is
+ *        the default for OMAP-1510).
+ */
+
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+/*
+ * The size of one data cache line.
+ */
+#define CACHE_DLINESIZE	16
+
+/*
+ * The number of data cache segments.
+ */
+#define CACHE_DSEGMENTS	2
+
+/*
+ * The number of lines in a cache segment.
+ */
+#define CACHE_DENTRIES	256
+
+/*
+ * This is the size at which it becomes more efficient to
+ * clean the whole cache, rather than using the individual
+ * cache line maintainence instructions.
+ */
+#define CACHE_DLIMIT	8192
+
+	.text
+/*
+ * cpu_arm925_proc_init()
+ */
+ENTRY(cpu_arm925_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm925_proc_fin()
+ */
+ENTRY(cpu_arm925_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+	bl	arm925_flush_kern_cache_all
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm925_reset(loc)
+ *
+ * Perform a soft reset of the system.  Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+	.align	5
+ENTRY(cpu_arm925_reset)
+	/* Send software reset to MPU and DSP */
+	mov	ip, #0xff000000
+	orr	ip, ip, #0x00fe0000
+	orr	ip, ip, #0x0000ce00
+	mov	r4, #1
+	strh	r4, [ip, #0x10]
+
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f			@ ............wcam
+	bic	ip, ip, #0x1100			@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * cpu_arm925_do_idle()
+ *
+ * Called with IRQs disabled
+ */
+	.align	10
+ENTRY(cpu_arm925_do_idle)
+	mov	r0, #0
+	mrc	p15, 0, r1, c1, c0, 0		@ Read control register
+	mcr	p15, 0, r0, c7, c10, 4		@ Drain write buffer
+	bic	r2, r1, #1 << 12
+	mcr	p15, 0, r2, c1, c0, 0		@ Disable I cache
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+	mcr	p15, 0, r1, c1, c0, 0		@ Restore ICache enable
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_all()
+ *
+ *	Clean and invalidate all cache entries in a particular
+ *	address space.
+ */
+ENTRY(arm925_flush_user_cache_all)
+	/* FALLTHROUGH */
+
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(arm925_flush_kern_cache_all)
+	mov	r2, #VM_EXEC
+	mov	ip, #0
+__flush_whole_cache:
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
+#else
+	/* Flush entries in both segments at once, see NOTE1 above */
+	mov	r3, #(CACHE_DENTRIES - 1) << 4	@ 256 entries in segment
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean+invalidate D index
+	subs	r3, r3, #1 << 4
+	bcs	2b				@ entries 255 to 0
+#endif
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Clean and invalidate a range of cache entries in the
+ *	specified address range.
+ *
+ *	- start	- start address (inclusive)
+ *	- end	- end address (exclusive)
+ *	- flags	- vm_flags describing address space
+ */
+ENTRY(arm925_flush_user_cache_range)
+	mov	ip, #0
+	sub	r3, r1, r0			@ calculate total size
+	cmp	r3, #CACHE_DLIMIT
+	bgt	__flush_whole_cache
+1:	tst	r2, #VM_EXEC
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+#else
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D entry
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D entry
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+#endif
+	cmp	r0, r1
+	blo	1b
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start, end.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm925_coherent_kern_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- addr	- page aligned address
+ */
+ENTRY(arm925_flush_kern_dcache_page)
+	add	r1, r0, #PAGE_SZ
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm925_dma_inv_range)
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	tst	r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
+#endif
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm925_dma_clean_range)
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm925_dma_flush_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+#else
+	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+#endif
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+ENTRY(arm925_cache_fns)
+	.long	arm925_flush_kern_cache_all
+	.long	arm925_flush_user_cache_all
+	.long	arm925_flush_user_cache_range
+	.long	arm925_coherent_kern_range
+	.long	arm925_flush_kern_dcache_page
+	.long	arm925_dma_inv_range
+	.long	arm925_dma_clean_range
+	.long	arm925_dma_flush_range
+
+ENTRY(cpu_arm925_dcache_clean_area)
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+#endif
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/* =============================== PageTable ============================== */
+
+/*
+ * cpu_arm925_switch_mm(pgd)
+ *
+ * Set the translation base pointer to be as described by pgd.
+ *
+ * pgd: new page tables
+ */
+	.align	5
+ENTRY(cpu_arm925_switch_mm)
+	mov	ip, #0
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
+#else
+	/* Flush entries in bothe segments at once, see NOTE1 above */
+	mov	r3, #(CACHE_DENTRIES - 1) << 4	@ 256 entries in segment
+2:	mcr	p15, 0, r3, c7, c14, 2		@ clean & invalidate D index
+	subs	r3, r3, #1 << 4
+	bcs	2b				@ entries 255 to 0
+#endif
+	mcr	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+
+	__INIT
+
+	.type	__arm925_setup, #function
+__arm925_setup:
+	mov	r0, #0
+#if defined(CONFIG_CPU_ICACHE_STREAMING_DISABLE)
+        orr     r0,r0,#1 << 7
+#endif
+
+	/* Transparent on, D-cache clean & flush mode. See  NOTE2 above */
+        orr     r0,r0,#1 << 1			@ transparent mode on
+        mcr     p15, 0, r0, c15, c1, 0          @ write TI config register
+
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mov	r0, #4				@ disable write-back on caches explicitly
+	mcr	p15, 7, r0, c15, c0, 0
+#endif
+
+	mrc	p15, 0, r0, c1, c0		@ get control register v4
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+						@   VI ZFRS BLDP WCAM
+	bic	r0, r0, #0x0e00
+	bic	r0, r0, #0x0002
+	bic	r0, r0, #0x000c
+	bic	r0, r0, #0x1000			@ ...0 000. .... 000.
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	orr	r0, r0, #0x0031			@ if we need MMU on for
+						@ d-cache, it would be
+#else						@ enabled.
+	orr	r0, r0, #0x0030
+#endif
+	orr	r0, r0, #0x2100			@ ..1. ...1 ..11 ...1
+
+	/* Writebuffer on */
+	orr	r0, r0, #0x0008			@ .... .... .... 1...
+
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	orr	r0, r0, #0x4000			@ .1.. .... .... ....
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	orr	r0, r0, #0x0004			@ .... .... .... .1..
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	orr	r0, r0, #0x1000			@ ...1 .... .... ....
+#endif
+	mov	pc, lr
+	.size	__arm925_setup, . - __arm925_setup
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm925_processor_functions, #object
+arm925_processor_functions:
+	.word	v4t_early_abort
+	.word	cpu_arm925_proc_init
+	.word	cpu_arm925_proc_fin
+	.word	cpu_arm925_reset
+	.word   cpu_arm925_do_idle
+	.word	cpu_arm925_dcache_clean_area
+	.word	cpu_arm925_switch_mm
+	.size	arm925_processor_functions, . - arm925_processor_functions
+
+	.section ".rodata"
+
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv4t"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v4"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm925_name, #object
+cpu_arm925_name:
+	.ascii	"ARM925T"
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	.ascii	"i"
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	.ascii	"d"
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.ascii	"(wt)"
+#else
+	.ascii	"(wb)"
+#endif
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	.ascii	"RR"
+#endif
+#endif
+	.ascii	"\0"
+	.size	cpu_arm925_name, . - cpu_arm925_name
+
+	.align
+
+	.section ".proc.info", #alloc, #execinstr
+
+	.type	__arm925_proc_info,#object
+__arm925_proc_info:
+	.long	0x54029250
+	.long	0xfffffff0
+	.long	0x00000c12			@ mmuflags
+	b	__arm925_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
+	.long	cpu_arm925_name
+	.long	arm925_processor_functions
+	.long	arm925_cache_fns
+	.size	__arm925_proc_info, . - __arm925_proc_info
+
+	.type	__arm915_proc_info,#object
+__arm915_proc_info:
+	.long	0x54029150
+	.long	0xfffffff0
+	.long	0x00000c12			@ mmuflags
+	b	__arm925_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB
+	.long	cpu_arm925_name
+	.long	arm925_processor_functions
+	.long	arm925_cache_fns
+	.size	__arm925_proc_info, . - __arm925_proc_info
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm926.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm926.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm926.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm926.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,445 @@
+/*
+ *  linux/arch/armnommu/mm/proc-arm926.S: MMU functions for ARM926EJ-S
+ *
+ *  Copyright (C) 1999-2001 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *  modified for NON-PAGED MMU version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * These are the low level assembler for performing cache
+ * functions on the arm926.
+ *
+ *  CONFIG_CPU_ARM926_CPU_IDLE -> nohlt
+ */
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+/*
+ * This is the maximum size of an area which will be invalidated
+ * using the single invalidate entry instructions.  Anything larger
+ * than this, and we go for the whole cache.
+ *
+ * This value should be chosen such that we choose the cheapest
+ * alternative.
+ */
+#define CACHE_DLIMIT	16384
+
+/*
+ * the cache line size of the I and D cache
+ */
+#define CACHE_DLINESIZE	32
+
+	.text
+/*
+ * cpu_arm926_proc_init()
+ */
+ENTRY(cpu_arm926_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm926_proc_fin()
+ */
+ENTRY(cpu_arm926_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+	bl	arm926_flush_kern_cache_all
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm926_reset(loc)
+ *
+ * Perform a soft reset of the system.  Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+	.align	5
+ENTRY(cpu_arm926_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f			@ ............wcam
+	bic	ip, ip, #0x1100			@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * cpu_arm926_do_idle()
+ *
+ * Called with IRQs disabled
+ */
+	.align	10
+ENTRY(cpu_arm926_do_idle)
+	mov	r0, #0
+	mrc	p15, 0, r1, c1, c0, 0		@ Read control register
+	mcr	p15, 0, r0, c7, c10, 4		@ Drain write buffer
+	bic	r2, r1, #1 << 12
+	mcr	p15, 0, r2, c1, c0, 0		@ Disable I cache
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+	mcr	p15, 0, r1, c1, c0, 0		@ Restore ICache enable
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_all()
+ *
+ *	Clean and invalidate all cache entries in a particular
+ *	address space.
+ */
+ENTRY(arm926_flush_user_cache_all)
+	/* FALLTHROUGH */
+
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(arm926_flush_kern_cache_all)
+	mov	r2, #VM_EXEC
+	mov	ip, #0
+__flush_whole_cache:
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
+#else
+1:	mrc	p15, 0, r15, c7, c14, 3 	@ test,clean,invalidate
+	bne	1b
+#endif
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Clean and invalidate a range of cache entries in the
+ *	specified address range.
+ *
+ *	- start	- start address (inclusive)
+ *	- end	- end address (exclusive)
+ *	- flags	- vm_flags describing address space
+ */
+ENTRY(arm926_flush_user_cache_range)
+	mov	ip, #0
+	sub	r3, r1, r0			@ calculate total size
+	cmp	r3, #CACHE_DLIMIT
+	bgt	__flush_whole_cache
+1:	tst	r2, #VM_EXEC
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+#else
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D entry
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D entry
+	mcrne	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+#endif
+	cmp	r0, r1
+	blo	1b
+	tst	r2, #VM_EXEC
+	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start, end.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm926_coherent_kern_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- addr	- page aligned address
+ */
+ENTRY(arm926_flush_kern_dcache_page)
+	add	r1, r0, #PAGE_SZ
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm926_dma_inv_range)
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	tst	r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
+#endif
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ *
+ * (same as v4wb)
+ */
+ENTRY(arm926_dma_clean_range)
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+#endif
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm926_dma_flush_range)
+	bic	r0, r0, #CACHE_DLINESIZE - 1
+1:
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
+#else
+	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+#endif
+	add	r0, r0, #CACHE_DLINESIZE
+	cmp	r0, r1
+	blo	1b
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+ENTRY(arm926_cache_fns)
+	.long	arm926_flush_kern_cache_all
+	.long	arm926_flush_user_cache_all
+	.long	arm926_flush_user_cache_range
+	.long	arm926_coherent_kern_range
+	.long	arm926_flush_kern_dcache_page
+	.long	arm926_dma_inv_range
+	.long	arm926_dma_clean_range
+	.long	arm926_dma_flush_range
+
+ENTRY(cpu_arm926_dcache_clean_area)
+#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+#endif
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+/* =============================== PageTable ============================== */
+
+/*
+ * cpu_arm926_switch_mm(pgd)
+ *
+ * Set the translation base pointer to be as described by pgd.
+ *
+ * pgd: new page tables
+ */
+	.align	5
+ENTRY(cpu_arm926_switch_mm)
+	mov	ip, #0
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mcr	p15, 0, ip, c7, c6, 0		@ invalidate D cache
+#else
+@ && 'Clean & Invalidate whole DCache'
+1:	mrc	p15, 0, r15, c7, c14, 3 	@ test,clean,invalidate
+	bne	1b
+#endif
+	mcr	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
+
+	__INIT
+
+	.type	__arm926_setup, #function
+__arm926_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7		@ invalidate I,D caches on v4
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer on v4
+
+
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	mov	r0, #4				@ disable write-back on caches explicitly
+	mcr	p15, 7, r0, c15, c0, 0
+#endif 
+
+	mov	r0, #0x1f			@ Domains 0, 1 = client
+	mcr	p15, 0, r0, c3, c0		@ load domain access register
+	mrc	p15, 0, r0, c1, c0		@ get control register v4
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+						@   VI ZFRS BLDP WCAM
+	bic	r0, r0, #0x0e00
+	bic	r0, r0, #0x0002
+	bic	r0, r0, #0x000c
+	bic	r0, r0, #0x1000			@ ...0 000. .... 000.
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	orr	r0, r0, #0x0031			@ if we need MMU on for
+						@ d-cache, it would be
+#else						@ enabled.
+	orr	r0, r0, #0x0030
+#endif
+	orr	r0, r0, #0x2100			@ ..1. ...1 ..11 ...1
+
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	orr	r0, r0, #0x4000			@ .1.. .... .... ....
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	orr	r0, r0, #0x0004			@ .... .... .... .1..
+#endif
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	orr	r0, r0, #0x1000			@ ...1 .... .... ....
+#endif
+	mov	pc, lr
+	.size	__arm926_setup, . - __arm926_setup
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm926_processor_functions, #object
+arm926_processor_functions:
+	.word	v5tj_early_abort
+	.word	cpu_arm926_proc_init
+	.word	cpu_arm926_proc_fin
+	.word	cpu_arm926_reset
+	.word	cpu_arm926_do_idle
+	.word	cpu_arm926_dcache_clean_area
+	.word	cpu_arm926_switch_mm
+	.size	arm926_processor_functions, . - arm926_processor_functions
+
+	.section ".rodata"
+
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv5tej"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v5"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm926_name, #object
+cpu_arm926_name:
+	.ascii	"ARM926EJ-S"
+#ifndef CONFIG_CPU_ICACHE_DISABLE
+	.ascii	"i"
+#endif
+#ifndef CONFIG_CPU_DCACHE_DISABLE
+	.ascii	"d"
+#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
+	.ascii	"(wt)"
+#else
+	.ascii	"(wb)"
+#endif
+#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
+	.ascii	"RR"
+#endif
+#endif
+	.ascii	"\0"
+	.size	cpu_arm926_name, . - cpu_arm926_name
+
+	.align
+
+	.section ".proc.info", #alloc, #execinstr
+
+	.type	__arm926_proc_info,#object
+__arm926_proc_info:
+	.long	0x41069260			@ ARM926EJ-S (v5TEJ)
+	.long	0xff0ffff0
+	.long	0x00000c1e			@ mmuflags
+	b	__arm926_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB | HWCAP_FAST_MULT | HWCAP_JAVA
+	.long	cpu_arm926_name
+	.long	arm926_processor_functions
+	.long	arm926_cache_fns
+	.size	__arm926_proc_info, . - __arm926_proc_info
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm940.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm940.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm940.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm940.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,216 @@
+/*
+ *  linux/arch/armnommu/mm/arm940.S: MPU functions for ARM940
+ *  2001 Minspeed
+ * 
+ *  2004/03/22  modified for 2.6 kernel by heechul.yun@samsung.com 
+ *  2004/04/20  clean-up by Hyok S. Choi
+ */
+	
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>	
+#include <asm/assembler.h>
+#include <asm/pgtable.h>	
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>	
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+	/* FIXME - this is also defined in cache-v4wb.S */ 
+#define CACHE_DSIZE	4096	/* 4K */
+#define CACHE_DLINESIZE	16	/* 4word */
+#define CACHE_DLIMIT	(CACHE_DSIZE * 4)
+
+/*
+ * cpu_arm940_data_abort()
+ *
+ * obtain information about current aborted instruction
+ *
+ * r0 = address of aborted instruction
+ *
+ * Returns:
+ *  r0 = address of abort
+ *  r1 != 0 if writing
+ *  r3 = FSR
+ */
+	.align	5
+ENTRY(cpu_arm940_data_abort)
+	ldr	r1, [r0]			@ read aborted instruction
+	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
+	tst	r1, r1, lsr #21			@ C = bit 20
+	mrc	p15, 0, r3, c5, c0, 0		@ get FSR
+	sbc	r1, r1, r1			@ r1 = C - 1
+	and	r3, r3, #255
+	mov	pc, lr
+
+/*
+ * cpu_arm940_check_bugs()
+ */
+ENTRY(cpu_arm940_check_bugs)
+	mrs	ip, cpsr
+	bic	ip, ip, #PSR_F_BIT
+	msr	cpsr, ip
+	mov	pc, lr
+
+/*
+ * cpu_arm940_proc_init()
+ *	
+ *  setup_processor()  - setup.c
+ *  +-> cpu_proc_init() - cpu-multi32.h --> proc-arm940.S
+ *	
+ *  TODO: cp15 initialization code can be placed here - hcyun 
+ */
+ENTRY(cpu_arm940_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm940_proc_fin()
+ */
+ENTRY(cpu_arm940_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+#if defined(CONFIG_CPU_CACHE_V4WT)
+	bl	v4wt_flush_kern_cache_all	@ write-through
+#elif defined(CONFIG_CPU_CACHE_V4WB)
+	bl	v4wb_flush_kern_cache_all	@ write-back
+#endif /* CONFIG_CPU_CACHE_V4WT */
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm940_reset(loc)
+ *
+ * Perform a soft reset of the system.  Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+ENTRY(cpu_arm940_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f			@ ............wcam
+	bic	ip, ip, #0x1100			@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * idle mode processing 
+ */
+ENTRY(cpu_arm940_do_idle)  
+#if defined(CONFIG_CPU_ARM940_CPU_IDLE)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+#endif
+	mov	pc, lr
+
+/* 
+ * *FIXME* 
+ */ 	
+ENTRY(cpu_arm940_dcache_clean_area)
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+	mov	pc, lr
+/*
+ * Function: arm940_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, 
+ */	
+ENTRY(cpu_arm940_switch_mm)
+	mov	pc, lr	
+
+	
+	/* .section ".text.init", #alloc, #execinstr */ 
+	__INIT
+	
+__arm940_setup:
+	MRC     p15, 0, R0, c1, c0, 0		@ get control register
+		
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+	bic	r0, r0, #0x0e00			@ ....??r.........
+	bic	r0, r0, #0x0002			@ ..............a.
+	bic	r0, r0, #0x000c			@ W,D
+	bic	r0, r0, #0x1000			@ I
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	orr	r0, r0, #0x0001			@ Enable PU
+#else
+	bic	r0, r0, #0x0001			@ Disable PU
+#endif
+
+#ifdef CONFIG_CPU_ARM940_D_CACHE_ON
+	orr	r0, r0, #0x0004			@ Enable D cache
+#endif
+#ifdef CONFIG_CPU_ARM940_I_CACHE_ON
+	orr	r0, r0, #0x1000                 @ I Cache on
+#endif
+	mov	pc, lr
+	.size	__arm940_setup, . - __arm940_setup	
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm940_processor_functions, #object
+ENTRY(arm940_processor_functions)
+	.word	cpu_arm940_data_abort
+	.word	cpu_arm940_proc_init
+	.word	cpu_arm940_proc_fin
+	.word	cpu_arm940_reset
+	.word   cpu_arm940_do_idle
+
+	.word	cpu_arm940_dcache_clean_area
+	.word	cpu_arm940_switch_mm
+	.size	arm940_processor_functions, . - arm940_processor_functions
+
+	.section ".rodata"	
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv4t"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v4"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm940_name, #object
+cpu_arm940_name:
+	.ascii	"ARM940T"
+	.size	cpu_arm940_name, . - cpu_arm940_name
+
+	.align
+
+
+	.section ".proc.info", #alloc, #execinstr
+	.type	__arm940_proc_info,#object
+__arm940_proc_info:
+	.long	0x41009400
+	.long	0xff00fff0
+	.long	0x00000c1e			@ mmuflags
+	b	__arm940_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT
+	.long	cpu_arm940_name  
+	.long	arm940_processor_functions 
+#if defined(CONFIG_CPU_CACHE_V4WT)
+	.long	v4wt_cache_fns			@ cache model
+#elif defined(CONFIG_CPU_CACHE_V4WB)
+	.long	v4wb_cache_fns			@ cache model
+#endif /* CONFIG_CPU_CACHE_V4WT */
+	.size	__arm940_proc_info, . - __arm940_proc_info
+
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-arm946.S linux-2.6.9-uc0/arch/armnommu/mm/proc-arm946.S
--- linux-2.6.9/arch/armnommu/mm/proc-arm946.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-arm946.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,215 @@
+/*
+ *  linux/arch/armnommu/mm/arm946.S: MPU functions for ARM946E-S
+ * 
+ *  Copyright 2003, STMicroelectronics
+ *  Copyright 2004, Hyok S. Choi, for 2.6.
+ *
+ */
+	
+#include <linux/linkage.h>
+#include <linux/config.h>
+#include <linux/init.h>	
+#include <asm/assembler.h>
+#include <asm/pgtable.h>	
+#include <asm/procinfo.h>
+#include <asm/hardware.h>
+#include <asm/page.h>	
+#include <asm/ptrace.h>
+#include "proc-macros.S"
+
+
+	/* FIXME - this is also defined in cache-v4wb.S */ 
+#define CACHE_DSIZE	4096	/* 4K */
+#define CACHE_DLINESIZE	32	/* 8word */
+#define CACHE_DLIMIT	(CACHE_DSIZE * 4)
+
+/*
+ * cpu_arm946_data_abort()
+ *
+ * obtain information about current aborted instruction
+ *
+ * r0 = address of aborted instruction
+ *
+ * Returns:
+ *  r0 = address of abort
+ *  r1 != 0 if writing
+ *  r3 = FSR
+ */
+	.align	5
+ENTRY(cpu_arm946_data_abort)
+	ldr	r1, [r0]			@ read aborted instruction
+	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
+	tst	r1, r1, lsr #21			@ C = bit 20
+	mrc	p15, 0, r3, c5, c0, 0		@ get FSR
+	sbc	r1, r1, r1			@ r1 = C - 1
+	and	r3, r3, #255
+	mov	pc, lr
+
+/*
+ * cpu_arm946_check_bugs()
+ */
+ENTRY(cpu_arm946_check_bugs)
+	mrs	ip, cpsr
+	bic	ip, ip, #PSR_F_BIT
+	msr	cpsr, ip
+	mov	pc, lr
+
+/*
+ * cpu_arm946_proc_init()
+ */
+ENTRY(cpu_arm946_proc_init)
+	mov	pc, lr
+
+/*
+ * cpu_arm946_proc_fin()
+ */
+ENTRY(cpu_arm946_proc_fin)
+	stmfd	sp!, {lr}
+	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	msr	cpsr_c, ip
+#if defined(CONFIG_CPU_CACHE_V4WT)
+	bl	v4wt_flush_kern_cache_all	@ write-through
+#elif defined(CONFIG_CPU_CACHE_V4WB)
+	bl	v4wb_flush_kern_cache_all	@ write-back
+#endif /* CONFIG_CPU_CACHE_V4WT */
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	ldmfd	sp!, {pc}
+
+/*
+ * cpu_arm946_reset(loc)
+ *
+ * Perform a soft reset of the system.  Put the CPU into the
+ * same state as it would be if it had been reset, and branch
+ * to what would be the reset vector.
+ *
+ * loc: location to jump to for soft reset
+ */
+ENTRY(cpu_arm946_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
+	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
+	bic	ip, ip, #0x000f			@ ............wcam
+	bic	ip, ip, #0x1100			@ ...i...s........
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
+
+/*
+ * idle mode processing 
+ */
+ENTRY(cpu_arm946_do_idle)  
+#if defined(CONFIG_CPU_ARM946_CPU_IDLE)
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
+#endif
+	mov	pc, lr
+
+/* 
+ * *FIXME* 
+ */ 	
+ENTRY(cpu_arm946_dcache_clean_area)
+1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+	add	r0, r0, #CACHE_DLINESIZE
+	subs	r1, r1, #CACHE_DLINESIZE
+	bhi	1b
+	mov	pc, lr
+/*
+ * Function: arm946_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, 
+ */	
+ENTRY(cpu_arm946_switch_mm)
+/* FIXME: customized cache initialize here */
+/*	bl	custom_init_cache */ 
+	mov	pc, lr	
+
+	
+	/* .section ".text.init", #alloc, #execinstr */ 
+	__INIT
+	
+__arm946_setup:
+	MRC     p15, 0, R0, c1, c0, 0		@ get control register
+		
+/*
+ * Clear out 'unwanted' bits (then put them in if we need them)
+ */
+	bic	r0, r0, #0x0e00			@ ....??r.........
+	bic	r0, r0, #0x0002			@ ..............a.
+	bic	r0, r0, #0x000c			@ W,D
+	bic	r0, r0, #0x1000			@ I
+/*
+ * Turn on what we want
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	orr	r0, r0, #0x0001			@ Enable PU
+#else
+	bic	r0, r0, #0x0001			@ Disable PU
+#endif
+
+#ifdef CONFIG_CPU_ARM940_D_CACHE_ON
+	orr	r0, r0, #0x0004			@ Enable D cache
+#endif
+#ifdef CONFIG_CPU_ARM940_I_CACHE_ON
+	orr	r0, r0, #0x1000                 @ I Cache on
+#endif
+	mov	pc, lr
+	.size	__arm946_setup, . - __arm946_setup	
+
+	__INITDATA
+
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+	.type	arm946_processor_functions, #object
+ENTRY(arm946_processor_functions)
+	.word	cpu_arm946_data_abort
+	.word	cpu_arm946_proc_init
+	.word	cpu_arm946_proc_fin
+	.word	cpu_arm946_reset
+	.word   cpu_arm946_do_idle
+
+	.word	cpu_arm946_dcache_clean_area
+	.word	cpu_arm946_switch_mm
+	.size	arm946_processor_functions, . - arm946_processor_functions
+
+	.section ".rodata"	
+	.type	cpu_arch_name, #object
+cpu_arch_name:
+	.asciz	"armv5"
+	.size	cpu_arch_name, . - cpu_arch_name
+
+	.type	cpu_elf_name, #object
+cpu_elf_name:
+	.asciz	"v5"
+	.size	cpu_elf_name, . - cpu_elf_name
+
+	.type	cpu_arm946_name, #object
+cpu_arm946_name:
+	.ascii	"ARM946E"
+	.size	cpu_arm946_name, . - cpu_arm946_name
+
+	.align
+
+
+	.section ".proc.info", #alloc, #execinstr
+	.type	__arm946_proc_info,#object
+__arm946_proc_info:
+	.long	0x41009460
+	.long	0xff00fff0
+	.long	0x00000c1e			@ mmuflags
+	b	__arm946_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT
+	.long	cpu_arm946_name  
+	.long	arm946_processor_functions 
+#if defined(CONFIG_CPU_CACHE_V4WT)
+	.long	v4wt_cache_fns			@ cache model
+#elif defined(CONFIG_CPU_CACHE_V4WB)
+	.long	v4wb_cache_fns			@ cache model
+#endif /* CONFIG_CPU_CACHE_V4WT */
+	.size	__arm946_proc_info, . - __arm946_proc_info
+
+
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-macros.S linux-2.6.9-uc0/arch/armnommu/mm/proc-macros.S
--- linux-2.6.9/arch/armnommu/mm/proc-macros.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-macros.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,51 @@
+/*
+ * We need constants.h for:
+ *  VMA_VM_MM
+ *  VMA_VM_FLAGS
+ *  VM_EXEC
+ */
+#include <asm/constants.h>
+#include <asm/thread_info.h>
+
+/*
+ * vma_vm_mm - get mm pointer from vma pointer (vma->vm_mm)
+ */
+	.macro	vma_vm_mm, rd, rn
+	ldr	\rd, [\rn, #VMA_VM_MM]
+	.endm
+
+/*
+ * vma_vm_flags - get vma->vm_flags
+ */
+	.macro	vma_vm_flags, rd, rn
+	ldr	\rd, [\rn, #VMA_VM_FLAGS]
+	.endm
+
+	.macro	tsk_mm, rd, rn
+	ldr	\rd, [\rn, #TI_TASK]
+	ldr	\rd, [\rd, #TSK_ACTIVE_MM]
+	.endm
+
+/*
+ * act_mm - get current->active_mm
+ */
+	.macro	act_mm, rd
+	bic	\rd, sp, #8128
+	bic	\rd, \rd, #63
+	ldr	\rd, [\rd, #TI_TASK]
+	ldr	\rd, [\rd, #TSK_ACTIVE_MM]
+	.endm
+
+/*
+ * mmid - get context id from mm pointer (mm->context.id)
+ */
+	.macro	mmid, rd, rn
+	ldr	\rd, [\rn, #MM_CONTEXT_ID]
+	.endm
+
+/*
+ * mask_asid - mask the ASID from the context ID
+ */
+	.macro	asid, rd, rn
+	and	\rd, \rn, #255
+	.endm
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-s3c4510b.S linux-2.6.9-uc0/arch/armnommu/mm/proc-s3c4510b.S
--- linux-2.6.9/arch/armnommu/mm/proc-s3c4510b.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-s3c4510b.S	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,407 @@
+/*
+ *  linux/arch/armnommu/mm/proc-s3c4510b.S
+ *
+ *  Copyright (C) 1997-2000 Russell King
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *  Modified for s3c4510b cache
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/constants.h>
+#include <asm/pgtable.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/errno.h>
+#include <asm/hardware.h>
+	
+/*
+ *	flush_user_cache_all()
+ *
+ *	Invalidate all cache entries in a particular address
+ *	space.
+ *
+ *	- mm	- mm_struct describing address space
+ */
+ENTRY(s3c4510b_flush_user_cache_all)
+	/* FALLTHROUGH */
+/*
+ *	flush_kern_cache_all()
+ *
+ *	Clean and invalidate the entire cache.
+ */
+ENTRY(s3c4510b_flush_kern_cache_all)
+	/* FALLTHROUGH */
+
+/*
+ *	flush_user_cache_range(start, end, flags)
+ *
+ *	Invalidate a range of cache entries in the specified
+ *	address space.
+ *
+ *	- start - start address (may not be aligned)
+ *	- end	- end address (exclusive, may not be aligned)
+ *	- flags	- vma_area_struct flags describing address space
+ */
+ENTRY(s3c4510b_flush_user_cache_range)
+	/* save r5-r8 */
+	adr	ip, reg_save
+	stmia   ip, {r5-r8}
+	/* save current cache state */
+	ldr	r7, =REG_SYSCFG
+	ldr     r8, [r7]
+	/* disable cache */
+        ldr	r6, =0x83ffffa0
+	str	r6, [r7]
+	/* zero out the 1KB TAG RAM area starting @ 0x11000000 */
+	ldr	r7, =0x11000000
+	ldr     r6, =(0x11000000 + 1024)
+	ldr	r5, =0x0
+tag_zero:		
+	str     r5, [r7]
+	add     r7, r7, #4
+	cmp	r6, r7
+	bne     tag_zero
+	
+	/* restore previoux cache state */
+	ldr	r7, =REG_SYSCFG
+	str	r8, [r7]
+
+	/* restore r5-r8 */
+	ldmia	ip, {r5-r8}
+	
+	mov	pc, lr
+	
+reg_save:	
+	.long 0x0
+	.long 0x0
+	.long 0x0
+	.long 0x0
+
+/*
+ *	coherent_kern_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(s3c4510b_coherent_kern_range)
+	/* FALLTHROUGH */
+
+/*
+ *	flush_kern_dcache_page(void *page)
+ *
+ *	Ensure no D cache aliasing occurs, either with itself or
+ *	the I cache
+ *
+ *	- addr	- page aligned address
+ */
+ENTRY(s3c4510b_flush_kern_dcache_page)
+	/* FALLTHROUGH */
+
+/*
+ *	dma_inv_range(start, end)
+ *
+ *	Invalidate (discard) the specified virtual address range.
+ *	May not write back any entries.  If 'start' or 'end'
+ *	are not cache line aligned, those lines must be written
+ *	back.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(s3c4510b_dma_inv_range)
+	/* FALLTHROUGH */
+
+/*
+ *	dma_flush_range(start, end)
+ *
+ *	Clean and invalidate the specified virtual address range.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(s3c4510b_dma_flush_range)
+	/* FALLTHROUGH */
+
+/*
+ *	dma_clean_range(start, end)
+ *
+ *	Clean (write back) the specified virtual address range.
+ *
+ *	- start  - virtual start address
+ *	- end	 - virtual end address
+ */
+ENTRY(s3c4510b_dma_clean_range)
+	mov	r0, #0
+	mov	pc, lr
+
+ENTRY(cpu_arm7_dcache_clean_area)
+	mov	pc, lr  
+
+/*
+ * Function: arm6_7_data_abort ()
+ *
+ * Params  : r2 = address of aborted instruction
+ *	   : sp = pointer to registers
+ *
+ * Purpose : obtain information about current aborted instruction
+ *
+ * Returns : r0 = address of abort
+ *	   : r1 = FSR
+ */
+
+ENTRY(cpu_arm7_data_abort)
+@FIXME
+	ldr     r8, [r2]                        @ read arm instruction
+	tst     r8, #1 << 20                    @ L = 1 -> write?
+	and	r7, r8, #15 << 24
+	orr	r1, r7, #1
+	orreq   r1, r1, #1 << 8                 @ yes.
+	add	pc, pc, r7, lsr #22		@ Now branch to the relevant processing routine
+	nop
+
+/* 0 */	b	.data_unknown
+/* 1 */	mov	pc, lr				@ swp
+/* 2 */	b	.data_unknown
+/* 3 */	b	.data_unknown
+/* 4 */	b	.data_arm_lateldrpostconst	@ ldr	rd, [rn], #m
+/* 5 */	b	.data_arm_lateldrpreconst	@ ldr	rd, [rn, #m]
+/* 6 */	b	.data_arm_lateldrpostreg	@ ldr	rd, [rn], rm
+/* 7 */	b	.data_arm_lateldrprereg		@ ldr	rd, [rn, rm]
+/* 8 */	b	.data_arm_ldmstm		@ ldm*a	rn, <rlist>
+/* 9 */	b	.data_arm_ldmstm		@ ldm*b	rn, <rlist>
+/* a */	b	.data_unknown
+/* b */	b	.data_unknown
+/* c */	mov	pc, lr				@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
+/* d */	mov	pc, lr				@ ldc	rd, [rn, #m]
+/* e */	b	.data_unknown
+/* f */
+.data_unknown:	@ Part of jumptable
+	mov	r0, r2
+	mov	r1, r8
+	mov	r2, sp
+	bl	baddataabort
+	b	ret_from_exception
+
+ENTRY(cpu_arm6_data_abort)
+@FIXME
+	ldr	r8, [r2]			@ read arm instruction
+	tst	r8, #1 << 20			@ L = 1 -> write?
+	orreq	r1, r1, #1 << 8			@ yes.
+	and	r7, r8, #14 << 24
+	teq	r7, #8 << 24			@ was it ldm/stm
+	movne	pc, lr
+
+.data_arm_ldmstm:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+	mov	r7, #0x11
+	orr	r7, r7, #0x1100
+	and	r6, r8, r7
+	and	r2, r8, r7, lsl #1
+	add	r6, r6, r2, lsr #1
+	and	r2, r8, r7, lsl #2
+	add	r6, r6, r2, lsr #2
+	and	r2, r8, r7, lsl #3
+	add	r6, r6, r2, lsr #3
+	add	r6, r6, r6, lsr #8
+	add	r6, r6, r6, lsr #4
+	and	r6, r6, #15			@ r6 = no. of registers to transfer.
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6, lsl #2		@ Undo increment
+	addeq	r7, r7, r6, lsl #2		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_apply_r6_and_rn:
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r6			@ Undo incrmenet
+	addeq	r7, r7, r6			@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrpreconst:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostconst:
+	movs	r2, r8, lsl #20			@ Get offset
+	moveq	pc, lr				@ zero -> no fixup
+	and	r5, r8, #15 << 16		@ Extract 'n' from instruction
+	ldr	r7, [sp, r5, lsr #14]		@ Get register 'Rn'
+	tst	r8, #1 << 23			@ Check U bit
+	subne	r7, r7, r2, lsr #20		@ Undo increment
+	addeq	r7, r7, r2, lsr #20		@ Undo decrement
+	str	r7, [sp, r5, lsr #14]		@ Put register 'Rn'
+	mov	pc, lr
+
+.data_arm_lateldrprereg:
+	tst	r8, #1 << 21			@ check writeback bit
+	moveq	pc, lr				@ no writeback -> no fixup
+.data_arm_lateldrpostreg:
+	and	r7, r8, #15			@ Extract 'm' from instruction
+	ldr	r6, [sp, r7, lsl #2]		@ Get register 'Rm'
+	mov	r5, r8, lsr #7			@ get shift count
+	ands	r5, r5, #31
+	and	r7, r8, #0x70			@ get shift type
+	orreq	r7, r7, #8			@ shift count = 0
+	add	pc, pc, r7
+	nop
+
+	mov	r6, r6, lsl r5			@ 0: LSL #!0
+	b	.data_arm_apply_r6_and_rn
+	b	.data_arm_apply_r6_and_rn	@ 1: LSL #0
+	nop
+	b	.data_unknown			@ 2: MUL?
+	nop
+	b	.data_unknown			@ 3: MUL?
+	nop
+	mov	r6, r6, lsr r5			@ 4: LSR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, lsr #32			@ 5: LSR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ 6: MUL?
+	nop
+	b	.data_unknown			@ 7: MUL?
+	nop
+	mov	r6, r6, asr r5			@ 8: ASR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, asr #32			@ 9: ASR #32
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ A: MUL?
+	nop
+	b	.data_unknown			@ B: MUL?
+	nop
+	mov	r6, r6, ror r5			@ C: ROR #!0
+	b	.data_arm_apply_r6_and_rn
+	mov	r6, r6, rrx			@ D: RRX
+	b	.data_arm_apply_r6_and_rn
+	b	.data_unknown			@ E: MUL?
+	nop
+	b	.data_unknown			@ F: MUL?
+
+/*
+ * Function: arm6_7_proc_init (void)
+ *	   : arm6_7_proc_fin (void)
+ *
+ * Notes   : This processor does not require these
+ */
+ENTRY(cpu_arm7_proc_init)
+		mov	pc, lr
+
+ENTRY(cpu_arm7_proc_fin)
+		mov	r0, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+		msr	cpsr_c, r0
+		mov     r0, #0
+		mov	pc, lr
+
+ENTRY(cpu_arm7_do_idle)
+		mov	r0, #-EINVAL
+		mov	pc, lr
+
+/*
+ * Function: arm6_7_switch_mm(unsigned long pgd_phys)
+ * Params  : pgd_phys	Physical address of page table
+ * Purpose : Perform a task switch, saving the old processes state, and restoring
+ *	     the new.
+ */
+ENTRY(cpu_arm7_switch_mm)
+		mov	r1, #0
+		mov	pc, lr
+
+/*
+ * Function: _arm6_7_reset
+ * Params  : r0 = address to jump to
+ * Notes   : This sets up everything for a reset
+ */
+ENTRY(cpu_arm7_reset)
+		mov	r1, #0
+		mov	pc, r0
+
+
+		__INIT
+
+		.type	__arm7_setup, #function
+__arm7_setup:
+		mov	r0, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+		msr	cpsr_c, r0
+		mov	r0, #0
+		mov	pc, lr
+		.size	__arm7_setup, . - __arm7_setup
+	
+		__INITDATA
+
+		.type	s3c4510b_cache_fns, #object
+ENTRY(s3c4510b_cache_fns)
+		.long	s3c4510b_flush_kern_cache_all
+		.long	s3c4510b_flush_user_cache_all
+		.long	s3c4510b_flush_user_cache_range
+		.long	s3c4510b_coherent_kern_range
+		.long	s3c4510b_flush_kern_dcache_page
+		.long	s3c4510b_dma_inv_range
+		.long	s3c4510b_dma_clean_range
+		.long	s3c4510b_dma_flush_range
+		.size	s3c4510b_cache_fns, . - s3c4510b_cache_fns
+	
+/*
+ * Purpose : Function pointers used to access above functions - all calls
+ *	     come through these
+ */
+		.type	arm7_processor_functions, #object
+ENTRY(arm7_processor_functions)
+		.word	cpu_arm7_data_abort
+		.word	cpu_arm7_proc_init
+		.word	cpu_arm7_proc_fin
+		.word	cpu_arm7_reset
+		.word	cpu_arm7_do_idle
+		.word	cpu_arm7_dcache_clean_area
+		.word	cpu_arm7_switch_mm
+		.size	arm7_processor_functions, . - arm7_processor_functions
+
+		.section ".rodata"
+
+		.type	cpu_arch_name, #object
+cpu_arch_name:	.asciz	"armv4t"
+		.size	cpu_arch_name, . - cpu_arch_name
+
+		.type	cpu_elf_name, #object
+cpu_elf_name:	.asciz	"v4"
+		.size	cpu_elf_name, . - cpu_elf_name
+
+		.type	cpu_s3c4510b, #object
+cpu_s3c4510b_name:
+		.asciz	"Samsung-S3C4510B"
+		.size	cpu_s3c4510b_name, . - cpu_s3c4510b_name
+
+		.align
+
+		.section ".proc.info", #alloc, #execinstr
+
+		.type	__s3c4510b_proc_info, #object
+__s3c4510b_proc_info:
+		.long	0x36807000
+		.long	0xfffff000
+		.long	0x00000c1e
+		b	__arm7_setup
+		.long	cpu_arch_name
+		.long	cpu_elf_name
+		.long	HWCAP_SWP | HWCAP_26BIT
+		.long	cpu_s3c4510b_name
+		.long	arm7_processor_functions
+		.long	s3c4510b_cache_fns
+		.size	__s3c4510b_proc_info, . - __s3c4510b_proc_info
+
diff -Naur linux-2.6.9/arch/armnommu/mm/proc-syms.c linux-2.6.9-uc0/arch/armnommu/mm/proc-syms.c
--- linux-2.6.9/arch/armnommu/mm/proc-syms.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/armnommu/mm/proc-syms.c	2004-10-28 11:11:16.000000000 +1000
@@ -0,0 +1,32 @@
+/*
+ *  linux/arch/armnommu/mm/proc-syms.c
+ *
+ *  Copyright (C) 2000-2002 Russell King
+ *  Modified by Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/mm.h>
+
+#include <asm/cacheflush.h>
+#include <asm/proc-fns.h>
+#include <asm/tlbflush.h>
+
+#ifndef MULTI_CPU
+EXPORT_SYMBOL(cpu_dcache_clean_area);
+#else
+EXPORT_SYMBOL(processor);
+#endif
+
+#ifndef MULTI_CACHE
+EXPORT_SYMBOL_NOVERS(__cpuc_flush_kern_all);
+EXPORT_SYMBOL_NOVERS(__cpuc_flush_user_all);
+EXPORT_SYMBOL_NOVERS(__cpuc_flush_user_range);
+EXPORT_SYMBOL_NOVERS(__cpuc_coherent_kern_range);
+EXPORT_SYMBOL_NOVERS(__cpuc_flush_dcache_page);
+#else
+EXPORT_SYMBOL(cpu_cache);
+#endif
diff -Naur linux-2.6.9/arch/m68knommu/defconfig linux-2.6.9-uc0/arch/m68knommu/defconfig
--- linux-2.6.9/arch/m68knommu/defconfig	2004-10-28 11:08:54.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/defconfig	2004-10-28 11:11:41.000000000 +1000
@@ -35,8 +35,9 @@
 # CONFIG_M5206 is not set
 # CONFIG_M5206e is not set
 # CONFIG_M5249 is not set
+# CONFIG_M527x is not set
 CONFIG_M5272=y
-# CONFIG_M5282 is not set
+# CONFIG_M528x is not set
 # CONFIG_M5307 is not set
 # CONFIG_M5407 is not set
 CONFIG_COLDFIRE=y
@@ -55,7 +56,10 @@
 # CONFIG_CLOCK_60MHz is not set
 CONFIG_CLOCK_66MHz=y
 # CONFIG_CLOCK_70MHz is not set
+# CONFIG_CLOCK_100MHz is not set
 # CONFIG_CLOCK_140MHz is not set
+# CONFIG_CLOCK_150MHz is not set
+# CONFIG_CLOCK_166MHz is not set
 
 #
 # Platform
diff -Naur linux-2.6.9/arch/m68knommu/Kconfig linux-2.6.9-uc0/arch/m68knommu/Kconfig
--- linux-2.6.9/arch/m68knommu/Kconfig	2004-10-28 11:08:54.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/Kconfig	2004-10-28 11:11:40.000000000 +1000
@@ -72,15 +72,20 @@
 	help
 	  Motorola ColdFire 5249 processor support.
 
+config M527x
+	bool "MCF527x"
+	help
+	  Freescale (Motorola) ColdFire 5270/5271/5274/5275 processor support.
+
 config M5272
 	bool "MCF5272"
 	help
 	  Motorola ColdFire 5272 processor support.
 
-config M5282
-	bool "MCF5282"
+config M528x
+	bool "MCF528x"
 	help
-	  Motorola ColdFire 5282 processor support.
+	  Motorola ColdFire 5280/5282 processor support.
 
 config M5307
 	bool "MCF5307"
@@ -96,7 +101,7 @@
 
 config COLDFIRE
 	bool
-	depends on (M5206 || M5206e || M5249 || M5272 || M5282 || M5307 || M5407)
+	depends on (M5206 || M5206e || M5249 || M527x || M5272 || M528x || M5307 || M5407)
 	default y
 
 choice
@@ -117,82 +122,97 @@
 config CLOCK_11MHz
 	bool "11MHz"
 	help
-	  Select an 11MHz CPU clock frequency.
+	  Select a 11MHz CPU clock frequency.
 
 config CLOCK_16MHz
 	bool "16MHz"
 	help
-	  Select an 16MHz CPU clock frequency.
+	  Select a 16MHz CPU clock frequency.
 
 config CLOCK_20MHz
 	bool "20MHz"
 	help
-	  Select an 20MHz CPU clock frequency.
+	  Select a 20MHz CPU clock frequency.
 
 config CLOCK_24MHz
 	bool "24MHz"
 	help
-	  Select an 24MHz CPU clock frequency.
+	  Select a 24MHz CPU clock frequency.
 
 config CLOCK_25MHz
 	bool "25MHz"
 	help
-	  Select an 25MHz CPU clock frequency.
+	  Select a 25MHz CPU clock frequency.
 
 config CLOCK_33MHz
 	bool "33MHz"
 	help
-	  Select an 33MHz CPU clock frequency.
+	  Select a 33MHz CPU clock frequency.
 
 config CLOCK_40MHz
 	bool "40MHz"
 	help
-	  Select an 40MHz CPU clock frequency.
+	  Select a 40MHz CPU clock frequency.
 
 config CLOCK_45MHz
 	bool "45MHz"
 	help
-	  Select an 45MHz CPU clock frequency.
+	  Select a 45MHz CPU clock frequency.
 
 config CLOCK_48MHz
 	bool "48MHz"
 	help
-	  Select an 48MHz CPU clock frequency.
+	  Select a 48MHz CPU clock frequency.
 
 config CLOCK_50MHz
 	bool "50MHz"
 	help
-	  Select an 50MHz CPU clock frequency.
+	  Select a 50MHz CPU clock frequency.
 
 config CLOCK_54MHz
 	bool "54MHz"
 	help
-	  Select an 54MHz CPU clock frequency.
+	  Select a 54MHz CPU clock frequency.
 
 config CLOCK_60MHz
 	bool "60MHz"
 	help
-	  Select an 60MHz CPU clock frequency.
+	  Select a 60MHz CPU clock frequency.
 
 config CLOCK_64MHz
 	bool "64MHz"
 	help
-	  Select an 64MHz CPU clock frequency.
+	  Select a 64MHz CPU clock frequency.
 
 config CLOCK_66MHz
 	bool "66MHz"
 	help
-	  Select an 66MHz CPU clock frequency.
+	  Select a 66MHz CPU clock frequency.
 
 config CLOCK_70MHz
 	bool "70MHz"
 	help
-	  Select an 70MHz CPU clock frequency.
+	  Select a 70MHz CPU clock frequency.
+
+config CLOCK_100MHz
+	bool "100MHz"
+	help
+	  Select a 100MHz CPU clock frequency.
 
 config CLOCK_140MHz
 	bool "140MHz"
 	help
-	  Select an 140MHz CPU clock frequency.
+	  Select a 140MHz CPU clock frequency.
+
+config CLOCK_150MHz
+	bool "150MHz"
+	help
+	  Select a 150MHz CPU clock frequency.
+
+config CLOCK_166MHz
+	bool "166MHz"
+	help
+	  Select a 166MHz CPU clock frequency.
 
 endchoice
 
@@ -284,6 +304,18 @@
 	help
 	  Support for the Motorola M5249C3 board.
 
+config M5271EVB
+	bool "Freescale (Motorola) M5271EVB board support"
+	depends on M527x
+	help
+	  Support for the Freescale (Motorola) M5271EVB board.
+
+config M5275EVB
+	bool "Freescale (Motorola) M5275EVB board support"
+	depends on M527x
+	help
+	  Support for the Freescale (Motorola) M5275EVB board.
+
 config M5272C3
 	bool "Motorola M5272C3 board support"
 	depends on M5272
@@ -296,15 +328,21 @@
 	help
 	  Support for the senTec COBRA5272 board.
 
-config M5282C3
-	bool "Motorola M5282C3 board support"
-	depends on M5282
+config M5275EVB
+	bool "Freescale (Motorola) M5275EVB board support"
+	depends on M527x
+	help
+	  Support for the Freescale (Motorola) M5275EVB board.
+
+config M5282EVB
+	bool "Motorola M5282EVB board support"
+	depends on M528x
 	help
-	  Support for the Motorola M5282C3 board.
+	  Support for the Motorola M5282EVB board.
 
 config COBRA5282
 	bool "senTec COBRA5282 board support"
-	depends on M5282
+	depends on M528x
 	help
 	  Support for the senTec COBRA5282 board.
 
@@ -344,6 +382,18 @@
 	help
 	  Support for the Feith Cleopatra boards.
 
+config CANCam
+	bool "Feith CANCam board support"
+	depends on M5272
+	help
+	  Support for the Feith CANCam board.
+
+config SCALES
+	bool "Feith SCALES board support"
+	depends on M5272
+	help
+	  Support for the Feith SCALES board.
+
 config NETtel
 	bool "SecureEdge/NETtel board support"
 	depends on (M5206e || M5272 || M5307)
@@ -356,6 +406,12 @@
 	help
 	  Special additional support for SnapGear router boards.
 
+config CPU16B
+	bool "Sneha Technologies S.L. Sarasvati board support"
+	depends on M5272
+	help
+	  Support for the SNEHA CPU16B board.
+
 config ROMFS_FROM_ROM
 	bool "  ROMFS image not RAM resident"
 	depends on (NETtel || SNAPGEAR)
@@ -376,13 +432,23 @@
 config MOTOROLA
 	bool
 	default y
-	depends on (M5206eC3 || M5249C3 || M5272C3 || M5282C3 || M5307C3 || M5407C3)
+	depends on (M5206eC3 || M5249C3 || M5271EVB || M5272C3 || M5275EVB || M5282EVB || M5307C3 || M5407C3)
+
+config HW_FEITH
+	bool
+	default y
+	depends on (CLEOPATRA || CANCam || SCALES)
 
 config senTec
 	bool
 	default y
 	depends on (COBRA5272 || COBRA5282)
 
+config SNEHA
+        bool
+	default y
+	depends on (CPU16B)
+	
 config LARGE_ALLOCS
 	bool "Allow allocating large blocks (> 1MB) of memory"
 	help
diff -Naur linux-2.6.9/arch/m68knommu/kernel/module.c linux-2.6.9-uc0/arch/m68knommu/kernel/module.c
--- linux-2.6.9/arch/m68knommu/kernel/module.c	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/kernel/module.c	2004-10-28 11:11:41.000000000 +1000
@@ -82,9 +82,38 @@
 		       unsigned int relsec,
 		       struct module *me)
 {
-	printk(KERN_ERR "module %s: ADD RELOCATION unsupported\n",
-	       me->name);
-	return -ENOEXEC;
+	unsigned int i;
+	Elf32_Rela *rel = (void *)sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	uint32_t *location;
+
+	DEBUGP("Applying relocate_add section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to.  Note that all
+		   undefined symbols have been resolved.  */
+		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
+			+ ELF32_R_SYM(rel[i].r_info);
+
+		switch (ELF32_R_TYPE(rel[i].r_info)) {
+		case R_68K_32:
+			/* We add the value into the location given */
+			*location = rel[i].r_addend + sym->st_value;
+			break;
+		case R_68K_PC32:
+			/* Add the value, subtract its postition */
+			*location = rel[i].r_addend + sym->st_value - (uint32_t)location;
+			break;
+		default:
+			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
+			       me->name, ELF32_R_TYPE(rel[i].r_info));
+			return -ENOEXEC;
+		}
+	}
+	return 0;
 }
 
 int module_finalize(const Elf_Ehdr *hdr,
diff -Naur linux-2.6.9/arch/m68knommu/kernel/setup.c linux-2.6.9-uc0/arch/m68knommu/kernel/setup.c
--- linux-2.6.9/arch/m68knommu/kernel/setup.c	2004-10-28 11:08:54.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/kernel/setup.c	2004-10-28 11:11:41.000000000 +1000
@@ -1,7 +1,7 @@
 /*
  *  linux/arch/m68knommu/kernel/setup.c
  *
- *  Copyright (C) 1999-2002  Greg Ungerer (gerg@snapgear.com)
+ *  Copyright (C) 1999-2004  Greg Ungerer (gerg@snapgear.com)
  *  Copyright (C) 1998,1999  D. Jeff Dionne <jeff@lineo.ca>
  *  Copyleft  ()) 2000       James D. Schettine {james@telos-systems.com}
  *  Copyright (C) 1998       Kenneth Albanowski <kjahds@kjahds.com>
@@ -106,11 +106,14 @@
 #if defined(CONFIG_M5249)
 	#define CPU "COLDFIRE(m5249)"
 #endif
+#if defined(CONFIG_M527x)
+	#define CPU "COLDFIRE(m5270/5271/5274/5275)"
+#endif
 #if defined(CONFIG_M5272)
 	#define CPU "COLDFIRE(m5272)"
 #endif
-#if defined(CONFIG_M5282)
-	#define CPU "COLDFIRE(m5282)"
+#if defined(CONFIG_M528x)
+	#define CPU "COLDFIRE(m5280/5282)"
 #endif
 #if defined(CONFIG_M5307)
 	#define	CPU "COLDFIRE(m5307)"
diff -Naur linux-2.6.9/arch/m68knommu/kernel/signal.c linux-2.6.9-uc0/arch/m68knommu/kernel/signal.c
--- linux-2.6.9/arch/m68knommu/kernel/signal.c	2004-10-28 11:08:54.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/kernel/signal.c	2004-10-28 11:11:41.000000000 +1000
@@ -745,147 +745,44 @@
  * Note that 'init' is a special process: it doesn't get signals it doesn't
  * want to handle. Thus you cannot kill init even with a SIGKILL even by
  * mistake.
- *
- * Note that we go through the signals twice: once to check the signals
- * that the kernel can handle, and then we build all the user-level signal
- * handling stack-frames in one go after that.
  */
 asmlinkage int do_signal(sigset_t *oldset, struct pt_regs *regs)
 {
+	struct k_sigaction ka;
 	siginfo_t info;
-	struct k_sigaction *ka;
+	int signr;
 
-	current->thread.esp0 = (unsigned long) regs;
+	/*
+	 * We want the common case to go fast, which
+	 * is why we may in certain cases get here from
+	 * kernel mode. Just return without doing anything
+	 * if so.
+	 */
+	if (!user_mode(regs))
+		return 1;
 
 	if (!oldset)
 		oldset = &current->blocked;
 
-	for (;;) {
-		int signr;
-
-		signr = get_signal_to_deliver(&info, regs, NULL);
-
-		if (!signr)
-			break;
-
-		if ((current->ptrace & PT_PTRACED) && signr != SIGKILL) {
-			current->exit_code = signr;
-			current->state = TASK_STOPPED;
-			regs->sr &= ~PS_T;
-
-			/* Did we come from a system call? */
-			if (regs->orig_d0 >= 0) {
-				/* Restart the system call the same way as
-				   if the process were not traced.  */
-				struct k_sigaction *ka =
-					&current->sighand->action[signr-1];
-				int has_handler =
-					(ka->sa.sa_handler != SIG_IGN &&
-					 ka->sa.sa_handler != SIG_DFL);
-				handle_restart(regs, ka, has_handler);
-			}
-			notify_parent(current, SIGCHLD);
-			schedule();
-
-			/* We're back.  Did the debugger cancel the sig?  */
-			if (!(signr = current->exit_code)) {
-			discard_frame:
-			    continue;
-			}
-			current->exit_code = 0;
-
-			/* The debugger continued.  Ignore SIGSTOP.  */
-			if (signr == SIGSTOP)
-				goto discard_frame;
-
-			/* Update the siginfo structure.  Is this good?  */
-			if (signr != info.si_signo) {
-				info.si_signo = signr;
-				info.si_errno = 0;
-				info.si_code = SI_USER;
-				info.si_pid = current->parent->pid;
-				info.si_uid = current->parent->uid;
-			}
-
-			/* If the (new) signal is now blocked, requeue it.  */
-			if (sigismember(&current->blocked, signr)) {
-				send_sig_info(signr, &info, current);
-				continue;
-			}
-		}
-
-		ka = &current->sighand->action[signr-1];
-		if (ka->sa.sa_handler == SIG_IGN) {
-			if (signr != SIGCHLD)
-				continue;
-			/* Check for SIGCHLD: it's special.  */
-			while (sys_wait4(-1, NULL, WNOHANG, NULL) > 0)
-				/* nothing */;
-			continue;
-		}
-
-		if (ka->sa.sa_handler == SIG_DFL) {
-			int exit_code = signr;
-
-			if (current->pid == 1)
-				continue;
-
-			switch (signr) {
-			case SIGCONT: case SIGCHLD:
-			case SIGWINCH: case SIGURG:
-				continue;
-
-			case SIGTSTP: case SIGTTIN: case SIGTTOU:
-				if (is_orphaned_pgrp(process_group(current)))
-					continue;
-				/* FALLTHRU */
-
-			case SIGSTOP:
-				current->state = TASK_STOPPED;
-				current->exit_code = signr;
-				if (!(current->parent->sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))
-					notify_parent(current, SIGCHLD);
-				schedule();
-				continue;
-
-			case SIGQUIT: case SIGILL: case SIGTRAP:
-			case SIGIOT: case SIGFPE: case SIGSEGV:
-			case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
-				if (do_coredump(signr, exit_code, regs))
-					exit_code |= 0x80;
-				/* FALLTHRU */
-
-			default:
-				sigaddset(&current->pending.signal, signr);
-				recalc_sigpending();
-				current->flags |= PF_SIGNALED;
-				do_exit(exit_code);
-				/* NOTREACHED */
-			}
-		}
-
+	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
+	if (signr > 0) {
 		/* Whee!  Actually deliver the signal.  */
-		handle_signal(signr, ka, &info, oldset, regs);
+		handle_signal(signr, &ka, &info, oldset, regs);
 		return 1;
 	}
 
 	/* Did we come from a system call? */
-	if (regs->orig_d0 >= 0)
+	if (regs->orig_d0 >= 0) {
 		/* Restart the system call - no handlers present */
-		handle_restart(regs, NULL, 0);
-
-	/* If we are about to discard some frame stuff we must copy
-	   over the remaining frame. */
-	if (regs->stkadj) {
-		struct pt_regs *tregs =
-		  (struct pt_regs *) ((ulong) regs + regs->stkadj);
-
-		/* This must be copied with decreasing addresses to
-		   handle overlaps.  */
-		tregs->vector = 0;
-		tregs->format = 0;
-		tregs->pc = regs->pc;
-		tregs->sr = regs->sr;
+		if (regs->d0 == -ERESTARTNOHAND
+		    || regs->d0 == -ERESTARTSYS
+		    || regs->d0 == -ERESTARTNOINTR) {
+			regs->d0 = regs->orig_d0;
+			regs->pc -= 2;
+		} else if (regs->d0 == -ERESTART_RESTARTBLOCK) {
+			regs->d0 = __NR_restart_syscall;
+			regs->pc -= 2;
+		}
 	}
 	return 0;
 }
diff -Naur linux-2.6.9/arch/m68knommu/kernel/syscalltable.S linux-2.6.9-uc0/arch/m68knommu/kernel/syscalltable.S
--- linux-2.6.9/arch/m68knommu/kernel/syscalltable.S	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/kernel/syscalltable.S	2004-10-28 11:11:41.000000000 +1000
@@ -185,7 +185,7 @@
 	.long sys_ni_syscall	/* sys_mremap */
 	.long sys_setresuid16
 	.long sys_getresuid16	/* 165 */
-	.long sys_ni_syscall	/* for vm86 */
+	.long sys_getpagesize	/* sys_getpagesize */
 	.long sys_ni_syscall	/* old "query_module" */
 	.long sys_poll
 	.long sys_ni_syscall	/* sys_nfsservctl */
@@ -237,42 +237,70 @@
 	.long sys_setfsuid	/* 215 */
 	.long sys_setfsgid
 	.long sys_pivot_root
-	.long sys_ni_syscall	/* sys_mincore */
-	.long sys_ni_syscall	/* sys_madvise */
-	.long sys_getdents64	/* 220 */
-	.long sys_fcntl64
-	.long sys_ni_syscall	/* reserved for TUX */
 	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_getdents64	/* 220 */
 	.long sys_gettid
-	.long sys_ni_syscall	/* 225 */ /* sys_readahead */
+	.long sys_tkill
 	.long sys_setxattr
 	.long sys_lsetxattr
-	.long sys_fsetxattr
+	.long sys_fsetxattr	/* 225 */
 	.long sys_getxattr
-	.long sys_lgetxattr	/* 230 */
+	.long sys_lgetxattr
 	.long sys_fgetxattr
 	.long sys_listxattr
-	.long sys_llistxattr
+	.long sys_llistxattr	/* 230 */
 	.long sys_flistxattr
-	.long sys_removexattr	/* 235 */
+	.long sys_removexattr
 	.long sys_lremovexattr
 	.long sys_fremovexattr
-	.long sys_tkill
+	.long sys_futex		/* 235 */
 	.long sys_sendfile64
-	.long sys_futex		/* 240 */
-	.long sys_sched_setaffinity
-	.long sys_sched_getaffinity
-	.long sys_ni_syscall	/* sys_set_thread_area */
-	.long sys_ni_syscall	/* sys_get_thread_area */
-	.long sys_io_setup	/* 245 */
+	.long sys_ni_syscall	/* sys_mincore */
+	.long sys_ni_syscall	/* sys_madvise */
+	.long sys_fcntl64
+	.long sys_readahead	/* 240 */
+	.long sys_io_setup
 	.long sys_io_destroy
 	.long sys_io_getevents
 	.long sys_io_submit
-	.long sys_io_cancel
-	.long sys_ni_syscall	/* 250 */ /* sys_alloc_hugepages */
-	.long sys_ni_syscall	/* sys_freec_hugepages */
+	.long sys_io_cancel	/* 245 */
+	.long sys_fadvise64
 	.long sys_exit_group
 	.long sys_lookup_dcookie
+	.long sys_epoll_create
+	.long sys_epoll_ctl	/* 250 */
+	.long sys_epoll_wait
+	.long sys_ni_syscall	/* sys_remap_file_pages */
+	.long sys_set_tid_address
+	.long sys_timer_create
+	.long sys_timer_settime	/* 255 */
+	.long sys_timer_gettime
+	.long sys_timer_getoverrun
+	.long sys_timer_delete
+	.long sys_clock_settime
+	.long sys_clock_gettime	/* 260 */
+	.long sys_clock_getres
+	.long sys_clock_nanosleep
+	.long sys_statfs64
+	.long sys_fstatfs64
+	.long sys_tgkill	/* 265 */
+	.long sys_utimes
+	.long sys_fadvise64_64
+	.long sys_mbind	
+	.long sys_get_mempolicy
+	.long sys_set_mempolicy	/* 270 */
+	.long sys_mq_open
+	.long sys_mq_unlink
+	.long sys_mq_timedsend
+	.long sys_mq_timedreceive
+	.long sys_mq_notify	/* 275 */
+	.long sys_mq_getsetattr
+	.long sys_waitid
+	.long sys_ni_syscall	/* sys_setaltroot */
+	.long sys_ni_syscall	/* sys_add_key */
+	.long sys_ni_syscall	/* 280 */ /* sys_request_key */
+	.long sys_ni_syscall	/* sys_keyctl */
 
 	.rept NR_syscalls-(.-sys_call_table)/4
 		.long sys_ni_syscall
diff -Naur linux-2.6.9/arch/m68knommu/kernel/vmlinux.lds.S linux-2.6.9-uc0/arch/m68knommu/kernel/vmlinux.lds.S
--- linux-2.6.9/arch/m68knommu/kernel/vmlinux.lds.S	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/kernel/vmlinux.lds.S	2004-10-28 11:11:41.000000000 +1000
@@ -1,7 +1,7 @@
 /*
  *	vmlinux.lds.S -- master linker script for m68knommu arch
  *
- *	(C) Copyright 2002-2003, Greg Ungerer <gerg@snapgear.com>
+ *	(C) Copyright 2002-2004, Greg Ungerer <gerg@snapgear.com>
  *
  *	This ends up looking compilcated, because of the number of
  *	address variations for ram and rom/flash layouts. The real
@@ -117,7 +117,8 @@
  */
 #if defined(CONFIG_M5206eC3) || defined(CONFIG_M5249C3) || \
     defined(CONFIG_M5272C3) || defined(CONFIG_M5307C3) || \
-    defined(CONFIG_ARN5307) || defined(CONFIG_M5407C3)
+    defined(CONFIG_ARN5307) || defined(CONFIG_M5407C3) || \
+    defined(CONFIG_M5271EVB) || defined(CONFIG_M5275EVB)
 #define	RAM_START	0x20000
 #define	RAM_LENGTH	0x3e0000
 #endif
@@ -132,14 +133,14 @@
 #define RAM_LENGTH  0xfe0000
 #endif
 
-#if defined(CONFIG_M5282C3)
+#if defined(CONFIG_M5282EVB)
 #define	RAM_START	0x10000
 #define	RAM_LENGTH	0x3f0000
 #endif
 
 /*
  *   The senTec COBRA5282 board has the same
- *   memory layout as the M5282C3.
+ *   memory layout as the M5282EVB.
  */
 #if defined(CONFIG_COBRA5282)
 #define  RAM_START   0x10000
@@ -153,11 +154,22 @@
  */
 #if defined(CONFIG_NETtel) || defined(CONFIG_eLIA) || \
     defined(CONFIG_DISKtel) || defined(CONFIG_SECUREEDGEMP3) || \
-    defined(CONFIG_CLEOPATRA)
+    defined(CONFIG_HW_FEITH)
 #define	RAM_START	0x400
 #define	RAM_LENGTH	0x3ffc00
 #endif
 
+/*
+ *	Sneha Boards mimimun memmory
+ *	The end of RAM will vary depending on how much ram is fitted,
+ *	but this isn't important here, we assume at least 4MiB.
+ */
+#if defined(CONFIG_CPU16B)   
+#define	RAM_START	0x20000
+#define	RAM_LENGTH	0x3e0000
+#endif
+
+
 #if defined(CONFIG_RAMKERNEL)
 #define	TEXT		ram
 #define	DATA		ram
@@ -247,6 +259,11 @@
 		/* Kernel symbol table: strings */
 		*(__ksymtab_strings)
 
+		/* Built-in module parameters */
+		__start___param = .;
+		*(__param)
+		__stop___param = .;
+
 		. = ALIGN(4) ;
 		_etext = . ;
 	} > TEXT
@@ -303,7 +320,7 @@
 		__initramfs_start = .;
 		*(.init.ramfs)
 		__initramfs_end = .;
-		. = ALIGN(4);
+		. = ALIGN(4096);
 		__init_end = .;
 	} > INIT
 
diff -Naur linux-2.6.9/arch/m68knommu/lib/delay.c linux-2.6.9-uc0/arch/m68knommu/lib/delay.c
--- linux-2.6.9/arch/m68knommu/lib/delay.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/lib/delay.c	2004-10-28 11:11:40.000000000 +1000
@@ -0,0 +1,18 @@
+/*
+ *	arch/m68knommu/lib/delay.c
+ *
+ *	(C) Copyright 2004, Greg Ungerer <gerg@snapgear.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/param.h>
+#include <asm/delay.h>
+
+void udelay(unsigned long usecs)
+{
+	_udelay(usecs);
+}
+
diff -Naur linux-2.6.9/arch/m68knommu/lib/Makefile linux-2.6.9-uc0/arch/m68knommu/lib/Makefile
--- linux-2.6.9/arch/m68knommu/lib/Makefile	2004-10-28 11:08:54.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/lib/Makefile	2004-10-28 11:11:40.000000000 +1000
@@ -4,4 +4,4 @@
 
 lib-y	:= ashldi3.o ashrdi3.o lshrdi3.o \
 	   muldi3.o mulsi3.o divsi3.o udivsi3.o modsi3.o umodsi3.o \
-	   checksum.o semaphore.o memcpy.o memset.o
+	   checksum.o semaphore.o memcpy.o memset.o delay.o
diff -Naur linux-2.6.9/arch/m68knommu/Makefile linux-2.6.9-uc0/arch/m68knommu/Makefile
--- linux-2.6.9/arch/m68knommu/Makefile	2004-10-28 11:08:54.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/Makefile	2004-10-28 11:11:40.000000000 +1000
@@ -15,8 +15,9 @@
 platform-$(CONFIG_M5206)	:= 5206
 platform-$(CONFIG_M5206e)	:= 5206e
 platform-$(CONFIG_M5249)	:= 5249
+platform-$(CONFIG_M527x)	:= 527x
 platform-$(CONFIG_M5272)	:= 5272
-platform-$(CONFIG_M5282)	:= 5282
+platform-$(CONFIG_M528x)	:= 528x
 platform-$(CONFIG_M5307)	:= 5307
 platform-$(CONFIG_M5407)	:= 5407
 PLATFORM := $(platform-y)
@@ -28,12 +29,16 @@
 board-$(CONFIG_DRAGEN2)		:= de2
 board-$(CONFIG_ARNEWSH)		:= ARNEWSH
 board-$(CONFIG_MOTOROLA)	:= MOTOROLA
+board-$(CONFIG_M5271EVB)	:= M5271EVB
+board-$(CONFIG_M5275EVB)	:= M5275EVB
+board-$(CONFIG_M5282EVB)	:= M5282EVB
 board-$(CONFIG_ELITE)		:= eLITE
 board-$(CONFIG_eLIA)		:= eLIA
 board-$(CONFIG_NETtel)		:= NETtel
 board-$(CONFIG_SECUREEDGEMP3)	:= MP3
 board-$(CONFIG_CLEOPATRA)	:= CLEOPATRA
-board-$(CONFIG_senTec) 	:= senTec
+board-$(CONFIG_senTec)		:= senTec
+board-$(CONFIG_SNEHA) 	        := SNEHA
 BOARD := $(board-y)
 
 model-$(CONFIG_RAMKERNEL)	:= ram
@@ -50,8 +55,9 @@
 cpuclass-$(CONFIG_M5206)	:= 5307
 cpuclass-$(CONFIG_M5206e)	:= 5307
 cpuclass-$(CONFIG_M5249)	:= 5307
+cpuclass-$(CONFIG_M527x)	:= 5307
 cpuclass-$(CONFIG_M5272)	:= 5307
-cpuclass-$(CONFIG_M5282)	:= 5307
+cpuclass-$(CONFIG_M528x)	:= 5307
 cpuclass-$(CONFIG_M5407)	:= 5307
 cpuclass-$(CONFIG_M68EZ328)	:= 68328
 cpuclass-$(CONFIG_M68VZ328)	:= 68328
@@ -69,8 +75,9 @@
 cflags-$(CONFIG_M5206)		:= -m5200 -Wa,-S -Wa,-m5200
 cflags-$(CONFIG_M5206e)		:= -m5200 -Wa,-S -Wa,-m5200
 cflags-$(CONFIG_M5249)		:= -m5200 -Wa,-S -Wa,-m5200
+cflags-$(CONFIG_M527x)		:= -m5307 -Wa,-S -Wa,-m5307
 cflags-$(CONFIG_M5272)		:= -m5307 -Wa,-S -Wa,-m5307
-cflags-$(CONFIG_M5282)		:= -m5307 -Wa,-S -Wa,-m5307
+cflags-$(CONFIG_M528x)		:= -m5307 -Wa,-S -Wa,-m5307
 cflags-$(CONFIG_M5307)		:= -m5307 -Wa,-S -Wa,-m5307
 cflags-$(CONFIG_M5407)		:= -m5200 -Wa,-S -Wa,-m5200
 cflags-$(CONFIG_M68328)		:= -m68000
@@ -82,7 +89,7 @@
 
 CFLAGS += $(cflags-y)
 CFLAGS += -fno-builtin
-CFLAGS += -O2 -g
+CFLAGS += -O1 -g
 CFLAGS += -D__linux__
 CFLAGS += -DUTS_SYSNAME=\"uClinux\"
 
diff -Naur linux-2.6.9/arch/m68knommu/mm/init.c linux-2.6.9-uc0/arch/m68knommu/mm/init.c
--- linux-2.6.9/arch/m68knommu/mm/init.c	2004-10-28 11:08:54.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/mm/init.c	2004-10-28 11:11:42.000000000 +1000
@@ -38,7 +38,6 @@
 #include <asm/pgtable.h>
 #include <asm/system.h>
 #include <asm/machdep.h>
-#include <asm/shglcore.h>
 
 #undef DEBUG
 
diff -Naur linux-2.6.9/arch/m68knommu/mm/memory.c linux-2.6.9-uc0/arch/m68knommu/mm/memory.c
--- linux-2.6.9/arch/m68knommu/mm/memory.c	2004-10-28 11:08:54.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/mm/memory.c	2004-10-28 11:11:42.000000000 +1000
@@ -24,7 +24,6 @@
 #include <asm/pgtable.h>
 #include <asm/system.h>
 #include <asm/traps.h>
-#include <asm/shglcore.h>
 #include <asm/io.h>
 
 /*
diff -Naur linux-2.6.9/arch/m68knommu/platform/5206e/config.c linux-2.6.9-uc0/arch/m68knommu/platform/5206e/config.c
--- linux-2.6.9/arch/m68knommu/platform/5206e/config.c	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5206e/config.c	2004-10-28 11:11:42.000000000 +1000
@@ -22,7 +22,6 @@
 #include <asm/mcfsim.h>
 #include <asm/mcfdma.h>
 #include <asm/irq.h>
-#include <asm/delay.h>
 
 /***************************************************************************/
 
diff -Naur linux-2.6.9/arch/m68knommu/platform/5206e/MOTOROLA/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/5206e/MOTOROLA/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/5206e/MOTOROLA/crt0_ram.S	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5206e/MOTOROLA/crt0_ram.S	2004-10-28 11:11:42.000000000 +1000
@@ -21,7 +21,6 @@
  */
 
 #define	MEM_BASE	0x00000000	/* Memory base at address 0 */
-#define	MEM_SIZE	0x00400000	/* Memory size 4Mb */
 #define	VBR_BASE	MEM_BASE	/* Vector address */
 
 /*****************************************************************************/
@@ -78,9 +77,36 @@
 
 
 	/*
-	 *	Set to 4 meg for the Cadre III board (m5206e).
+	 *	SDRAM size for the Cadre III board (m5206e).
 	 */
+#if defined(CONFIG_RAMAUTO)
+	movea.l	#0x00000000,%a0
+	move.l	MCF_MBAR+MCFSIM_DCMR0,%d0
+	and.l	#0x00fe0000, %d0
+	beq	noaddr1
+	add.l	#0x00020000,%d0
+	move.l	%d0,%a0
+noaddr1:
+	move.l	MCF_MBAR+MCFSIM_DCMR1,%d0
+	and.l	#0x00fe0000, %d0
+	beq	noaddr2
+	add.l	#0x00020000,%d0
+	add.l	%d0,%a0
+noaddr2:
+
+#else
+
+#if defined(CONFIG_RAM32MB)
+#define MEM_SIZE	0x02000000	/* Memory size 32Mb */
+#elif defined(CONFIG_RAM16MB)
+#define MEM_SIZE	0x01000000	/* Memory size 16Mb */
+#elif defined(CONFIG_RAM8MB)
+#define MEM_SIZE	0x00800000	/* Memory size 8Mb */
+#else
+#define MEM_SIZE	0x00400000	/* Memory size 4Mb */
+#endif
 	move.l	#MEM_SIZE, %a0
+#endif
 
 	move.l	%a0, %d0			/* Mem end addr is in a0 */
 	move.l	%d0, %sp			/* Set up initial stack ptr */
diff -Naur linux-2.6.9/arch/m68knommu/platform/5249/config.c linux-2.6.9-uc0/arch/m68knommu/platform/5249/config.c
--- linux-2.6.9/arch/m68knommu/platform/5249/config.c	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5249/config.c	2004-10-28 11:11:42.000000000 +1000
@@ -21,7 +21,6 @@
 #include <asm/mcftimer.h>
 #include <asm/mcfsim.h>
 #include <asm/mcfdma.h>
-#include <asm/delay.h>
 
 /***************************************************************************/
 
diff -Naur linux-2.6.9/arch/m68knommu/platform/5272/CANCam/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/5272/CANCam/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/5272/CANCam/crt0_ram.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5272/CANCam/crt0_ram.S	2004-10-28 11:11:42.000000000 +1000
@@ -0,0 +1,154 @@
+/*****************************************************************************/
+
+/*
+ *	crt0_ram.S -- startup code for Feith CANCan board.
+ *
+ *	(C) Copyright 1999-2002, Greg Ungerer (gerg@snapgear.com).
+ *	(C) Copyright 2000, Lineo (www.lineo.com).
+ */
+
+/*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+/*****************************************************************************/
+
+/*
+ *	Feith ColdFire CANCam, chip select and memory setup.
+ */
+
+#define	MEM_BASE	0x00000000	/* Memory base at address 0 */
+#define	VBR_BASE	MEM_BASE	/* Vector address */
+#define MEM_SIZE  0x04000000      /* Memory size 64Mb */
+
+
+/*****************************************************************************/
+
+.global	_start
+.global _rambase
+.global _ramvec
+.global	_ramstart
+.global	_ramend
+
+/*****************************************************************************/
+
+.data
+
+/*
+ *	Set up the usable of RAM stuff. Size of RAM is determined then
+ *	an initial stack set up at the end.
+ */
+_rambase:
+.long	0
+_ramvec:
+.long	0
+_ramstart:
+.long	0
+_ramend:
+.long	0
+
+/*****************************************************************************/
+
+.text
+
+/*
+ *	This is the codes first entry point. This is where it all
+ *	begins...
+ */
+
+_start:
+	nop					/* Filler */
+	move.w	#0x2700, %sr			/* No interrupts */
+
+	/*
+	 * Setup VBR here, otherwise buserror remap will not work.
+	 * if dBug was active before (on my SBC with dBug 1.1 of Dec 16 1996)
+	 *
+	 * bkr@cut.de 19990306
+	 *
+	 * Note: this is because dBUG points VBR to ROM, making vectors read
+	 * only, so the bus trap can't be changed. (RS)
+	 */
+	move.l	#VBR_BASE, %a7			/* Note VBR can't be read */
+	movec   %a7, %VBR
+	move.l	%a7, _ramvec			/* Set up vector addr */
+	move.l	%a7, _rambase			/* Set up base RAM addr */
+
+
+	/*
+	 *	Set memory size.
+	 */
+	move.l	#MEM_SIZE, %a0
+
+	move.l	%a0, %d0			/* Mem end addr is in a0 */
+	move.l	%d0, %sp			/* Set up initial stack ptr */
+	move.l	%d0, _ramend			/* Set end ram addr */
+
+	/*
+	 *	Enable CPU internal cache.
+	 */
+	move.l	#0x01000000, %d0		/* Invalidate cache cmd */
+	movec	%d0, %CACR			/* Invalidate cache */
+	move.l	#0x80000100, %d0		/* Setup cache mask */
+	movec	%d0, %CACR			/* Enable cache */
+	nop
+
+#ifdef CONFIG_ROMFS_FS
+	/*
+	 *	Move ROM filesystem above bss :-)
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Set up destination  */
+	move.l	%a0, %a2			/* Copy of bss start */
+
+	move.l	8(%a0), %d0			/* Get size of ROMFS */
+	addq.l	#8, %d0				/* Allow for rounding */
+	and.l	#0xfffffffc, %d0		/* Whole words */
+
+	add.l	%d0, %a0			/* Copy from end */
+	add.l	%d0, %a1			/* Copy from end */
+	move.l	%a1, _ramstart			/* Set start of ram */
+
+_copy_romfs:
+	move.l	-(%a0), %d0			/* Copy dword */
+	move.l	%d0, -(%a1)
+	cmp.l	%a0, %a2			/* Check if at end */
+	bne	_copy_romfs
+
+#else /* CONFIG_ROMFS_FS */
+	lea.l	_ebss, %a1
+	move.l	%a1, _ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
+	/*
+	 *	Zero out the bss region.
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Get end of bss */
+	clr.l	%d0				/* Set value */
+_clear_bss:
+	move.l	%d0, (%a0)+			/* Clear each word */
+	cmp.l	%a0, %a1			/* Check if at end */
+	bne	_clear_bss
+
+	/*
+	 *	Load the current thread pointer and stack.
+	 */
+	lea	init_thread_union, %a0
+	lea	0x2000(%a0), %sp
+
+	/*
+	 *	Assember start up done, start code proper.
+	 */
+	jsr	start_kernel			/* Start Linux kernel */
+
+_exit:
+	jmp	_exit				/* Should never get here */
+
+/*****************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/5272/config.c linux-2.6.9-uc0/arch/m68knommu/platform/5272/config.c
--- linux-2.6.9/arch/m68knommu/platform/5272/config.c	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5272/config.c	2004-10-28 11:11:44.000000000 +1000
@@ -23,7 +23,6 @@
 #include <asm/mcftimer.h>
 #include <asm/mcfsim.h>
 #include <asm/mcfdma.h>
-#include <asm/delay.h>
 
 /***************************************************************************/
 
@@ -110,7 +109,7 @@
 #if defined(CONFIG_BOOTPARAM)
 	strncpy(commandp, CONFIG_BOOTPARAM_STRING, size);
 	commandp[size-1] = 0;
-#elif defined(CONFIG_NETtel)
+#elif defined(CONFIG_NETtel) || defined(CONFIG_SCALES)
 	/* Copy command line from FLASH to local buffer... */
 	memcpy(commandp, (char *) 0xf0004000, size);
 	commandp[size-1] = 0;
@@ -118,6 +117,10 @@
 	/* Copy command line from FLASH to local buffer... */
 	memcpy(commandp, (char *) 0xffe06000, size);
 	commandp[size-1] = 0;
+#elif defined(CONFIG_CANCam)
+	/* Copy command line from FLASH to local buffer... */
+	memcpy(commandp, (char *) 0xf0010000, size);
+	commandp[size-1] = 0;
 #else
 	memset(commandp, 0, size);
 #endif
diff -Naur linux-2.6.9/arch/m68knommu/platform/5272/SCALES/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/5272/SCALES/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/5272/SCALES/crt0_ram.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5272/SCALES/crt0_ram.S	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,154 @@
+/*****************************************************************************/
+
+/*
+ *	crt0_ram.S -- startup code for Feith SCALES board.
+ *
+ *	(C) Copyright 1999-2002, Greg Ungerer (gerg@snapgear.com).
+ *	(C) Copyright 2000, Lineo (www.lineo.com).
+ */
+
+/*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+/*****************************************************************************/
+
+/*
+ *	Feith ColdFire SCALES, chip select and memory setup.
+ */
+
+#define	MEM_BASE	0x00000000	/* Memory base at address 0 */
+#define	VBR_BASE	MEM_BASE	/* Vector address */
+#define MEM_SIZE  0x02000000      /* Memory size 32Mb */
+
+
+/*****************************************************************************/
+
+.global	_start
+.global _rambase
+.global _ramvec
+.global	_ramstart
+.global	_ramend
+
+/*****************************************************************************/
+
+.data
+
+/*
+ *	Set up the usable of RAM stuff. Size of RAM is determined then
+ *	an initial stack set up at the end.
+ */
+_rambase:
+.long	0
+_ramvec:
+.long	0
+_ramstart:
+.long	0
+_ramend:
+.long	0
+
+/*****************************************************************************/
+
+.text
+
+/*
+ *	This is the codes first entry point. This is where it all
+ *	begins...
+ */
+
+_start:
+	nop					/* Filler */
+	move.w	#0x2700, %sr			/* No interrupts */
+
+	/*
+	 * Setup VBR here, otherwise buserror remap will not work.
+	 * if dBug was active before (on my SBC with dBug 1.1 of Dec 16 1996)
+	 *
+	 * bkr@cut.de 19990306
+	 *
+	 * Note: this is because dBUG points VBR to ROM, making vectors read
+	 * only, so the bus trap can't be changed. (RS)
+	 */
+	move.l	#VBR_BASE, %a7			/* Note VBR can't be read */
+	movec   %a7, %VBR
+	move.l	%a7, _ramvec			/* Set up vector addr */
+	move.l	%a7, _rambase			/* Set up base RAM addr */
+
+
+	/*
+	 *	Set memory size.
+	 */
+	move.l	#MEM_SIZE, %a0
+
+	move.l	%a0, %d0			/* Mem end addr is in a0 */
+	move.l	%d0, %sp			/* Set up initial stack ptr */
+	move.l	%d0, _ramend			/* Set end ram addr */
+
+	/*
+	 *	Enable CPU internal cache.
+	 */
+	move.l	#0x01000000, %d0		/* Invalidate cache cmd */
+	movec	%d0, %CACR			/* Invalidate cache */
+	move.l	#0x80000100, %d0		/* Setup cache mask */
+	movec	%d0, %CACR			/* Enable cache */
+	nop
+
+#ifdef CONFIG_ROMFS_FS
+	/*
+	 *	Move ROM filesystem above bss :-)
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Set up destination  */
+	move.l	%a0, %a2			/* Copy of bss start */
+
+	move.l	8(%a0), %d0			/* Get size of ROMFS */
+	addq.l	#8, %d0				/* Allow for rounding */
+	and.l	#0xfffffffc, %d0		/* Whole words */
+
+	add.l	%d0, %a0			/* Copy from end */
+	add.l	%d0, %a1			/* Copy from end */
+	move.l	%a1, _ramstart			/* Set start of ram */
+
+_copy_romfs:
+	move.l	-(%a0), %d0			/* Copy dword */
+	move.l	%d0, -(%a1)
+	cmp.l	%a0, %a2			/* Check if at end */
+	bne	_copy_romfs
+
+#else /* CONFIG_ROMFS_FS */
+	lea.l	_ebss, %a1
+	move.l	%a1, _ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
+	/*
+	 *	Zero out the bss region.
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Get end of bss */
+	clr.l	%d0				/* Set value */
+_clear_bss:
+	move.l	%d0, (%a0)+			/* Clear each word */
+	cmp.l	%a0, %a1			/* Check if at end */
+	bne	_clear_bss
+
+	/*
+	 *	Load the current thread pointer and stack.
+	 */
+	lea	init_thread_union, %a0
+	lea	0x2000(%a0), %sp
+
+	/*
+	 *	Assember start up done, start code proper.
+	 */
+	jsr	start_kernel			/* Start Linux kernel */
+
+_exit:
+	jmp	_exit				/* Should never get here */
+
+/*****************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/5272/SNEHA/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/5272/SNEHA/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/5272/SNEHA/crt0_ram.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5272/SNEHA/crt0_ram.S	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,165 @@
+/*****************************************************************************/
+
+/*
+ *	crt0_ram.S -- startup code for MCF5272 ColdFire based MOTOROLA boards.
+ *
+ *	(C) Copyright 1999-2002, Greg Ungerer (gerg@snapgear.com).
+ *	(C) Copyright 2000, Lineo (www.lineo.com).
+ */
+
+/*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+/*****************************************************************************/
+
+/*
+ *	Motorola M5272C3 ColdFire eval board, chip select and memory setup.
+ */
+
+#define	MEM_BASE	0x00000000	/* Memory base at address 0 */
+#define	VBR_BASE	MEM_BASE	/* Vector address */
+
+/*****************************************************************************/
+
+.global	_start
+.global _rambase
+.global _ramvec
+.global	_ramstart
+.global	_ramend
+
+/*****************************************************************************/
+
+.data
+
+/*
+ *	Set up the usable of RAM stuff. Size of RAM is determined then
+ *	an initial stack set up at the end.
+ */
+_rambase:
+.long	0
+_ramvec:
+.long	0
+_ramstart:
+.long	0
+_ramend:
+.long	0
+
+/*****************************************************************************/
+
+.text
+
+/*
+ *	This is the codes first entry point. This is where it all
+ *	begins...
+ */
+
+_start:
+	nop					/* Filler */
+	move.w	#0x2700, %sr			/* No interrupts */
+
+	/*
+	 * Setup VBR here, otherwise buserror remap will not work.
+	 * if dBug was active before (on my SBC with dBug 1.1 of Dec 16 1996)
+	 *
+	 * bkr@cut.de 19990306
+	 *
+	 * Note: this is because dBUG points VBR to ROM, making vectors read
+	 * only, so the bus trap can't be changed. (RS)
+	 */
+	move.l	#VBR_BASE, %a7			/* Note VBR can't be read */
+	movec	%a7, %VBR
+	move.l	%a7, _ramvec			/* Set up vector addr */
+	move.l	%a7, _rambase			/* Set up base RAM addr */
+
+	/*
+	 *	Determine size of RAM, then set up initial stack.
+	 */
+#if defined(CONFIG_RAMAUTO)
+	move.l	MCF_MBAR+0x7c,%d0	/* get SDRAM address mask */
+	andi.l	#0xfffff000,%d0		/* mask out chip select options */
+	neg.l	%d0			/* negate bits */
+#else
+#if defined(CONFIG_RAM16MB)
+#define	MEM_SIZE	0x01000000	/* Memory size 16Mb */
+#elif defined(CONFIG_RAM8MB)
+#define	MEM_SIZE	0x00800000	/* Memory size 8Mb */
+#else
+#define	MEM_SIZE	0x00400000	/* Memory size 4Mb */
+#endif
+	/*
+	 *	Set memory size.
+	 */
+	move.l	#MEM_SIZE, %d0
+#endif
+
+	move.l	%d0, %sp			/* Set up initial stack ptr */
+	move.l	%d0, _ramend			/* Set end ram addr */
+
+	/*
+	 *	Enable CPU internal cache.
+	 */
+	move.l	#0x01000000, %d0		/* Invalidate cache cmd */
+	movec	%d0, %CACR			/* Invalidate cache */
+	move.l	#0x80000100, %d0		/* Setup cache mask */
+	movec	%d0, %CACR			/* Enable cache */
+
+#ifdef CONFIG_ROMFS_FS
+	/*
+	 *	Move ROM filesystem above bss :-)
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Set up destination  */
+	move.l	%a0, %a2			/* Copy of bss start */
+
+	move.l	8(%a0), %d0			/* Get size of ROMFS */
+	addq.l	#8, %d0				/* Allow for rounding */
+	and.l	#0xfffffffc, %d0		/* Whole words */
+
+	add.l	%d0, %a0			/* Copy from end */
+	add.l	%d0, %a1			/* Copy from end */
+	move.l	%a1, _ramstart			/* Set start of ram */
+
+_copy_romfs:
+	move.l	-(%a0), %d0			/* Copy dword */
+	move.l	%d0, -(%a1)
+	cmp.l	%a0, %a2			/* Check if at end */
+	bne	_copy_romfs
+
+#else /* CONFIG_ROMFS_FS */
+	lea.l	_ebss, %a1
+	move.l	%a1, _ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
+	/*
+	 *	Zero out the bss region.
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Get end of bss */
+	clr.l	%d0				/* Set value */
+_clear_bss:
+	move.l	%d0, (%a0)+			/* Clear each word */
+	cmp.l	%a0, %a1			/* Check if at end */
+	bne	_clear_bss
+
+	/*
+	 *	Load the current thread pointer and stack.
+	 */
+	lea	init_thread_union, %a0
+	lea	0x2000(%a0), %sp
+
+	/*
+	 *	Assember start up done, start code proper.
+	 */
+	jsr	start_kernel			/* Start Linux kernel */
+
+_exit:
+	jmp	_exit				/* Should never get here */
+
+/*****************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/527x/config.c linux-2.6.9-uc0/arch/m68knommu/platform/527x/config.c
--- linux-2.6.9/arch/m68knommu/platform/527x/config.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/527x/config.c	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,82 @@
+/***************************************************************************/
+
+/*
+ *	linux/arch/m68knommu/platform/527x/config.c
+ *
+ *	Sub-architcture dependant initialization code for the Freescale
+ *	5270/5271 CPUs.
+ *
+ *	Copyright (C) 1999-2004, Greg Ungerer (gerg@snapgear.com)
+ *	Copyright (C) 2001-2004, SnapGear Inc. (www.snapgear.com)
+ */
+
+/***************************************************************************/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/param.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/dma.h>
+#include <asm/traps.h>
+#include <asm/machdep.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/mcfdma.h>
+
+/***************************************************************************/
+
+void coldfire_pit_tick(void);
+void coldfire_pit_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
+unsigned long coldfire_pit_offset(void);
+void coldfire_trap_init(void);
+void coldfire_reset(void);
+
+/***************************************************************************/
+
+/*
+ *	DMA channel base address table.
+ */
+unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
+        MCF_MBAR + MCFDMA_BASE0,
+};
+
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
+/***************************************************************************/
+
+void mcf_disableall(void)
+{
+	*((volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRH)) = 0xffffffff;
+	*((volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRL)) = 0xffffffff;
+}
+
+/***************************************************************************/
+
+void mcf_autovector(unsigned int vec)
+{
+	/* Everything is auto-vectored on the 5272 */
+}
+
+/***************************************************************************/
+
+void config_BSP(char *commandp, int size)
+{
+	mcf_disableall();
+
+#ifdef CONFIG_BOOTPARAM
+	strncpy(commandp, CONFIG_BOOTPARAM_STRING, size);
+	commandp[size-1] = 0;
+#else
+	memset(commandp, 0, size);
+#endif
+
+	mach_sched_init = coldfire_pit_init;
+	mach_tick = coldfire_pit_tick;
+	mach_gettimeoffset = coldfire_pit_offset;
+	mach_trap_init = coldfire_trap_init;
+	mach_reset = coldfire_reset;
+}
+
+/***************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/527x/M5271EVB/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/527x/M5271EVB/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/527x/M5271EVB/crt0_ram.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/527x/M5271EVB/crt0_ram.S	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,166 @@
+/*****************************************************************************/
+
+/*
+ *	crt0_ram.S -- startup code for MCF527x ColdFire based Freescale boards.
+ *
+ *	(C) Copyright 2003-2004, Greg Ungerer (gerg@snapgear.com).
+ */
+
+/*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+/*****************************************************************************/
+
+/*
+ *	Freescale M5271EVB ColdFire eval board, chip select and memory setup.
+ */
+
+#define	MEM_BASE	0x00000000	/* Memory base at address 0 */
+#define	VBR_BASE	MEM_BASE	/* Vector address */
+
+#if defined(CONFIG_RAM4MB)
+#define	MEM_SIZE	0x00400000	/* Memory size 4Mb */
+#elif defined(CONFIG_RAM8MB)
+#define	MEM_SIZE	0x00800000	/* Memory size 8Mb */
+#else
+#define	MEM_SIZE	0x01000000	/* Memory size 16Mb */
+#endif
+
+/*****************************************************************************/
+
+.global	_start
+.global _rambase
+.global _ramvec
+.global	_ramstart
+.global	_ramend
+
+/*****************************************************************************/
+
+.data
+
+/*
+ *	Set up the usable of RAM stuff. Size of RAM is determined then
+ *	an initial stack set up at the end.
+ */
+_rambase:
+.long	0
+_ramvec:
+.long	0
+_ramstart:
+.long	0
+_ramend:
+.long	0
+
+/*****************************************************************************/
+
+.text
+
+/*
+ *	This is the codes first entry point. This is where it all
+ *	begins...
+ */
+
+_start:
+	nop					/* Filler */
+	move.w	#0x2700, %sr			/* No interrupts */
+
+	/*
+	 * Setup VBR here, otherwise buserror remap will not work.
+	 * if dBug was active before (on my SBC with dBug 1.1 of Dec 16 1996)
+	 *
+	 * bkr@cut.de 19990306
+	 *
+	 * Note: this is because dBUG points VBR to ROM, making vectors read
+	 * only, so the bus trap can't be changed. (RS)
+	 */
+	move.l	#VBR_BASE, %a7			/* Note VBR can't be read */
+	movec   %a7, %VBR
+	move.l	%a7, _ramvec			/* Set up vector addr */
+	move.l	%a7, _rambase			/* Set up base RAM addr */
+
+
+	/*
+	 *	Set memory size.
+	 */
+	move.l	#MEM_SIZE, %a0
+
+	move.l	%a0, %d0			/* Mem end addr is in a0 */
+	move.l	%d0, %sp			/* Set up initial stack ptr */
+	move.l	%d0, _ramend			/* Set end ram addr */
+
+	/*
+	 *	Enable CPU internal cache.
+	 */
+	move.l	#0x01400000, %d0
+	movec	%d0, %CACR			/* Invalidate cache */
+	nop
+
+	move.l	#0x0000c000, %d0		/* Set SDRAM cached only */
+	movec	%d0, %ACR0
+	move.l	#0x00000000, %d0		/* No other regions cached */
+	movec	%d0, %ACR1
+
+	move.l	#0x80400100, %d0		/* Configure cache */
+	movec	%d0, %CACR			/* Enable cache */
+	nop
+
+
+#ifdef CONFIG_ROMFS_FS
+	/*
+	 *	Move ROM filesystem above bss :-)
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Set up destination  */
+	move.l	%a0, %a2			/* Copy of bss start */
+
+	move.l	8(%a0), %d0			/* Get size of ROMFS */
+	addq.l	#8, %d0				/* Allow for rounding */
+	and.l	#0xfffffffc, %d0		/* Whole words */
+
+	add.l	%d0, %a0			/* Copy from end */
+	add.l	%d0, %a1			/* Copy from end */
+	move.l	%a1, _ramstart			/* Set start of ram */
+
+_copy_romfs:
+	move.l	-(%a0), %d0			/* Copy dword */
+	move.l	%d0, -(%a1)
+	cmp.l	%a0, %a2			/* Check if at end */
+	bne	_copy_romfs
+#else /* CONFIG_ROMFS_FS */
+	lea.l	_ebss, %a1
+	move.l	%a1, _ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
+	/*
+	 *	Zero out the bss region.
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Get end of bss */
+	clr.l	%d0				/* Set value */
+_clear_bss:
+	move.l	%d0, (%a0)+			/* Clear each word */
+	cmp.l	%a0, %a1			/* Check if at end */
+	bne	_clear_bss
+
+	/*
+	 *	Load the current thread pointer and stack.
+	 */
+	lea	init_thread_union, %a0
+	lea	0x2000(%a0), %sp
+
+	/*
+	 *	Assember start up done, start code proper.
+	 */
+	jsr	start_kernel			/* Start Linux kernel */
+
+_exit:
+	jmp	_exit				/* Should never get here */
+
+/*****************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/527x/M5275EVB/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/527x/M5275EVB/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/527x/M5275EVB/crt0_ram.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/527x/M5275EVB/crt0_ram.S	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,166 @@
+/*****************************************************************************/
+
+/*
+ *	crt0_ram.S -- startup code for MCF527x ColdFire based Freescale boards.
+ *
+ *	(C) Copyright 2003-2004, Greg Ungerer (gerg@snapgear.com).
+ */
+
+/*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+/*****************************************************************************/
+
+/*
+ *	Freescale M5275EVB ColdFire eval board, chip select and memory setup.
+ */
+
+#define	MEM_BASE	0x00000000	/* Memory base at address 0 */
+#define	VBR_BASE	MEM_BASE	/* Vector address */
+
+#if defined(CONFIG_RAM4MB)
+#define	MEM_SIZE	0x00400000	/* Memory size 4Mb */
+#elif defined(CONFIG_RAM8MB)
+#define	MEM_SIZE	0x00800000	/* Memory size 8Mb */
+#else
+#define	MEM_SIZE	0x01000000	/* Memory size 16Mb */
+#endif
+
+/*****************************************************************************/
+
+.global	_start
+.global _rambase
+.global _ramvec
+.global	_ramstart
+.global	_ramend
+
+/*****************************************************************************/
+
+.data
+
+/*
+ *	Set up the usable of RAM stuff. Size of RAM is determined then
+ *	an initial stack set up at the end.
+ */
+_rambase:
+.long	0
+_ramvec:
+.long	0
+_ramstart:
+.long	0
+_ramend:
+.long	0
+
+/*****************************************************************************/
+
+.text
+
+/*
+ *	This is the codes first entry point. This is where it all
+ *	begins...
+ */
+
+_start:
+	nop					/* Filler */
+	move.w	#0x2700, %sr			/* No interrupts */
+
+	/*
+	 * Setup VBR here, otherwise buserror remap will not work.
+	 * if dBug was active before (on my SBC with dBug 1.1 of Dec 16 1996)
+	 *
+	 * bkr@cut.de 19990306
+	 *
+	 * Note: this is because dBUG points VBR to ROM, making vectors read
+	 * only, so the bus trap can't be changed. (RS)
+	 */
+	move.l	#VBR_BASE, %a7			/* Note VBR can't be read */
+	movec   %a7, %VBR
+	move.l	%a7, _ramvec			/* Set up vector addr */
+	move.l	%a7, _rambase			/* Set up base RAM addr */
+
+
+	/*
+	 *	Set memory size.
+	 */
+	move.l	#MEM_SIZE, %a0
+
+	move.l	%a0, %d0			/* Mem end addr is in a0 */
+	move.l	%d0, %sp			/* Set up initial stack ptr */
+	move.l	%d0, _ramend			/* Set end ram addr */
+
+	/*
+	 *	Enable CPU internal cache.
+	 */
+	move.l	#0x01400000, %d0
+	movec	%d0, %CACR			/* Invalidate cache */
+	nop
+
+	move.l	#0x0000c000, %d0		/* Set SDRAM cached only */
+	movec	%d0, %ACR0
+	move.l	#0x00000000, %d0		/* No other regions cached */
+	movec	%d0, %ACR1
+
+	move.l	#0x80400100, %d0		/* Configure cache */
+	movec	%d0, %CACR			/* Enable cache */
+	nop
+
+
+#ifdef CONFIG_ROMFS_FS
+	/*
+	 *	Move ROM filesystem above bss :-)
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Set up destination  */
+	move.l	%a0, %a2			/* Copy of bss start */
+
+	move.l	8(%a0), %d0			/* Get size of ROMFS */
+	addq.l	#8, %d0				/* Allow for rounding */
+	and.l	#0xfffffffc, %d0		/* Whole words */
+
+	add.l	%d0, %a0			/* Copy from end */
+	add.l	%d0, %a1			/* Copy from end */
+	move.l	%a1, _ramstart			/* Set start of ram */
+
+_copy_romfs:
+	move.l	-(%a0), %d0			/* Copy dword */
+	move.l	%d0, -(%a1)
+	cmp.l	%a0, %a2			/* Check if at end */
+	bne	_copy_romfs
+#else /* CONFIG_ROMFS_FS */
+	lea.l	_ebss, %a1
+	move.l	%a1, _ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
+	/*
+	 *	Zero out the bss region.
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Get end of bss */
+	clr.l	%d0				/* Set value */
+_clear_bss:
+	move.l	%d0, (%a0)+			/* Clear each word */
+	cmp.l	%a0, %a1			/* Check if at end */
+	bne	_clear_bss
+
+	/*
+	 *	Load the current thread pointer and stack.
+	 */
+	lea	init_thread_union, %a0
+	lea	0x2000(%a0), %sp
+
+	/*
+	 *	Assember start up done, start code proper.
+	 */
+	jsr	start_kernel			/* Start Linux kernel */
+
+_exit:
+	jmp	_exit				/* Should never get here */
+
+/*****************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/527x/Makefile linux-2.6.9-uc0/arch/m68knommu/platform/527x/Makefile
--- linux-2.6.9/arch/m68knommu/platform/527x/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/527x/Makefile	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,21 @@
+#
+# Makefile for the linux kernel.
+#
+
+#
+# If you want to play with the HW breakpoints then you will
+# need to add define this,  which will give you a stack backtrace
+# on the console port whenever a DBG interrupt occurs.  You have to
+# set up you HW breakpoints to trigger a DBG interrupt:
+#
+# EXTRA_CFLAGS += -DTRAP_DBG_INTERRUPT
+# EXTRA_AFLAGS += -DTRAP_DBG_INTERRUPT
+#
+
+ifdef CONFIG_FULLDEBUG
+AFLAGS += -DDEBUGGER_COMPATIBLE_CACHE=1
+endif
+
+obj-y := config.o
+
+extra-y := $(BOARD)/crt0_$(MODEL).o
diff -Naur linux-2.6.9/arch/m68knommu/platform/5282/config.c linux-2.6.9-uc0/arch/m68knommu/platform/5282/config.c
--- linux-2.6.9/arch/m68knommu/platform/5282/config.c	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5282/config.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,82 +0,0 @@
-/***************************************************************************/
-
-/*
- *	linux/arch/m68knommu/platform/5282/config.c
- *
- *	Sub-architcture dependant initialization code for the Motorola
- *	5282 CPU.
- *
- *	Copyright (C) 1999-2003, Greg Ungerer (gerg@snapgear.com)
- *	Copyright (C) 2001-2003, SnapGear Inc. (www.snapgear.com)
- */
-
-/***************************************************************************/
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/param.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <asm/dma.h>
-#include <asm/traps.h>
-#include <asm/machdep.h>
-#include <asm/coldfire.h>
-#include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
-
-/***************************************************************************/
-
-void coldfire_pit_tick(void);
-void coldfire_pit_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
-unsigned long coldfire_pit_offset(void);
-void coldfire_trap_init(void);
-void coldfire_reset(void);
-
-/***************************************************************************/
-
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
-};
-
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
-
-/***************************************************************************/
-
-void mcf_disableall(void)
-{
-	*((volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRH)) = 0xffffffff;
-	*((volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRL)) = 0xffffffff;
-}
-
-/***************************************************************************/
-
-void mcf_autovector(unsigned int vec)
-{
-	/* Everything is auto-vectored on the 5272 */
-}
-
-/***************************************************************************/
-
-void config_BSP(char *commandp, int size)
-{
-	mcf_disableall();
-
-#ifdef CONFIG_BOOTPARAM
-	strncpy(commandp, CONFIG_BOOTPARAM_STRING, size);
-	commandp[size-1] = 0;
-#else
-	memset(commandp, 0, size);
-#endif
-
-	mach_sched_init = coldfire_pit_init;
-	mach_tick = coldfire_pit_tick;
-	mach_gettimeoffset = coldfire_pit_offset;
-	mach_trap_init = coldfire_trap_init;
-	mach_reset = coldfire_reset;
-}
-
-/***************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/5282/Makefile linux-2.6.9-uc0/arch/m68knommu/platform/5282/Makefile
--- linux-2.6.9/arch/m68knommu/platform/5282/Makefile	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5282/Makefile	1970-01-01 10:00:00.000000000 +1000
@@ -1,21 +0,0 @@
-#
-# Makefile for the linux kernel.
-#
-
-#
-# If you want to play with the HW breakpoints then you will
-# need to add define this,  which will give you a stack backtrace
-# on the console port whenever a DBG interrupt occurs.  You have to
-# set up you HW breakpoints to trigger a DBG interrupt:
-#
-# EXTRA_CFLAGS += -DTRAP_DBG_INTERRUPT
-# EXTRA_AFLAGS += -DTRAP_DBG_INTERRUPT
-#
-
-ifdef CONFIG_FULLDEBUG
-AFLAGS += -DDEBUGGER_COMPATIBLE_CACHE=1
-endif
-
-obj-y := config.o pit.o
-
-extra-y := $(BOARD)/crt0_$(MODEL).o
diff -Naur linux-2.6.9/arch/m68knommu/platform/5282/MOTOROLA/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/5282/MOTOROLA/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/5282/MOTOROLA/crt0_ram.S	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5282/MOTOROLA/crt0_ram.S	1970-01-01 10:00:00.000000000 +1000
@@ -1,171 +0,0 @@
-/*****************************************************************************/
-
-/*
- *	crt0_ram.S -- startup code for MCF5282 ColdFire based MOTOROLA boards.
- *
- *	(C) Copyright 2003, Greg Ungerer (gerg@snapgear.com).
- */
-
-/*****************************************************************************/
-
-#include <linux/config.h>
-#include <linux/threads.h>
-#include <linux/linkage.h>
-#include <asm/segment.h>
-#include <asm/coldfire.h>
-#include <asm/mcfsim.h>
-
-/*****************************************************************************/
-
-/*
- *	Motorola M5282C3 ColdFire eval board, chip select and memory setup.
- */
-
-#define	MEM_BASE	0x00000000	/* Memory base at address 0 */
-#define	VBR_BASE	MEM_BASE	/* Vector address */
-
-#if defined(CONFIG_RAM16MB)
-#define	MEM_SIZE	0x01000000	/* Memory size 16Mb */
-#elif defined(CONFIG_RAM8MB)
-#define	MEM_SIZE	0x00800000	/* Memory size 8Mb */
-#else
-#define	MEM_SIZE	0x00400000	/* Memory size 4Mb */
-#endif
-
-/*****************************************************************************/
-
-.global	_start
-.global _rambase
-.global _ramvec
-.global	_ramstart
-.global	_ramend
-
-/*****************************************************************************/
-
-.data
-
-/*
- *	Set up the usable of RAM stuff. Size of RAM is determined then
- *	an initial stack set up at the end.
- */
-_rambase:
-.long	0
-_ramvec:
-.long	0
-_ramstart:
-.long	0
-_ramend:
-.long	0
-
-/*****************************************************************************/
-
-.text
-
-/*
- *	This is the codes first entry point. This is where it all
- *	begins...
- */
-
-_start:
-	nop					/* Filler */
-	move.w	#0x2700, %sr			/* No interrupts */
-
-	/*
-	 * Setup VBR here, otherwise buserror remap will not work.
-	 * if dBug was active before (on my SBC with dBug 1.1 of Dec 16 1996)
-	 *
-	 * bkr@cut.de 19990306
-	 *
-	 * Note: this is because dBUG points VBR to ROM, making vectors read
-	 * only, so the bus trap can't be changed. (RS)
-	 */
-	move.l	#VBR_BASE, %a7			/* Note VBR can't be read */
-	movec   %a7, %VBR
-	move.l	%a7, _ramvec			/* Set up vector addr */
-	move.l	%a7, _rambase			/* Set up base RAM addr */
-
-
-	/*
-	 *	Set memory size.
-	 */
-	move.l	#MEM_SIZE, %a0
-
-	move.l	%a0, %d0			/* Mem end addr is in a0 */
-	move.l	%d0, %sp			/* Set up initial stack ptr */
-	move.l	%d0, _ramend			/* Set end ram addr */
-
-	/*
-	 *	Enable CPU internal cache.
-	 *
-	 *	Cache is totally broken in first 5282 silicon.
-	 *	No point enabling it for now.
-	 */
-#if 0
-	move.l	#0x01000000, %d0
-	movec	%d0, %CACR			/* Invalidate cache */
-	nop
-
-	move.l	#0x0000c000, %d0		/* Set SDRAM cached only */
-	movec	%d0, %ACR0
-	move.l	#0x00000000, %d0		/* No other regions cached */
-	movec	%d0, %ACR1
-
-	move.l	#0x00000000, %d0		/* Setup cache mask */
-	movec	%d0, %CACR			/* Enable cache */
-	nop
-#endif
-
-
-#ifdef CONFIG_ROMFS_FS
-	/*
-	 *	Move ROM filesystem above bss :-)
-	 */
-	lea.l	_sbss, %a0			/* Get start of bss */
-	lea.l	_ebss, %a1			/* Set up destination  */
-	move.l	%a0, %a2			/* Copy of bss start */
-
-	move.l	8(%a0), %d0			/* Get size of ROMFS */
-	addq.l	#8, %d0				/* Allow for rounding */
-	and.l	#0xfffffffc, %d0		/* Whole words */
-
-	add.l	%d0, %a0			/* Copy from end */
-	add.l	%d0, %a1			/* Copy from end */
-	move.l	%a1, _ramstart			/* Set start of ram */
-
-_copy_romfs:
-	move.l	-(%a0), %d0			/* Copy dword */
-	move.l	%d0, -(%a1)
-	cmp.l	%a0, %a2			/* Check if at end */
-	bne	_copy_romfs
-#else /* CONFIG_ROMFS_FS */
-	lea.l	_ebss, %a1
-	move.l	%a1, _ramstart
-#endif /* CONFIG_ROMFS_FS */
-
-
-	/*
-	 *	Zero out the bss region.
-	 */
-	lea.l	_sbss, %a0			/* Get start of bss */
-	lea.l	_ebss, %a1			/* Get end of bss */
-	clr.l	%d0				/* Set value */
-_clear_bss:
-	move.l	%d0, (%a0)+			/* Clear each word */
-	cmp.l	%a0, %a1			/* Check if at end */
-	bne	_clear_bss
-
-	/*
-	 *	Load the current thread pointer and stack.
-	 */
-	lea	init_thread_union, %a0
-	lea	0x2000(%a0), %sp
-
-	/*
-	 *	Assember start up done, start code proper.
-	 */
-	jsr	start_kernel			/* Start Linux kernel */
-
-_exit:
-	jmp	_exit				/* Should never get here */
-
-/*****************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/5282/pit.c linux-2.6.9-uc0/arch/m68knommu/platform/5282/pit.c
--- linux-2.6.9/arch/m68knommu/platform/5282/pit.c	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5282/pit.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,87 +0,0 @@
-/***************************************************************************/
-
-/*
- *	pit.c -- Motorola ColdFire PIT timer. Currently this type of
- *	         hardware timer only exists in the Motorola ColdFire
- *		 5282 CPU.
- *
- *	Copyright (C) 1999-2003, Greg Ungerer (gerg@snapgear.com)
- *	Copyright (C) 2001-2003, SnapGear Inc. (www.snapgear.com)
- *
- */
-
-/***************************************************************************/
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/param.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <asm/irq.h>
-#include <asm/coldfire.h>
-#include <asm/mcfpit.h>
-#include <asm/mcfsim.h>
-
-/***************************************************************************/
-
-void coldfire_pit_tick(void)
-{
-	volatile struct mcfpit *tp;
-
-	/* Reset the ColdFire timer */
-	tp = (volatile struct mcfpit *) (MCF_IPSBAR + MCFPIT_BASE1);
-	tp->pcsr |= MCFPIT_PCSR_PIF;
-}
-
-/***************************************************************************/
-
-void coldfire_pit_init(irqreturn_t (*handler)(int, void *, struct pt_regs *))
-{
-	volatile unsigned char *icrp;
-	volatile unsigned long *imrp;
-	volatile struct mcfpit *tp;
-
-	request_irq(64+55, handler, SA_INTERRUPT, "ColdFire Timer", NULL);
-
-	icrp = (volatile unsigned char *) (MCF_IPSBAR + MCFICM_INTC0 +
-		MCFINTC_ICR0 + MCFINT_PIT1);
-	*icrp = 0x2b; /* PIT1 with level 5, priority 3 */
-
-	imrp = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRH);
-	*imrp &= ~(1 << (55 - 32));
-
-	/* Set up PIT timer 1 as poll clock */
-	tp = (volatile struct mcfpit *) (MCF_IPSBAR + MCFPIT_BASE1);
-	tp->pcsr = MCFPIT_PCSR_DISABLE;
-
-	tp->pmr = ((MCF_CLK / 2) / 64) / HZ;
-	tp->pcsr = MCFPIT_PCSR_EN | MCFPIT_PCSR_PIE | MCFPIT_PCSR_OVW |
-		MCFPIT_PCSR_RLD | MCFPIT_PCSR_CLK64;
-}
-
-/***************************************************************************/
-
-unsigned long coldfire_pit_offset(void)
-{
-	volatile struct mcfpit *tp;
-	volatile unsigned long *ipr;
-	unsigned long pmr, pcntr, offset;
-
-	tp = (volatile struct mcfpit *) (MCF_IPSBAR + MCFPIT_BASE1);
-	ipr = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IPRH);
-
-	pmr = tp->pmr;
-	pcntr = tp->pcntr;
-
-	/*
-	 * If we are still in the first half of the upcount and a
-	 * timer interupt is pending, then add on a ticks worth of time.
-	 */
-	offset = ((pcntr * (1000000 / HZ)) / pmr);
-	if ((offset < (1000000 / HZ / 2)) && (*ipr & (1 << (55 - 32))))
-		offset += 1000000 / HZ;
-	return offset;	
-}
-
-/***************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/5282/senTec/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/5282/senTec/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/5282/senTec/crt0_ram.S	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5282/senTec/crt0_ram.S	1970-01-01 10:00:00.000000000 +1000
@@ -1,180 +0,0 @@
-/*****************************************************************************/
-
-/*
- *	crt0_ram.S -- startup code for MCF5282 ColdFire based boards.
- *
- *	(C) Copyright 2003, Greg Ungerer (gerg@snapgear.com).
- */
-
-/*****************************************************************************/
-
-#include <linux/config.h>
-#include <linux/threads.h>
-#include <linux/linkage.h>
-#include <asm/segment.h>
-#include <asm/coldfire.h>
-#include <asm/mcfsim.h>
-
-/*****************************************************************************/
-
-/*
- *	senTec COBRA5282 board, chip select and memory setup.
- */
-
-#define	MEM_BASE	0x00000000	/* Memory base at address 0 */
-#define	VBR_BASE	MEM_BASE	/* Vector address */
-
-#if defined(CONFIG_RAM16MB)
-#define	MEM_SIZE	0x01000000	/* Memory size 16Mb */
-#elif defined(CONFIG_RAM8MB)
-#define	MEM_SIZE	0x00800000	/* Memory size 8Mb */
-#else
-#define	MEM_SIZE	0x00400000	/* Memory size 4Mb */
-#endif
-
-#define IPSBAR 0x40000000
-#define GPACR0 0x30
-/*****************************************************************************/
-
-.global	_start
-.global	_rambase
-.global	_ramvec
-.global	_ramstart
-.global	_ramend
-
-/*****************************************************************************/
-
-.data
-
-/*
- *	Set up the usable of RAM stuff. Size of RAM is determined then
- *	an initial stack set up at the end.
- */
-_rambase:
-.long	0
-_ramvec:
-.long	0
-_ramstart:
-.long	0
-_ramend:
-.long	0
-
-/*****************************************************************************/
-
-.text
-
-/*
- *	This is the codes first entry point. This is where it all
- *	begins...
- */
-
-_start:
-	nop								/* Filler */
-	move.w	#0x2700, %sr			/* No interrupts */
-
-	/*
-	 * Setup VBR here, otherwise buserror remap will not work.
-	 * if dBug was active before (on my SBC with dBug 1.1 of Dec 16 1996)
-	 *
-	 * bkr@cut.de 19990306
-	 *
-	 * Note: this is because dBUG points VBR to ROM, making vectors read
-	 * only, so the bus trap can't be changed. (RS)
-	 */
-	move.l	#VBR_BASE, %a7			/* Note VBR can't be read */
-	movec   %a7, %VBR
-	move.l	%a7, _ramvec			/* Set up vector addr */
-	move.l	%a7, _rambase			/* Set up base RAM addr */
-
-
-	/*
-	 *	Set memory size.
-	 */
-	move.l	#MEM_SIZE, %a0
-
-	move.l	%a0, %d0			/* Mem end addr is in a0 */
-	move.l	%d0, %sp			/* Set up initial stack ptr */
-	move.l	%d0, _ramend		/* Set end ram addr */
-
-	/*
-	 *	Enable CPU internal cache.
-	 *
-	 *	Cache is totally broken in first 5282 silicon.
-	 *	No point enabling it for now.
-	 */
-#if 0
-	move.l	#0x01000000, %d0
-	movec	%d0, %CACR				/* Invalidate cache */
-	nop
-
-	move.l	#0x0000c000, %d0		/* Set SDRAM cached only */
-	movec	%d0, %ACR0
-	move.l	#0x00000000, %d0		/* No other regions cached */
-	movec	%d0, %ACR1
-
-	move.l	#0x00000000, %d0		/* Setup cache mask */
-	movec	%d0, %CACR				/* Enable cache */
-	nop
-#endif
-
-
-#ifdef CONFIG_ROMFS_FS
-	/*
-	 *	Move ROM filesystem above bss :-)
-	 */
-	lea.l	_sbss, %a0			/* Get start of bss */
-	lea.l	_ebss, %a1			/* Set up destination  */
-	move.l	%a0, %a2			/* Copy of bss start */
-
-	move.l	8(%a0), %d0			/* Get size of ROMFS */
-	addq.l	#8, %d0				/* Allow for rounding */
-	and.l	#0xfffffffc, %d0	/* Whole words */
-
-	add.l	%d0, %a0			/* Copy from end */
-	add.l	%d0, %a1			/* Copy from end */
-	move.l	%a1, _ramstart		/* Set start of ram */
-
-_copy_romfs:
-	move.l	-(%a0), %d0			/* Copy dword */
-	move.l	%d0, -(%a1)
-	cmp.l	%a0, %a2			/* Check if at end */
-	bne	_copy_romfs
-#else /* CONFIG_ROMFS_FS */
-	lea.l	_ebss, %a1
-	move.l	%a1, _ramstart
-#endif /* CONFIG_ROMFS_FS */
-
-
-	/*
-	 *	Zero out the bss region.
-	 */
-	lea.l	_sbss, %a0			/* Get start of bss */
-	lea.l	_ebss, %a1			/* Get end of bss */
-	clr.l	%d0					/* Set value */
-_clear_bss:
-	move.l	%d0, (%a0)+			/* Clear each word */
-	cmp.l	%a0, %a1			/* Check if at end */
-	bne	_clear_bss
-
-	/*
-	 *	Load the current thread pointer and stack.
-	 */
-	lea	init_thread_union, %a0
-	lea	0x2000(%a0), %sp
-
-   /*
-    * User mode port access
-    */
-   move.l   #0x0000000c, %d0
-   move.b   %d0, (IPSBAR+GPACR0)
-
-
-	/*
-	 *	Assember start up done, start code proper.
-	 */
-	jsr	start_kernel			/* Start Linux kernel */
-
-_exit:
-	jmp	_exit				/* Should never get here */
-
-/*****************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/528x/config.c linux-2.6.9-uc0/arch/m68knommu/platform/528x/config.c
--- linux-2.6.9/arch/m68knommu/platform/528x/config.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/528x/config.c	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,82 @@
+/***************************************************************************/
+
+/*
+ *	linux/arch/m68knommu/platform/528x/config.c
+ *
+ *	Sub-architcture dependant initialization code for the Motorola
+ *	5280 and 5282 CPUs.
+ *
+ *	Copyright (C) 1999-2003, Greg Ungerer (gerg@snapgear.com)
+ *	Copyright (C) 2001-2003, SnapGear Inc. (www.snapgear.com)
+ */
+
+/***************************************************************************/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/param.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/dma.h>
+#include <asm/traps.h>
+#include <asm/machdep.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/mcfdma.h>
+
+/***************************************************************************/
+
+void coldfire_pit_tick(void);
+void coldfire_pit_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
+unsigned long coldfire_pit_offset(void);
+void coldfire_trap_init(void);
+void coldfire_reset(void);
+
+/***************************************************************************/
+
+/*
+ *	DMA channel base address table.
+ */
+unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
+        MCF_MBAR + MCFDMA_BASE0,
+};
+
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
+/***************************************************************************/
+
+void mcf_disableall(void)
+{
+	*((volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRH)) = 0xffffffff;
+	*((volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRL)) = 0xffffffff;
+}
+
+/***************************************************************************/
+
+void mcf_autovector(unsigned int vec)
+{
+	/* Everything is auto-vectored on the 5272 */
+}
+
+/***************************************************************************/
+
+void config_BSP(char *commandp, int size)
+{
+	mcf_disableall();
+
+#ifdef CONFIG_BOOTPARAM
+	strncpy(commandp, CONFIG_BOOTPARAM_STRING, size);
+	commandp[size-1] = 0;
+#else
+	memset(commandp, 0, size);
+#endif
+
+	mach_sched_init = coldfire_pit_init;
+	mach_tick = coldfire_pit_tick;
+	mach_gettimeoffset = coldfire_pit_offset;
+	mach_trap_init = coldfire_trap_init;
+	mach_reset = coldfire_reset;
+}
+
+/***************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/528x/M5282EVB/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/528x/M5282EVB/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/528x/M5282EVB/crt0_ram.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/528x/M5282EVB/crt0_ram.S	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,171 @@
+/*****************************************************************************/
+
+/*
+ *	crt0_ram.S -- startup code for M5282EVB ColdFire based MOTOROLA boards.
+ *
+ *	(C) Copyright 2003, Greg Ungerer (gerg@snapgear.com).
+ */
+
+/*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+/*****************************************************************************/
+
+/*
+ *	Motorola M5282EVB ColdFire eval board, chip select and memory setup.
+ */
+
+#define	MEM_BASE	0x00000000	/* Memory base at address 0 */
+#define	VBR_BASE	MEM_BASE	/* Vector address */
+
+#if defined(CONFIG_RAM16MB)
+#define	MEM_SIZE	0x01000000	/* Memory size 16Mb */
+#elif defined(CONFIG_RAM8MB)
+#define	MEM_SIZE	0x00800000	/* Memory size 8Mb */
+#else
+#define	MEM_SIZE	0x00400000	/* Memory size 4Mb */
+#endif
+
+/*****************************************************************************/
+
+.global	_start
+.global _rambase
+.global _ramvec
+.global	_ramstart
+.global	_ramend
+
+/*****************************************************************************/
+
+.data
+
+/*
+ *	Set up the usable of RAM stuff. Size of RAM is determined then
+ *	an initial stack set up at the end.
+ */
+_rambase:
+.long	0
+_ramvec:
+.long	0
+_ramstart:
+.long	0
+_ramend:
+.long	0
+
+/*****************************************************************************/
+
+.text
+
+/*
+ *	This is the codes first entry point. This is where it all
+ *	begins...
+ */
+
+_start:
+	nop					/* Filler */
+	move.w	#0x2700, %sr			/* No interrupts */
+
+	/*
+	 * Setup VBR here, otherwise buserror remap will not work.
+	 * if dBug was active before (on my SBC with dBug 1.1 of Dec 16 1996)
+	 *
+	 * bkr@cut.de 19990306
+	 *
+	 * Note: this is because dBUG points VBR to ROM, making vectors read
+	 * only, so the bus trap can't be changed. (RS)
+	 */
+	move.l	#VBR_BASE, %a7			/* Note VBR can't be read */
+	movec   %a7, %VBR
+	move.l	%a7, _ramvec			/* Set up vector addr */
+	move.l	%a7, _rambase			/* Set up base RAM addr */
+
+
+	/*
+	 *	Set memory size.
+	 */
+	move.l	#MEM_SIZE, %a0
+
+	move.l	%a0, %d0			/* Mem end addr is in a0 */
+	move.l	%d0, %sp			/* Set up initial stack ptr */
+	move.l	%d0, _ramend			/* Set end ram addr */
+
+	/*
+	 *	Enable CPU internal cache.
+	 *
+	 *	Cache is totally broken in first 5282 silicon.
+	 *	No point enabling it for now.
+	 */
+#if 0
+	move.l	#0x01000000, %d0
+	movec	%d0, %CACR			/* Invalidate cache */
+	nop
+
+	move.l	#0x0000c000, %d0		/* Set SDRAM cached only */
+	movec	%d0, %ACR0
+	move.l	#0x00000000, %d0		/* No other regions cached */
+	movec	%d0, %ACR1
+
+	move.l	#0x00000000, %d0		/* Setup cache mask */
+	movec	%d0, %CACR			/* Enable cache */
+	nop
+#endif
+
+
+#ifdef CONFIG_ROMFS_FS
+	/*
+	 *	Move ROM filesystem above bss :-)
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Set up destination  */
+	move.l	%a0, %a2			/* Copy of bss start */
+
+	move.l	8(%a0), %d0			/* Get size of ROMFS */
+	addq.l	#8, %d0				/* Allow for rounding */
+	and.l	#0xfffffffc, %d0		/* Whole words */
+
+	add.l	%d0, %a0			/* Copy from end */
+	add.l	%d0, %a1			/* Copy from end */
+	move.l	%a1, _ramstart			/* Set start of ram */
+
+_copy_romfs:
+	move.l	-(%a0), %d0			/* Copy dword */
+	move.l	%d0, -(%a1)
+	cmp.l	%a0, %a2			/* Check if at end */
+	bne	_copy_romfs
+#else /* CONFIG_ROMFS_FS */
+	lea.l	_ebss, %a1
+	move.l	%a1, _ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
+	/*
+	 *	Zero out the bss region.
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Get end of bss */
+	clr.l	%d0				/* Set value */
+_clear_bss:
+	move.l	%d0, (%a0)+			/* Clear each word */
+	cmp.l	%a0, %a1			/* Check if at end */
+	bne	_clear_bss
+
+	/*
+	 *	Load the current thread pointer and stack.
+	 */
+	lea	init_thread_union, %a0
+	lea	0x2000(%a0), %sp
+
+	/*
+	 *	Assember start up done, start code proper.
+	 */
+	jsr	start_kernel			/* Start Linux kernel */
+
+_exit:
+	jmp	_exit				/* Should never get here */
+
+/*****************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/528x/Makefile linux-2.6.9-uc0/arch/m68knommu/platform/528x/Makefile
--- linux-2.6.9/arch/m68knommu/platform/528x/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/528x/Makefile	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,21 @@
+#
+# Makefile for the linux kernel.
+#
+
+#
+# If you want to play with the HW breakpoints then you will
+# need to add define this,  which will give you a stack backtrace
+# on the console port whenever a DBG interrupt occurs.  You have to
+# set up you HW breakpoints to trigger a DBG interrupt:
+#
+# EXTRA_CFLAGS += -DTRAP_DBG_INTERRUPT
+# EXTRA_AFLAGS += -DTRAP_DBG_INTERRUPT
+#
+
+ifdef CONFIG_FULLDEBUG
+AFLAGS += -DDEBUGGER_COMPATIBLE_CACHE=1
+endif
+
+obj-y := config.o
+
+extra-y := $(BOARD)/crt0_$(MODEL).o
diff -Naur linux-2.6.9/arch/m68knommu/platform/528x/senTec/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/528x/senTec/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/528x/senTec/crt0_ram.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/528x/senTec/crt0_ram.S	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,180 @@
+/*****************************************************************************/
+
+/*
+ *	crt0_ram.S -- startup code for senTec COBRA5282 ColdFire based boards.
+ *
+ *	(C) Copyright 2003, Greg Ungerer (gerg@snapgear.com).
+ */
+
+/*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+/*****************************************************************************/
+
+/*
+ *	senTec COBRA5282 board, chip select and memory setup.
+ */
+
+#define	MEM_BASE	0x00000000	/* Memory base at address 0 */
+#define	VBR_BASE	MEM_BASE	/* Vector address */
+
+#if defined(CONFIG_RAM16MB)
+#define	MEM_SIZE	0x01000000	/* Memory size 16Mb */
+#elif defined(CONFIG_RAM8MB)
+#define	MEM_SIZE	0x00800000	/* Memory size 8Mb */
+#else
+#define	MEM_SIZE	0x00400000	/* Memory size 4Mb */
+#endif
+
+#define IPSBAR 0x40000000
+#define GPACR0 0x30
+/*****************************************************************************/
+
+.global	_start
+.global	_rambase
+.global	_ramvec
+.global	_ramstart
+.global	_ramend
+
+/*****************************************************************************/
+
+.data
+
+/*
+ *	Set up the usable of RAM stuff. Size of RAM is determined then
+ *	an initial stack set up at the end.
+ */
+_rambase:
+.long	0
+_ramvec:
+.long	0
+_ramstart:
+.long	0
+_ramend:
+.long	0
+
+/*****************************************************************************/
+
+.text
+
+/*
+ *	This is the codes first entry point. This is where it all
+ *	begins...
+ */
+
+_start:
+	nop								/* Filler */
+	move.w	#0x2700, %sr			/* No interrupts */
+
+	/*
+	 * Setup VBR here, otherwise buserror remap will not work.
+	 * if dBug was active before (on my SBC with dBug 1.1 of Dec 16 1996)
+	 *
+	 * bkr@cut.de 19990306
+	 *
+	 * Note: this is because dBUG points VBR to ROM, making vectors read
+	 * only, so the bus trap can't be changed. (RS)
+	 */
+	move.l	#VBR_BASE, %a7			/* Note VBR can't be read */
+	movec   %a7, %VBR
+	move.l	%a7, _ramvec			/* Set up vector addr */
+	move.l	%a7, _rambase			/* Set up base RAM addr */
+
+
+	/*
+	 *	Set memory size.
+	 */
+	move.l	#MEM_SIZE, %a0
+
+	move.l	%a0, %d0			/* Mem end addr is in a0 */
+	move.l	%d0, %sp			/* Set up initial stack ptr */
+	move.l	%d0, _ramend		/* Set end ram addr */
+
+	/*
+	 *	Enable CPU internal cache.
+	 *
+	 *	Cache is totally broken in first 5282 silicon.
+	 *	No point enabling it for now.
+	 */
+#if 0
+	move.l	#0x01000000, %d0
+	movec	%d0, %CACR				/* Invalidate cache */
+	nop
+
+	move.l	#0x0000c000, %d0		/* Set SDRAM cached only */
+	movec	%d0, %ACR0
+	move.l	#0x00000000, %d0		/* No other regions cached */
+	movec	%d0, %ACR1
+
+	move.l	#0x00000000, %d0		/* Setup cache mask */
+	movec	%d0, %CACR				/* Enable cache */
+	nop
+#endif
+
+
+#ifdef CONFIG_ROMFS_FS
+	/*
+	 *	Move ROM filesystem above bss :-)
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Set up destination  */
+	move.l	%a0, %a2			/* Copy of bss start */
+
+	move.l	8(%a0), %d0			/* Get size of ROMFS */
+	addq.l	#8, %d0				/* Allow for rounding */
+	and.l	#0xfffffffc, %d0	/* Whole words */
+
+	add.l	%d0, %a0			/* Copy from end */
+	add.l	%d0, %a1			/* Copy from end */
+	move.l	%a1, _ramstart		/* Set start of ram */
+
+_copy_romfs:
+	move.l	-(%a0), %d0			/* Copy dword */
+	move.l	%d0, -(%a1)
+	cmp.l	%a0, %a2			/* Check if at end */
+	bne	_copy_romfs
+#else /* CONFIG_ROMFS_FS */
+	lea.l	_ebss, %a1
+	move.l	%a1, _ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
+	/*
+	 *	Zero out the bss region.
+	 */
+	lea.l	_sbss, %a0			/* Get start of bss */
+	lea.l	_ebss, %a1			/* Get end of bss */
+	clr.l	%d0					/* Set value */
+_clear_bss:
+	move.l	%d0, (%a0)+			/* Clear each word */
+	cmp.l	%a0, %a1			/* Check if at end */
+	bne	_clear_bss
+
+	/*
+	 *	Load the current thread pointer and stack.
+	 */
+	lea	init_thread_union, %a0
+	lea	0x2000(%a0), %sp
+
+   /*
+    * User mode port access
+    */
+   move.l   #0x0000000c, %d0
+   move.b   %d0, (IPSBAR+GPACR0)
+
+
+	/*
+	 *	Assember start up done, start code proper.
+	 */
+	jsr	start_kernel			/* Start Linux kernel */
+
+_exit:
+	jmp	_exit				/* Should never get here */
+
+/*****************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/5307/CLEOPATRA/crt0_ram.S linux-2.6.9-uc0/arch/m68knommu/platform/5307/CLEOPATRA/crt0_ram.S
--- linux-2.6.9/arch/m68knommu/platform/5307/CLEOPATRA/crt0_ram.S	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5307/CLEOPATRA/crt0_ram.S	2004-10-28 11:11:45.000000000 +1000
@@ -99,33 +99,25 @@
 	move.l	%d0, %sp			/* Set up initial stack ptr */
 	move.l	%d0, _ramend			/* Set end ram addr */
 
-
-	/* now fire off the cache, remember to invalidate it first */
-	movl  #0,%d0
-	movc  %d0,%CACR
+	/*
+	 *	Enable CPU internal cache.
+	 */
+	move.l	#0x01000000, %d0		/* invalidate whole cache */
+	movec	%d0,%CACR
 	nop
-	movc  %d0,%CACR				/* cache is off */
-
-	movl  #CACR_CINVA,%d0			/* invalidate whole cache */
-	movc  %d0,%CACR
+#ifdef DEBUGGER_COMPATIBLE_CACHE
+	move.l	#0x0000c000, %d0		/* Set SDRAM cached only */
+#else
+	move.l	#0x0000c020, %d0		/* Set SDRAM cached only (copyback) */
+#endif
+	movec	%d0, %ACR0
+	move.l	#0x00000000, %d0		/* No other regions cached */
+	movec	%d0, %ACR1
+
+	/* Enable cache */
+	move.l	#0xa0000200, %d0
+	movec	%d0,%CACR
 	nop
-	movc  %d0,%CACR
-	nop                                    
-
-	/* make region ROM cachable (turn off for flash programming?) */
-	/* 0xff000000 - 0xffffffff */
-	movl #(0xff<<ACR_BASE_POS)+(0<<ACR_MASK_POS)+ACR_ENABLE+ACR_ANY+ACR_CM_WBACK+ACR_WPROTECT,%d0
-	movc  %d0,%ACR0
-
-	/* make region RAM cachable *
-	/* 0x00000000 - 0x00ffffffff */
-	movl #(0x00<<ACR_BASE_POS)+(0<<ACR_MASK_POS)+ACR_ENABLE+ACR_ANY+ACR_CM_WBACK,%d0
-	movc  %d0,%ACR1
-
-	/* make the default cache mode precise */
-	movl  #CACR_EC+CACR_ESB+CACR_DCM_OFF_PRE,%d0 /* enable cache */
-	movc  %d0,%CACR
-
 
 #ifdef CONFIG_ROMFS_FS
 	/*
diff -Naur linux-2.6.9/arch/m68knommu/platform/5307/config.c linux-2.6.9-uc0/arch/m68knommu/platform/5307/config.c
--- linux-2.6.9/arch/m68knommu/platform/5307/config.c	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5307/config.c	2004-10-28 11:11:45.000000000 +1000
@@ -23,7 +23,6 @@
 #include <asm/mcftimer.h>
 #include <asm/mcfsim.h>
 #include <asm/mcfdma.h>
-#include <asm/delay.h>
 #include <asm/mcfwdebug.h>
 
 /***************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/5307/entry.S linux-2.6.9-uc0/arch/m68knommu/platform/5307/entry.S
--- linux-2.6.9/arch/m68knommu/platform/5307/entry.S	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5307/entry.S	2004-10-28 11:11:45.000000000 +1000
@@ -145,8 +145,8 @@
 	addl    %sp@+,%sp		/* stk adj */
 	addql   #8,%sp			/* remove exception */
 	movel   %sp,sw_ksp		/* save ksp */
+	subql   #8,sw_usp		/* set exception */
 	movel   sw_usp,%sp		/* restore usp */
-	subql   #8,%sp			/* set exception */
 	rte
 
 Lwork_to_do:
@@ -160,8 +160,7 @@
 	subql	#4,%sp			/* dummy return address */
 	SAVE_SWITCH_STACK
 	pea	%sp@(SWITCH_STACK_SIZE)
-	clr	%d1
-	movel	%d1,%sp@-
+	clrl	%sp@-
 	jsr	do_signal
 	addql	#8,%sp
 	RESTORE_SWITCH_STACK
diff -Naur linux-2.6.9/arch/m68knommu/platform/5307/Makefile linux-2.6.9-uc0/arch/m68knommu/platform/5307/Makefile
--- linux-2.6.9/arch/m68knommu/platform/5307/Makefile	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5307/Makefile	2004-10-28 11:11:45.000000000 +1000
@@ -20,8 +20,10 @@
 obj-$(CONFIG_M5206)	+= timers.o
 obj-$(CONFIG_M5206e)	+= timers.o
 obj-$(CONFIG_M5249)	+= timers.o
+obj-$(CONFIG_M527x)     += pit.o
 obj-$(CONFIG_M5272)	+= timers.o
 obj-$(CONFIG_M5307)	+= config.o timers.o
+obj-$(CONFIG_M528x)     += pit.o
 obj-$(CONFIG_M5407)	+= timers.o
 
 ifeq ($(CONFIG_M5307),y)
diff -Naur linux-2.6.9/arch/m68knommu/platform/5307/pit.c linux-2.6.9-uc0/arch/m68knommu/platform/5307/pit.c
--- linux-2.6.9/arch/m68knommu/platform/5307/pit.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5307/pit.c	2004-10-28 11:11:45.000000000 +1000
@@ -0,0 +1,88 @@
+/***************************************************************************/
+
+/*
+ *	pit.c -- Motorola ColdFire PIT timer. Currently this type of
+ *	         hardware timer only exists in the Motorola ColdFire
+ *		 5270/5271 and 5282 CPUs.
+ *
+ *	Copyright (C) 1999-2004, Greg Ungerer (gerg@snapgear.com)
+ *	Copyright (C) 2001-2004, SnapGear Inc. (www.snapgear.com)
+ *
+ */
+
+/***************************************************************************/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/param.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+#include <asm/coldfire.h>
+#include <asm/mcfpit.h>
+#include <asm/mcfsim.h>
+
+/***************************************************************************/
+
+void coldfire_pit_tick(void)
+{
+	volatile struct mcfpit *tp;
+
+	/* Reset the ColdFire timer */
+	tp = (volatile struct mcfpit *) (MCF_IPSBAR + MCFPIT_BASE1);
+	tp->pcsr |= MCFPIT_PCSR_PIF;
+}
+
+/***************************************************************************/
+
+void coldfire_pit_init(irqreturn_t (*handler)(int, void *, struct pt_regs *))
+{
+	volatile unsigned char *icrp;
+	volatile unsigned long *imrp;
+	volatile struct mcfpit *tp;
+
+	request_irq(MCFINT_VECBASE + MCFINT_PIT1, handler, SA_INTERRUPT,
+		"ColdFire Timer", NULL);
+
+	icrp = (volatile unsigned char *) (MCF_IPSBAR + MCFICM_INTC0 +
+		MCFINTC_ICR0 + MCFINT_PIT1);
+	*icrp = 0x2b; /* PIT1 with level 5, priority 3 */
+
+	imrp = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IMRH);
+	*imrp &= ~(1 << (MCFINT_PIT1 - 32));
+
+	/* Set up PIT timer 1 as poll clock */
+	tp = (volatile struct mcfpit *) (MCF_IPSBAR + MCFPIT_BASE1);
+	tp->pcsr = MCFPIT_PCSR_DISABLE;
+
+	tp->pmr = ((MCF_CLK / 2) / 64) / HZ;
+	tp->pcsr = MCFPIT_PCSR_EN | MCFPIT_PCSR_PIE | MCFPIT_PCSR_OVW |
+		MCFPIT_PCSR_RLD | MCFPIT_PCSR_CLK64;
+}
+
+/***************************************************************************/
+
+unsigned long coldfire_pit_offset(void)
+{
+	volatile struct mcfpit *tp;
+	volatile unsigned long *ipr;
+	unsigned long pmr, pcntr, offset;
+
+	tp = (volatile struct mcfpit *) (MCF_IPSBAR + MCFPIT_BASE1);
+	ipr = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_IPRH);
+
+	pmr = *(&tp->pmr);
+	pcntr = *(&tp->pcntr);
+
+	/*
+	 * If we are still in the first half of the upcount and a
+	 * timer interupt is pending, then add on a ticks worth of time.
+	 */
+	offset = ((pmr - pcntr) * (1000000 / HZ)) / pmr;
+	if ((offset < (1000000 / HZ / 2)) && (*ipr & (1 << (MCFINT_PIT1 - 32))))
+		offset += 1000000 / HZ;
+	return offset;	
+}
+
+/***************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/5307/vectors.c linux-2.6.9-uc0/arch/m68knommu/platform/5307/vectors.c
--- linux-2.6.9/arch/m68knommu/platform/5307/vectors.c	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5307/vectors.c	2004-10-28 11:11:45.000000000 +1000
@@ -14,6 +14,7 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/unistd.h>
+#include <linux/delay.h>
 #include <asm/irq.h>
 #include <asm/dma.h>
 #include <asm/traps.h>
@@ -22,7 +23,6 @@
 #include <asm/mcftimer.h>
 #include <asm/mcfsim.h>
 #include <asm/mcfdma.h>
-#include <asm/delay.h>
 #include <asm/mcfwdebug.h>
 
 /***************************************************************************/
diff -Naur linux-2.6.9/arch/m68knommu/platform/5407/config.c linux-2.6.9-uc0/arch/m68knommu/platform/5407/config.c
--- linux-2.6.9/arch/m68knommu/platform/5407/config.c	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/5407/config.c	2004-10-28 11:11:46.000000000 +1000
@@ -23,7 +23,6 @@
 #include <asm/mcftimer.h>
 #include <asm/mcfsim.h>
 #include <asm/mcfdma.h>
-#include <asm/delay.h>
 
 /***************************************************************************/
 
diff -Naur linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/Makefile linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/Makefile
--- linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/Makefile	2004-10-28 11:08:53.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/Makefile	2004-10-28 11:11:46.000000000 +1000
@@ -2,11 +2,13 @@
 # Makefile for arch/m68knommu/platform/68VZ328/de2.
 #
 
-obj-y := config.o
+obj-$(CONFIG_DRAGEN2) := config.o
 
-EXTRA_TARGETS := bootlogo.rh crt0_$(MODEL).o
+extra-$(CONFIG_DRAGEN2) := crt0_ram.o
 
-$(obj)/bootlogo.rh: $(src)/../../68EZ328/bootlogo.h
-	perl $(src)/../../68328/bootlogo.pl < $(src)/../../68EZ328/bootlogo.h \
-		> $(obj)/bootlogo.rh
+$(obj)/config.o: $(obj)/screen.h
 
+$(obj)/screen.h: $(src)/screen.xbm $(src)/xbm2lcd.pl
+	perl $(src)/xbm2lcd.pl < $(src)/screen.xbm > $(obj)/screen.h
+
+clean-files := $(obj)/screen.h
diff -Naur linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/screen.xbm linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/screen.xbm
--- linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/screen.xbm	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/screen.xbm	2004-10-28 11:11:46.000000000 +1000
@@ -0,0 +1,804 @@
+/* Created with The GIMP */
+#define screen_width 320
+#define screen_height 240
+static unsigned char screen_bits[] = {
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x63, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x34, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x95,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x4f, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6b, 0xa5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x29, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x3f, 0x56, 0xa9, 0xff, 0xff, 0xff, 0x3f, 0xe0, 0xf1, 0xf8, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3,
+   0x7f, 0xe0, 0xff, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0x25, 0x55, 0xff, 0xff, 0xff, 0x0f,
+   0xc0, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xe3, 0x3f, 0xc0, 0xff, 0x01, 0xfe, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x52, 0x95,
+   0xff, 0xff, 0xff, 0x87, 0xcf, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x3f, 0x8f, 0xff, 0x79,
+   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x14, 0x55, 0x55, 0xff, 0x3f, 0x8e, 0xc7, 0xff, 0xf1, 0x78, 0x86,
+   0x8f, 0xe3, 0x78, 0xfe, 0xf1, 0xfc, 0xf0, 0x31, 0x33, 0xfc, 0xe1, 0xe3,
+   0xff, 0x8f, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xbf, 0x6a, 0xaa, 0x4a, 0xff, 0x3f, 0x8e, 0xe3,
+   0xff, 0xf1, 0x78, 0x00, 0x8f, 0xe3, 0x38, 0xfe, 0x71, 0x3c, 0xe0, 0x11,
+   0x03, 0x78, 0xc0, 0xe3, 0xff, 0x8f, 0xff, 0x08, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0x2b, 0x55, 0xa9,
+   0xff, 0x3f, 0x8e, 0xe3, 0xff, 0xf1, 0x78, 0x18, 0x8f, 0xe3, 0x31, 0xff,
+   0x31, 0x3e, 0xc6, 0x01, 0xc3, 0x78, 0x8c, 0xe3, 0xff, 0xc7, 0xff, 0x00,
+   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x57, 0x95, 0x2a, 0x55, 0xff, 0x3f, 0x8e, 0xe3, 0xff, 0xf1, 0x78, 0x1c,
+   0x8f, 0xe3, 0x91, 0xff, 0x11, 0x1f, 0xc7, 0xe1, 0xe3, 0x38, 0x8e, 0xe3,
+   0xff, 0xe1, 0xff, 0x30, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x69, 0x55, 0xa5, 0x12, 0xff, 0x3f, 0x8e, 0xe3,
+   0xff, 0xf1, 0x78, 0x1c, 0x8f, 0xe3, 0xc3, 0xff, 0x81, 0x1f, 0xc0, 0xf1,
+   0xe3, 0x38, 0x80, 0xe3, 0xff, 0xf0, 0xff, 0x78, 0xfc, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x5a, 0xa6, 0x2a, 0x49,
+   0xff, 0x3f, 0x8e, 0xc3, 0xff, 0xf1, 0x78, 0x1c, 0x8f, 0xe3, 0x83, 0xff,
+   0x01, 0x1f, 0xc0, 0xf1, 0xe3, 0x38, 0x80, 0xe3, 0x7f, 0xfc, 0xff, 0x78,
+   0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f,
+   0x4d, 0x51, 0x92, 0x54, 0xff, 0x3f, 0x8e, 0xc7, 0xff, 0xf1, 0x78, 0x1c,
+   0x8f, 0xe3, 0x11, 0xff, 0x11, 0x1e, 0xff, 0xf1, 0xe3, 0x38, 0xfe, 0xe3,
+   0x3f, 0xfe, 0xff, 0x78, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xd7, 0xaa, 0xac, 0x54, 0x25, 0xff, 0x3f, 0x86, 0x07,
+   0xcf, 0xf1, 0x78, 0x1c, 0x8f, 0xe1, 0x19, 0xff, 0x31, 0x1c, 0xce, 0xf1,
+   0xe3, 0x38, 0x9c, 0xe3, 0x3f, 0x80, 0xe3, 0x71, 0xfc, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xab, 0x52, 0x22, 0x25, 0xa9,
+   0xff, 0x3f, 0x80, 0x0f, 0xc0, 0xf1, 0x78, 0x1c, 0x0f, 0xe0, 0x38, 0xfe,
+   0x71, 0x38, 0xc0, 0xf1, 0xe3, 0x78, 0x80, 0xe3, 0x3f, 0x80, 0xe3, 0x01,
+   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6a,
+   0x29, 0x95, 0x94, 0x4a, 0xff, 0x7f, 0x98, 0x3f, 0xf0, 0xf1, 0x78, 0x1c,
+   0x1f, 0xe6, 0x3c, 0xfe, 0xf1, 0xf8, 0xe0, 0xf1, 0xe3, 0xf8, 0xc1, 0xe3,
+   0x3f, 0x80, 0xe3, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x3f, 0x55, 0x55, 0xa9, 0xa2, 0x28, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x57, 0x95, 0x54, 0x54, 0x54, 0xca,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xab, 0xa5,
+   0x12, 0x43, 0x15, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x51, 0x49, 0xaa, 0x34, 0xca, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x2e, 0xa9, 0x92, 0x84, 0x29, 0x92,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xa2, 0x4a,
+   0x28, 0xb3, 0xa4, 0x4a, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x87, 0xaa, 0x52, 0x4a, 0x89, 0x96, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0x7f, 0x9e, 0xff, 0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xc0, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0x3c, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x57, 0x29, 0x09, 0xa5, 0x52, 0x51, 0x69,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0x9e, 0xff, 0xff, 0x9f, 0xe7, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3c,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x50, 0xa4, 0x64,
+   0x35, 0x28, 0x29, 0x2d, 0xff, 0xff, 0xf0, 0x84, 0x3f, 0x98, 0xf0, 0xe1,
+   0x9f, 0xcf, 0xc9, 0xc1, 0x07, 0x1e, 0x9e, 0xf0, 0xfc, 0x84, 0x0f, 0xcc,
+   0x84, 0x0f, 0xff, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x3f, 0x94, 0x2a, 0x15, 0x89, 0xae, 0x94, 0xa2, 0xff, 0x7f, 0xe6, 0x18,
+   0x7f, 0x1e, 0xe3, 0xcc, 0x9f, 0xcf, 0xc9, 0x9f, 0x73, 0xce, 0x1c, 0xe3,
+   0xfc, 0x18, 0xe7, 0xcc, 0x18, 0x67, 0xfe, 0x3c, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x8f, 0x4b, 0x85, 0xa4, 0x55, 0x22, 0x65, 0xbd,
+   0xff, 0x3f, 0xcf, 0x3c, 0x7f, 0x9e, 0x67, 0xce, 0x9f, 0xcf, 0xf1, 0x9f,
+   0x79, 0xe6, 0x99, 0xe7, 0xe0, 0x3c, 0xf3, 0xcc, 0x3c, 0x73, 0xfe, 0x3c,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa7, 0x10, 0x29, 0xa9,
+   0x2a, 0x95, 0x94, 0x02, 0xff, 0x3f, 0xcf, 0x3c, 0x7f, 0x9e, 0x67, 0xc0,
+   0x9f, 0xcf, 0xf9, 0x81, 0x79, 0xe6, 0x99, 0xe7, 0xfc, 0x3c, 0xf3, 0xcc,
+   0x3c, 0x03, 0xfe, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x51, 0xd6, 0x24, 0x51, 0x89, 0xa4, 0xaa, 0xba, 0xff, 0x3f, 0xcf, 0x3c,
+   0x7f, 0x9e, 0x67, 0xfe, 0x9f, 0xcf, 0xf9, 0x9c, 0x79, 0xe6, 0x99, 0xe7,
+   0xfc, 0x3c, 0xf3, 0xcc, 0x3c, 0xf3, 0xff, 0x3c, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0x24, 0x29, 0x4a, 0x26, 0x1b, 0x55, 0x55, 0x55,
+   0xff, 0x3f, 0xcf, 0x3c, 0x7f, 0x9e, 0x67, 0xfe, 0x9f, 0xcf, 0xf9, 0x9c,
+   0x33, 0xe6, 0x99, 0xe7, 0xfc, 0x3c, 0x67, 0xcc, 0x3c, 0xf3, 0xff, 0x3c,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x93, 0x84, 0x52, 0x59,
+   0x51, 0xa5, 0x54, 0x95, 0xff, 0x7f, 0xe6, 0x3c, 0x7f, 0x9e, 0xe7, 0xdc,
+   0x9f, 0xe7, 0xf9, 0x8c, 0x47, 0xce, 0x9c, 0xe7, 0xfc, 0x3c, 0x8f, 0xcc,
+   0x3c, 0xe7, 0xfe, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf,
+   0x48, 0x52, 0x49, 0x95, 0x55, 0x55, 0x55, 0x8a, 0xff, 0xff, 0xf0, 0x3c,
+   0xff, 0x98, 0xe7, 0xe1, 0x1f, 0xf0, 0xf9, 0x11, 0x7f, 0x1e, 0x9e, 0xe7,
+   0xc0, 0x3c, 0xff, 0xcc, 0x3c, 0x0f, 0xff, 0x3c, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xa1, 0x2a, 0x49, 0xa4, 0xaa, 0xac, 0x54, 0x49, 0xe5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0xfe, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x95, 0xa4, 0xaa, 0xa8, 0x8a,
+   0x26, 0xa5, 0x6a, 0x2d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x54,
+   0x22, 0x40, 0x4a, 0x4a, 0x69, 0xa8, 0x2c, 0x55, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x5f, 0x0a, 0x92, 0xae, 0xa9, 0x62, 0xa5, 0x4b, 0xa2, 0x92,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x47, 0xa1, 0x51, 0x89, 0x4c, 0xb5,
+   0x26, 0x24, 0x55, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x25, 0x4a,
+   0x0a, 0x56, 0x55, 0x48, 0x55, 0x55, 0x29, 0x55, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xa8, 0x52, 0xc8, 0x40, 0x65, 0xa5, 0x52, 0x95, 0xaa, 0x92,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x12, 0x29, 0x93, 0xad, 0x28, 0x2a,
+   0x4b, 0xa9, 0x26, 0x29, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x4a, 0x09,
+   0x29, 0x28, 0x44, 0x21, 0xa9, 0x55, 0x52, 0x95, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x17, 0x91, 0xa4, 0x94, 0x45, 0xb9, 0x9c, 0x54, 0x93, 0xaa, 0x52,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0x24, 0x95, 0xc2, 0xb0, 0x5a, 0x45,
+   0x96, 0xaa, 0x92, 0x94, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x88, 0x40,
+   0x54, 0xcb, 0x49, 0xa6, 0x51, 0x25, 0xa9, 0x52, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x3f, 0x88, 0x4a, 0x55, 0x57, 0x08, 0xd5, 0x90, 0x5c, 0xa9, 0x6a, 0x9a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x5f, 0x25, 0x94, 0x4a, 0x82, 0xf2, 0x9a, 0x53,
+   0x25, 0x54, 0xad, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x28, 0x45, 0x50,
+   0xaa, 0x14, 0xd0, 0x51, 0xa2, 0x55, 0x0a, 0x89, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x13, 0x85, 0x10, 0x55, 0x79, 0xc2, 0xef, 0x25, 0x55, 0xa5, 0x6a, 0x52,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0x90, 0xa2, 0xaa, 0xaa, 0x06, 0x69, 0xc8, 0x54,
+   0x2d, 0x6a, 0xaa, 0xab, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x4b, 0x54, 0x48, 0xa5,
+   0xb0, 0x94, 0x8a, 0x24, 0x86, 0x1b, 0x05, 0x52, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
+   0x49, 0x25, 0xaa, 0xa4, 0x8a, 0x56, 0xe5, 0x54, 0xd3, 0x49, 0xe9, 0x4a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x57, 0x24, 0x14, 0x95, 0x52, 0x54, 0x49, 0x6b, 0x25,
+   0x2d, 0x24, 0x15, 0x92, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x93, 0xa4, 0xca, 0x54, 0x2d,
+   0x15, 0xa9, 0x26, 0x91, 0xc5, 0x56, 0xd5, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0,
+   0x12, 0x20, 0x2a, 0x92, 0xa8, 0x4a, 0xb9, 0x56, 0x7a, 0x50, 0x6a, 0x4a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x3f, 0x15, 0x0a, 0x29, 0xb1, 0xd5, 0x66, 0x54, 0x8f, 0x30,
+   0x05, 0x57, 0xab, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xa8, 0xd4, 0x4a, 0x45, 0x53,
+   0x52, 0xd3, 0xb2, 0xaa, 0xd5, 0xa2, 0x4a, 0x55, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x85,
+   0x0a, 0x48, 0x2a, 0xa8, 0x32, 0xaa, 0xa9, 0x4a, 0x54, 0x54, 0xaa, 0x2a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xab, 0x62, 0x50, 0x22, 0x52, 0x55, 0xd9, 0x15, 0x55, 0x29,
+   0x45, 0xf4, 0xb5, 0xca, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x2a, 0x25, 0x92, 0x49, 0x13,
+   0x09, 0xaa, 0x25, 0xba, 0x52, 0x07, 0x48, 0x31, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x59, 0xaa,
+   0x89, 0x20, 0x34, 0xa5, 0xd4, 0xd5, 0xaa, 0x85, 0x3c, 0x52, 0x57, 0x95,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x1f, 0x0a, 0x01, 0xa8, 0x92, 0xaa, 0x94, 0x4a, 0x70, 0xb4, 0x54,
+   0x95, 0x55, 0xa9, 0x54, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0x42, 0xa4, 0x0a, 0x51, 0x09, 0xa5,
+   0x5d, 0x9b, 0x12, 0x25, 0xfb, 0x44, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa3, 0x28, 0x01,
+   0x50, 0x4d, 0x56, 0x91, 0x64, 0x95, 0x52, 0xb5, 0x49, 0xb7, 0x4a, 0xaa,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x15, 0x03, 0xda, 0x0e, 0x62, 0x89, 0xba, 0x09, 0x47, 0xa9, 0x08,
+   0x52, 0x49, 0xaa, 0x52, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x3f, 0x40, 0x51, 0x0b, 0xc1, 0x15, 0xee, 0x90,
+   0xfe, 0x52, 0x15, 0xc5, 0x14, 0x55, 0xd5, 0x8a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x63, 0x00, 0x90,
+   0x2a, 0xa1, 0x15, 0xd6, 0x08, 0x4f, 0xd8, 0xa8, 0xea, 0xaa, 0x2a, 0x00,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xcf, 0x10, 0x00, 0x49, 0x12, 0x2d, 0x63, 0x17, 0xab, 0xa0, 0x12, 0x95,
+   0x12, 0xaa, 0x48, 0x64, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xe7, 0x82, 0x40, 0xa4, 0x86, 0xc8, 0x98, 0x54,
+   0xb5, 0xab, 0xe5, 0x6a, 0xd5, 0xa5, 0x16, 0x18, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x68, 0x90, 0x82,
+   0xd4, 0x25, 0x4a, 0x39, 0x79, 0x10, 0x12, 0x0a, 0x55, 0xb5, 0x06, 0x88,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,
+   0x6c, 0x42, 0x20, 0x29, 0x28, 0x50, 0x29, 0x4b, 0x15, 0xb5, 0xd6, 0xaa,
+   0x72, 0x2a, 0xad, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xbf, 0x24, 0x2c, 0x00, 0x50, 0x23, 0x55, 0xfa, 0xff,
+   0x5d, 0x89, 0x52, 0x52, 0x59, 0xb5, 0xff, 0xcd, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4f, 0x8b, 0x41, 0x24, 0x5a,
+   0xac, 0x82, 0xfe, 0xff, 0xaf, 0xd5, 0xaa, 0x5a, 0x5d, 0xef, 0x6f, 0x57,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3,
+   0xe4, 0x34, 0x27, 0x8a, 0x12, 0xa8, 0xff, 0xff, 0xff, 0x56, 0xaa, 0x95,
+   0xc4, 0x78, 0x7b, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x35, 0x7d, 0x00, 0x11, 0x42, 0xaa, 0xe5, 0xff, 0xff,
+   0xff, 0x24, 0x51, 0xd4, 0xb2, 0xda, 0x1f, 0xa8, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x08, 0x1f, 0x42, 0x59, 0x28,
+   0xba, 0xf4, 0xff, 0xff, 0xff, 0x5b, 0x2d, 0x53, 0x95, 0xfe, 0x11, 0xa9,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xeb,
+   0x7f, 0xeb, 0xa6, 0x92, 0x14, 0xf9, 0xff, 0xff, 0xff, 0xcf, 0xaa, 0xaa,
+   0xaa, 0xbf, 0x1f, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x17, 0xf8, 0x17, 0x72, 0x02, 0x88, 0xd2, 0xfc, 0xff, 0xff,
+   0xff, 0xef, 0xaa, 0x4a, 0xe9, 0xd5, 0xdf, 0xa5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0xd1, 0x1e, 0x11, 0xb1, 0xa5,
+   0x2a, 0xfe, 0xff, 0xff, 0xff, 0xbf, 0xd4, 0x52, 0xb5, 0xef, 0x25, 0xd4,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x51, 0xff,
+   0x07, 0x94, 0x08, 0xa4, 0x54, 0xff, 0xff, 0xff, 0xcf, 0x7f, 0xb5, 0x54,
+   0xfd, 0x70, 0x55, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x26, 0xff, 0x17, 0x2d, 0xb6, 0x12, 0x0a, 0xff, 0xff, 0xff,
+   0x8f, 0x7f, 0x8d, 0xaa, 0x8a, 0x56, 0x55, 0x49, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xe2, 0x77, 0x2b, 0x37, 0x91, 0x08,
+   0xd5, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xd5, 0xaa, 0xaa, 0x52, 0x4a, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xfd, 0xff,
+   0x81, 0xc1, 0x59, 0xd0, 0xe1, 0xff, 0xff, 0xff, 0x07, 0xff, 0x2a, 0x95,
+   0x54, 0x55, 0x65, 0xa5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xaf, 0xfd, 0xbd, 0x49, 0x8c, 0x58, 0x8a, 0xd5, 0xff, 0xff, 0xff,
+   0xe7, 0xff, 0x49, 0x51, 0x45, 0x55, 0x4d, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xab, 0xbe, 0x3f, 0xc4, 0xd5, 0x02, 0x79,
+   0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb7, 0x4a, 0xba, 0x52, 0xf9, 0x4a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa5, 0xff, 0x97,
+   0x64, 0x52, 0xda, 0x1c, 0xc9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa5, 0xa8,
+   0x8a, 0x54, 0x15, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xd5, 0xdf, 0x4f, 0x91, 0x22, 0x2d, 0xc2, 0xe5, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x93, 0x56, 0x6a, 0x55, 0xd5, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0xf5, 0xef, 0x25, 0x5c, 0x43, 0x16, 0xaf,
+   0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0x92, 0x2a, 0x2b, 0x55, 0x2a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xdb, 0xfb, 0x43,
+   0x65, 0x21, 0x91, 0x13, 0xe5, 0xff, 0xff, 0xff, 0xff, 0xff, 0x47, 0x49,
+   0x51, 0x52, 0x55, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xb7, 0xf0, 0x7f, 0x00, 0x7b, 0xea, 0x3c, 0xd1, 0xea, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x27, 0x6a, 0x2d, 0x55, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x5b, 0xfc, 0x7d, 0xac, 0xc6, 0x11, 0xe5, 0x46,
+   0xe9, 0xff, 0xff, 0xff, 0xff, 0xff, 0x57, 0x95, 0xd2, 0x4a, 0xb2, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2d, 0xfe, 0x0f, 0x82,
+   0xfc, 0x90, 0x54, 0x32, 0xf5, 0xff, 0xff, 0xff, 0xff, 0xff, 0x57, 0xd5,
+   0x5a, 0xaa, 0x55, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x17, 0xdf, 0x1e, 0xc2, 0xa9, 0x23, 0xca, 0x46, 0xe5, 0xff, 0xff, 0x3f,
+   0xf8, 0xff, 0x97, 0x2a, 0x55, 0xad, 0x94, 0x5a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0xc5, 0xff, 0x07, 0xd5, 0x6c, 0xab, 0x12, 0x9a,
+   0xe4, 0x0f, 0xff, 0x1f, 0xe0, 0xff, 0x57, 0xa9, 0x55, 0xa5, 0xda, 0xaa,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa1, 0xef, 0xd1, 0xac,
+   0xc6, 0xa5, 0xea, 0x5c, 0xf3, 0x07, 0xfe, 0x0f, 0xc0, 0xff, 0x4f, 0x55,
+   0xaa, 0x5a, 0x55, 0x6d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf,
+   0xf0, 0xfb, 0xa8, 0xa5, 0xf2, 0x18, 0x56, 0x41, 0xf7, 0x03, 0xfc, 0x07,
+   0x80, 0xff, 0xaf, 0xaa, 0xaa, 0x4a, 0xad, 0x56, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x3f, 0xd0, 0xbf, 0x41, 0x52, 0x0e, 0xc6, 0xaa, 0x68,
+   0xfa, 0x03, 0xfc, 0x07, 0x80, 0xff, 0x9f, 0x52, 0xd5, 0x6a, 0xab, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x17, 0xfd, 0x1d, 0x28, 0x2a,
+   0x51, 0x75, 0x55, 0x4d, 0xe4, 0x03, 0xf8, 0x03, 0x03, 0xff, 0xaf, 0xaa,
+   0x6a, 0xad, 0xaa, 0x4a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3b,
+   0xfc, 0x9f, 0x00, 0x58, 0x92, 0x22, 0x6a, 0xd3, 0xed, 0xf3, 0xf8, 0xc3,
+   0x0f, 0xff, 0xaf, 0xaa, 0xae, 0xaa, 0xaa, 0xda, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x0a, 0xfe, 0x06, 0x7a, 0x4e, 0x52, 0x94, 0x36, 0x4c,
+   0xf6, 0xb9, 0xf9, 0xc3, 0x1b, 0xff, 0x9f, 0xaa, 0x52, 0xaa, 0xaa, 0x6a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0xb6, 0x03, 0x52, 0x93,
+   0x95, 0x52, 0x46, 0x55, 0xf6, 0xb9, 0xf9, 0xe3, 0x17, 0xfe, 0x4f, 0xd5,
+   0xaa, 0xd5, 0xaa, 0xa6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xa1,
+   0xff, 0xa2, 0x2a, 0x31, 0x18, 0xba, 0x92, 0x55, 0xcb, 0x79, 0xf9, 0xe3,
+   0x17, 0xfe, 0x6f, 0x29, 0xad, 0x54, 0xad, 0xb6, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x4f, 0x80, 0x3f, 0x49, 0xa8, 0xef, 0x75, 0x47, 0x2b, 0x53,
+   0xef, 0x79, 0xf9, 0xe3, 0x1f, 0xfe, 0x9f, 0xa4, 0xaa, 0x6a, 0x55, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1b, 0xe0, 0x8d, 0x20, 0x6e, 0x84,
+   0x53, 0xa8, 0x29, 0xb1, 0xeb, 0xf9, 0xf1, 0xe3, 0x1f, 0xfe, 0x5f, 0xb5,
+   0xaa, 0xaa, 0x56, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xe0,
+   0x4f, 0x39, 0x42, 0x38, 0x15, 0x55, 0x92, 0x6d, 0xcc, 0xfb, 0x01, 0xe0,
+   0x1f, 0xfe, 0xaf, 0xaa, 0xaa, 0xaa, 0xaa, 0x4a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x45, 0x78, 0xd3, 0x9c, 0x2a, 0x1a, 0x76, 0x11, 0x13, 0xcc,
+   0xed, 0xf3, 0x06, 0xc3, 0x1f, 0xfe, 0xaf, 0xaa, 0xaa, 0xaa, 0xaa, 0x69,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x23, 0xfc, 0xd3, 0x24, 0x8d, 0x60,
+   0x8a, 0x54, 0xd5, 0x78, 0xd2, 0x67, 0x03, 0x80, 0x0f, 0xff, 0x5f, 0x55,
+   0x55, 0x55, 0xb5, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0x01, 0x6e,
+   0x70, 0x10, 0x58, 0x15, 0xa8, 0x4e, 0xcd, 0xa4, 0xca, 0x37, 0x00, 0x00,
+   0xfe, 0xff, 0xaf, 0x54, 0xaa, 0xda, 0x56, 0xd5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x10, 0xbf, 0x35, 0xc9, 0xb1, 0xf7, 0x3a, 0xa9, 0xd1, 0xa8,
+   0xd3, 0x1f, 0x00, 0x00, 0xf8, 0xff, 0x5f, 0x8d, 0xd5, 0x56, 0x55, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x37, 0xc0, 0x16, 0x94, 0x55, 0x92, 0x2a,
+   0x12, 0x5d, 0x9d, 0x4a, 0xd0, 0x07, 0x00, 0x00, 0x80, 0xff, 0x5f, 0xab,
+   0x54, 0xd5, 0x56, 0x75, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x0c, 0x8f,
+   0x20, 0x4b, 0xb7, 0xd4, 0xe2, 0x92, 0x28, 0xa9, 0xf7, 0x03, 0x00, 0x00,
+   0x00, 0xff, 0xbf, 0xa4, 0xae, 0x2a, 0xa9, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x15, 0xc2, 0xa3, 0x9c, 0x4f, 0x91, 0x72, 0x11, 0x57, 0xab, 0x95,
+   0xd3, 0x01, 0x00, 0x00, 0x00, 0xfe, 0xbf, 0x5a, 0x51, 0xab, 0xb5, 0xaa,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xbf, 0x0f, 0xc0, 0x04, 0x51, 0x46, 0xa5, 0x19,
+   0x57, 0x65, 0x32, 0xc9, 0xcd, 0x01, 0x00, 0x00, 0x00, 0xfe, 0x5f, 0x55,
+   0xae, 0xaa, 0xaa, 0xda, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x60, 0x24,
+   0x48, 0x93, 0xa5, 0x28, 0x4a, 0x29, 0x15, 0x45, 0xda, 0x01, 0x00, 0x00,
+   0x30, 0xfe, 0x5f, 0xd5, 0xb2, 0xaa, 0xaa, 0x6a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x01, 0xd0, 0xa5, 0xaa, 0x24, 0xfd, 0xfb, 0xa8, 0xaa, 0xea, 0x67,
+   0xe8, 0x07, 0x00, 0x00, 0x18, 0xff, 0xbf, 0x55, 0x2d, 0x54, 0x55, 0xad,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x5f, 0x00, 0xb0, 0x52, 0x41, 0x95, 0xaa, 0x91,
+   0x5a, 0x8c, 0xd2, 0x74, 0xcb, 0x0f, 0x00, 0x00, 0x0f, 0xff, 0xbf, 0x5a,
+   0xa5, 0xab, 0x55, 0x65, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x7c, 0x73,
+   0xa6, 0x4e, 0x79, 0x8b, 0xb2, 0x52, 0x15, 0x65, 0xee, 0x1f, 0x00, 0xe0,
+   0x81, 0x9f, 0xff, 0xaa, 0x59, 0xb4, 0xaa, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x07, 0x81, 0xbf, 0x55, 0x19, 0x52, 0x25, 0x5f, 0xa0, 0x2a, 0xaf, 0x4e,
+   0xd8, 0x3f, 0x00, 0x3c, 0x80, 0x1f, 0x7f, 0xaa, 0xaa, 0x9b, 0xaa, 0x6a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x97, 0x41, 0xf7, 0x15, 0x46, 0xad, 0xae, 0x14,
+   0x56, 0xa5, 0x54, 0x4d, 0xe5, 0xff, 0xc0, 0x07, 0x98, 0x3f, 0x7c, 0x55,
+   0xb5, 0x54, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x78, 0xbd, 0xda,
+   0x41, 0x14, 0xa2, 0xf2, 0xdb, 0x54, 0x16, 0x5c, 0xb4, 0xff, 0xff, 0x01,
+   0x1e, 0x3f, 0xf8, 0xbd, 0xaa, 0x56, 0x55, 0x2d, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x4f, 0xbd, 0x17, 0x20, 0xce, 0xca, 0x9d, 0x8a, 0x44, 0x32, 0xe9, 0xb6,
+   0xc9, 0x3f, 0x3f, 0x80, 0x0f, 0x7f, 0xf8, 0xa5, 0x55, 0xb9, 0xaa, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0x43, 0xaf, 0xb3, 0x54, 0x21, 0x6c, 0x84, 0x4a,
+   0x76, 0xad, 0xaa, 0x9c, 0xe9, 0x7b, 0x00, 0xe0, 0x01, 0xff, 0xf9, 0xab,
+   0x6a, 0x8b, 0x6a, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbb, 0xd9, 0x32, 0xe7,
+   0x8e, 0x8a, 0xd2, 0x9d, 0xa6, 0x22, 0xd5, 0x54, 0xd2, 0xf3, 0x00, 0xf8,
+   0x00, 0xfe, 0xff, 0xb5, 0x5a, 0x75, 0x55, 0xad, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f,
+   0xbe, 0x7c, 0xb5, 0x32, 0x2c, 0x5c, 0xd4, 0xa4, 0x34, 0xad, 0xe9, 0x1e,
+   0xe9, 0xf3, 0x03, 0x3f, 0x00, 0xfe, 0xff, 0xab, 0xaa, 0x55, 0x5d, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0x7f, 0x25, 0x9c, 0x6a, 0x67, 0xd1, 0x43, 0x6a, 0xb6,
+   0x2a, 0x25, 0x56, 0xf2, 0xeb, 0xe1, 0xff, 0x1f, 0x00, 0xfc, 0xff, 0x57,
+   0xab, 0x56, 0xab, 0xab, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xf7, 0x0f, 0x29, 0xba,
+   0x12, 0xbb, 0x79, 0x2b, 0xb5, 0xaa, 0x33, 0x47, 0xfa, 0xc1, 0xff, 0x0f,
+   0x00, 0xf8, 0xff, 0xd7, 0xda, 0xaa, 0x6a, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f,
+   0xff, 0x3b, 0x1b, 0xd9, 0x4e, 0x20, 0xd9, 0x1a, 0xa5, 0xaa, 0x34, 0xa5,
+   0xfa, 0xc1, 0xff, 0x03, 0x00, 0xf8, 0xff, 0x5f, 0x6b, 0xb5, 0x5d, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xbf, 0xad, 0x05, 0x99, 0xa9, 0x2a, 0xbb, 0x0a, 0xc8,
+   0x6a, 0x55, 0x17, 0x17, 0xfa, 0x80, 0xff, 0x01, 0x00, 0xf0, 0xff, 0xbf,
+   0xaa, 0xad, 0xaa, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x77, 0x4e, 0x3e, 0x6d, 0x4a,
+   0xa6, 0x15, 0xf5, 0x29, 0x29, 0xa5, 0x74, 0xa7, 0xfe, 0x00, 0xff, 0x00,
+   0x00, 0xf0, 0xff, 0x5f, 0xb5, 0x56, 0x6b, 0x55, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xce,
+   0x27, 0x2d, 0x2c, 0x5d, 0x21, 0x8d, 0x2d, 0x45, 0xab, 0x54, 0x97, 0x6b,
+   0x7d, 0x00, 0x1e, 0x00, 0x00, 0xe0, 0xff, 0x7f, 0xab, 0x5a, 0xad, 0xb5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xfb, 0xb5, 0xe6, 0x46, 0x8f, 0x56, 0x59, 0xe3, 0x56,
+   0x55, 0xa9, 0x2a, 0x53, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x7f,
+   0x6a, 0xd7, 0x6a, 0xad, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xfe, 0x38, 0x2b, 0xd1, 0x4d,
+   0x52, 0x55, 0x54, 0x56, 0x69, 0xad, 0xca, 0x89, 0x3f, 0x00, 0x00, 0x00,
+   0x00, 0xc0, 0xff, 0x7f, 0x5b, 0x59, 0xab, 0x56, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
+   0xa6, 0x12, 0x2f, 0xf2, 0x09, 0xc0, 0x40, 0xa9, 0x2e, 0x54, 0x8d, 0xea,
+   0x3f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x7f, 0x6d, 0xd7, 0x5a, 0xa9,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xef, 0xbf, 0xd6, 0x2a, 0x43, 0x6c, 0x29, 0x52, 0x3d, 0x88,
+   0x92, 0x56, 0xd5, 0xa6, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff,
+   0xaa, 0xd5, 0xaa, 0xad, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 0x37, 0x06, 0xe9, 0x25,
+   0x00, 0xa0, 0x14, 0xa0, 0x5a, 0xa9, 0xca, 0xd4, 0x1f, 0x00, 0x00, 0x00,
+   0x00, 0x80, 0xff, 0xff, 0x55, 0x35, 0xab, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xdf,
+   0x59, 0xc3, 0x2e, 0x36, 0x1e, 0x91, 0x51, 0x50, 0x15, 0x55, 0xc5, 0xea,
+   0x0f, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x2f, 0xd5, 0x56, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xab, 0x21, 0x40, 0x51, 0xa2, 0x8a, 0x80, 0xdd, 0xa5,
+   0xae, 0xac, 0xc6, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff,
+   0xd7, 0xad, 0xaa, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xe4, 0xba, 0x42, 0x65, 0xb5,
+   0x8e, 0xc8, 0xed, 0x70, 0x4b, 0xb5, 0xc6, 0xfa, 0x0f, 0x00, 0x00, 0x00,
+   0x00, 0x80, 0xbf, 0xff, 0xbf, 0x56, 0xd5, 0xb6, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2f, 0x53,
+   0x05, 0x48, 0xa9, 0xb0, 0x56, 0x67, 0x6f, 0xaa, 0xa9, 0x45, 0xed, 0xfc,
+   0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xbf, 0xaa, 0xb5, 0xaa,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xdf, 0xbb, 0x9a, 0x3c, 0x04, 0xf4, 0x99, 0x6b, 0xf0, 0x7f, 0xa9,
+   0xac, 0x54, 0x65, 0xfe, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe,
+   0x5f, 0xab, 0xaa, 0xb5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4f, 0xda, 0x3f, 0xb0, 0x79, 0x48,
+   0x17, 0xb8, 0xbf, 0xaa, 0x66, 0xab, 0xe6, 0xfe, 0x1f, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xfe, 0xfd, 0xbf, 0x55, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x6f, 0x5f,
+   0xee, 0x1a, 0x1d, 0xc4, 0xfc, 0xff, 0xab, 0x29, 0xad, 0xa9, 0xf2, 0xff,
+   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfb, 0x7f, 0x55, 0x55, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xfe, 0x8b, 0x6e, 0x77, 0x20, 0x1e, 0xc6, 0xf6, 0xd9, 0xaa, 0xa6,
+   0xad, 0x6a, 0xa7, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xf3,
+   0xff, 0xea, 0xbd, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x2b, 0x97, 0x2b, 0x5e, 0x6f, 0xe0,
+   0x3e, 0x5d, 0x45, 0x4a, 0x56, 0x6d, 0xc5, 0xef, 0x07, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xf8, 0xf7, 0xff, 0x8a, 0xa8, 0xad, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0x6d, 0xeb,
+   0x23, 0x50, 0x42, 0xf3, 0xd7, 0x96, 0x56, 0xa9, 0xb4, 0x52, 0xaa, 0xf7,
+   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xe7, 0xff, 0x6a, 0x57, 0x55,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xbf, 0x67, 0x9b, 0xe5, 0x91, 0xad, 0x87, 0x78, 0xa1, 0xa2, 0x72, 0x25,
+   0xad, 0x2a, 0xcb, 0xf7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xef,
+   0xff, 0x2b, 0xa9, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0x77, 0x7b, 0x4d, 0xe1, 0x49, 0xfb,
+   0xaf, 0xde, 0xa4, 0x0a, 0x55, 0x95, 0xb5, 0xfb, 0x03, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xf0, 0xcf, 0xff, 0xd5, 0xaa, 0x5a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbb, 0xe8, 0xb9,
+   0x4c, 0x6d, 0xe4, 0xbd, 0xd2, 0xe2, 0x96, 0xa3, 0x5a, 0xd5, 0xd4, 0xff,
+   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xdf, 0xff, 0xd7, 0xaa, 0xad,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x5f, 0x4b, 0xe7, 0x8d, 0x8f, 0x79, 0xf2, 0xaf, 0x2a, 0x29, 0xaa, 0x13,
+   0x4f, 0xa5, 0xea, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x9f,
+   0xff, 0x2b, 0xad, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xf7, 0xfd, 0x72, 0xe4, 0x05, 0x7c, 0xf6, 0x55,
+   0x55, 0xad, 0xb3, 0x48, 0x61, 0x6d, 0xf5, 0xff, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xe0, 0x9f, 0xff, 0xb7, 0xaa, 0x6a, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x97, 0xff, 0x74,
+   0xca, 0x6e, 0x76, 0xad, 0xaa, 0xaa, 0x6a, 0xb2, 0x5c, 0x59, 0xe9, 0xff,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0xff, 0x57, 0xab, 0xad,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,
+   0xd9, 0xd5, 0x7e, 0x0c, 0x6e, 0xff, 0x07, 0xb0, 0xaa, 0x54, 0x29, 0x53,
+   0xa5, 0x4a, 0xea, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f,
+   0xff, 0x5f, 0xa9, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x6e, 0x3b, 0x90, 0xb5, 0xeb, 0x67, 0x54,
+   0x5d, 0x55, 0x6d, 0xd5, 0x5a, 0xa9, 0xfa, 0x7f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0xc0, 0x3f, 0xff, 0x57, 0xdb, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x6f, 0xe7, 0xdf, 0xc9,
+   0xd9, 0x79, 0x7b, 0x56, 0x4a, 0x95, 0xaa, 0x14, 0x2a, 0x55, 0xf5, 0x3f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x7f, 0xfe, 0xdf, 0xaa, 0xd6,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,
+   0xb7, 0x9d, 0xfb, 0xc4, 0xdc, 0x7f, 0x7f, 0xaa, 0xaa, 0x6a, 0x25, 0x6d,
+   0xab, 0x4a, 0xfa, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f,
+   0xfe, 0xbf, 0xda, 0x5a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xf7, 0xdd, 0xef, 0xff, 0x74, 0xde, 0xfb, 0x5f, 0xaa,
+   0xaa, 0x56, 0x99, 0xaa, 0xaa, 0xaa, 0xfa, 0x3f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x80, 0x7f, 0xfe, 0x5f, 0x55, 0x6b, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xcf, 0xea, 0x6e, 0x66,
+   0xff, 0xbb, 0x3f, 0x54, 0xad, 0xaa, 0x1a, 0x4d, 0xa5, 0x54, 0xfd, 0x1f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f, 0xfe, 0xbf, 0x6d, 0xad,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xed,
+   0xe7, 0xbf, 0x3f, 0xdb, 0xf7, 0xea, 0x0b, 0xa9, 0xaa, 0xaa, 0x5d, 0x75,
+   0xad, 0x52, 0xfd, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
+   0xfe, 0xdf, 0x56, 0xab, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xbf, 0x7f, 0x5f, 0xed, 0x1f, 0x8a, 0x3e, 0xbf, 0xce, 0xab,
+   0x56, 0xb5, 0x4c, 0x95, 0x4a, 0x95, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x80, 0xff, 0xfc, 0x7f, 0xb5, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb7, 0xe5, 0xe6, 0x0b, 0xf3,
+   0xbf, 0xbe, 0x7f, 0xa9, 0xaa, 0xaa, 0x4e, 0x6b, 0x53, 0x52, 0xdf, 0x1f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xfc, 0xbf, 0xd6, 0x56,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef,
+   0x5d, 0xf3, 0x07, 0xfa, 0x5b, 0x47, 0x57, 0xad, 0x5a, 0x75, 0x4a, 0x55,
+   0x49, 0xa9, 0xde, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
+   0xfc, 0x7f, 0x6b, 0xb5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xef, 0x7a, 0x4b, 0x7b, 0x01, 0xfd, 0x4d, 0xf2, 0x53, 0x55,
+   0x57, 0x57, 0x61, 0x5b, 0xad, 0xac, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xff, 0xfc, 0xbf, 0xb5, 0x96, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfd, 0x01, 0xdb,
+   0xae, 0xe5, 0x4a, 0x55, 0x55, 0xb5, 0xaf, 0xa5, 0xaa, 0x22, 0xdf, 0x0f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0xff, 0x5a, 0xfb,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7d, 0x6f,
+   0xf5, 0xbd, 0x40, 0xfc, 0x65, 0x35, 0x35, 0xcd, 0xaa, 0xd5, 0xa5, 0xba,
+   0x4a, 0xaa, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
+   0xfc, 0x7f, 0x4d, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xef, 0xbf, 0x57, 0xf6, 0x41, 0x57, 0x91, 0xca, 0x4a, 0xb5,
+   0x56, 0x55, 0xaa, 0xcd, 0x5a, 0xd5, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xff, 0xfc, 0xff, 0x5a, 0xb7, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xcf, 0x3e, 0x7f, 0x00, 0x60,
+   0x57, 0x6b, 0x75, 0x55, 0xb5, 0xcb, 0xba, 0xd5, 0x2a, 0xc9, 0xdf, 0x0f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x7f, 0xeb, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe6,
+   0x9f, 0x7f, 0x00, 0x68, 0x55, 0x54, 0x95, 0x5a, 0x55, 0xaa, 0x4a, 0x75,
+   0x53, 0xd5, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
+   0xfe, 0xff, 0xad, 0x6a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x7f, 0xef, 0x73, 0xc7, 0xb7, 0xd0, 0x5c, 0xdd, 0xa5, 0xaa, 0x6d,
+   0xaa, 0x6a, 0xea, 0x56, 0x55, 0xf5, 0xdf, 0x0f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x7f, 0xfe, 0x7f, 0xb5, 0xbe, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfd, 0xed, 0xc7, 0x7d, 0x83, 0x8b,
+   0x2e, 0xd5, 0xaa, 0x2a, 0xb5, 0x5a, 0x5d, 0xdb, 0x56, 0xf5, 0x9f, 0x0f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x7f, 0xdb, 0xa5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xff,
+   0xe3, 0x7f, 0x47, 0xd9, 0xa6, 0x6a, 0xab, 0xd6, 0xaa, 0x2a, 0x55, 0x55,
+   0xaa, 0xe4, 0xbf, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
+   0xff, 0x7f, 0xad, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x37, 0xec, 0xff, 0xf2, 0xbf, 0x83, 0x96, 0x53, 0xa9, 0xaa, 0x55,
+   0xad, 0x56, 0xad, 0xd5, 0x55, 0xeb, 0x3f, 0x0f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x0e, 0xfc, 0x7f, 0x6b, 0xad, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x3e, 0x6d, 0xfb, 0xce, 0xe1, 0x52,
+   0x59, 0xad, 0xaa, 0x9a, 0xaa, 0x5a, 0x6b, 0x5d, 0xaa, 0xea, 0x3f, 0x0f,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf1, 0x7f, 0x5d, 0xeb,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5b, 0x3f, 0xfb,
+   0xff, 0xf3, 0x51, 0xcd, 0x56, 0x55, 0xd5, 0x6a, 0xb5, 0x56, 0xb5, 0x56,
+   0xab, 0xea, 0x7f, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
+   0xe7, 0xff, 0xd6, 0x5a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x4f, 0xcf, 0xcf, 0xdd, 0xe7, 0x58, 0x62, 0x52, 0xd5, 0xb6, 0x96,
+   0xaa, 0x55, 0xad, 0x69, 0x55, 0xfb, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x6b, 0x6b, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0x8b, 0xef, 0xc7, 0x7f, 0x21, 0xc4, 0x96,
+   0xad, 0xaa, 0xaa, 0x6a, 0xad, 0xaa, 0x56, 0xaf, 0x31, 0xf5, 0xff, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x7f, 0xb5, 0xb5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xfb, 0xf3,
+   0xdd, 0x61, 0xee, 0xd4, 0x56, 0x6d, 0xd5, 0x2a, 0xb5, 0xd6, 0xda, 0xaa,
+   0x9c, 0x75, 0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
+   0xff, 0xff, 0xae, 0xae, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xe3, 0xab, 0x7b, 0x7f, 0x20, 0xfa, 0x41, 0xd5, 0x52, 0x55, 0xd5,
+   0x56, 0x55, 0x6b, 0x55, 0x6b, 0x15, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x80, 0xff, 0xff, 0xbf, 0xf5, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0xbf, 0xe1, 0xf6, 0xff, 0x4f, 0x20, 0xac, 0xb4,
+   0xaa, 0xb6, 0x6d, 0x55, 0x55, 0xab, 0xad, 0xad, 0x34, 0x15, 0xc0, 0x07,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xbf, 0x56, 0xd5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x63, 0xfb, 0xda,
+   0x37, 0x40, 0x2a, 0xab, 0xb5, 0x5a, 0xb5, 0x55, 0xb5, 0x6a, 0x55, 0x55,
+   0xab, 0x15, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0xff,
+   0xff, 0x4f, 0xdb, 0x6e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xef, 0xf3, 0xfc, 0xff, 0x11, 0x52, 0x55, 0x69, 0xad, 0xaa, 0x96, 0xaa,
+   0xd6, 0xaa, 0x76, 0x5d, 0x55, 0x0d, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x0c, 0xff, 0xff, 0x87, 0x55, 0xab, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0xf3, 0x7e, 0xff, 0x19, 0xd2, 0xd1, 0xb5,
+   0x55, 0x55, 0xab, 0xaa, 0xaa, 0xb5, 0x55, 0x53, 0xb5, 0x0a, 0x00, 0x7e,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xff, 0x87, 0xfa, 0xed,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0x38, 0xff, 0xef,
+   0x9e, 0xad, 0xd4, 0x54, 0xd5, 0x76, 0x6d, 0x55, 0x75, 0xd5, 0x56, 0x6d,
+   0x95, 0x0d, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe,
+   0xff, 0x83, 0x2f, 0x35, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x5f, 0xdc, 0xbf, 0xff, 0x01, 0x42, 0xae, 0x5b, 0x6d, 0x55, 0xab, 0x52,
+   0x55, 0xb5, 0xda, 0x96, 0xca, 0x0e, 0x00, 0xf8, 0x01, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x06, 0xfe, 0xff, 0x81, 0xd5, 0xda, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x3d, 0xfe, 0xfb, 0x7b, 0x4d, 0x03, 0xb5, 0xd2,
+   0x55, 0xab, 0x55, 0x55, 0xad, 0xda, 0x56, 0xb3, 0x5a, 0x0d, 0x00, 0xf8,
+   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xfc, 0xff, 0x80, 0x6d, 0xd7,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xe8, 0xdf, 0xef,
+   0xa7, 0x9d, 0xd4, 0x6d, 0xaa, 0xda, 0xaa, 0xaa, 0xd5, 0x56, 0xab, 0xdc,
+   0xd6, 0x0e, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xf8,
+   0x7f, 0x80, 0xb6, 0x6d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0x8e, 0xfd, 0xfe, 0xff, 0xd1, 0xdd, 0x75, 0x55, 0xd9, 0x6a, 0x6d, 0x55,
+   0x6d, 0x75, 0xb5, 0xa5, 0xab, 0x07, 0x00, 0xe0, 0x1f, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x06, 0xf0, 0x1f, 0x80, 0xdb, 0xb5, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xff, 0x4f, 0xf6, 0xff, 0x7d, 0x28, 0xb7, 0x2a, 0xb5,
+   0x6a, 0xad, 0xaa, 0x5a, 0xb5, 0x56, 0xab, 0xba, 0xea, 0x07, 0x00, 0xe0,
+   0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xe0, 0x07, 0x80, 0xb5, 0xae,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x23, 0x7e, 0xef, 0x5f,
+   0x38, 0x57, 0x5a, 0x93, 0x56, 0xad, 0xad, 0xaa, 0x5d, 0xab, 0xba, 0xca,
+   0xff, 0x03, 0x00, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
+   0x00, 0x80, 0xdf, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+   0xb2, 0xff, 0xff, 0xfe, 0xe8, 0xb5, 0xca, 0xea, 0xda, 0xb6, 0x6a, 0xad,
+   0x56, 0x75, 0x4b, 0xf5, 0x78, 0x00, 0x00, 0x80, 0xff, 0x01, 0x00, 0x00,
+   0x00, 0x00, 0x06, 0x00, 0x00, 0x80, 0x6b, 0x5f, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xdf, 0xff, 0x53, 0xf7, 0x6f, 0x6a, 0xad, 0xaa, 0xaa,
+   0x6a, 0xd5, 0x56, 0xab, 0xda, 0xae, 0x6a, 0x3d, 0x00, 0x00, 0x00, 0x80,
+   0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x80, 0xb7, 0x6a,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8b, 0x7f, 0x3f,
+   0xd3, 0x5a, 0x67, 0x5b, 0x55, 0x55, 0x55, 0x55, 0x57, 0x55, 0x5d, 0x35,
+   0x00, 0x00, 0x00, 0x00, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
+   0x00, 0x80, 0xdf, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7,
+   0x6d, 0xc3, 0xff, 0xd3, 0x51, 0xad, 0xba, 0xaa, 0xb6, 0xb6, 0xb6, 0xd5,
+   0xb5, 0xd5, 0x66, 0x35, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0x00, 0x00,
+   0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xd7, 0xd6, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xbf, 0xff, 0xe1, 0xb7, 0xc0, 0xaa, 0xb6, 0x4b, 0xd5,
+   0xda, 0x5a, 0xab, 0xb6, 0xd6, 0xb6, 0xba, 0x3a, 0x00, 0x00, 0x00, 0x00,
+   0xfe, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x7f, 0x75,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0x97, 0xf0, 0xfe, 0x71,
+   0x5c, 0xab, 0x59, 0x5b, 0x55, 0xad, 0xb5, 0xaa, 0x75, 0xb5, 0x56, 0x7b,
+   0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00,
+   0x00, 0x00, 0x7e, 0xb7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf,
+   0x8e, 0xfa, 0xff, 0x32, 0xd6, 0xda, 0x6a, 0x55, 0x5d, 0xd5, 0x5a, 0x5b,
+   0x5b, 0xab, 0x59, 0x7d, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00,
+   0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xfe, 0xad, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xff, 0xfa, 0x0f, 0xbd, 0x37, 0x9d, 0xd6, 0xd6, 0x5a, 0xad,
+   0xd5, 0xb6, 0xee, 0xea, 0x6d, 0x55, 0xad, 0x75, 0x00, 0x00, 0x00, 0x00,
+   0xf8, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xf8, 0xb5,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcd, 0x4b, 0xff, 0x1e, 0x95,
+   0x2d, 0xab, 0x66, 0x55, 0xad, 0xaa, 0x55, 0xad, 0xb6, 0xba, 0xd5, 0xea,
+   0x00, 0x00, 0x00, 0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x40, 0x0e, 0x00,
+   0x00, 0x00, 0x80, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xee,
+   0xe7, 0xdf, 0x07, 0x77, 0x75, 0x75, 0x2f, 0xd5, 0xd6, 0x5a, 0xb5, 0xb6,
+   0x55, 0xd5, 0x56, 0xfb, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00,
+   0x00, 0x60, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x6e, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x77, 0xf8, 0xe3, 0x7f, 0x83, 0x4d, 0xaf, 0x55, 0xa5, 0x55,
+   0x55, 0xad, 0x5b, 0xdb, 0x7e, 0x5b, 0x6b, 0xed, 0x00, 0x00, 0x00, 0x00,
+   0xe0, 0x07, 0x00, 0x00, 0x00, 0xf0, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xbc,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfe, 0xf0, 0xf6, 0x81, 0xd4,
+   0xe9, 0xb6, 0xaa, 0xd5, 0xb6, 0xb6, 0x6a, 0x55, 0x8b, 0xaa, 0xba, 0xe5,
+   0x01, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xf8, 0x0e, 0x00,
+   0x00, 0x00, 0x00, 0xd8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xdf,
+   0xfd, 0xff, 0x6d, 0xb8, 0xae, 0x6a, 0xd5, 0x56, 0xab, 0xd5, 0xad, 0xed,
+   0x76, 0x75, 0xab, 0xec, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+   0x00, 0xfc, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xb8, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0x8b, 0xff, 0xff, 0x3f, 0x61, 0xad, 0x6a, 0x5d, 0x6d, 0xd5,
+   0xda, 0x6e, 0x6d, 0xb5, 0xae, 0x5e, 0xad, 0xe6, 0x01, 0x00, 0x00, 0x00,
+   0x80, 0x01, 0x00, 0x00, 0x00, 0xfe, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xdc,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xed, 0xdd, 0x76, 0x59, 0x55,
+   0xad, 0xd5, 0x96, 0x5e, 0x55, 0xb5, 0xaa, 0xae, 0xa7, 0xaa, 0x65, 0xf3,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x80, 0x7f, 0x0f, 0x00,
+   0x00, 0x00, 0x00, 0xbe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfb, 0xff,
+   0xff, 0xbf, 0x3c, 0xf5, 0x6b, 0x6d, 0x4b, 0x53, 0xdb, 0xd5, 0x6e, 0xb3,
+   0xb5, 0x76, 0x6d, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x00, 0x00,
+   0xc0, 0x7f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xdf, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xff, 0xfb, 0xef, 0xfe, 0xff, 0x1e, 0x2d, 0xbd, 0x56, 0xab, 0xad,
+   0xad, 0x6e, 0xb5, 0xdd, 0x5d, 0x5b, 0x55, 0xf7, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0xe6, 0x01, 0x00, 0xf0, 0x7f, 0x0f, 0x00, 0x00, 0x00, 0xc0, 0x6f,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfd, 0xfd, 0x77, 0x57, 0xa9, 0xb6,
+   0x4d, 0x6b, 0xad, 0xaa, 0xda, 0xaa, 0x55, 0xd5, 0xa6, 0xd1, 0xdd, 0x72,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x07, 0x00, 0xff, 0x7f, 0x0f, 0x00,
+   0x00, 0x00, 0xf0, 0x6b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff,
+   0xfe, 0x7f, 0xed, 0xd5, 0xd6, 0x9a, 0x6a, 0xb5, 0x5d, 0xdb, 0xde, 0xb6,
+   0xda, 0x5e, 0xab, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0xff, 0xff,
+   0xff, 0x7f, 0x07, 0x00, 0x00, 0x00, 0xfc, 0xb6, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0x77, 0xff, 0x6f, 0xbf, 0x3f, 0x35, 0x57, 0xab, 0x6d, 0xad, 0x5a,
+   0x6d, 0x6b, 0x6b, 0xdb, 0xab, 0x54, 0xd5, 0x3a, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x9c, 0xff, 0xff, 0xff, 0x3f, 0x07, 0x00, 0x00, 0x80, 0x7f, 0xdb,
+   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdb, 0xbf, 0xfb, 0x9b, 0xd4, 0xba,
+   0x6d, 0x52, 0x57, 0xad, 0xb5, 0x6a, 0xad, 0xb6, 0x5a, 0xb7, 0xb5, 0x3a,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0xff, 0xff, 0xff, 0x3f, 0x07, 0x00,
+   0x00, 0xf0, 0xd7, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xde, 0xff, 0xdd,
+   0xff, 0xcf, 0xdc, 0xda, 0xea, 0x5b, 0xab, 0xaa, 0xde, 0x5d, 0xeb, 0xda,
+   0xea, 0x5a, 0xad, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0xff, 0xff,
+   0xff, 0x9f, 0x07, 0x00, 0x00, 0xfc, 0x5b, 0xdb, 0xff, 0xff, 0xff, 0xff,
+   0xff, 0xf7, 0xfe, 0xb7, 0x7f, 0x77, 0xb7, 0xae, 0x56, 0x6d, 0x55, 0x6d,
+   0xab, 0xaa, 0x5d, 0xaf, 0xad, 0xd6, 0xaa, 0xf6, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0xbc, 0xff, 0xff, 0xff, 0x9f, 0x07, 0x00, 0x00, 0xbf, 0xed, 0xb6,
+   0xff, 0xff, 0xff, 0xff, 0xbf, 0x7f, 0xef, 0xff, 0xbb, 0x7f, 0xdb, 0x56,
+   0x7b, 0x55, 0x55, 0xab, 0xd5, 0xb6, 0xd6, 0xea, 0x6a, 0xab, 0xb6, 0xea,
+   0x07, 0x00, 0x00, 0x00, 0x00, 0xbe, 0xff, 0xff, 0xff, 0x9f, 0x0f, 0x00,
+   0x80, 0xbf, 0x6d, 0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x7f, 0xfd,
+   0xff, 0xdc, 0x6e, 0x77, 0xd5, 0x56, 0x6b, 0x6d, 0x6d, 0xdb, 0x6b, 0xb7,
+   0xb6, 0x5a, 0x55, 0xeb, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xbe, 0xff, 0xff,
+   0xff, 0xbf, 0x0f, 0x00, 0xc0, 0xd7, 0xb6, 0x6d, 0xff, 0xff, 0xff, 0xff,
+   0xef, 0xbd, 0x9f, 0xdd, 0x5d, 0xef, 0xb6, 0xdb, 0x56, 0xaa, 0x5a, 0xb5,
+   0xb6, 0x55, 0xbd, 0xb5, 0xaa, 0xad, 0x6d, 0xad, 0xfe, 0x0f, 0x00, 0x00,
+   0x00, 0xde, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xf0, 0xdf, 0xb6, 0x6d,
+   0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xab, 0xfe, 0x7f, 0x56, 0xab, 0xae,
+   0xfa, 0x56, 0xab, 0x56, 0xd5, 0xda, 0xd5, 0xde, 0xdd, 0x56, 0x55, 0x6b,
+   0xd5, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00,
+   0xf8, 0x6b, 0xdb, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xbb, 0xdf, 0x3f, 0x3f,
+   0xbd, 0xb7, 0xb5, 0xab, 0x57, 0x55, 0xd5, 0xea, 0xb6, 0x6a, 0x6d, 0x6b,
+   0xd5, 0xaa, 0xb6, 0xb5, 0x5a, 0xfd, 0x1f, 0x00, 0x00, 0xff, 0x57, 0xf5,
+   0xb6, 0xdd, 0x1f, 0x00, 0xfc, 0xb5, 0xd5, 0xaa, 0xff, 0xff, 0xff, 0xff,
+   0xde, 0xbf, 0x9e, 0x3f, 0xef, 0x7d, 0xed, 0xd6, 0x5a, 0xb5, 0xaa, 0xae,
+   0x6d, 0xb5, 0xb6, 0x5d, 0x6d, 0x55, 0xab, 0xaa, 0xd6, 0x96, 0xff, 0x01,
+   0x80, 0x7f, 0x55, 0x2b, 0x5b, 0xf5, 0x3f, 0x00, 0xff, 0xda, 0x76, 0xef,
+   0xff, 0xff, 0xff, 0xff, 0xee, 0xcb, 0xe7, 0xd7, 0xaf, 0xaa, 0xb6, 0x55,
+   0x6d, 0x55, 0xad, 0x6a, 0xb5, 0xdd, 0xb6, 0xd6, 0xb6, 0xb6, 0xac, 0xad,
+   0x55, 0x1b, 0xfa, 0x0f, 0xe0, 0x5f, 0x53, 0x6d, 0xe9, 0x76, 0xff, 0xe0,
+   0xdf, 0x56, 0x5b, 0x6b, 0xff, 0xff, 0xff, 0x7f, 0xef, 0xdf, 0xe7, 0xff,
+   0xef, 0xdf, 0x6d, 0xef, 0x55, 0xad, 0x6a, 0xb7, 0x56, 0x55, 0x6d, 0xbb,
+   0x59, 0xab, 0xa5, 0xb6, 0x6a, 0x6d, 0xd5, 0xff, 0xf8, 0xdb, 0xb2, 0x55,
+   0x57, 0xcd, 0xff, 0xff, 0xbf, 0xed, 0xb5, 0xb5, 0xff, 0xff, 0xff, 0xbf,
+   0x7b, 0x6f, 0xf5, 0x7e, 0x75, 0x69, 0xed, 0xb5, 0xb6, 0xd6, 0xaa, 0xd5,
+   0x5b, 0xd5, 0xb6, 0xad, 0x6e, 0xd5, 0xbe, 0xaa, 0xad, 0x35, 0x55, 0xff,
+   0xff, 0x6d, 0x59, 0xb5, 0x75, 0xb7, 0xfe, 0xff, 0xd7, 0xb6, 0xb6, 0xbd,
+   0xff, 0xff, 0xff, 0x7f, 0xff, 0xfb, 0xf5, 0xdb, 0xab, 0x56, 0x5b, 0x6b,
+   0xad, 0x52, 0xed, 0x5a, 0xb5, 0x6d, 0xdb, 0xd6, 0xaa, 0x2a, 0x57, 0xdb,
+   0xb6, 0x5a, 0xd5, 0xfd, 0xff, 0xaa, 0x52, 0x5b, 0xad, 0xda, 0xfe, 0xff,
+   0x7b, 0xdb, 0xea, 0xd6, 0xff, 0xff, 0xff, 0xaf, 0xdd, 0xbf, 0x72, 0x7f,
+   0xdb, 0xfe, 0xed, 0xba, 0x55, 0x55, 0xb5, 0xae, 0xd6, 0xaa, 0x6d, 0xbb,
+   0xae, 0x6d, 0x6d, 0x55, 0xad, 0x75, 0x5b, 0xed, 0xbf, 0xea, 0xa9, 0x69,
+   0xb7, 0x6b, 0xf5, 0xff, 0x55, 0xdb, 0x7e, 0xdb, 0xff, 0xff, 0xff, 0x3b,
+   0xfe, 0xf6, 0xf1, 0xd7, 0xbe, 0x55, 0xbb, 0xae, 0x6a, 0xd7, 0xaa, 0x6a,
+   0x5b, 0x75, 0xab, 0x55, 0x7b, 0x55, 0x55, 0xb7, 0x55, 0xb3, 0xaa, 0xd6,
+   0x5a, 0x55, 0xa5, 0xb6, 0xd5, 0x5a, 0xb5, 0xdb, 0xba, 0x6d, 0xab, 0xb6,
+   0xff, 0xff, 0xff, 0x8f, 0xef, 0xff, 0xb8, 0xfa, 0xdf, 0xd5, 0xde, 0xb5,
+   0xad, 0xda, 0xaa, 0xab, 0x6a, 0x5b, 0x5d, 0xbd, 0x8a, 0xb6, 0xdd, 0xda,
+   0x76, 0xdb, 0xaa, 0xaa, 0xaa, 0x76, 0x55, 0x55, 0x75, 0x55, 0xd5, 0x6a,
+   0xd7, 0xb6, 0x6d, 0xdb, 0xff, 0xff, 0xff, 0xdb, 0x7f, 0xbe, 0xf1, 0x6f,
+   0xab, 0x7d, 0xab, 0x6e, 0xd7, 0x6d, 0x6b, 0xb5, 0xad, 0xaa, 0xab, 0x57,
+   0xb7, 0xaa, 0x6a, 0xab, 0xaa, 0xa2, 0xda, 0xd6, 0x56, 0x55, 0xa5, 0x6d,
+   0x5b, 0xfb, 0x6d, 0xbb, 0x5a, 0xdb, 0xb6, 0xb6, 0xff, 0xff, 0x7f, 0xcf,
+   0x36, 0xf7, 0xb8, 0x77, 0xff, 0xd6, 0xbb, 0xb5, 0x69, 0x35, 0xb5, 0x5d,
+   0x6d, 0xbb, 0xda, 0xad, 0x55, 0x6b, 0xab, 0xda, 0xb5, 0xbd, 0xaa, 0x5a,
+   0xb5, 0xea, 0xaa, 0x55, 0xad, 0x2a, 0x6a, 0xad, 0xd5, 0x6d, 0xb3, 0xdb };
diff -Naur linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/xbm2lcd.pl linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/xbm2lcd.pl
--- linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/xbm2lcd.pl	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/xbm2lcd.pl	2004-10-28 11:11:46.000000000 +1000
@@ -0,0 +1,6 @@
+
+$_ = join("", <>);
+
+s/(0x[0-9a-f]{2})/sprintf("0x%.2x",ord(pack("b8",unpack("B8",chr(~hex($1)&0377)))))/gei;
+
+print $_;
diff -Naur linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/crt0.S linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/crt0.S
--- linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/crt0.S	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/crt0.S	2004-10-28 11:11:46.000000000 +1000
@@ -0,0 +1,78 @@
+/*
+ *  linux/arch/m68knommu/platform/MC68VZ328/de2/zimage/crt0.S
+ *
+ *  Copyright (C) 2002 Georges Menie
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+	.title "de2/zimage/crt0.S"
+
+	.extern unzip_image
+	.extern __stack
+	.extern __text_end
+	.extern __data_start
+	.extern __data_end
+	.extern __bss_start
+	.extern __bss_end
+	.extern start_image
+
+	.text
+	.global start
+start:
+
+        /* initialize the stack */
+        move.l  #__stack,%sp
+
+	/* disable interrupts */
+	move.l	#-1,0xfffff304
+	move.b	#0,0xfffff300
+
+        /* initialize the data section */
+	lea.l	__text_end,%a0
+	lea.l	__data_start,%a1
+	lea.l	__data_end,%a2
+1:	cmpa.l  %a1,%a2
+        jbeq	2f
+	move.l	(%a0)+,(%a1)+
+	jbra	1b
+2:
+        /* initialize the bss section */
+        lea.l   __bss_start,%a0
+        lea.l   __bss_end,%a1
+1:	cmpa.l  %a0,%a1
+        jbeq	2f
+	move.l  #0,(%a0)+
+	jbra	1b
+2:
+	
+/*
+ * Unzip the kernel image
+ */
+	jsr	unzip_image
+
+/*
+ * Start the image
+ */
+	movea.l	#start_image,%a0
+	jmp	(%a0)
+
+/*
+ * Infinite loop for exit
+ */
+        .global exit
+exit:
+	bra	exit
+
+/*
+ * Define putc to send a char to the UART1
+ */
+        .global putc
+putc:
+1:	move.w	0xfffff906,%d0
+	and.w	#0x2000,%d0
+	beq	1b
+	move.b	7(%sp),0xfffff907
+	rts
diff -Naur linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/image.ld linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/image.ld
--- linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/image.ld	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/image.ld	2004-10-28 11:11:46.000000000 +1000
@@ -0,0 +1,98 @@
+STARTUP(crt0.o)
+OUTPUT_ARCH(m68k)
+SEARCH_DIR(.)
+GROUP(-lc -lgcc)
+__DYNAMIC  =  0;
+
+/*
+
+ To test the decompression use:
+
+   rom (rwx) : ORIGIN = 0x400000, LENGTH = 2M
+
+ download and run the compressed zImage.bin at 0x400000.
+ Depending on the build model (RAM,HIMEM,ROM) and
+ the size of the kernel (either compressed or uncompressed)
+ you might need to change this address.
+ 
+ To generate a flashable compressed image, use:
+
+   rom (rwx) : ORIGIN = <addr_in_flash>, LENGTH = <available space>
+
+ store and run the compressed image at <addr_in_flash>
+
+*/
+
+MEMORY
+{
+  ram (rwx) : ORIGIN =   0x1000, LENGTH = 64k-4k
+  rom (rwx) : ORIGIN = 0x400000, LENGTH = 2M
+}
+
+PROVIDE (__stack = 4k - 4);
+
+SECTIONS
+{
+  .text :
+  {
+    __text_start = .;
+    *(.text)
+
+    . = ALIGN(0x4);
+    *(.rodata)
+
+    . = ALIGN(0x4);
+    *(.gcc_except_table) 
+
+    . = ALIGN(0x4);
+    *(.eh_frame)
+
+    . = ALIGN(0x4);
+    *(.lit)
+
+    . = ALIGN(0x4);
+    input_data = .;
+    image.o
+    input_data_end = .;
+
+    . = ALIGN(0x4);
+    __text_end = .;
+  } > rom
+
+  .data : AT(__text_end)
+   {
+    . = ALIGN (0x4);
+    __data_start = .;
+
+    *(.shdata)
+    *(.data)
+    *(.gcc_exc)
+
+    . = ALIGN (0x4);
+    __data_end = .;
+   } > ram
+
+  .bss :
+  {
+    . = ALIGN(0x4);
+    __bss_start = . ;
+
+    *(.shbss)
+    *(.bss)
+    *(COMMON)
+
+    . = ALIGN(0x4);
+    __bss_end = .;
+    _end = .;
+  } > ram
+
+  .stab 0 (NOLOAD) :
+  {
+    *(.stab)
+  }
+
+  .stabstr 0 (NOLOAD) :
+  {
+    *(.stabstr)
+  }
+}
diff -Naur linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/main.c linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/main.c
--- linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/main.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/main.c	2004-10-28 11:11:46.000000000 +1000
@@ -0,0 +1,32 @@
+
+/*
+ *  linux/arch/m68knommu/platform/MC68VZ328/de2/zimage/main.c
+ *
+ *  Copyright (C) 2002 Georges Menie
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+extern unsigned char input_data[];
+extern unsigned char input_data_end[];
+extern unsigned char output_data[];
+
+void outstring (char *s)
+{
+	extern void putc (int);
+
+	while (*s)
+		putc (*s++);
+}
+
+void unzip_image (void)
+{
+	void memgunzip (unsigned char *dst, const unsigned char *src,
+					unsigned int sz);
+
+	outstring ("Uncompressing Linux");
+	memgunzip (output_data, input_data, input_data_end - input_data);
+	outstring ("\r\nOk, booting the kernel.\r\n");
+}
diff -Naur linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/Makefile linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/Makefile
--- linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/Makefile	2004-10-28 11:11:46.000000000 +1000
@@ -0,0 +1,46 @@
+
+# Runtime parameters
+UNZIP_ADDRESS := $(shell [ -f $(ROOTDIR)/$(LINUXDIR)/System.map ] && grep ' _stext$$' $(ROOTDIR)/$(LINUXDIR)/System.map | cut -d' ' -f1)
+START_ADDRESS := $(shell [ -f $(ROOTDIR)/$(LINUXDIR)/System.map ] && grep ' _start$$' $(ROOTDIR)/$(LINUXDIR)/System.map | cut -d' ' -f1)
+
+# Compiler and associated tools filenames.
+CC = $(CROSS_COMPILE)gcc
+LD = $(CROSS_COMPILE)ld
+OBJCOPY = $(CROSS_COMPILE)objcopy
+
+# Flags.
+AFLAGS = -m68000 -Wall -I$(ROOTDIR)/$(LINUXDIR)/include
+CFLAGS = -m68000 -Wall -O2 --omit-frame-pointer -I$(ROOTDIR)/$(LINUXDIR)/include
+LFLAGS = -m68000 -nostdlib -Wl,-Map=$(basename $@).map
+
+#
+# Targets
+#
+
+OBJECTS = \
+	main.o \
+	misc.o
+
+all: $(IMAGEDIR)/zImage.bin
+
+crt0.o: crt0.S
+	$(CC) $(AFLAGS) -o $@ -c $+
+
+image.o: $(IMAGEDIR)/image.bin
+	tmpimage=_tmp_$$$$image; \
+	cat $+ | gzip -f -9 > $$tmpimage; \
+	$(LD) -r -o $@ -b binary $$tmpimage; \
+	rm -f $$tmpimage
+
+$(IMAGEDIR)/zImage.bin: crt0.o image.o ${OBJECTS}
+	tmpprog=_tmp_$$$$prog; \
+	tmplnk=_tmp_$$$$lnk; \
+	cp image.ld $$tmplnk; \
+	echo "PROVIDE (output_data = 0x$(UNZIP_ADDRESS));" >> $$tmplnk; \
+	echo "PROVIDE (start_image = 0x$(START_ADDRESS));" >> $$tmplnk; \
+	$(CC) $(LFLAGS) -T $$tmplnk -o $$tmpprog ${OBJECTS}; \
+	$(OBJCOPY) -O binary -j .text -j .data $$tmpprog $@; \
+	rm -f $$tmpprog $$tmplnk
+
+clean:
+	rm -f *.o _tmp_*
diff -Naur linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/misc.c linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/misc.c
--- linux-2.6.9/arch/m68knommu/platform/68VZ328/de2/zimage/misc.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/arch/m68knommu/platform/68VZ328/de2/zimage/misc.c	2004-10-28 11:11:46.000000000 +1000
@@ -0,0 +1,151 @@
+
+/*
+ *  linux/arch/m68knommu/platform/MC68VZ328/de2/zimage/misc.c
+ *
+ *  Copyright (C) 2002 Georges Menie
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * gunzip wrapper based on :
+ *
+ * arch/sh/boot/compressed/misc.c
+ * 
+ * This is a collection of several routines from gzip-1.0.3 
+ * adapted for Linux.
+ *
+ * malloc by Hannu Savolainen 1993 and Matthias Urlichs 1994
+ *
+ * Adapted for SH by Stuart Menefy, Aug 1999
+ *
+ * Modified to use standard LinuxSH BIOS by Greg Banks 7Jul2000
+ */
+
+/*
+ * gzip declarations
+ */
+
+#define NULL 0
+
+#define OF(args)  args
+#define STATIC static
+
+#define memzero(s, n)     memset ((s), 0, (n))
+
+void outstring (const char *);
+void exit (int);
+
+typedef unsigned char uch;
+typedef unsigned short ush;
+typedef unsigned long ulg;
+
+#define WSIZE 0x8000			/* Window size must be at least 32k, */
+								/* and a power of two */
+
+static uch window[WSIZE];		/* Sliding window buffer */
+
+static ulg inptr = 0;			/* index of next byte to be processed in inbuf */
+static ulg outcnt = 0;			/* bytes in output buffer */
+static ulg bytes_out = 0;
+
+/* Diagnostic functions */
+#define Assert(cond,msg)
+#define Trace(x)
+#define Tracev(x)
+#define Tracevv(x)
+#define Tracec(c,x)
+#define Tracecv(c,x)
+
+static void flush_window (void);
+static void *malloc (int size);
+static void free (void *where);
+static void error (char *m);
+static void gzip_mark (void **);
+static void gzip_release (void **);
+
+static const unsigned char *data_in;
+static unsigned char *data_out;
+static unsigned int data_in_len;
+
+#define get_byte() ((inptr < data_in_len)?data_in[inptr++]:(error("ran out of input data\n"),0))
+#define put_byte(c) *data_out++ = c
+
+#include "../../../../../../lib/inflate.c"
+
+#define HEAPSIZE (24*1024)
+static unsigned char heap[HEAPSIZE];
+static unsigned char *free_mem_ptr = heap;
+
+static void *malloc (int size)
+{
+	void *p;
+
+	if (size < 0)
+		error ("Malloc error\n");
+	if (free_mem_ptr == 0)
+		error ("Memory error\n");
+
+	free_mem_ptr = (unsigned char *) (((unsigned long) free_mem_ptr + 3) & ~3);	/* Align */
+
+	p = free_mem_ptr;
+	free_mem_ptr += size;
+
+	if (free_mem_ptr >= &heap[HEAPSIZE])
+		error ("\nOut of memory\n");
+
+	return p;
+}
+
+static void free (void *where)
+{								/* Don't care */
+}
+
+static void gzip_mark (void **ptr)
+{
+	*ptr = free_mem_ptr;
+}
+
+static void gzip_release (void **ptr)
+{
+	free_mem_ptr = *ptr;
+}
+
+/* ===========================================================================
+ * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+ * (Used for the decompressed data only.)
+ */
+static void flush_window (void)
+{
+	ulg c = crc;				/* temporary variable */
+	unsigned n;
+	uch *in, ch;
+
+	in = window;
+	for (n = 0; n < outcnt; n++) {
+		ch = *in++;
+		put_byte (ch);
+		c = crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);
+	}
+	crc = c;
+	bytes_out += outcnt;
+	outcnt = 0;
+	outstring (".");
+}
+
+static void error (char *x)
+{
+	outstring ("\r\n\r\n");
+	outstring (x);
+	outstring ("\r\n\r\n -- System halted\r\n");
+	exit (1);
+}
+
+void memgunzip (unsigned char *dst, const unsigned char *src, unsigned int sz)
+{
+	data_out = dst;
+	data_in = src;
+	data_in_len = sz;
+	makecrc ();
+	gunzip ();
+}
diff -Naur linux-2.6.9/CREDITS linux-2.6.9-uc0/CREDITS
--- linux-2.6.9/CREDITS	2004-10-28 11:10:59.000000000 +1000
+++ linux-2.6.9-uc0/CREDITS	2004-10-28 11:11:00.000000000 +1000
@@ -603,6 +603,17 @@
 S: Stanford, California 94305
 S: USA
 
+N: Hyok S. Choi
+W: http://opensrc.sec.samsung.com/
+E: hyok.choi@samsung.com
+E: hschoe@adam.kaist.ac.kr
+D: Author and Maintainer of uClinux/ARM port (armnommu)
+D: Author of Trace32 JTAG1 serial console emulation driver
+S: SW Platform Lab, DM R&D center
+S: Samsung Electronics Co.,Ltd.
+S: Suwon, Gyeonggi, 443-742
+S: Korea
+
 N: Randolph Chung
 E: tausq@debian.org
 D: Linux/PA-RISC hacker
diff -Naur linux-2.6.9/drivers/mtd/maps/mtdcpu16b.c linux-2.6.9-uc0/drivers/mtd/maps/mtdcpu16b.c
--- linux-2.6.9/drivers/mtd/maps/mtdcpu16b.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/drivers/mtd/maps/mtdcpu16b.c	2004-10-28 11:12:46.000000000 +1000
@@ -0,0 +1,189 @@
+/*
+ *
+ * Normal mappings of chips in physical memory
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/reboot.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nftl.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/root_dev.h>
+
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+
+#define FLASH_BASE   0xffe00000
+#define FLASH_SIZE   0x00200000
+#define BUS_WIDTH 2
+
+#define NB_OF(x)   (sizeof(x)/sizeof(x[0]))
+
+//extern char* ppcboot_getenv(char* v);
+
+
+static struct map_info cpu16b_flash_map = {
+	.name      = "SNEHA CPU16B",
+	.size      = FLASH_SIZE,
+	.bankwidth = BUS_WIDTH,
+	.phys      = FLASH_BASE
+};
+
+static struct mtd_info *flash_mtdinfo;
+
+static struct mtd_partition cpu16b_partitions[] = {
+	{.name = "boot (128K)",   .offset = 0x00000,  .size = 0x020000},
+	{.name = "kernel (896K)", .offset = 0x20000,  .size = 0x0E0000},
+	{.name = "jffs2 (1024K)", .offset = 0x100000, .size = 0x100000}
+};
+
+/* Find the MTD device with the given name */
+static struct mtd_info *get_mtd_named(char *name)
+{
+	int i;
+	struct mtd_info *mtd;
+
+	for (i=0;i<MAX_MTD_DEVICES;i++)
+	{
+		mtd=get_mtd_device(NULL,i);
+		if (mtd)
+		{
+			if (strcmp(mtd->name, name)==0)
+				return(mtd);
+			put_mtd_device(mtd);
+		}
+	}
+	return(NULL);
+}
+
+
+
+
+/****************************************************************************/
+
+static int
+cpu16b_point(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char **mtdbuf)
+{
+	struct map_info *map = (struct map_info *) mtd->priv;
+	*mtdbuf = (u_char *) (map->map_priv_1 + (int)from);
+	*retlen = len;
+	return(0);
+}
+
+/****************************************************************************/
+
+static int __init
+cpu16b_probe(void)
+{
+	struct mtd_info *mymtd;
+	struct map_info *map_ptr;
+
+	map_ptr = &cpu16b_flash_map;
+
+	//map_ptr->buswidth = buswidth;
+	//map_ptr->map_priv_2 = addr;
+	//map_ptr->phys = addr;
+        map_ptr->map_priv_2 = FLASH_BASE;
+	//map_ptr->size = size;
+
+	map_ptr->virt = (unsigned long)
+			ioremap_nocache(map_ptr->phys, map_ptr->size);
+
+	if (!map_ptr->virt) {
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+	simple_map_init(map_ptr);	
+	mymtd = do_map_probe("cfi_probe", map_ptr);
+	if (!mymtd)
+		mymtd = do_map_probe("jedec_probe", map_ptr);
+
+	if (!mymtd) {
+		iounmap((void *)map_ptr->map_priv_1);
+		return -ENXIO;
+	}
+		
+	mymtd->owner = THIS_MODULE;	mymtd->point = cpu16b_point;
+	mymtd->priv = map_ptr;
+
+
+	flash_mtdinfo = mymtd;
+	add_mtd_partitions(mymtd, cpu16b_partitions, NB_OF(cpu16b_partitions));
+
+	return 0;
+}
+
+/****************************************************************************/
+
+int __init cpu16b_mtd_init(void)
+{
+	int rc = -1;
+	struct mtd_info *mtd;
+
+    	if (rc != 0)
+        	rc = cpu16b_probe();
+
+
+	
+//	mtd = get_mtd_named("Romfs");
+//	if (mtd) {
+//		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+//		put_mtd_device(mtd);
+//	} else
+//		printk("%s: Failed to find & make root filesystem\n", __FUNCTION__);
+
+//	mtd = get_mtd_named("boot");
+//    	if (mtd) {
+//        	ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+//        	put_mtd_device(mtd);
+//    	}
+//	mtd = get_mtd_named("kernel");
+//    	if (mtd) {
+//        	ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+//        	put_mtd_device(mtd);
+//    	}
+//	mtd = get_mtd_named("jffs2");
+//    	if (mtd) {
+//        	ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+//        	put_mtd_device(mtd);
+//    	}
+
+	return(rc);
+}
+
+/****************************************************************************/
+
+static void __exit cpu16b_mtd_cleanup(void)
+{
+	if (flash_mtdinfo) {
+		del_mtd_partitions(flash_mtdinfo);
+		map_destroy(flash_mtdinfo);
+		flash_mtdinfo = NULL;
+	}
+	if (cpu16b_flash_map.map_priv_1) {
+		iounmap((void *)cpu16b_flash_map.map_priv_1);
+		cpu16b_flash_map.map_priv_1 = 0;
+	}
+}
+
+/****************************************************************************/
+
+module_init(cpu16b_mtd_init);
+module_exit(cpu16b_mtd_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jorge Borrego <jbs@sneha-tech.com>");
+MODULE_DESCRIPTION("SNEHA Sarasvati FLASH support for uClinux");
+
+/****************************************************************************/
diff -Naur linux-2.6.9/drivers/mtd/maps/uclinux.c linux-2.6.9-uc0/drivers/mtd/maps/uclinux.c
--- linux-2.6.9/drivers/mtd/maps/uclinux.c	2004-10-28 11:08:11.000000000 +1000
+++ linux-2.6.9-uc0/drivers/mtd/maps/uclinux.c	2004-10-28 11:12:46.000000000 +1000
@@ -5,7 +5,7 @@
  *
  *	(C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
  *
- * 	$Id: uclinux.c,v 1.7 2004/07/12 21:59:45 dwmw2 Exp $
+ * 	$Id: uclinux.c,v 1.12 2004/10/19 06:41:34 gerg Exp $
  */
 
 /****************************************************************************/
@@ -25,9 +25,6 @@
 
 /****************************************************************************/
 
-
-/****************************************************************************/
-
 struct map_info uclinux_ram_map = {
 	.name = "RAM",
 };
@@ -60,14 +57,20 @@
 	struct mtd_info *mtd;
 	struct map_info *mapp;
 	extern char _ebss;
+	unsigned long addr = (unsigned long) &_ebss;
+
+#ifdef CONFIG_PILOT
+	extern char _etext, _sdata, __init_end;
+	addr = (unsigned long) (&_etext + (&__init_end - &_sdata));
+#endif
 
 	mapp = &uclinux_ram_map;
-	mapp->phys = (unsigned long) &_ebss;
-	mapp->size = PAGE_ALIGN(*((unsigned long *)((&_ebss) + 8)));
+	mapp->phys = addr;
+	mapp->size = PAGE_ALIGN(*((unsigned long *)(addr + 8)));
 	mapp->bankwidth = 4;
 
 	printk("uclinux[mtd]: RAM probe address=0x%x size=0x%x\n",
-	       	(int) mapp->map_priv_2, (int) mapp->size);
+	       	(int) mapp->phys, (int) mapp->size);
 
 	mapp->virt = ioremap_nocache(mapp->phys, mapp->size);
 
@@ -95,7 +98,6 @@
 	printk("uclinux[mtd]: set %s to be root filesystem\n",
 	     	uclinux_romfs[0].name);
 	ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, 0);
-	put_mtd_device(mtd);
 
 	return(0);
 }
@@ -109,7 +111,7 @@
 		map_destroy(uclinux_ram_mtdinfo);
 		uclinux_ram_mtdinfo = NULL;
 	}
-	if (uclinux_ram_map.map_priv_1) {
+	if (uclinux_ram_map.virt) {
 		iounmap((void *) uclinux_ram_map.virt);
 		uclinux_ram_map.virt = 0;
 	}
diff -Naur linux-2.6.9/drivers/net/8390.c linux-2.6.9-uc0/drivers/net/8390.c
--- linux-2.6.9/drivers/net/8390.c	2004-10-28 11:07:39.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/8390.c	2004-10-28 11:12:47.000000000 +1000
@@ -41,6 +41,7 @@
 			  module by all drivers that require it.
   Alan Cox		: Spinlocking work, added 'BUG_83C690'
   Paul Gortmaker	: Separate out Tx timeout code from Tx path.
+  Greg Ungerer		: added some coldfire addressing code.
   Paul Gortmaker	: Remove old unused single Tx buffer code.
   Hayato Fujiwara	: Add m32r support.
 
@@ -77,6 +78,18 @@
 #define NS8390_CORE
 #include "8390.h"
 
+#ifdef CONFIG_COLDFIRE
+#ifdef CONFIG_NE2K_PCI
+#include <asm/mcfpci.h>
+#else
+#include <asm/mcfne.h>
+#endif /* CONFIG_NE2K_PCI */
+#endif /* CONFIG_COLDFIRE */
+
+#ifdef CONFIG_LEDMAN
+#include <linux/ledman.h>
+#endif
+
 #define BUG_83C690
 
 /* These are the operational function interfaces to board-specific
@@ -413,6 +426,10 @@
 		printk ("net_interrupt(): irq %d for unknown device.\n", irq);
 		return IRQ_NONE;
 	}
+
+#ifdef CONFIG_M5272
+	ne2000_irqack(irq);
+#endif     
     
 	e8390_base = dev->base_addr;
 	ei_local = (struct ei_device *) netdev_priv(dev);
@@ -454,6 +471,19 @@
 			interrupts = 0;
 			break;
 		}
+#ifdef CONFIG_LEDMAN
+		if (interrupts & (ENISR_TX|ENISR_TX_ERR)) {
+			ledman_cmd(LEDMAN_CMD_SET,
+				strcmp(dev->name, "eth0") == 0 ?
+				LEDMAN_LAN1_TX :
+				LEDMAN_LAN2_TX);
+		} else {
+			ledman_cmd(LEDMAN_CMD_SET,
+				strcmp(dev->name, "eth0") == 0 ?
+				LEDMAN_LAN1_RX :
+				LEDMAN_LAN2_RX);
+		}
+#endif
 		if (interrupts & ENISR_OVER) 
 			ei_rx_overrun(dev);
 		else if (interrupts & (ENISR_RX+ENISR_RX_ERR)) 
diff -Naur linux-2.6.9/drivers/net/8390.h linux-2.6.9-uc0/drivers/net/8390.h
--- linux-2.6.9/drivers/net/8390.h	2004-10-28 11:07:40.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/8390.h	2004-10-28 11:12:47.000000000 +1000
@@ -29,6 +29,12 @@
 #define ei_debug 1
 #endif
 
+#ifndef HAVE_AUTOIRQ
+/* From auto_irq.c */
+extern void autoirq_setup(int waittime);
+extern unsigned long autoirq_report(int waittime);
+#endif
+
 #ifdef CONFIG_NET_POLL_CONTROLLER
 extern void ei_poll(struct net_device *dev);
 #endif
diff -Naur linux-2.6.9/drivers/net/arm/eth_s3c4510b.c linux-2.6.9-uc0/drivers/net/arm/eth_s3c4510b.c
--- linux-2.6.9/drivers/net/arm/eth_s3c4510b.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/arm/eth_s3c4510b.c	2004-10-28 11:12:52.000000000 +1000
@@ -0,0 +1,513 @@
+/*
+ * linux/drivers/net/arm/eth_s3c4510b.c
+ *
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * Re-written from scratch for 2.6.x after studying the original 2.4.x
+ * driver by Mac Wang.
+ *
+ * Copyright (C) 2002 Mac Wang <mac@os.nctu.edu.tw>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/interrupt.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+
+#include <asm/irq.h>
+#include <asm/arch/hardware.h>
+#include "eth_s3c4510b.h"
+
+#define __DRIVER_NAME    "Samsung S3C4510B Ethernet Driver version 0.2 (2004-06-13) <curt@cucy.com>"
+
+#define _SDEBUG
+#ifdef _SDEBUG
+#  define _DPRINTK(format, args...)  \
+          printk (KERN_INFO "%s():%05d "format".\n" , __FUNCTION__ , __LINE__ , ## args);
+#else
+#  define _DPRINTK(format, args...)
+#endif
+
+#define _EPRINTK(format, args...)  \
+          printk (KERN_ERR "%s():%05d "format".\n" , __FUNCTION__ , __LINE__ , ## args);
+
+struct eth_priv {
+
+	/* Frame Descriptors */
+	TX_FrameDesc m_txFDbase[ETH_NTxFrames];  /* array of TX frame descriptors */
+	RX_FrameDesc m_rxFDbase[ETH_NRxFrames];  /* array of RX frame descriptors */
+	volatile TX_FrameDesc *m_curTX_FD;   /* current TX FD to queue */
+	volatile TX_FrameDesc *m_oldTX_FD;   /* oldest  TX FD queued, but not transmitted  */
+	volatile RX_FrameDesc *m_curRX_FD;   /* current RX FD to receive */
+	
+	struct net_device_stats stats;
+	spinlock_t lock;
+};
+
+/* This struct must be 16 byte aligned */
+struct skb_priv {
+	volatile RX_FrameDesc *m_RxFD;
+	struct net_device      *m_dev;
+	u32                  m_pad[2];
+};
+
+static s32 __skb_head_offset;
+
+/**
+ ** Avoid memcpy in RX handler by pre-allocating the socket buffers
+ **/
+
+// static void __skb_destruct( struct sk_buff *skb);
+static void __skb_prepare( struct net_device *dev, volatile RX_FrameDesc *pRxFD)
+{
+	struct sk_buff *skb;
+
+	skb = dev_alloc_skb( sizeof(ETHFrame) + 16 + 2);
+	if ( unlikely(!skb)) {
+		_EPRINTK(" unable to allocate skb...");
+	}
+
+//	_DPRINTK("allocate skb: 0x%08x", (u32)skb);
+
+	skb->dev = dev;
+
+	/* attach skb to FD */
+	pRxFD->skb = skb;
+	pRxFD->m_frameDataPtr.bf.dataPtr = (u32)skb->data | CACHE_DISABLE_MASK;
+	pRxFD->m_frameDataPtr.bf.owner   = 0x1; /* BDMA owner */
+
+}
+
+static s32 RxFDinit( struct net_device *dev) {
+
+	struct eth_priv *priv = (struct eth_priv *) dev->priv;
+	s32 i;
+	volatile RX_FrameDesc *rxFDbase;
+	struct sk_buff *skb;
+	
+	/* determine skb initial headroom for later use in the skb destructor */
+	skb = dev_alloc_skb(256);
+	__skb_head_offset = skb_headroom( skb);
+	dev_kfree_skb( skb);
+
+	/* store start of Rx descriptors and set current */
+	rxFDbase = priv->m_curRX_FD = 
+		(RX_FrameDesc *)((u32)priv->m_rxFDbase | CACHE_DISABLE_MASK);
+	for ( i = 0; i < ETH_NRxFrames; i++) {
+		__skb_prepare( dev, &rxFDbase[i]);
+		priv->m_rxFDbase[i].m_reserved                = 0x0;
+		priv->m_rxFDbase[i].m_status.ui               = 0x0;
+		priv->m_rxFDbase[i].m_nextFD                  = &rxFDbase[i+1];
+//		_DPRINTK("rxFDbase[%d]: 0x%08x", i, (u32)&rxFDbase[i]);
+	}
+	
+	/* make the list circular */
+	priv->m_rxFDbase[i-1].m_nextFD                  = &rxFDbase[0];
+	
+	outl( (unsigned int)rxFDbase, REG_BDMARXPTR);
+	
+	return 0;
+}
+
+static s32 TxFDinit( struct net_device *dev) {
+
+	struct eth_priv *priv = (struct eth_priv *) dev->priv;
+	s32 i;
+	volatile TX_FrameDesc   *txFDbase;
+	
+	/* store start of Tx descriptors and set current */
+	txFDbase = priv->m_curTX_FD  =  priv->m_oldTX_FD =
+		(TX_FrameDesc *) ((u32)priv->m_txFDbase | CACHE_DISABLE_MASK);
+	
+	for ( i = 0; i < ETH_NTxFrames; i++) {
+		priv->m_txFDbase[i].m_frameDataPtr.ui         = 0x0; /* CPU owner */
+		priv->m_txFDbase[i].m_opt.ui                  = 0x0;
+		priv->m_txFDbase[i].m_status.ui               = 0x0;
+		priv->m_txFDbase[i].m_nextFD                  = &txFDbase[i+1];
+//		_DPRINTK("txFDbase[%d]: 0x%08x", i, (u32)&txFDbase[i]);
+	}
+	
+	/* make the list circular */
+	priv->m_txFDbase[i-1].m_nextFD          = &txFDbase[0];
+	
+	outl( (unsigned int)txFDbase, REG_BDMATXPTR);
+
+	return 0;
+}
+
+static irqreturn_t __s3c4510b_rx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct sk_buff          *skb;
+	struct net_device       *dev = (struct net_device *) dev_id;
+	struct eth_priv        *priv = (struct eth_priv *) dev->priv;
+	volatile RX_FrameDesc *pRxFD;
+	volatile RX_FrameDesc *cRxFD;
+
+	spin_lock(&priv->lock);
+
+	LED_SET(4);
+
+	pRxFD = priv->m_curRX_FD;
+	cRxFD = (RX_FrameDesc *)inl(REG_BDMARXPTR);
+
+	/* clear received frame bit */
+	outl( ETH_S_BRxRDF, REG_BDMASTAT);
+
+	do {
+		if ( likely( pRxFD->m_status.bf.good)) {
+			skb = pRxFD->skb;
+
+			__skb_prepare( dev, pRxFD);
+
+			/* reserve two words used by protocol layers */
+			skb_reserve(skb, 2);
+			skb_put(skb, pRxFD->m_status.bf.len);
+			skb->protocol = eth_type_trans(skb, dev);
+			priv->stats.rx_packets++;
+			priv->stats.rx_bytes += pRxFD->m_status.bf.len;
+			netif_rx(skb);
+		}
+		else {
+			priv->stats.rx_errors++;
+			if( pRxFD->m_status.bf.overFlow)
+				priv->stats.rx_fifo_errors++;
+			if( pRxFD->m_status.bf.overMax)
+				priv->stats.rx_length_errors++;
+			if( pRxFD->m_status.bf.crcErr)
+				priv->stats.rx_crc_errors++;
+			if( pRxFD->m_status.bf.longErr)
+				priv->stats.rx_length_errors++;
+			if( pRxFD->m_status.bf.alignErr)
+				priv->stats.rx_frame_errors++;
+			/**
+			 ** No good category for these errors
+			if( pRxFD->m_status.bf.parityErr)
+			**/			
+
+		}
+
+		/* set owner back to CPU */
+		pRxFD->m_frameDataPtr.bf.owner = 1;
+		/* clear status */
+		pRxFD->m_status.ui = 0x0;
+		/* advance to next descriptor */
+		pRxFD = pRxFD->m_nextFD;
+
+	} while ( pRxFD != cRxFD);
+
+	priv->m_curRX_FD = pRxFD;
+
+	LED_CLR(4);
+
+	spin_unlock(&priv->lock);
+
+	return IRQ_HANDLED;
+
+}
+
+static irqreturn_t __s3c4510b_tx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct eth_priv *priv = (struct eth_priv *) dev->priv;
+	volatile TX_FrameDesc *pTxFD;
+	volatile TX_FrameDesc *cTxFD;
+
+	spin_lock(&priv->lock);
+
+	pTxFD = priv->m_oldTX_FD;
+	cTxFD = (TX_FrameDesc *)inl(REG_BDMATXPTR);
+
+	while ( pTxFD != cTxFD) {
+
+		if ( likely(pTxFD->m_status.bf.complete)) {
+			priv->stats.tx_packets++;
+		}
+		if( pTxFD->m_status.bf.exColl) {
+			_EPRINTK("TX collision detected");
+			priv->stats.tx_errors++;
+			priv->stats.collisions++;
+		}
+		if( pTxFD->m_status.bf.underRun) {
+			_EPRINTK("TX Underrun detected");
+			priv->stats.tx_errors++;
+			priv->stats.tx_fifo_errors++;
+		}
+		if( pTxFD->m_status.bf.noCarrier) {
+			_EPRINTK("TX no carrier detected");
+			priv->stats.tx_errors++;
+			priv->stats.tx_carrier_errors++;
+		}
+		if(  pTxFD->m_status.bf.lateColl) {
+			_EPRINTK("TX late collision detected");
+			priv->stats.tx_errors++;
+			priv->stats.tx_window_errors++;
+		}
+		if(  pTxFD->m_status.bf.parityErr) {
+			_EPRINTK("TX parity error detected");
+			priv->stats.tx_errors++;
+			priv->stats.tx_aborted_errors++;
+		}
+
+		dev_kfree_skb_irq( pTxFD->skb);
+		pTxFD = pTxFD->m_nextFD;
+	}
+
+	priv->m_oldTX_FD = pTxFD;
+
+	LED_CLR(3);
+
+	spin_unlock(&priv->lock);
+
+	return IRQ_HANDLED;
+
+}
+
+static int __s3c4510b_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int len;
+	u32 addr;
+	struct eth_priv *priv = (struct eth_priv *) dev->priv;
+
+//	_DPRINTK("entered with dev = 0x%08x", (unsigned int)dev);
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	dev->trans_start = jiffies;
+	
+	if ( unlikely( priv->m_curTX_FD->m_frameDataPtr.bf.owner)) {
+		_EPRINTK("Ethernet TX Frame.  CPU not owner");
+		return -EBUSY;
+	}
+
+	/* this needs to be word aligned for the BDMA -- round down */
+	addr = ((u32)skb->data & ~0x3) | CACHE_DISABLE_MASK;
+	priv->m_curTX_FD->m_frameDataPtr.bf.dataPtr = addr;
+
+	/* Set TX Frame flags */
+	priv->m_curTX_FD->m_opt.bf.widgetAlign  = (u32)skb->data - addr; /* compenstate for alignment */
+	priv->m_curTX_FD->m_opt.bf.frameDataDir = 1;
+	priv->m_curTX_FD->m_opt.bf.littleEndian = 1;
+	priv->m_curTX_FD->m_opt.bf.macTxIrqEnbl = 1;
+	priv->m_curTX_FD->m_opt.bf.no_crc       = 0;
+	priv->m_curTX_FD->m_opt.bf.no_padding   = 0;
+	
+	/* Set TX Frame length */
+	priv->m_curTX_FD->m_status.bf.len       = len;
+	
+	priv->m_curTX_FD->skb = skb;
+
+	/* Change ownership to BDMA */
+	priv->m_curTX_FD->m_frameDataPtr.bf.owner = 1;
+	
+	/* Change the Tx frame descriptor for next use */
+	priv->m_curTX_FD = priv->m_curTX_FD->m_nextFD;
+
+	LED_SET(3);
+
+	/* Enable MAC and BDMA Tx control register */
+	outl( ETH_BTxBRST   |	/* BDMA Tx burst size 16 words  */
+	      ETH_BTxMSL110 |	/* BDMA Tx wait to fill 6/8 of the BDMA */
+	      ETH_BTxSTSKO  |	/* BDMA Tx interrupt(Stop) on non-owner TX FD */
+	      ETH_BTxEn,	/* BDMA Tx Enable  */
+	      REG_BDMATXCON);
+
+	outl( ETH_EnComp     | 	/* interrupt when the MAC transmits or discards packet */
+	      ETH_TxEn	     |	/* MAC transmit enable */
+	      ETH_EnUnder    |	/*  interrupt on Underrun */
+	      ETH_EnNCarr    |	/*  interrupt on No Carrier  */
+	      ETH_EnExColl   |	/*  interrupt if 16 collision occur  */
+	      ETH_EnLateColl |	/*  interrupt if collision occurs after 512 bit times(64 bytes times) */
+	      ETH_EnTxPar,	/*  interrupt if the MAC transmit FIFO has a parity error  */
+	      REG_MACTXCON);
+
+	return 0;
+	
+}
+
+static struct irqaction __rx_irqaction = {
+	name:	  "eth_rx",
+	flags:	  SA_INTERRUPT,
+	handler:  __s3c4510b_rx_int,
+};
+
+static struct irqaction __tx_irqaction = {
+	name:	  "eth_tx",
+	flags:	  SA_INTERRUPT,
+	handler:  __s3c4510b_tx_int,
+};
+
+static int __s3c4510b_open(struct net_device *dev)
+{
+	unsigned long status;
+
+	/* Disable interrupts */
+	INT_DISABLE(INT_BDMARX);
+	INT_DISABLE(INT_MACTX);
+
+	/**
+	 ** install RX ISR
+	 **/
+	__rx_irqaction.dev_id = (void *)dev;
+	status = setup_irq( INT_BDMARX, &__rx_irqaction);
+	if ( unlikely(status)) {
+		printk( KERN_ERR "Unabled to hook irq %d for ethernet RX\n", INT_BDMARX);
+		return status;
+	}
+
+	/**
+	 ** install TX ISR
+	 **/
+	__tx_irqaction.dev_id = (void *)dev;
+	status = setup_irq( INT_MACTX, &__tx_irqaction);
+	if ( unlikely(status)) {
+		printk( KERN_ERR "Unabled to hook irq %d for ethernet TX\n", INT_MACTX);
+		return status;
+	}
+
+	/* setup DBMA and MAC */
+	outl( ETH_BRxRS, REG_BDMARXCON);	/* reset BDMA RX machine */
+	outl( ETH_BTxRS, REG_BDMATXCON);	/* reset BDMA TX machine */
+	outl( ETH_SwReset, REG_MACCON);		/* reset MAC machine */
+	outl( sizeof( ETHFrame), REG_BDMARXLSZ);
+	outl( ETH_FullDup, REG_MACCON);		/* enable full duplex */
+
+	/* init frame descriptors */
+	TxFDinit( dev);
+	RxFDinit( dev);
+
+	outl( (dev->dev_addr[0] << 24) |
+	      (dev->dev_addr[1] << 16) |
+	      (dev->dev_addr[2] <<  8) |
+	      (dev->dev_addr[3])       , REG_CAM_BASE);
+	outl( (dev->dev_addr[4] << 24) |
+	      (dev->dev_addr[5] << 16) , REG_CAM_BASE + 4);
+
+	outl(  0x0001, REG_CAMEN);
+	outl( ETH_CompEn | 	/* enable compare mode (check against the CAM) */
+	      ETH_BroadAcc, 	/* accept broadcast packetes */
+	      REG_CAMCON);
+
+	INT_ENABLE(INT_BDMARX);
+	INT_ENABLE(INT_MACTX);
+
+	/* enable RX machinery */
+	outl( ETH_BRxBRST   |	/* BDMA Rx Burst Size 16 words */
+	      ETH_BRxSTSKO  |	/* BDMA Rx interrupt(Stop) on non-owner RX FD */
+	      ETH_BRxMAINC  |	/* BDMA Rx Memory Address increment */
+	      ETH_BRxDIE    |	/* BDMA Rx Every Received Frame Interrupt Enable */
+	      ETH_BRxNLIE   |	/* BDMA Rx NULL List Interrupt Enable */
+	      ETH_BRxNOIE   |	/* BDMA Rx Not Owner Interrupt Enable */
+	      ETH_BRxLittle |	/* BDMA Rx Little endian */
+	      ETH_BRxWA10   |	/* BDMA Rx Word Alignment- two invalid bytes */
+	      ETH_BRxEn,	/* BDMA Rx Enable */
+	      REG_BDMARXCON);
+
+	outl( ETH_RxEn	    |	/* enable MAC RX */
+	      ETH_StripCRC  |	/* check and strip CRC */
+	      ETH_EnCRCErr  |	/* interrupt on CRC error */
+	      ETH_EnOver    |	/* interrupt on overflow error */
+	      ETH_EnLongErr |	/* interrupt on long frame error */
+	      ETH_EnRxPar,   	/* interrupt on MAC FIFO parity error */
+	      REG_MACRXCON);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int __s3c4510b_stop(struct net_device *dev)
+{
+	// Disable irqs
+	INT_DISABLE(INT_BDMARX);
+	INT_DISABLE(INT_MACTX);
+
+	outl( 0, REG_BDMATXCON);
+	outl( 0, REG_BDMARXCON);
+	outl( 0, REG_MACTXCON);
+	outl( 0, REG_MACRXCON);
+
+	free_irq(INT_BDMARX, dev);
+	free_irq(INT_MACTX, dev);
+
+	netif_stop_queue(dev);
+	
+	return 0;
+}
+
+struct net_device_stats *__s3c4510b_get_stats(struct net_device *dev)
+{
+	return &((struct eth_priv *)dev->priv)->stats;
+}
+
+/*
+ * The init function, invoked by register_netdev()
+ */
+static int __s3c4510b_init(struct net_device *dev)
+{
+	ether_setup(dev);
+
+	/* assign net_device methods */
+	dev->open = __s3c4510b_open;
+	dev->stop = __s3c4510b_stop;
+//	dev->ioctl = __s3c4510b_ioctl;
+	dev->get_stats = __s3c4510b_get_stats;
+//	dev->tx_timeout = __s3c4510b_tx_timeout;
+	dev->hard_start_xmit = __s3c4510b_start_xmit;
+
+	dev->irq = INT_BDMARX;
+	dev->tx_queue_len = ETH_NTxFrames;
+	dev->dma = 0;
+	dev->watchdog_timeo = HZ;
+
+	/* set MAC address */
+	dev->dev_addr[0] = 0x00;
+	dev->dev_addr[1] = 0x40;
+	dev->dev_addr[2] = 0x95;
+	dev->dev_addr[3] = 0x36;
+	dev->dev_addr[4] = 0x35;
+	dev->dev_addr[5] = 0x33;
+
+	SET_MODULE_OWNER(dev);
+
+	dev->priv = kmalloc(sizeof(struct eth_priv), GFP_KERNEL);
+	if( dev->priv == NULL)
+		return -ENOMEM;
+	memset(dev->priv, 0, sizeof(struct eth_priv));
+	spin_lock_init(&((struct eth_priv *) dev->priv)->lock);
+	return 0;
+}
+
+struct net_device __s3c4510b_netdevs = {
+	init: __s3c4510b_init,
+};
+
+static int __init __s3c4510b_init_module(void)
+{
+	int status = 0;
+
+	printk(KERN_INFO "%s\n", __DRIVER_NAME);
+
+	if( (status = register_netdev( &__s3c4510b_netdevs)))
+		printk("S3C4510 eth: Error %i registering interface %s\n", status, __s3c4510b_netdevs.name);
+
+	return status;
+}
+
+static void __exit __s3c4510b_cleanup(void)
+{
+	kfree( __s3c4510b_netdevs.priv);
+	unregister_netdev( &__s3c4510b_netdevs);
+	return;
+}
+
+module_init(__s3c4510b_init_module);
+module_exit(__s3c4510b_cleanup);
+
+MODULE_DESCRIPTION("Samsung S3C4510B ethernet driver");
+MODULE_AUTHOR("Curt Brune <curt@cucy.com>");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.9/drivers/net/arm/eth_s3c4510b.h linux-2.6.9-uc0/drivers/net/arm/eth_s3c4510b.h
--- linux-2.6.9/drivers/net/arm/eth_s3c4510b.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/arm/eth_s3c4510b.h	2004-10-28 11:12:52.000000000 +1000
@@ -0,0 +1,301 @@
+#ifndef __ETH_S3C4510B_H
+#define __ETH_S3C4510B_H
+
+/*
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Description:   Ethernet interface
+ * Runtime Env:   ARM7TDMI
+ * Change History:
+ *     03-02-04    Create (Curt Brune) curt@cucy.com
+ *
+ */
+
+#define __packed    __attribute__ ((packed))
+
+#define ETH_NTxFrames               (16)   /*  Max number of Tx Frames */
+#define ETH_NRxFrames               (16)   /*  Max number of Rx Frames */
+
+/*  Buffered DMA Receiver Control Register  */
+#define ETH_BRxBRST     0x0000F  /*  BDMA Rx Burst Size * BRxBRST  */
+                                 /*  = Burst Data Size 16 */
+#define ETH_BRxSTSKO    0x00020  /*  BDMA Rx Stop/Skip  Frame or Interrupt(=1)  */
+                                 /*  case of not OWNER the current Frame  */
+#define ETH_BRxMAINC    0x00040  /*  BDMA Rx Memory Address Inc/Dec  */
+#define ETH_BRxDIE      0x00080  /*  BDMA Rx Every Received Frame Interrupt Enable */
+#define ETH_BRxNLIE     0x00100  /*  BDMA Rx NULL List Interrupt Enable  */
+#define ETH_BRxNOIE     0x00200  /*  BDMA Rx Not Owner Interrupt Enable */
+#define ETH_BRxMSOIE    0x00400  /*  BDMA Rx Maximum Size over Interrupr Enable  */
+#define ETH_BRxLittle   0x00800  /*  BDMA Rx Big/Little Endian  */
+#define ETH_BRxBig      0x00000  /*  BDMA Rx Big/Little Endian */
+#define ETH_BRxWA01     0x01000  /*  BDMA Rx Word Alignment- one invalid byte     */
+#define ETH_BRxWA10     0x02000  /*  BDMA Rx Word Alignment- two invalid bytes    */
+#define ETH_BRxWA11     0x03000  /*  BDMA Rx Word Alignment- three invalid bytes  */
+#define ETH_BRxEn       0x04000  /*  BDMA Rx Enable */
+#define ETH_BRxRS       0x08000  /*  BDMA Rx Reset */
+#define ETH_RxEmpty     0x10000  /*  BDMA Rx Buffer empty interrupt  */
+#define ETH_BRxEarly    0x20000  /*  BDMA Rx Early notify Interrupt */
+
+/*  Buffered DMA Trasmit Control Register(BDMATXCON)  */
+#define ETH_BTxBRST     0x0000F  /*  BDMA Tx Burst Size = 16  */
+#define ETH_BTxSTSKO    0x00020  /*  BDMA Tx Stop/Skip Frame or Interrupt in case */
+                                 /*  of not Owner the current frame  */
+#define ETH_BTxCPIE     0x00080  /*  BDMA Tx Complete to send control  */
+                                 /*  packet Enable */
+#define ETH_BTxNOIE     0x00200  /*  BDMA Tx Buffer Not Owner */
+#define ETH_BTxEmpty    0x00400  /*  BDMA Tx Buffer Empty Interrupt  */
+
+/*  BDMA Tx buffer can be moved to the MAC Tx IO when the new frame comes in.  */
+#define ETH_BTxMSL000   0x00000  /*  No wait to fill the BDMA  */
+#define ETH_BTxMSL001   0x00800  /*  wait to fill 1/8 of the BDMA  */
+#define ETH_BTxMSL010   0x01000  /*  wait to fill 2/8 of the BDMA */
+#define ETH_BTxMSL011   0x01800  /*  wait to fill 3/8 of the BDMA */
+#define ETH_BTxMSL100   0x02000  /*  wait to fill 4/8 of the BDMA */
+#define ETH_BTxMSL101   0x02800  /*  wait to fill 5/8 of the BDMA */
+#define ETH_BTxMSL110   0x03000  /*  wait to fill 6/8 of the BDMA */
+#define ETH_BTxMSL111   0x03800  /*  wait to fill 7/8 of the BDMA */
+#define ETH_BTxEn       0x04000  /*  BDMA Tx Enable  */
+#define ETH_BTxRS       0x08000  /*  BDMA Tx Reset  */
+
+/*  BDMA Status Register  */
+#define ETH_S_BRxRDF    0x00001  /*  BDMA Rx Done Every Received Frame  */
+#define ETH_S_BRxNL     0x00002  /*  BDMA Rx NULL List  */
+#define ETH_S_BRxNO     0x00004  /*  BDMA Rx Not Owner  */
+#define ETH_S_BRxMSO    0x00008  /*  BDMA Rx Maximum Size Over  */
+#define ETH_S_BRxEmpty  0x00010  /*  BDMA Rx Buffer Empty  */
+#define ETH_S_BRxSEarly 0x00020  /*  Early Notify  */
+#define ETH_S_BRxFRF    0x00080  /*  One more frame data in BDMA receive buffer  */
+#define ETH_S_BTxCCP    0x10000  /*  BDMA Tx Complete to send Control Packet  */
+#define ETH_S_BTxNL     0x20000  /*  BDMA Tx Null List  */
+#define ETH_S_BTxNO     0x40000  /*  BDMA Tx Not Owner */
+#define ETH_S_BTxEmpty  0x100000 /*  BDMA Tx Buffer Empty  */
+
+/*  MAC Control Register  */
+#define ETH_HaltReg     0x0001   /*  stop transmission and reception  */
+                                 /*  after completion of any current packets  */
+#define ETH_HaltImm     0x0002   /*  Stop transmission and reception immediately  */
+#define ETH_SwReset     0x0004   /*  reset all Ethernet controller state machines */
+                                 /*  and FIFOs  */
+#define ETH_FullDup     0x0008   /*  allow transmission to begin while reception */
+                                 /*  is occurring  */
+#define ETH_MACLoop     0x0010   /*  MAC loopback */
+#define ETH_ConnM00     0x0000   /*  Automatic-default  */
+#define ETH_ConnM01     0x0020   /*  Force 10Mbits endec */
+#define ETH_ConnM10     0x0040   /*  Force MII (rate determined by MII clock  */
+#define ETH_MIIOFF      0x0040   /*  Force MII (rate determined by MII clock  */
+#define ETH_Loop10      0x0080   /*  Loop 10Mbps  */
+#define ETH_MissRoll    0x0400   /*  Missed error counter rolled over  */
+#define ETH_MDCOFF      0x1000   /*  MII Station Management Clock Off */
+#define ETH_EnMissRoll  0x2000   /*  Interrupt when missed error counter rolls  */
+                                 /*  over  */
+#define ETH_Link10      0x8000   /*  Link status 10Mbps  */
+
+/*  CAM control register(CAMCON)  */
+#define ETH_StationAcc  0x0001   /*  Accept any packet with a unicast station  */
+                                 /*  address  */
+#define ETH_GroupAcc    0x0002   /*  Accept any packet with multicast-group  */
+                                 /*  station address   */
+#define ETH_BroadAcc    0x0004   /*  Accept any packet with a broadcast station */
+                                 /*  address  */
+#define ETH_NegCAM      0x0008   /*  0: Accept packets CAM recognizes,  */
+                                 /*     reject others */
+                                 /*  1: reject packets CAM recognizes,  */
+                                 /*     accept others  */
+#define ETH_CompEn      0x0010   /*  Compare Enable mode */
+
+/*  Transmit Control Register(MACTXCON) */
+#define ETH_TxEn        0x0001   /*  transmit Enable  */
+#define ETH_TxHalt      0x0002   /*  Transmit Halt Request  */
+#define ETH_NoPad       0x0004   /*  suppress Padding  */
+#define ETH_NoCRC       0x0008   /*  Suppress CRC  */
+#define ETH_FBack       0x0010   /*  Fast Back-off */
+#define ETH_NoDef       0x0020   /*  Disable the defer counter */
+#define ETH_SdPause     0x0040   /*  Send Pause */
+#define ETH_MII10En     0x0080   /*  MII 10Mbps mode enable */
+#define ETH_EnUnder     0x0100   /*  Enable Underrun */
+#define ETH_EnDefer     0x0200   /*  Enable Deferral */
+#define ETH_EnNCarr     0x0400   /*  Enable No Carrier  */
+#define ETH_EnExColl    0x0800   /*  interrupt if 16 collision occur  */
+                                 /*  in the same packet  */
+#define ETH_EnLateColl  0x1000   /*  interrupt if collision occurs after  */
+                                 /*  512 bit times(64 bytes times)  */
+#define ETH_EnTxPar     0x2000   /*  interrupt if the MAC transmit FIFO  */
+                                 /*  has a parity error  */
+#define ETH_EnComp      0x4000   /*  interrupt when the MAC transmits or  */
+                                 /*  discards one packet  */
+
+/*  Transmit Status Register(MACTXSTAT) */
+#define ETH_ExColl      0x0010   /*  Excessive collision  */
+#define ETH_TxDeffered  0x0020   /*  set if 16 collisions occur for same packet */
+#define ETH_Paused      0x0040   /*  packet waited because of pause during  */
+                                 /*  transmission  */
+#define ETH_IntTx       0x0080   /*  set if transmission of packet causes an  */
+                                 /*  interrupt condiftion  */
+#define ETH_Under       0x0100   /*  MAC transmit FIFO becomes empty during  */
+                                 /*  transmission  */
+#define ETH_Defer       0x0200   /*  MAC defers for MAC deferral  */
+#define ETH_NCarr       0x0400   /*  No carrier sense detected during the  */
+                                 /*  transmission of a packet  */
+#define ETH_SQE         0x0800   /*  Signal Quality Error */
+#define ETH_LateColl    0x1000   /*  a collision occures after 512 bit times  */
+#define ETH_TxPar       0x2000   /*  MAC transmit FIFO has detected a parity error */
+#define ETH_Comp        0x4000   /*  MAC transmit or discards one packet  */
+#define ETH_TxHalted    0x8000   /*  Transmission was halted by clearing  */
+                                 /*  TxEn or Halt immedite  */
+
+/*  Receive Control Register (MACRXCON)  */
+#define ETH_RxEn        0x0001
+#define ETH_RxHalt      0x0002
+#define ETH_LongEn      0x0004
+#define ETH_ShortEn     0x0008
+#define ETH_StripCRC    0x0010
+#define ETH_PassCtl     0x0020
+#define ETH_IgnoreCRC   0x0040
+#define ETH_EnAlign     0x0100
+#define ETH_EnCRCErr    0x0200
+#define ETH_EnOver      0x0400
+#define ETH_EnLongErr   0x0800
+#define ETH_EnRxPar     0x2000
+#define ETH_EnGood      0x4000
+
+/*  Receive Status Register(MACRXSTAT) */
+#define ETH_MCtlRecd    0x0020
+#define ETH_MIntRx      0x0040
+#define ETH_MRx10Stat   0x0080
+#define ETH_MAllignErr  0x0100
+#define ETH_MCRCErr     0x0200
+#define ETH_MOverflow   0x0400
+#define ETH_MLongErr    0x0800
+#define ETH_MRxPar      0x2000
+#define ETH_MRxGood     0x4000
+#define ETH_MRxHalted   0x8000
+
+/* Tx Frame Descriptor Options */
+#define TX_OptNoPadding		(0x01)
+#define TX_OptNoCRCMode		(0x02)
+#define TX_OptMACTxIntEn	(0x04)
+#define TX_OptLittleEndian	(0x08)
+#define TX_OptFrameDataPtrInc	(0x10)
+#define TX_OptWA01		(0x20)
+#define TX_OptWA10		(0x40)
+#define TX_OptWA11		(0x60)
+
+/*  bit field for frame data pointer word */
+typedef struct __BF_FrameDataPtr {
+	u32 dataPtr:31;
+	u32   owner: 1;
+} BF_FrameDataPtr;
+
+typedef union _FrameDataPtr {
+	u32             ui;
+	BF_FrameDataPtr bf;
+} FrameDataPtr;
+
+typedef struct __BF_TX_Options {
+	u32    no_padding: 1;
+	u32        no_crc: 1;
+	u32  macTxIrqEnbl: 1;
+	u32  littleEndian: 1;
+	u32  frameDataDir: 1;
+	u32   widgetAlign: 2;
+	u32      reserved:25;
+} BF_TX_Options;
+
+typedef union _TX_Options {
+	u32    ui;
+	BF_TX_Options   bf;
+} TX_Options;
+
+typedef struct __BF_RX_Status {
+	u32           len:16;	/*  frame length */
+	u32     reserved1: 3;
+	u32       overMax: 1;
+	u32     reserved2: 1;
+	u32       ctrlRcv: 1;
+	u32         intRx: 1;
+	u32      rx10stat: 1;
+	u32      alignErr: 1;
+	u32        crcErr: 1;
+	u32      overFlow: 1;
+	u32       longErr: 1;
+	u32     reserved3: 1;
+	u32     parityErr: 1;
+	u32          good: 1;
+	u32        halted: 1;
+} BF_RX_Status;
+
+typedef union _RX_Status {
+	u32             ui;
+	BF_RX_Status    bf;
+} RX_Status;
+
+typedef struct __BF_TX_Status {
+	u32           len:16;	/*  frame length */
+	u32     txCollCnt: 4;
+	u32        exColl: 1;
+	u32       txDefer: 1;
+	u32        paused: 1;
+	u32         intTx: 1;
+	u32      underRun: 1;
+	u32         defer: 1;
+	u32     noCarrier: 1;
+	u32         SQErr: 1;
+	u32      lateColl: 1;
+	u32     parityErr: 1;
+	u32      complete: 1;
+	u32        halted: 1;
+} BF_TX_Status;
+
+typedef union _TX_Status {
+	u32    ui;
+	BF_TX_Status    bf;
+} TX_Status;
+
+/*  TX descriptor structure  */
+typedef struct __TX_FrameDescriptor {
+	volatile FrameDataPtr           m_frameDataPtr;
+	volatile TX_Options                      m_opt;
+	volatile TX_Status                    m_status;
+	volatile struct __TX_FrameDescriptor *m_nextFD;
+	/* We can add our own "per frame" data here */
+	struct sk_buff *skb;
+} TX_FrameDesc;
+
+/*  RX descriptor structure  */
+typedef struct __RX_FrameDescriptor {
+	volatile FrameDataPtr           m_frameDataPtr;
+	volatile u32                        m_reserved;
+	volatile RX_Status                    m_status;
+	volatile struct __RX_FrameDescriptor *m_nextFD;
+	/* We can add our own "per frame" data here */
+	struct sk_buff *skb;
+} RX_FrameDesc;
+
+/*  ETH Frame Structure */
+typedef struct __ETHFrame {
+	u8      m_dstAddr[ETH_ALEN] __packed;
+	u8      m_srcAddr[ETH_ALEN] __packed;
+	u16                 m_proto __packed;
+	u8  m_payload[ETH_DATA_LEN] __packed;
+} ETHFrame;
+
+#endif
diff -Naur linux-2.6.9/drivers/net/arm/Kconfig linux-2.6.9-uc0/drivers/net/arm/Kconfig
--- linux-2.6.9/drivers/net/arm/Kconfig	2004-10-28 11:07:34.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/arm/Kconfig	2004-10-28 11:12:52.000000000 +1000
@@ -44,3 +44,10 @@
 	  will generate a suitable hw address based on the board serial
 	  number (MTD support is required for this). Otherwise you will
 	  need to set a suitable hw address using ifconfig.
+
+config ETH_S3C4510B
+	bool "Samsung S3C4510B Ethernet Support"
+	depends on NET_ETHERNET && ARM && CPU_S3C4510B
+	help
+	  This is the driver for Samsung's S3C4510B SoC MAC IP core. Say
+	  Y here if you want to build support for this into the kernel.
diff -Naur linux-2.6.9/drivers/net/arm/Makefile linux-2.6.9-uc0/drivers/net/arm/Makefile
--- linux-2.6.9/drivers/net/arm/Makefile	2004-10-28 11:07:34.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/arm/Makefile	2004-10-28 11:12:52.000000000 +1000
@@ -8,3 +8,4 @@
 obj-$(CONFIG_ARM_ETHERH)	+= etherh.o
 obj-$(CONFIG_ARM_ETHER3)	+= ether3.o
 obj-$(CONFIG_ARM_ETHER1)	+= ether1.o
+obj-$(CONFIG_ETH_S3C4510B)	+= eth_s3c4510b.o
diff -Naur linux-2.6.9/drivers/net/cs89x0.c linux-2.6.9-uc0/drivers/net/cs89x0.c
--- linux-2.6.9/drivers/net/cs89x0.c	2004-10-28 11:07:41.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/cs89x0.c	2004-10-28 11:12:50.000000000 +1000
@@ -81,9 +81,23 @@
                     : Make `version[]' __initdata
                     : Uninlined the read/write reg/word functions.
 
+  Craig Peacock     : Apr 2001 - Craig.Peacock@senet.com.au
+  Tom Walsh         : May 2001 - tom@openhardware.net
+  David McCullough  : Jun 2001 - davidm@snapgear.com
+                    : Customized for use on uClinux & MC68EZ328 platforms.
+ 
+  Evan Stawnyczy    : Customized for use on MC68VZ328 platform.
+
+  Daniel Potts      : uClinux sleep support, ucDimm
+  Mark McChrystal   : uClinux sleep support, ucSimm
+
   Oskar Schirmer    : oskar@scara.com
                     : HiCO.SH4 (superh) support added (irq#1, cs89x0_media=)
 
+  Craig Hackney     : Added support for Triscend A7S.
+
+  Georges Menie     : Jan 2004 - reworked uClinux support
+
   Deepak Saxena     : dsaxena@plexity.net
                     : Intel IXDP2x01 (XScale ixp2x00 NPU) platform support
 
@@ -138,12 +152,18 @@
 
 #include <asm/system.h>
 #include <asm/bitops.h>
+#ifdef CONFIG_CS89x0_SWAPPED
+#include <asm/io_hw_swap.h>
+#else
 #include <asm/io.h>
+#endif
 #if ALLOW_DMA
 #include <asm/dma.h>
 #endif
+#include <linux/pm.h>
 
 #include "cs89x0.h"
+#include "cs89x0_defs.h"
 
 static char version[] __initdata =
 "cs89x0.c: v2.4.3-pre1 Russell Nelson <nelson@crynwr.com>, Andrew Morton <andrewm@uow.edu.au>\n";
@@ -161,7 +181,12 @@
 /* The cs8900 has 4 IRQ pins, software selectable. cs8900_irq_map maps 
    them to system IRQ numbers. This mapping is card specific and is set to
    the configuration of the Cirrus Eval board for this chip. */
-#ifdef CONFIG_ARCH_CLPS7500
+#if defined(_CS89X0_DEFS_EMBED_)
+/* ioaddr and irq for embedded boards are set in specific setup hook */
+static unsigned int netcard_portlist[] __initdata = { 0 };
+#elif defined(CONFIG_ALMA_ANS)
+static unsigned int netcard_portlist[] __initdata = { 0x10200300, 0 };
+#elif defined(CONFIG_ARCH_CLPS7500)
 static unsigned int netcard_portlist[] __initdata =
    { 0x80090303, 0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240, 0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0};
 static unsigned int cs8900_irq_map[] = {12,0,0,0};
@@ -235,15 +260,24 @@
 static int net_close(struct net_device *dev);
 static struct net_device_stats *net_get_stats(struct net_device *dev);
 static void reset_chip(struct net_device *dev);
-static int get_eeprom_data(struct net_device *dev, int off, int len, int *buffer);
-static int get_eeprom_cksum(int off, int len, int *buffer);
 static int set_mac_address(struct net_device *dev, void *addr);
 static void count_rx_errors(int status, struct net_local *lp);
+static void write_irq(struct net_device *dev, int chip_type, int irq);
+static int readreg(struct net_device *dev, int portno);
+static void writereg(struct net_device *dev, int portno, int value);
+static int readword(struct net_device *dev, int portno);
+static void writeword(struct net_device *dev, int portno, int value);
+#ifndef NO_EPROM
+static int get_eeprom_data(struct net_device *dev, int off, int len, int *buffer);
+static int get_eeprom_cksum(int off, int len, int *buffer);
+#endif
 #if ALLOW_DMA
 static void get_dma_channel(struct net_device *dev);
 static void release_dma_buff(struct net_local *lp);
 #endif
 
+#include "cs89x0_fct.h"
+
 /* Example routines you must write ;->. */
 #define tx_done(dev) 1
 
@@ -262,6 +296,10 @@
 __setup("cs89x0_dma=", dma_fn);
 #endif	/* !defined(MODULE) && (ALLOW_DMA != 0) */
 
+#ifdef CONFIG_PM
+static int cs89x0_in_use = 0;
+#endif
+
 #ifndef MODULE
 static int g_cs89x0_media__force;
 
@@ -297,6 +335,14 @@
 
 	sprintf(dev->name, "eth%d", unit);
 	netdev_boot_setup_check(dev);
+
+#ifdef HW_INIT_HOOK
+	if (cs89x_hw_init_hook(dev, unit) != 0) {
+		free_netdev(dev);
+		return ERR_PTR(-ENODEV);
+	}
+#endif
+
 	io = dev->base_addr;
 	irq = dev->irq;
 
@@ -358,6 +404,7 @@
 	outw(value, dev->base_addr + portno);
 }
 
+#ifndef NO_EPROM
 static int __init
 wait_eeprom_ready(struct net_device *dev)
 {
@@ -402,6 +449,7 @@
 		return 0;
 	return -1;
 }
+#endif
 
 /* This is the real probe routine.  Linux has a history of friendly device
    probes on the ISA bus.  A good device probes avoids doing writes, and
@@ -414,10 +462,11 @@
 {
 	struct net_local *lp = netdev_priv(dev);
 	static unsigned version_printed;
-	int i;
+	int i, retval;
 	unsigned rev_type = 0;
+#ifndef NO_EPROM
 	int eeprom_buff[CHKSUM_LEN];
-	int retval;
+#endif
 
 	SET_MODULE_OWNER(dev);
 	/* Initialize the device structure. */
@@ -436,6 +485,7 @@
 #endif
         }
 
+#ifndef NO_REQUEST_REGION
 	/* Grab the region so we can find another board if autoIRQ fails. */
 	/* WTF is going on here? */
 	if (!request_region(ioaddr & ~3, NETCARD_IO_EXTENT, DRV_NAME)) {
@@ -444,6 +494,10 @@
 		retval = -EBUSY;
 		goto out1;
 	}
+#else
+	if (0)
+		goto out1; /* to suppress warning */
+#endif /* NO_REQUEST_REGION */
 
 #ifdef CONFIG_SH_HICOSH4
 	/* truely reset the chip */
@@ -466,7 +520,8 @@
 				goto out2;
 			}
 	}
-printk("PP_addr=0x%x\n", inw(ioaddr + ADD_PORT));
+	if (net_debug)
+		printk("PP_addr=0x%x\n", inw(ioaddr + ADD_PORT));
 
 	ioaddr &= ~3;
 	outw(PP_ChipID, ioaddr + ADD_PORT);
@@ -488,11 +543,16 @@
 
 	/* Check the chip type and revision in order to set the correct send command
 	CS8920 revision C and CS8900 revision F can use the faster send. */
+#ifndef USE_TX_AFTER_ALL
 	lp->send_cmd = TX_AFTER_381;
 	if (lp->chip_type == CS8900 && lp->chip_revision >= 'F')
 		lp->send_cmd = TX_NOW;
 	if (lp->chip_type != CS8900 && lp->chip_revision >= 'C')
 		lp->send_cmd = TX_NOW;
+#else
+	/* some board have trouble keeping up */
+	lp->send_cmd = TX_AFTER_ALL;
+#endif
 
 	if (net_debug  &&  version_printed++ == 0)
 		printk(version);
@@ -506,6 +566,7 @@
 
 	reset_chip(dev);
    
+#ifndef NO_EPROM
         /* Here we read the current configuration of the chip. If there
 	   is no Extended EEPROM then the idea is to not disturb the chip
 	   configuration, it should have been correctly setup by automatic
@@ -636,6 +697,12 @@
 			printk(KERN_DEBUG "%s: new adapter_cnf: 0x%x\n",
 				dev->name, lp->adapter_cnf);
         }
+#else /* NO_EPROM */
+	printk("\n");
+	/* Fill this in, we don't have an EEPROM */
+	lp->adapter_cnf = A_CNF_10B_T | A_CNF_MEDIA_10B_T;
+	lp->auto_neg_cnf = EE_AUTO_NEG_ENABLE | IMM_BIT;
+#endif /* NO_EPROM */
 
         /* allow them to force multiple transceivers.  If they force multiple, autosense */
         {
@@ -667,6 +734,7 @@
 
 	lp->irq_map = 0xffff;
 
+#ifndef MONO_IRQ_MAP
 	/* If this is a CS8900 then no pnp soft */
 	if (lp->chip_type != CS8900 &&
 	    /* Check if the ISA IRQ has been set  */
@@ -701,6 +769,7 @@
 		if (!dev->irq)
 			dev->irq = i;
 	}
+#endif
 
 	printk(" IRQ %d", dev->irq);
 
@@ -734,6 +803,11 @@
 	printk("\n");
 	if (net_debug)
 		printk("cs89x0_probe1() successful\n");
+#if defined (CONFIG_PM)
+	cs89x0_pm = pm_register(PM_SYS_DEV, PM_SYS_COM, cs89x0_pm_callback);
+	if (cs89x0_pm)
+		cs89x0_pm->data = dev;
+#endif
 	return 0;
 out2:
 	release_region(ioaddr & ~3, NETCARD_IO_EXTENT);
@@ -908,6 +982,9 @@
 
 	writereg(dev, PP_SelfCTL, readreg(dev, PP_SelfCTL) | POWER_ON_RESET);
 
+#ifdef CONFIG_ARCH_TA7S
+	a7hal_lancs8900_reset( 0 );
+#endif
 	/* wait 30 ms */
 	current->state = TASK_INTERRUPTIBLE;
 	schedule_timeout(30*HZ/1000);
@@ -924,6 +1001,12 @@
 		outb((dev->mem_start >> 8) & 0xff,   ioaddr + DATA_PORT + 1);
 	}
 #endif	/* IXDP2x01 */
+#ifdef CONFIG_EXCALIBUR
+/* This is a hack that seems to be necessary for the 2.0 nios core
+ * that must be done after power up resets.
+ */
+	*(char *)dev->base_addr = 0;
+#endif
 
 	/* Wait until the chip is reset */
 	reset_start_time = jiffies;
@@ -1111,6 +1194,7 @@
 static void
 write_irq(struct net_device *dev, int chip_type, int irq)
 {
+#ifndef MONO_IRQ_MAP
 	int i;
 
 	if (chip_type == CS8900) {
@@ -1125,6 +1209,9 @@
 	} else {
 		writereg(dev, PP_CS8920_ISAINT, irq);
 	}
+#else
+	writereg(dev, PP_CS8900_ISAINT, 0);
+#endif
 }
 
 /* Open/initialize the board.  This is called (in the current kernel)
@@ -1145,6 +1232,7 @@
 	int i;
 	int ret;
 
+#ifndef MONO_IRQ_MAP
 #ifndef CONFIG_SH_HICOSH4 /* uses irq#1, so this won't work */
 	if (dev->irq < 2) {
 		/* Allow interrupts to be generated by the chip */
@@ -1199,6 +1287,10 @@
 		}
 	}
 
+#else /* MONO_IRQ_MAP */
+	cs89x_set_irq(dev);
+#endif /* MONO_IRQ_MAP */
+
 #if ALLOW_DMA
 	if (lp->use_dma) {
 		if (lp->isa_config & ANY_ISA_DMA) {
@@ -1366,6 +1458,9 @@
         netif_start_queue(dev);
 	if (net_debug > 1)
 		printk("cs89x0: net_open() succeeded\n");
+#ifdef CONFIG_PM
+	cs89x0_in_use = 1;
+#endif
 	return 0;
 bad_out:
 	return ret;
@@ -1417,6 +1512,13 @@
 	outsw(dev->base_addr + TX_FRAME_PORT,skb->data,(skb->len+1) >>1);
 	spin_unlock_irq(&lp->lock);
 	dev->trans_start = jiffies;
+	/*
+	 * This is the estimate of how many bytes have been sent,
+	 * we don't realy know if the packet was sent 'till we get
+	 * the TX interrupt with a status of OK. However the interrupt
+	 * routine does not know the length of the packet that was sent.
+	 */
+	lp->stats.tx_bytes += skb->len;
 	dev_kfree_skb (skb);
 
 	/*
@@ -1488,8 +1590,13 @@
 			if (status & TX_UNDERRUN) {
 				if (net_debug > 0) printk("%s: transmit underrun\n", dev->name);
                                 lp->send_underrun++;
+#ifndef USE_TX_AFTER_ALL
                                 if (lp->send_underrun == 3) lp->send_cmd = TX_AFTER_381;
                                 else if (lp->send_underrun == 6) lp->send_cmd = TX_AFTER_ALL;
+#else
+								/* some boards have trouble keeping up */
+                                lp->send_cmd = TX_AFTER_ALL;
+#endif
 				/* transmit cycle is done, although
 				   frame wasn't transmitted - this
 				   avoids having to wait for the upper
@@ -1618,6 +1725,10 @@
 	}
 #endif
 
+#if defined(CONFIG_PM)
+	cs89x0_in_use = 0;
+#endif
+
 	/* Update the statistics here. */
 	return 0;
 }
diff -Naur linux-2.6.9/drivers/net/cs89x0_defs.h linux-2.6.9-uc0/drivers/net/cs89x0_defs.h
--- linux-2.6.9/drivers/net/cs89x0_defs.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/cs89x0_defs.h	2004-10-28 11:12:50.000000000 +1000
@@ -0,0 +1,76 @@
+
+/* linux/drivers/net/cs89x0_defs.h: cs89x0 specific settings for embedded boards
+ *
+ * Copyright (C) 2004  Georges Menie
+ *
+ */
+
+#ifndef _CS89X0_DEFS_H_
+#define _CS89X0_DEFS_H_
+
+#ifdef CONFIG_M68328
+#include <asm/irq.h>
+#include <asm/MC68328.h>
+#define _CS89X0_DEFS_EMBED_
+#endif
+
+#ifdef CONFIG_M68EZ328
+#include <asm/irq.h>
+#include <asm/MC68EZ328.h>
+#define _CS89X0_DEFS_EMBED_
+#endif
+
+#ifdef CONFIG_M68VZ328
+#include <asm/irq.h>
+#include <asm/MC68VZ328.h>
+#define _CS89X0_DEFS_EMBED_
+#endif
+
+#ifdef CONFIG_EXCALIBUR
+#include <asm/nios.h>
+#define _CS89X0_DEFS_EMBED_
+#endif
+
+#ifdef CONFIG_ARCH_TA7S
+#include <asm/arch/arch.h>
+#include <asm/arch/irqs.h>
+#define _CS89X0_DEFS_EMBED_
+#endif
+
+#ifdef CONFIG_HYPERSTONE 
+#include <asm/irq.h>
+#include <asm/io.h>
+#define _CS89X0_DEFS_EMBED_
+#endif
+
+#ifdef _CS89X0_DEFS_EMBED_
+
+/* suppress debugging output */
+#undef DEBUGGING
+#define DEBUGGING	0
+
+/* suppress DMA support */
+#undef ALLOW_DMA
+#define ALLOW_DMA	0
+
+/* suppress EEPROM support */
+#define NO_EPROM
+
+/* suppress request_region() call */
+#define NO_REQUEST_REGION
+
+/* use static IRQ mapping */
+#define MONO_IRQ_MAP
+
+/* don't start sending packet before the whole data
+ * has been written to the cs89x0 registers
+ */
+#define USE_TX_AFTER_ALL
+
+/* place a hook into the cs89x0_probe1 function
+ * to call cs89x_hw_init_hook() for hardware initialisation
+ */
+#define HW_INIT_HOOK
+
+#endif /* _CS89X0_DEFS_EMBED_ */
+#endif /* _CS89X0_DEFS_H_ */
diff -Naur linux-2.6.9/drivers/net/cs89x0_fct.h linux-2.6.9-uc0/drivers/net/cs89x0_fct.h
--- linux-2.6.9/drivers/net/cs89x0_fct.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/cs89x0_fct.h	2004-10-28 11:12:50.000000000 +1000
@@ -0,0 +1,30 @@
+
+/* linux/drivers/net/cs89x0_fct.h: arch/platform specific code for CS89x0
+ *
+ * Copyright (C) 2004  Georges Menie
+ *
+ */
+
+#ifdef CONFIG_M68328
+#include <asm/cs89x0_fct.h>
+#endif
+
+#ifdef CONFIG_M68EZ328
+#include <asm/cs89x0_fct.h>
+#endif
+
+#ifdef CONFIG_M68VZ328
+#include <asm/cs89x0_fct.h>
+#endif
+
+#ifdef CONFIG_EXCALIBUR
+#include <asm/cs89x0_fct.h>
+#endif
+
+#ifdef CONFIG_ARCH_TA7S
+#include <asm/cs89x0_fct.h>
+#endif
+
+#ifdef CONFIG_HYPERSTONE 
+#include <asm/cs89x0_fct.h>
+#endif
diff -Naur linux-2.6.9/drivers/net/fec.c linux-2.6.9-uc0/drivers/net/fec.c
--- linux-2.6.9/drivers/net/fec.c	2004-10-28 11:07:39.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/fec.c	2004-10-28 11:12:51.000000000 +1000
@@ -18,8 +18,8 @@
  * Much better multiple PHY support by Magnus Damm.
  * Copyright (c) 2000 Ericsson Radio Systems AB.
  *
- * Support for FEC controller of ColdFire/5272.
- * Copyrught (c) 2001-2002 Greg Ungerer (gerg@snapgear.com)
+ * Support for FEC controller of ColdFire/5270/5271/5272/5274/5275/5280/5282.
+ * Copyrught (c) 2001-2004 Greg Ungerer (gerg@snapgear.com)
  */
 
 #include <linux/config.h>
@@ -46,7 +46,7 @@
 #include <asm/io.h>
 #include <asm/pgtable.h>
 
-#ifdef CONFIG_M5272
+#if defined(CONFIG_M527x) || defined(CONFIG_M5272) || defined(CONFIG_M528x)
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
 #include "fec.h"
@@ -56,19 +56,31 @@
 #include "commproc.h"
 #endif
 
-static int opened = 0;
-static int found = 0;
+#if defined(CONFIG_FEC2)
+#define	FEC_MAX_PORTS	2
+#else
+#define	FEC_MAX_PORTS	1
+#endif
 
 /*
  * Define the fixed address of the FEC hardware.
  */
-#ifdef CONFIG_M5272
-static volatile fec_t   *fec_hwp = (volatile fec_t *) (MCF_MBAR + 0x840);
-static ushort		my_enet_addr[] = { 0x00d0, 0xcf00, 0x0072 };
+static unsigned int fec_hw[] = {
+#if defined(CONFIG_M5272)
+	(MCF_MBAR + 0x840),
+#elif defined(CONFIG_M527x)
+	(MCF_MBAR + 0x1000),
+	(MCF_MBAR + 0x1800),
+#elif defined(CONFIG_M528x)
+	(MCF_MBAR + 0x1000),
 #else
-static volatile fec_t	*fec_hwp = &(((immap_t *)IMAP_ADDR)->im_cpm.cp_fec)
-static ushort		my_enet_addr[3];
-#endif /* CONFIG_M5272 */
+	&(((immap_t *)IMAP_ADDR)->im_cpm.cp_fec),
+#endif
+};
+
+static unsigned char	fec_mac_default[] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
 
 /*
  * Some hardware gets it MAC address out of local flash memory.
@@ -76,10 +88,12 @@
  */
 #if defined(CONFIG_NETtel)
 #define	FEC_FLASHMAC	0xf0006006
-#elif defined(CONFIG_GILBARCONAP)
+#elif defined(CONFIG_GILBARCONAP) || defined(CONFIG_SCALES)
 #define	FEC_FLASHMAC	0xf0006000
 #elif defined (CONFIG_MTD_KeyTechnology)
 #define	FEC_FLASHMAC	0xffe04000
+#elif defined(CONFIG_CANCam)
+#define	FEC_FLASHMAC	0xf0020000
 #else
 #define	FEC_FLASHMAC	0
 #endif
@@ -110,21 +124,14 @@
  * We don't need to allocate pages for the transmitter.  We just use
  * the skbuffer directly.
  */
-#if 1
-#define FEC_ENET_RX_PAGES	4
-#define FEC_ENET_RX_FRSIZE	2048
-#define FEC_ENET_RX_FRPPG	(PAGE_SIZE / FEC_ENET_RX_FRSIZE)
-#define RX_RING_SIZE		(FEC_ENET_RX_FRPPG * FEC_ENET_RX_PAGES)
-#define TX_RING_SIZE		8	/* Must be power of two */
-#define TX_RING_MOD_MASK	7	/*   for this to work */
-#else
-#define FEC_ENET_RX_PAGES	16
+#define FEC_ENET_RX_PAGES	8
 #define FEC_ENET_RX_FRSIZE	2048
 #define FEC_ENET_RX_FRPPG	(PAGE_SIZE / FEC_ENET_RX_FRSIZE)
 #define RX_RING_SIZE		(FEC_ENET_RX_FRPPG * FEC_ENET_RX_PAGES)
+#define FEC_ENET_TX_FRSIZE	2048
+#define FEC_ENET_TX_FRPPG	(PAGE_SIZE / FEC_ENET_TX_FRSIZE)
 #define TX_RING_SIZE		16	/* Must be power of two */
 #define TX_RING_MOD_MASK	15	/*   for this to work */
-#endif
 
 /* Interrupt events/masks.
 */
@@ -145,6 +152,18 @@
 #define PKT_MINBUF_SIZE		64
 #define PKT_MAXBLR_SIZE		1520
 
+
+/*
+ * The 5270/5271/5280/5282 RX control register also contains maximum frame
+ * size bits. Other FEC hardware does not, so we need to take that into
+ * account when setting it.
+ */
+#if defined(CONFIG_M527x) || defined(CONFIG_M528x)
+#define	OPT_FRAME_SIZE	(PKT_MAXBUF_SIZE << 16)
+#else
+#define	OPT_FRAME_SIZE	0
+#endif
+
 /* The FEC buffer descriptors track the ring buffers.  The rx_bd_base and
  * tx_bd_base always point to the base of the buffer descriptors.  The
  * cur_rx and cur_tx point to the currently available buffer.
@@ -154,7 +173,11 @@
  * the buffer descriptor determines the actual condition.
  */
 struct fec_enet_private {
+	/* Hardware registers of the FEC device */
+	volatile fec_t	*hwp;
+
 	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
+	unsigned char *tx_bounce[TX_RING_SIZE];
 	struct	sk_buff* tx_skbuff[TX_RING_SIZE];
 	ushort	skb_cur;
 	ushort	skb_dirty;
@@ -177,12 +200,16 @@
 	struct work_struct phy_task;
 
 	uint	sequence_done;
+	uint	mii_phy_task_queued;
 
 	uint	phy_addr;
 
+	int	index;
+	int	opened;
 	int	link;
 	int	old_link;
 	int	full_duplex;
+	unsigned char mac_addr[ETH_ALEN];
 };
 
 static int fec_enet_open(struct net_device *dev);
@@ -299,6 +326,18 @@
 	bdp->cbd_bufaddr = __pa(skb->data);
 	bdp->cbd_datlen = skb->len;
 
+	/*
+	 *	On some FEC implementations data must be aligned on
+	 *	4-byte boundaries. Use bounce buffers to copy data
+	 *	and get it aligned. Ugh.
+	 */
+	if (bdp->cbd_bufaddr & 0x3) {
+		unsigned int index;
+		index = bdp - fep->tx_bd_base;
+		memcpy(fep->tx_bounce[index], (void *) bdp->cbd_bufaddr, bdp->cbd_datlen);
+		bdp->cbd_bufaddr = __pa(fep->tx_bounce[index]);
+	}
+
 	/* Save skb pointer.
 	*/
 	fep->tx_skbuff[fep->skb_cur] = skb;
@@ -407,10 +446,6 @@
 	*/
 	while ((int_events = fecp->fec_ievent) != 0) {
 		fecp->fec_ievent = int_events;
-		if ((int_events & (FEC_ENET_HBERR | FEC_ENET_BABR |
-				   FEC_ENET_BABT | FEC_ENET_EBERR)) != 0) {
-			printk("FEC ERROR %x\n", int_events);
-		}
 
 		/* Handle receive event in its own function.
 		 */
@@ -542,7 +577,7 @@
 		printk("FEC ENET: rcv is not +last\n");
 #endif
 
-	if (!opened)
+	if (!fep->opened)
 		goto rx_processing_done;
 
 	/* Check for errors. */
@@ -646,7 +681,7 @@
 	uint		mii_reg;
 
 	fep = netdev_priv(dev);
-	ep = fec_hwp;
+	ep = fep->hwp;
 	mii_reg = ep->fec_mii_data;
 	
 	if ((mip = mii_head) == NULL) {
@@ -694,7 +729,7 @@
 		}
 		else {
 			mii_head = mii_tail = mip;
-			fec_hwp->fec_mii_data = regval;
+			fep->hwp->fec_mii_data = regval;
 		}
 	}
 	else {
@@ -1029,30 +1064,69 @@
 };
 
 /* ------------------------------------------------------------------------- */
+/* Kendin KS8721BL phy                                                       */
+
+/* register definitions for the 8721 */
+
+#define MII_KS8721BL_RXERCR	21
+#define MII_KS8721BL_ICSR	22
+#define	MII_KS8721BL_PHYCR	31
+
+static phy_info_t phy_info_ks8721bl = {
+	0x00022161, 
+	"KS8721BL",
+	
+	(const phy_cmd_t []) {  /* config */  
+		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
+		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {  /* startup */
+		{ mk_mii_write(MII_KS8721BL_ICSR, 0xff00), NULL },
+		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
+		{ mk_mii_read(MII_REG_SR), mii_parse_sr }, 
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* ack_int */
+		/* find out the current status */
+		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
+		/* we only need to read ISR to acknowledge */
+		{ mk_mii_read(MII_KS8721BL_ICSR), NULL },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {  /* shutdown */
+		{ mk_mii_write(MII_KS8721BL_ICSR, 0x0000), NULL },
+		{ mk_mii_end, }
+	},
+};
+
+/* ------------------------------------------------------------------------- */
 
 static phy_info_t *phy_info[] = {
 	&phy_info_lxt970,
 	&phy_info_lxt971,
 	&phy_info_qs6612,
 	&phy_info_am79c874,
+	&phy_info_ks8721bl,
 	NULL
 };
 
 /* ------------------------------------------------------------------------- */
 
-static void
 #ifdef CONFIG_RPXCLASSIC
+static void
 mii_link_interrupt(void *dev_id);
 #else
+static irqreturn_t
 mii_link_interrupt(int irq, void * dev_id, struct pt_regs * regs);
 #endif
 
-#ifdef CONFIG_M5272
+#if defined(CONFIG_M5272)
 
 /*
  *	Code specific to Coldfire 5272 setup.
  */
-static void __inline__ fec_request_intrs(struct net_device *dev, volatile fec_t *fecp)
+static void __inline__ fec_request_intrs(struct net_device *dev)
 {
 	volatile unsigned long *icrp;
 
@@ -1076,26 +1150,29 @@
 static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
 {
 	volatile fec_t *fecp;
-	fecp = fec_hwp;
 
-	fecp->fec_r_cntrl = 0x04;
+	fecp = fep->hwp;
+	fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x04;
 	fecp->fec_x_cntrl = 0x00;
 
-	/* Set MII speed to 2.5 MHz
-	*/
-	fecp->fec_mii_speed = fep->phy_speed = 0x0e;
+	/*
+	 * Set MII speed to 2.5 MHz
+	 * See 5272 manual section 11.5.8: MSCR
+	 */
+	fep->phy_speed = ((((MCF_CLK / 4) / (2500000 / 10)) + 5) / 10) * 2;
+	fecp->fec_mii_speed = fep->phy_speed;
 
 	fec_restart(dev, 0);
 }
 
-static void __inline__ fec_get_mac(struct net_device *dev, struct fec_enet_private *fep)
+static void __inline__ fec_get_mac(struct net_device *dev)
 {
+	struct fec_enet_private *fep = netdev_priv(dev);
 	volatile fec_t *fecp;
-	unsigned char *eap, *iap, tmpaddr[6];
+	unsigned char *iap, tmpaddr[6];
 	int i;
 
-	fecp = fec_hwp;
-	eap = (unsigned char *) my_enet_addr;
+	fecp = fep->hwp;
 
 	if (fec_flashmac) {
 		/*
@@ -1105,18 +1182,24 @@
 		iap = fec_flashmac;
 		if ((iap[0] == 0) && (iap[1] == 0) && (iap[2] == 0) &&
 		    (iap[3] == 0) && (iap[4] == 0) && (iap[5] == 0))
-			iap = eap;
+			iap = fec_mac_default;
 		if ((iap[0] == 0xff) && (iap[1] == 0xff) && (iap[2] == 0xff) &&
 		    (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
-			iap = eap;
+			iap = fec_mac_default;
 	} else {
 		*((unsigned long *) &tmpaddr[0]) = fecp->fec_addr_low;
 		*((unsigned short *) &tmpaddr[4]) = (fecp->fec_addr_high >> 16);
 		iap = &tmpaddr[0];
 	}
 
-	for (i=0; i<6; i++)
-		dev->dev_addr[i] = *eap++ = *iap++;
+	for (i=0; i<ETH_ALEN; i++)
+		dev->dev_addr[i] = fep->mac_addr[i] = *iap++;
+
+	/* Adjust MAC if using default MAC address */
+	if (iap == fec_mac_default) {
+		dev->dev_addr[ETH_ALEN-1] = fep->mac_addr[ETH_ALEN-1] =
+			iap[ETH_ALEN-1] + fep->index;
+	}
 }
 
 static void __inline__ fec_enable_phy_intr(void)
@@ -1151,12 +1234,167 @@
 
 /* ------------------------------------------------------------------------- */
 
+#elif defined(CONFIG_M527x) || defined(CONFIG_M528x)
+
+/*
+ *	Code specific to Coldfire 5270/5271/5274/5275 and 5280/5282 setups.
+ */
+static void __inline__ fec_request_intrs(struct net_device *dev)
+{
+	struct fec_enet_private *fep;
+	int b;
+
+	fep = netdev_priv(dev);
+	b = (fep->index) ? 128 : 64;
+
+	/* Setup interrupt handlers. */
+	if (request_irq(b+23, fec_enet_interrupt, 0, "fec(TXF)", dev) != 0)
+		printk("FEC: Could not allocate FEC(TXF) IRQ(%d+23)!\n", b);
+	if (request_irq(b+24, fec_enet_interrupt, 0, "fec(TXB)", dev) != 0)
+		printk("FEC: Could not allocate FEC(TXB) IRQ(%d+24)!\n", b);
+	if (request_irq(b+25, fec_enet_interrupt, 0, "fec(TXFIFO)", dev) != 0)
+		printk("FEC: Could not allocate FEC(TXFIFO) IRQ(%d+25)!\n", b);
+	if (request_irq(b+26, fec_enet_interrupt, 0, "fec(TXCR)", dev) != 0)
+		printk("FEC: Could not allocate FEC(TXCR) IRQ(%d+26)!\n", b);
+
+	if (request_irq(b+27, fec_enet_interrupt, 0, "fec(RXF)", dev) != 0)
+		printk("FEC: Could not allocate FEC(RXF) IRQ(%d+27)!\n", b);
+	if (request_irq(b+28, fec_enet_interrupt, 0, "fec(RXB)", dev) != 0)
+		printk("FEC: Could not allocate FEC(RXB) IRQ(%d+28)!\n", b);
+
+	if (request_irq(b+29, fec_enet_interrupt, 0, "fec(MII)", dev) != 0)
+		printk("FEC: Could not allocate FEC(MII) IRQ(%d+29)!\n", b);
+	if (request_irq(b+30, fec_enet_interrupt, 0, "fec(LC)", dev) != 0)
+		printk("FEC: Could not allocate FEC(LC) IRQ(%d+30)!\n", b);
+	if (request_irq(b+31, fec_enet_interrupt, 0, "fec(HBERR)", dev) != 0)
+		printk("FEC: Could not allocate FEC(HBERR) IRQ(%d+31)!\n", b);
+	if (request_irq(b+32, fec_enet_interrupt, 0, "fec(GRA)", dev) != 0)
+		printk("FEC: Could not allocate FEC(GRA) IRQ(%d+32)!\n", b);
+	if (request_irq(b+33, fec_enet_interrupt, 0, "fec(EBERR)", dev) != 0)
+		printk("FEC: Could not allocate FEC(EBERR) IRQ(%d+33)!\n", b);
+	if (request_irq(b+34, fec_enet_interrupt, 0, "fec(BABT)", dev) != 0)
+		printk("FEC: Could not allocate FEC(BABT) IRQ(%d+34)!\n", b);
+	if (request_irq(b+35, fec_enet_interrupt, 0, "fec(BABR)", dev) != 0)
+		printk("FEC: Could not allocate FEC(BABR) IRQ(%d+35)!\n", b);
+
+	/* Unmask interrupts at ColdFire 5280/5282 interrupt controller */
+	{
+		volatile unsigned char  *icrp;
+		volatile unsigned long  *imrp;
+		int i;
+
+		b = (fep->index) ? MCFICM_INTC1 : MCFICM_INTC0;
+		icrp = (volatile unsigned char *) (MCF_IPSBAR + b +
+			MCFINTC_ICR0);
+		for (i = 23; (i < 36); i++)
+			icrp[i] = 0x23;
+
+		imrp = (volatile unsigned long *) (MCF_IPSBAR + b +
+			MCFINTC_IMRH);
+		*imrp &= ~0x0000000f;
+		imrp = (volatile unsigned long *) (MCF_IPSBAR + b +
+			MCFINTC_IMRL);
+		*imrp &= ~0xff800001;
+	}
+
+#if defined(CONFIG_M528x)
+	/* Set up gpio outputs for MII lines */
+	{
+		volatile unsigned short *gpio_paspar;
+  
+		gpio_paspar = (volatile unsigned short *) (MCF_IPSBAR +
+			0x100056);
+		*gpio_paspar = 0x0f00;
+	}
+#endif
+}
+
+static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
+{
+	volatile fec_t *fecp;
+
+	fecp = fep->hwp;
+	fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x04;
+	fecp->fec_x_cntrl = 0x00;
+
+	/*
+	 * Set MII speed to 2.5 MHz
+	 * See 5282 manual section 17.5.4.7: MSCR
+	 */
+	fep->phy_speed = ((((MCF_CLK / 2) / (2500000 / 10)) + 5) / 10) * 2;
+	fecp->fec_mii_speed = fep->phy_speed;
+
+	fec_restart(dev, 0);
+}
+
+static void __inline__ fec_get_mac(struct net_device *dev)
+{
+	struct fec_enet_private *fep = netdev_priv(dev);
+	volatile fec_t *fecp;
+	unsigned char *iap, tmpaddr[6];
+	int i;
+
+	fecp = fep->hwp;
+
+	if (fec_flashmac) {
+		/*
+		 * Get MAC address from FLASH.
+		 * If it is all 1's or 0's, use the default.
+		 */
+		iap = fec_flashmac;
+		if ((iap[0] == 0) && (iap[1] == 0) && (iap[2] == 0) &&
+		    (iap[3] == 0) && (iap[4] == 0) && (iap[5] == 0))
+			iap = fec_mac_default;
+		if ((iap[0] == 0xff) && (iap[1] == 0xff) && (iap[2] == 0xff) &&
+		    (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
+			iap = fec_mac_default;
+	} else {
+		*((unsigned long *) &tmpaddr[0]) = fecp->fec_addr_low;
+		*((unsigned short *) &tmpaddr[4]) = (fecp->fec_addr_high >> 16);
+		iap = &tmpaddr[0];
+	}
+
+	for (i=0; i<ETH_ALEN; i++)
+		dev->dev_addr[i] = fep->mac_addr[i] = *iap++;
+
+	/* Adjust MAC if using default MAC address */
+	if (iap == fec_mac_default) {
+		dev->dev_addr[ETH_ALEN-1] = fep->mac_addr[ETH_ALEN-1] =
+			iap[ETH_ALEN-1] + fep->index;
+	}
+}
+
+static void __inline__ fec_enable_phy_intr(void)
+{
+}
+
+static void __inline__ fec_disable_phy_intr(void)
+{
+}
+
+static void __inline__ fec_phy_ack_intr(void)
+{
+}
+
+static void __inline__ fec_localhw_setup(void)
+{
+}
+
+/*
+ *	Do not need to make region uncached on 5272.
+ */
+static void __inline__ fec_uncache(unsigned long addr)
+{
+}
+
+/* ------------------------------------------------------------------------- */
+
 #else
 
 /*
  *	Code sepcific to the MPC860T setup.
  */
-static void __inline__ fec_request_intrs(struct net_device *dev, volatile fec_t *fecp)
+static void __inline__ fec_request_intrs(struct net_device *dev)
 {
 	volatile immap_t *immap;
 
@@ -1184,13 +1422,13 @@
 #endif
 }
 
-static void __inline__ fec_get_mac(struct net_device *dev, struct fec_enet_private *fep)
+static void __inline__ fec_get_mac(struct net_device *dev)
 {
-	unsigned char *eap, *iap, tmpaddr[6];
+	struct fec_enet_private *fep = netdev_priv(dev);
+	unsigned char *iap, tmpaddr[6];
 	bd_t *bd;
 	int i;
 
-	eap = (unsigned char *)my_enet_addr;
 	iap = bd->bi_enetaddr;
 	bd = (bd_t *)__res;
 
@@ -1208,7 +1446,7 @@
 #endif
 
 	for (i=0; i<6; i++)
-		dev->dev_addr[i] = *eap++ = *iap++;
+		dev->dev_addr[i] = fep->mac_addr[i] = *iap++;
 }
 
 static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
@@ -1217,7 +1455,7 @@
 	volatile immap_t *immap;
 	volatile fec_t *fecp;
 
-	fecp = fec_hwp;
+	fecp = fep->hwp;
 	immap = (immap_t *)IMAP_ADDR;	/* pointer to internal registers */
 
 	/* Configure all of port D for MII.
@@ -1240,7 +1478,8 @@
 static void __inline__ fec_enable_phy_intr(void)
 {
 	volatile fec_t *fecp;
-	fecp = fec_hwp;
+
+	fecp = fep->hwp;
 
 	/* Enable MII command finished interrupt 
 	*/
@@ -1258,8 +1497,8 @@
 static void __inline__ fec_localhw_setup(void)
 {
 	volatile fec_t *fecp;
-	fecp = fec_hwp;
 
+	fecp = fep->hwp;
 	fecp->fec_r_hash = PKT_MAXBUF_SIZE;
 	/* Enable big endian and don't care about SDMA FC.
 	*/
@@ -1319,6 +1558,11 @@
 	struct fec_enet_private *fep = netdev_priv(dev);
 	volatile uint *s = &(fep->phy_status);
 
+	/*
+	** When we get here, phy_task is already removed from
+	** the workqueue.  It is thus safe to allow to reuse it.
+	*/
+	fep->mii_phy_task_queued = 0;
 	printk("%s: config: auto-negotiation ", dev->name);
 
 	if (*s & PHY_CONF_ANE)
@@ -1350,6 +1594,11 @@
 	struct fec_enet_private *fep = netdev_priv(dev);
 	int duplex;
 
+	/*
+	** When we get here, phy_task is already removed from
+	** the workqueue.  It is thus safe to allow to reuse it.
+	*/
+	fep->mii_phy_task_queued = 0;
 	fep->link = (fep->phy_status & PHY_STAT_LINK) ? 1 : 0;
 	mii_display_status(dev);
 	fep->old_link = fep->link;
@@ -1370,18 +1619,35 @@
 
 }
 
+/* mii_queue_relink is called in interrupt context from mii_link_interrupt */
 static void mii_queue_relink(uint mii_reg, struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
 
+	/*
+	** We cannot queue phy_task twice in the workqueue.  It
+	** would cause an endless loop in the workqueue.
+	** Fortunately, if the last mii_relink entry has not yet been
+	** executed now, it will do the job for the current interrupt,
+	** which is just what we want.
+	*/
+	if (fep->mii_phy_task_queued)
+		return;
+
+	fep->mii_phy_task_queued = 1;
 	INIT_WORK(&fep->phy_task, (void*)mii_relink, dev);
 	schedule_work(&fep->phy_task);
 }
 
+/* mii_queue_config is called in user context from fec_enet_open */
 static void mii_queue_config(uint mii_reg, struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
 
+	if (fep->mii_phy_task_queued)
+		return;
+
+	fep->mii_phy_task_queued = 1;
 	INIT_WORK(&fep->phy_task, (void*)mii_display_config, dev);
 	schedule_work(&fep->phy_task);
 }
@@ -1401,7 +1667,7 @@
 mii_discover_phy3(uint mii_reg, struct net_device *dev)
 {
 	struct fec_enet_private *fep;
-	int	i;
+	int i;
 
 	fep = netdev_priv(dev);
 	fep->phy_id |= (mii_reg & 0xffff);
@@ -1432,7 +1698,7 @@
 	uint phytype;
 
 	fep = netdev_priv(dev);
-	fecp = fec_hwp;
+	fecp = fep->hwp;
 
 	if (fep->phy_addr < 32) {
 		if ((phytype = (mii_reg & 0xffff)) != 0xffff && phytype != 0) {
@@ -1458,10 +1724,11 @@
 
 /* This interrupt occurs when the PHY detects a link change.
 */
-static void
 #ifdef CONFIG_RPXCLASSIC
+static void
 mii_link_interrupt(void *dev_id)
 #else
+static irqreturn_t
 mii_link_interrupt(int irq, void * dev_id, struct pt_regs * regs)
 #endif
 {
@@ -1477,6 +1744,7 @@
 	mii_do_cmd(dev, fep->phy->ack_int);
 	mii_do_cmd(dev, phy_cmd_relink);  /* restart and display status */
 
+	return IRQ_HANDLED;
 }
 
 static int
@@ -1487,7 +1755,6 @@
 	/* I should reset the ring buffers here, but I don't yet know
 	 * a simple way to do that.
 	 */
-
 	fec_set_mac_address(dev);
 
 	fep->sequence_done = 0;
@@ -1506,6 +1773,12 @@
 			schedule();
 
 		mii_do_cmd(dev, fep->phy->startup);
+
+		/* Set the initial link state to true. A lot of hardware
+		 * based on this device does not implement a PHY interrupt,
+		 * so we are never notified of link change.
+		 */
+		fep->link = 1;
 	} else {
 		fep->link = 1; /* lets just try it and see */
 		/* no phy,  go full duplex,  it's most likely a hub chip */
@@ -1513,16 +1786,18 @@
 	}
 
 	netif_start_queue(dev);
-	opened = 1;
+	fep->opened = 1;
 	return 0;		/* Success */
 }
 
 static int
 fec_enet_close(struct net_device *dev)
 {
+	struct fec_enet_private *fep = netdev_priv(dev);
+
 	/* Don't know what to do yet.
 	*/
-	opened = 0;
+	fep->opened = 0;
 	netif_stop_queue(dev);
 	fec_stop(dev);
 
@@ -1558,7 +1833,7 @@
 	unsigned char hash;
 
 	fep = netdev_priv(dev);
-	ep = fec_hwp;
+	ep = fep->hwp;
 
 	if (dev->flags&IFF_PROMISC) {
 		/* Log any net taps. */
@@ -1622,18 +1897,18 @@
 static void
 fec_set_mac_address(struct net_device *dev)
 {
-	int i;
+	struct fec_enet_private *fep;
 	volatile fec_t *fecp;
 
-	fecp = fec_hwp;
-
-	/* Set our copy of the Ethernet address */
-	for (i = 0; i < (ETH_ALEN / 2); i++)
-		my_enet_addr[i] = (dev->dev_addr[i*2] << 8) | dev->dev_addr[i*2 + 1];
+	fep = netdev_priv(dev);
+	fecp = fep->hwp;
 
 	/* Set station address. */
-	fecp->fec_addr_low = (my_enet_addr[0] << 16) | my_enet_addr[1];
-	fecp->fec_addr_high = my_enet_addr[2] << 16;
+	fecp->fec_addr_low = fep->mac_addr[3] | (fep->mac_addr[2] << 8) |
+		(fep->mac_addr[1] << 16) | (fep->mac_addr[0] << 24);
+	fecp->fec_addr_high = (fep->mac_addr[5] << 16) |
+		(fep->mac_addr[4] << 24);
+
 }
 
 /* Initialize the FEC Ethernet on 860T (or ColdFire 5272).
@@ -1649,14 +1924,18 @@
 	cbd_t		*cbd_base;
 	volatile fec_t	*fecp;
 	int 		i, j;
+	static int	index = 0;
 
 	/* Only allow us to be probed once. */
-	if (found)
-		return(-ENXIO);
+	if (index >= FEC_MAX_PORTS)
+		return -ENXIO;
 
 	/* Create an Ethernet device instance.
 	*/
-	fecp = fec_hwp;
+	fecp = (volatile fec_t *) fec_hw[index];
+
+	fep->index = index;
+	fep->hwp = fecp;
 
 	/* Whack a reset.  We should wait for this.
 	*/
@@ -1679,7 +1958,7 @@
 	 * This is our default MAC address unless the user changes
 	 * it via eth_mac_addr (our dev->set_mac_addr handler).
 	 */
-	fec_get_mac(dev, fep);
+	fec_get_mac(dev);
 
 	/* Allocate memory for buffer descriptors.
 	*/
@@ -1734,7 +2013,15 @@
 	/* ...and the same for transmmit.
 	*/
 	bdp = fep->tx_bd_base;
-	for (i=0; i<TX_RING_SIZE; i++) {
+	for (i=0, j=FEC_ENET_TX_FRPPG; i<TX_RING_SIZE; i++) {
+		if (j >= FEC_ENET_TX_FRPPG) {
+			mem_addr = __get_free_page(GFP_KERNEL);
+			j = 1;
+		} else {
+			mem_addr += FEC_ENET_TX_FRSIZE;
+			j++;
+		}
+		fep->tx_bounce[i] = (unsigned char *) mem_addr;
 
 		/* Initialize the BD for every fragment in the page.
 		*/
@@ -1756,7 +2043,7 @@
 	/* Install our interrupt handlers. This varies depending on
 	 * the architecture.
 	*/
-	fec_request_intrs(dev, fecp);
+	fec_request_intrs(dev);
 
 	dev->base_addr = (unsigned long)fecp;
 
@@ -1788,7 +2075,7 @@
 	fep->phy_addr = 0;
 	mii_queue(dev, mk_mii_read(MII_REG_PHYIR1), mii_discover_phy);
 
-	found++;
+	index++;
 	return 0;
 }
 
@@ -1800,14 +2087,12 @@
 fec_restart(struct net_device *dev, int duplex)
 {
 	struct fec_enet_private *fep;
-	int i;
-	unsigned char *eap;
 	volatile cbd_t *bdp;
 	volatile fec_t *fecp;
-
-	fecp = fec_hwp;
+	int i;
 
 	fep = netdev_priv(dev);
+	fecp = fep->hwp;
 
 	/* Whack a reset.  We should wait for this.
 	*/
@@ -1826,12 +2111,13 @@
 
 	/* Set station address.
 	*/
-	fecp->fec_addr_low = (my_enet_addr[0] << 16) | my_enet_addr[1];
-	fecp->fec_addr_high = (my_enet_addr[2] << 16);
+	fecp->fec_addr_low = fep->mac_addr[3] | (fep->mac_addr[2] << 8) |
+		(fep->mac_addr[1] << 16) | (fep->mac_addr[0] << 24);
+	fecp->fec_addr_high = (fep->mac_addr[5] << 16) |
+		(fep->mac_addr[4] << 24);
 
-	eap = (unsigned char *)&my_enet_addr[0];
-	for (i=0; i<6; i++)
-		dev->dev_addr[i] = *eap++;
+	for (i=0; i<ETH_ALEN; i++)
+		dev->dev_addr[i] = fep->mac_addr[i];
 
 	/* Reset all multicast.
 	*/
@@ -1898,11 +2184,12 @@
 	/* Enable MII mode.
 	*/
 	if (duplex) {
-		fecp->fec_r_cntrl = 0x04;	/* MII enable */
-		fecp->fec_x_cntrl = 0x04;	/* FD enable */
+		fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x04;/* MII enable */
+		fecp->fec_x_cntrl = 0x04;		  /* FD enable */
 	}
 	else {
-		fecp->fec_r_cntrl = 0x06;	/* MII enable|No Rcv on Xmit */
+		/* MII enable|No Rcv on Xmit */
+		fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x06;
 		fecp->fec_x_cntrl = 0x00;
 	}
 	fep->full_duplex = duplex;
@@ -1923,8 +2210,8 @@
 	volatile fec_t *fecp;
 	struct fec_enet_private *fep;
 
-	fecp = fec_hwp;
 	fep = netdev_priv(dev);
+	fecp = fep->hwp;
 
 	fecp->fec_x_cntrl = 0x01;	/* Graceful transmit stop */
 
@@ -1944,29 +2231,27 @@
 	fecp->fec_mii_speed = fep->phy_speed;
 }
 
-static struct net_device *fec_dev;
-
 static int __init fec_enet_module_init(void)
 {
 	struct net_device *dev;
-	int err;
+	int i, err;
 
-	dev = alloc_etherdev(sizeof(struct fec_enet_private));
-	if (!dev)
-		return -ENOMEM;
-	err = fec_enet_init(dev);
-	if (err) {
-		free_netdev(dev);
-		return err;
-	}
-
-	if (register_netdev(dev) != 0) {
-		/* XXX: missing cleanup here */
-		free_netdev(dev);
-		return -EIO;
+	for (i = 0; (i < FEC_MAX_PORTS); i++) {
+		dev = alloc_etherdev(sizeof(struct fec_enet_private));
+		if (!dev)
+			return -ENOMEM;
+		err = fec_enet_init(dev);
+		if (err) {
+			free_netdev(dev);
+			continue;
+		}
+		if (register_netdev(dev) != 0) {
+			/* XXX: missing cleanup here */
+			free_netdev(dev);
+			return -EIO;
+		}
 	}
-	fec_dev = dev;
-	return(0);
+	return 0;
 }
 
 module_init(fec_enet_module_init);
diff -Naur linux-2.6.9/drivers/net/fec.h linux-2.6.9-uc0/drivers/net/fec.h
--- linux-2.6.9/drivers/net/fec.h	2004-10-28 11:07:40.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/fec.h	2004-10-28 11:12:51.000000000 +1000
@@ -1,8 +1,8 @@
 /****************************************************************************/
 
 /*
- *	fec.h  --  Fast Ethernet Controller for Motorola ColdFire 5272
- *		   and 5282..
+ *	fec.h  --  Fast Ethernet Controller for Motorola ColdFire 5270,
+		   5271, 5272, 5274, 5275, 5280 and 5282.
  *
  *	(C) Copyright 2000-2003, Greg Ungerer (gerg@snapgear.com)
  *	(C) Copyright 2000-2001, Lineo (www.lineo.com)
@@ -13,7 +13,7 @@
 #define	FEC_H
 /****************************************************************************/
 
-#ifdef CONFIG_M5282
+#if defined(CONFIG_M527x) || defined(CONFIG_M528x)
 /*
  *	Just figures, Motorola would have to change the offsets for
  *	registers in the same peripheral device on different models
diff -Naur linux-2.6.9/drivers/net/Kconfig linux-2.6.9-uc0/drivers/net/Kconfig
--- linux-2.6.9/drivers/net/Kconfig	2004-10-28 11:07:41.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/Kconfig	2004-10-28 11:12:47.000000000 +1000
@@ -743,7 +743,7 @@
 
 config NET_VENDOR_SMC
 	bool "Western Digital/SMC cards"
-	depends on NET_ETHERNET && (ISA || MCA || EISA || MAC)
+	depends on NET_ETHERNET && (ISA || MCA || EISA || MAC || EMBEDDED)
 	help
 	  If you have a network (Ethernet) card belonging to this class, say Y
 	  and read the Ethernet-HOWTO, available from
@@ -833,7 +833,7 @@
 
 config SMC9194
 	tristate "SMC 9194 support"
-	depends on NET_VENDOR_SMC && (ISA || MAC && BROKEN)
+	depends on NET_VENDOR_SMC && (ISA || MAC && BROKEN || EMBEDDED)
 	select CRC32
 	---help---
 	  This is support for the SMC9xxx based Ethernet cards. Choose this
@@ -1075,7 +1075,7 @@
 
 config NE2000
 	tristate "NE2000/NE1000 support"
-	depends on NET_ISA || (Q40 && m) || M32R
+	depends on NET_ISA || (Q40 && m) || M32R || EMBEDDED
 	select CRC32
 	---help---
 	  If you have a network (Ethernet) card of this type, say Y and read
@@ -1353,7 +1353,7 @@
 
 config CS89x0
 	tristate "CS89x0 support"
-	depends on NET_PCI && (ISA || ARCH_IXDP2X01)
+	depends on NET_PCI && (ISA || ARCH_IXDP2X01 || M68328 || M68EZ328 || M68VZ328)
 	---help---
 	  Support for CS89x0 chipset based Ethernet cards. If you have a
 	  network (Ethernet) card of this type, say Y and read the
@@ -1365,6 +1365,14 @@
 	  <file:Documentation/networking/net-modules.txt>.  The module will be
 	  called cs89x.
 
+config CS89x0_SWAPPED
+	bool "Hardware swapped CS89x0"
+	depends on CS89x0 && !NET_PCI && !ISA
+	---help---
+	  Say Y if your CS89x0 data bus is swapped.
+	  This option is for single board computers using a CS89x0 chip. If you
+	  are using a regular Ethernet card, say N.
+
 config TC35815
 	tristate "TOSHIBA TC35815 Ethernet support"
 	depends on NET_PCI && PCI && TOSHIBA_JMR3927
@@ -1864,11 +1872,18 @@
 	  the Motorola 68360 processor.
 
 config FEC
-	bool "FEC ethernet controller (of ColdFire 5272)"
-	depends on M5272 || M5282
+	bool "FEC ethernet controller (of ColdFire CPUs)"
+	depends on M527x || M5272 || M528x
 	help
 	  Say Y here if you want to use the built-in 10/100 Fast ethernet
-	  controller on the Motorola ColdFire 5272 processor.
+	  controller on some Motorola ColdFire processors.
+
+config FEC2
+	bool "Second FEC ethernet controller (on some ColdFire CPUs)"
+	depends on FEC
+	help
+	  Say Y here if you want to use the second built-in 10/100 Fast
+	  ethernet controller on some Motorola ColdFire processors.
 
 config NE_H8300
 	tristate "NE2000 compatible support for H8/300"
diff -Naur linux-2.6.9/drivers/net/ne.c linux-2.6.9-uc0/drivers/net/ne.c
--- linux-2.6.9/drivers/net/ne.c	2004-10-28 11:07:40.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/ne.c	2004-10-28 11:12:51.000000000 +1000
@@ -30,6 +30,7 @@
     Richard Guenther    : Added support for ISAPnP cards
     Paul Gortmaker	: Discontinued PCI support - use ne2k-pci.c instead.
     Hayato Fujiwara	: Add m32r support.
+    Greg Ungerer	: added some coldfire addressing code.
 
 */
 
@@ -56,6 +57,18 @@
 
 #include "8390.h"
 
+#ifdef CONFIG_COLDFIRE
+#define COLDFIRE_NE2000_FUNCS
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/mcfne.h>
+unsigned char   ne_defethaddr[] = { 0x00, 0xd0, 0xcf, 0x00, 0x00, 0x01 };
+#endif /* CONFIG_COLDFIRE */
+#if defined(CONFIG_M5307) && defined(CONFIG_NETtel)
+static unsigned int ne_portlist[] = { NE2000_ADDR0, NE2000_ADDR1, 0 };
+static unsigned int ne_irqlist[] =  { NE2000_IRQ_VECTOR0,NE2000_IRQ_VECTOR1,0 };
+#endif
+
 #define DRV_NAME "ne"
 
 /* Some defines that people can play with if so inclined. */
@@ -180,6 +193,23 @@
 	int orig_irq = dev->irq;
 #endif
 
+#if defined (CONFIG_NETtel) && defined (CONFIG_M5307)
+	static int index = 0;
+	if (!ne_portlist[index])
+		return -ENXIO;
+	dev->base_addr = base_addr = ne_portlist[index];
+	dev->irq = ne_irqlist[index++];
+#elif defined(CONFIG_COLDFIRE)
+	static int once = 0;
+	if (once)
+		return -ENXIO;
+	if (base_addr == 0) {
+		dev->base_addr = base_addr = NE2000_ADDR;
+		dev->irq = NE2000_IRQ_VECTOR;
+		once++;
+	}
+#endif
+
 	SET_MODULE_OWNER(dev);
 
 	/* First check any supplied i/o locations. User knows best. <cough> */
@@ -391,10 +421,83 @@
 			wordlength = 1;
 	}
 
+#if defined(CONFIG_M5307) || defined(CONFIG_M5407)
+	{
+		outb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);
+		for(i = 0; i < 6; i++)
+		{
+			SA_prom[i] = inb(ioaddr + i + 1);
+		}
+		SA_prom[14] = SA_prom[15] = 0x57;
+	}
+#endif /* CONFIG_M5307 || CONFIG_M5407 */
+#if defined(CONFIG_NETtel) || defined(CONFIG_SECUREEDGEMP3)
+	{
+		unsigned char *ep;
+		static int nr = 0;
+		ep = (unsigned char *) (0xf0006000 + (nr++ * 6));
+		/*
+		* MAC address should be in FLASH, check that it is valid.
+		* If good use it, otherwise use the default.
+		*/
+		if (((ep[0] == 0xff) && (ep[1] == 0xff) && (ep[2] == 0xff) &&
+		    (ep[3] == 0xff) && (ep[4] == 0xff) && (ep[5] == 0xff)) ||
+		    ((ep[0] == 0) && (ep[1] == 0) && (ep[2] == 0) &&
+		    (ep[3] == 0) && (ep[4] == 0) && (ep[5] == 0))) {
+			ep = (unsigned char *) &ne_defethaddr[0];
+			ne_defethaddr[5]++;
+		}
+ 
+		for(i = 0; i < 6; i++)
+			SA_prom[i] = ep[i];
+		SA_prom[14] = SA_prom[15] = 0x57;
+ 
+#if defined(CONFIG_M5206e) && defined(CONFIG_NETtel)
+		wordlength = 1;
+ 
+		/* We must set the 8390 for 8bit mode. */
+		outb_p(0x48, ioaddr + EN0_DCFG);
+#endif
+		start_page = NESM_START_PG;
+		stop_page = NESM_STOP_PG;
+	}
+#elif defined(CONFIG_CFV240)
+	{
+		unsigned char *ep = (unsigned char *) 0xffc0406b;
+		/*
+		 * MAC address should be in FLASH, check that it is valid.
+		 * If good use it, otherwise use the default.
+		 */
+		if (((ep[0] == 0xff) && (ep[1] == 0xff) && (ep[2] == 0xff) &&
+		     (ep[3] == 0xff) && (ep[4] == 0xff) && (ep[5] == 0xff)) ||
+		     ((ep[0] == 0) && (ep[1] == 0) && (ep[2] == 0) &&
+		     (ep[3] == 0) && (ep[4] == 0) && (ep[5] == 0))) {
+			ep = (unsigned char *) &ne_defethaddr[0];
+			ne_defethaddr[5]++;
+		}
+		outb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);
+		for(i = 0; i < 6; i++)
+			SA_prom[i] = ep[i];
+		SA_prom[14] = SA_prom[15] = 0x57;
+	}
+#elif defined(CONFIG_M5206e)
+	{
+		outb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);
+		for(i = 0; i < 6; i++)
+		{
+			SA_prom[i] = inb(ioaddr + i + 1);
+		}
+		SA_prom[14] = SA_prom[15] = 0x57;
+	}
+#endif /* CONFIG_M5206e */
+ 
+#if !(defined(CONFIG_M5206e) && defined(CONFIG_NETtel))
 	if (wordlength == 2)
 	{
+#ifndef CONFIG_COLDFIRE
 		for (i = 0; i < 16; i++)
 			SA_prom[i] = SA_prom[i+i];
+#endif
 		/* We must set the 8390 for word mode. */
 		outb_p(DCR_VAL, ioaddr + EN0_DCFG);
 		start_page = NESM_START_PG;
@@ -403,6 +506,7 @@
 		start_page = NE1SM_START_PG;
 		stop_page = NE1SM_STOP_PG;
 	}
+#endif
 
 #if  defined(CONFIG_PLAT_MAPPI) || defined(CONFIG_PLAT_OAKS32R)
 	neX000 = ((SA_prom[14] == 0x57  &&  SA_prom[15] == 0x57)
@@ -483,6 +587,10 @@
 	/* Snarf the interrupt now.  There's no point in waiting since we cannot
 	   share and the board will usually be enabled. */
 	ret = request_irq(dev->irq, ei_interrupt, 0, name, dev);
+#ifdef CONFIG_COLDFIRE
+	if (ret == 0)
+		ne2000_irqsetup(dev->irq);
+#endif
 	if (ret) {
 		printk (" unable to get IRQ %d (errno=%d).\n", dev->irq, ret);
 		goto err_out;
diff -Naur linux-2.6.9/drivers/net/smc9194.c linux-2.6.9-uc0/drivers/net/smc9194.c
--- linux-2.6.9/drivers/net/smc9194.c	2004-10-28 11:07:41.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/smc9194.c	2004-10-28 11:12:52.000000000 +1000
@@ -59,9 +59,11 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
+#include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/fcntl.h>
 #include <linux/interrupt.h>
+#include <linux/ptrace.h>
 #include <linux/ioport.h>
 #include <linux/in.h>
 #include <linux/slab.h>
@@ -72,12 +74,46 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
+#include <linux/delay.h>
 
 #include <asm/bitops.h>
 #include <asm/io.h>
 
 #include "smc9194.h"
 
+#ifdef CONFIG_M68EZ328
+#include <asm/MC68EZ328.h>
+#include <asm/irq.h>
+#include <asm/mcfsmc.h>
+unsigned char	smc_defethaddr[] = { 0x00, 0x10, 0x8b, 0xf1, 0xda, 0x01 };
+#define NO_AUTOPROBE
+#endif
+
+#ifdef CONFIG_COLDFIRE
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/mcfsmc.h>
+
+unsigned char	smc_defethaddr[] = { 0x00, 0xd0, 0xcf, 0x00, 0x00, 0x01 };
+
+#define NO_AUTOPROBE
+#endif
+
+#ifdef CONFIG_SH_KEYWEST
+#include <asm/keywest.h>
+#define NO_AUTOPROBE
+#define PHY_SETUP
+#endif
+
+#ifdef CONFIG_LEDMAN
+#include <linux/ledman.h>
+#endif
+
+#if defined(CONFIG_CPU_H8300H) || defined(CONFIG_CPU_H8S)
+#include <asm/h8300_smsc.h>
+#define NO_AUTOPROBE
+#endif
+
 #define DRV_NAME "smc9194"
 
 /*------------------------------------------------------------------------
@@ -90,7 +126,8 @@
  . Do you want to use 32 bit xfers?  This should work on all chips, as
  . the chipset is designed to accommodate them.
 */
-#ifdef __sh__
+#if (defined(__sh__) && !defined(CONFIG_SH_KEYWEST)) || \
+    defined(__H8300H__) || defined(__H8300S__)
 #undef USE_32_BIT
 #else
 #define USE_32_BIT 1
@@ -105,17 +142,37 @@
 #endif
 
 /*
+ .A typedef so we can change what IO looks like easily
+*/
+typedef unsigned int smcio_t;
+
+/*
  .the SMC9194 can be at any of the following port addresses.  To change,
  .for a slightly different card, you can add it to the array.  Keep in
  .mind that the array must end in zero.
 */
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328) || \
+	defined(CONFIG_SH_KEYWEST)
 
-struct devlist {
-	unsigned int port;
-	unsigned int irq;
-};
+#ifdef CONFIG_NETtel
+static smcio_t smc_portlist[]      = { 0x30600300, 0x30600000, 0 };
+static unsigned int smc_irqlist[]  = {         29,         27, 0 };
+#elif defined(CONFIG_SH_KEYWEST)
+static smcio_t smc_portlist[]      = { KEYWEST_ETHR, 0 };
+static unsigned int smc_irqlist[]  = { IRQ4_IRQ,     0 };
+#elif defined(CONFIG_M68EZ328)
+/* make sure that you program Port D selects to allow the interrupts! */
+static smcio_t smc_portlist[]      = { 0x2000300,    0x2000320,    0 };
+static unsigned int smc_irqlist[]  = { IRQ1_IRQ_NUM, IRQ2_IRQ_NUM, 0 };
+#elif defined(CONFIG_CLEOPATRA)
+static unsigned int smc_portlist[] = { 0x30600300, 0 };
+static unsigned int smc_irqlist[]  = {         29, 0 };
+#else
+static smcio_t smc_portlist[]      = { 0x30600300, 0 };
+static unsigned int smc_irqlist[]  = {         27, 0 };
+#endif
 
-#if defined(CONFIG_H8S_EDOSK2674)
+#elif defined(CONFIG_H8S_EDOSK2674)
 static struct devlist smc_devlist[] __initdata = {
 	{.port = 0xf80000, .irq = 16},
 	{.port = 0,        .irq = 0 },
@@ -294,7 +351,7 @@
  . Test if a given location contains a chip, trying to cause as
  . little damage as possible if it's not a SMC chip.
 */
-static int smc_probe(struct net_device *dev, int ioaddr);
+static int smc_probe(struct net_device *dev, smcio_t ioaddr);
 
 /*
  . A rather simple routine to print out a packet for debugging purposes.
@@ -315,20 +372,31 @@
 static int  smc_wait_to_send_packet( struct sk_buff * skb, struct net_device *dev );
 
 /* this does a soft reset on the device */
-static void smc_reset( int ioaddr );
+static void smc_reset( smcio_t ioaddr );
 
 /* Enable Interrupts, Receive, and Transmit */
-static void smc_enable( int ioaddr );
+static void smc_enable( smcio_t ioaddr );
 
 /* this puts the device in an inactive state */
-static void smc_shutdown( int ioaddr );
+static void smc_shutdown( smcio_t ioaddr );
 
+#ifndef NO_AUTOPROBE
 /* This routine will find the IRQ of the driver if one is not
  . specified in the input to the device.  */
-static int smc_findirq( int ioaddr );
+static int smc_findirq( smcio_t ioaddr );
+#endif
+
+#ifdef PHY_SETUP
+static void clkmdio(smcio_t ioaddr, unsigned int MGMTData);
+static unsigned PHYAccess(smcio_t ioaddr, unsigned char PHYAdd,
+				unsigned char RegAdd, unsigned char OPCode, unsigned wData);
+static unsigned char DetectPHY(smcio_t ioaddr, unsigned long *OUI,
+						unsigned char *Model, unsigned char *Revision);
+static int setup_phy(smcio_t ioaddr);
+#endif
 
 /*
- . Function: smc_reset( int ioaddr )
+ . Function: smc_reset( smcio_t ioaddr )
  . Purpose:
  .  	This sets the SMC91xx chip to its normal state, hopefully from whatever
  . 	mess that any other DOS driver has put it in.
@@ -344,7 +412,7 @@
  .	5.  clear all interrupts
  .
 */
-static void smc_reset( int ioaddr )
+static void smc_reset( smcio_t ioaddr )
 {
 	/* This resets the registers mostly to defaults, but doesn't
 	   affect EEPROM.  That seems unnecessary */
@@ -365,6 +433,10 @@
 	SMC_SELECT_BANK( 1 );
 	outw( inw( ioaddr + CONTROL ) | CTL_AUTO_RELEASE , ioaddr + CONTROL );
 
+#if defined(CONFIG_LEDMAN) && defined(CONFIG_SNAPGEAR)
+	outw( inw( ioaddr + CONTROL ) | CTL_LE_ENABLE , ioaddr + CONTROL );	
+#endif
+
 	/* Reset the MMU */
 	SMC_SELECT_BANK( 2 );
 	outw( MC_RESET, ioaddr + MMU_CMD );
@@ -373,7 +445,7 @@
 	   but this is a place where future chipsets _COULD_ break.  Be wary
  	   of issuing another MMU command right after this */
 
-	outb( 0, ioaddr + INT_MASK );
+	SMC_SET_INT( 0 );
 }
 
 /*
@@ -384,7 +456,7 @@
  .	2.  Enable the receiver
  .	3.  Enable interrupts
 */
-static void smc_enable( int ioaddr )
+static void smc_enable( smcio_t ioaddr )
 {
 	SMC_SELECT_BANK( 0 );
 	/* see the header file for options in TCR/RCR NORMAL*/
@@ -393,7 +465,7 @@
 
 	/* now, enable interrupts */
 	SMC_SELECT_BANK( 2 );
-	outb( SMC_INTERRUPT_MASK, ioaddr + INT_MASK );
+	SMC_SET_INT( SMC_INTERRUPT_MASK );
 }
 
 /*
@@ -410,16 +482,21 @@
  .	the manual says that it will wake up in response to any I/O requests
  .	in the register space.   Empirical results do not show this working.
 */
-static void smc_shutdown( int ioaddr )
+static void smc_shutdown( smcio_t ioaddr )
 {
 	/* no more interrupts for me */
 	SMC_SELECT_BANK( 2 );
-	outb( 0, ioaddr + INT_MASK );
+	SMC_SET_INT( 0 );
 
 	/* and tell the card to stay away from that nasty outside world */
 	SMC_SELECT_BANK( 0 );
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outw( RCR_CLEAR, ioaddr + RCR );
+	outw( TCR_CLEAR, ioaddr + TCR );
+#else
 	outb( RCR_CLEAR, ioaddr + RCR );
 	outb( TCR_CLEAR, ioaddr + TCR );
+#endif /* CONFIG_COLDFIRE */
 #if 0
 	/* finally, shut the chip down */
 	SMC_SELECT_BANK( 1 );
@@ -429,7 +506,7 @@
 
 
 /*
- . Function: smc_setmulticast( int ioaddr, int count, dev_mc_list * adds )
+ . Function: smc_setmulticast( smcio_t ioaddr, int count, dev_mc_list * adds )
  . Purpose:
  .    This sets the internal hardware table to filter out unwanted multicast
  .    packets before they take up memory.
@@ -446,7 +523,7 @@
 */
 
 
-static void smc_setmulticast( int ioaddr, int count, struct dev_mc_list * addrs ) {
+static void smc_setmulticast( smcio_t ioaddr, int count, struct dev_mc_list * addrs ) {
 	int			i;
 	unsigned char		multicast_table[ 8 ];
 	struct dev_mc_list	* cur_addr;
@@ -479,11 +556,18 @@
 	/* now, the table can be loaded into the chipset */
 	SMC_SELECT_BANK( 3 );
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	for ( i = 0; i < 8 ; i += 2 ) {
+		outw(((multicast_table[i+1]<<8)+(multicast_table[i])), ioaddr+MULTICAST1+i );
+	}
+#else
 	for ( i = 0; i < 8 ; i++ ) {
 		outb( multicast_table[i], ioaddr + MULTICAST1 + i );
 	}
+#endif
 }
 
+
 /*
  . Function: smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * )
  . Purpose:
@@ -518,18 +602,18 @@
 		printk(CARDNAME": Bad Craziness - sent packet while busy.\n" );
 		return 1;
 	}
-	lp->saved_skb = skb;
 
 	length = skb->len;
 
-	if (length < ETH_ZLEN) {
+	if(length < ETH_ZLEN) {
 		skb = skb_padto(skb, ETH_ZLEN);
-		if (skb == NULL) {
+		if(skb == NULL) {
 			netif_wake_queue(dev);
 			return 0;
 		}
 		length = ETH_ZLEN;
 	}
+	lp->saved_skb = skb;
 		
 	/*
 	** The MMU wants the number of pages to be the number of 256 bytes
@@ -575,7 +659,7 @@
 		status = inb( ioaddr + INTERRUPT );
 		if ( status & IM_ALLOC_INT ) {
 			/* acknowledge the interrupt */
-			outb( IM_ALLOC_INT, ioaddr + INTERRUPT );
+			SMC_ACK_INT( IM_ALLOC_INT );
   			break;
 		}
    	} while ( -- time_out );
@@ -617,7 +701,7 @@
 	byte	 		packet_no;
 	struct sk_buff * 	skb = lp->saved_skb;
 	word			length;
-	unsigned int		ioaddr;
+	smcio_t			ioaddr;
 	byte			* buf;
 
 	ioaddr = dev->base_addr;
@@ -641,7 +725,11 @@
 	}
 
 	/* we have a packet address, so tell the card to use it */
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outw( packet_no, ioaddr + PNR_ARR );
+#else
 	outb( packet_no, ioaddr + PNR_ARR );
+#endif
 
 	/* point to the beginning of the packet */
 	outw( PTR_AUTOINC , ioaddr + POINTER );
@@ -653,14 +741,23 @@
 
 	/* send the packet length ( +6 for status, length and ctl byte )
  	   and the status word ( set to zeros ) */
+
 #ifdef USE_32_BIT
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outl(  (length +6 ) , ioaddr + DATA_1 );
+#else
 	outl(  (length +6 ) << 16 , ioaddr + DATA_1 );
+#endif
 #else
 	outw( 0, ioaddr + DATA_1 );
 	/* send the packet length ( +6 for status words, length, and ctl*/
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328) || defined(CONFIG_CPU_H8S)
+	outw( (length+6) & 0xFFFF, ioaddr + DATA_1 );
+#else
 	outb( (length+6) & 0xFF,ioaddr + DATA_1 );
 	outb( (length+6) >> 8 , ioaddr + DATA_1 );
 #endif
+#endif
 
 	/* send the actual data
 	 . I _think_ it's faster to send the longs first, and then
@@ -672,7 +769,9 @@
 #ifdef USE_32_BIT
 	if ( length & 0x2  ) {
 		outsl(ioaddr + DATA_1, buf,  length >> 2 );
-#if !defined(__H8300H__) && !defined(__H8300S__)
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+		outwd( *((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +DATA_1);
+#elif !defined(__H8300H__) && !defined(__H8300S__)
 		outw( *((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +DATA_1);
 #else
 		ctrl_outw( *((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +DATA_1);
@@ -688,8 +787,12 @@
 	if ( (length & 1) == 0 ) {
 		outw( 0, ioaddr + DATA_1 );
 	} else {
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+		outw( buf[length -1 ] | (0x20 << 8), ioaddr + DATA_1);
+#else
 		outb( buf[length -1 ], ioaddr + DATA_1 );
 		outb( 0x20, ioaddr + DATA_1);
+#endif
 	}
 
 	/* enable the interrupts */
@@ -755,8 +858,11 @@
 	} else if (io != 0) {	/* Don't probe at all. */
 		err = -ENXIO;
 	} else {
-		for (;smcdev->port; smcdev++) {
-			if (smc_probe(dev, smcdev->port) == 0)
+		for (port = smc_portlist; *port; port++) {
+#ifdef CONFIG_NETtel
+			smc_remap(port);
+#endif
+			if (smc_probe(dev, *port) == 0)
 				break;
 		}
 		if (!smcdev->port)
@@ -783,13 +889,21 @@
  . interrupt, so an auto-detect routine can detect it, and find the IRQ,
  ------------------------------------------------------------------------
 */
-int __init smc_findirq( int ioaddr )
+#ifndef NO_AUTOPROBE
+int __init smc_findirq( smcio_t ioaddr )
 {
 #ifndef NO_AUTOPROBE
 	int	timeout = 20;
 	unsigned long cookie;
 
 
+#if 0
+	/* I have to do a STI() here, because this is called from
+	   a routine that does an CLI during this process, making it
+	   rather difficult to get interrupts for auto detection */
+	sti();
+#endif
+
 	cookie = probe_irq_on();
 
 	/*
@@ -801,7 +915,7 @@
 
 	SMC_SELECT_BANK(2);
 	/* enable ALLOCation interrupts ONLY */
-	outb( IM_ALLOC_INT, ioaddr + INT_MASK );
+	SMC_SET_INT( IM_ALLOC_INT );
 
 	/*
  	 . Allocate 512 bytes of memory.  Note that the chip was just
@@ -836,7 +950,13 @@
 	SMC_DELAY();
 
 	/* and disable all interrupts again */
-	outb( 0, ioaddr + INT_MASK );
+	SMC_SET_INT( 0 );
+
+#if 0
+	/* clear hardware interrupts again, because that's how it
+	   was when I was called... */
+	cli();
+#endif
 
 	/* and return what I found */
 	return probe_irq_off(cookie);
@@ -849,9 +969,10 @@
 	return 0;
 #endif
 }
+#endif /* NO_AUTOPROBE */
 
 /*----------------------------------------------------------------------
- . Function: smc_probe( int ioaddr )
+ . Function: smc_probe( smcio_t ioaddr )
  .
  . Purpose:
  .	Tests to see if a given ioaddr points to an SMC9xxx chip.
@@ -879,11 +1000,17 @@
  . o  GRAB the region
  .-----------------------------------------------------------------
 */
-static int __init smc_probe(struct net_device *dev, int ioaddr)
+static int __init smc_probe(struct net_device *dev, smcio_t ioaddr)
 {
 	int i, memory, retval;
 	static unsigned version_printed;
 	unsigned int bank;
+#if defined(CONFIG_NETtel) || defined(CONFIG_eLIA) || defined(CONFIG_DISKtel) || defined(CONFIG_CLEOPATRA)
+	static int nr = 0;
+#endif
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	unsigned char *ep;
+#endif
 
 	const char *version_string;
 	const char *if_string;
@@ -895,9 +1022,18 @@
 	word memory_info_register;
 	word memory_cfg_register;
 
+#if !defined(CONFIG_COLDFIRE) && !defined(CONFIG_M68EZ328) && \
+    !defined(CONFIG_CPU_H8300H) && !defined(CONFIG_CPU_H8S)
 	/* Grab the region so that no one else tries to probe our ioports. */
 	if (!request_region(ioaddr, SMC_IO_EXTENT, DRV_NAME))
 		return -EBUSY;
+#elif defined(CONFIG_COLDFIRE)
+	/*
+	 *	We need to put the SMC into 68k mode.
+	 *	Do a write before anything else.
+	 */
+	outw(0, ioaddr + BANK_SELECT);
+#endif
 
 	dev->irq = irq;
 	dev->if_port = ifport;
@@ -916,13 +1052,13 @@
 		retval = -ENODEV;
 		goto err_out;
 	}
-#if !defined(CONFIG_H8S_EDOSK2674)
 	/* well, we've already written once, so hopefully another time won't
  	   hurt.  This time, I need to switch the bank register to bank 1,
 	   so I can access the base address register */
+#if !defined(CONFIG_CPU_H8300H) && !defined(CONFIG_CPU_H8S)
 	SMC_SELECT_BANK(1);
 	base_address_register = inw( ioaddr + BASE );
-	if ( ioaddr != ( base_address_register >> 3 & 0x3E0 ) )  {
+	if ( (ioaddr & 0x3E0) != ( base_address_register >> 3 & 0x3E0 ) )  {
 		printk(CARDNAME ": IOADDR %x doesn't match configuration (%x)."
 			"Probably not a SMC chip\n",
 			ioaddr, base_address_register >> 3 & 0x3E0 );
@@ -935,7 +1071,6 @@
 	(void)base_address_register; /* Warning suppression */
 #endif
 
-
 	/*  check if the revision register is something that I recognize.
 	    These might need to be added to later, as future revisions
 	    could be added.  */
@@ -953,13 +1088,30 @@
 	/* at this point I'll assume that the chip is an SMC9xxx.
 	   It might be prudent to check a listing of MAC addresses
 	   against the hardware address, or do some other tests. */
-
 	if (version_printed++ == 0)
 		printk("%s", version);
 
 	/* fill in some of the fields */
 	dev->base_addr = ioaddr;
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+#if defined(CONFIG_NETtel) || defined(CONFIG_eLIA) || defined(CONFIG_DISKtel) || defined(CONFIG_CLEOPATRA)
+	/*
+	 . MAC address should be in FLASH, check that it is valid.
+	 . If good use it, otherwise use the default.
+	*/
+	ep = (unsigned char *) (0xf0006000 + (nr++ * 6));
+	if ((ep[0] == 0xff) && (ep[1] == 0xff) && (ep[2] == 0xff) &&
+	    (ep[3] == 0xff) && (ep[4] == 0xff) && (ep[5] == 0xff))
+		ep = (unsigned char *) &smc_defethaddr[0];
+	else if ((ep[0] == 0) && (ep[1] == 0) && (ep[2] == 0) &&
+	    (ep[3] == 0) && (ep[4] == 0) && (ep[5] == 0))
+		ep = (unsigned char *) &smc_defethaddr[0];
+#else
+	ep = (unsigned char *) &smc_defethaddr[0];
+#endif
+#endif
+
 	/*
  	 . Get the MAC address ( bank 1, regs 4 - 9 )
 	*/
@@ -967,11 +1119,23 @@
 	for ( i = 0; i < 6; i += 2 ) {
 		word	address;
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+		dev->dev_addr[ i ] = ep[ i ];
+		dev->dev_addr[ i + 1 ] = ep[ i + 1 ];
+		address = (((word) ep[ i ]) << 8) | ep[ i + 1 ];
+		outw( address, ioaddr + ADDR0 + i);
+#else
 		address = inw( ioaddr + ADDR0 + i  );
 		dev->dev_addr[ i + 1] = address >> 8;
-		dev->dev_addr[ i ] = address & 0xFF;
+		dev->dev_addr[ i ] = address & 0xFF;	
+#endif
 	}
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	/* HACK: to support 2 ethernets when using default address! */
+	smc_defethaddr[5]++;
+#endif
+
 	/* get the memory information */
 
 	SMC_SELECT_BANK( 0 );
@@ -1024,6 +1188,7 @@
 	 . what (s)he is doing.  No checking is done!!!!
  	 .
 	*/
+#ifndef NO_AUTOPROBE
 	if ( dev->irq < 2 ) {
 		int	trials;
 
@@ -1041,6 +1206,13 @@
 		retval = -ENODEV;
 		goto err_out;
 	}
+#else
+	if (dev->irq == 0 ) {
+		printk(CARDNAME
+		": Autoprobing IRQs is not supported for this configuration.\n");
+		return -ENODEV;
+	}
+#endif
 
 	/* now, print out the card info, in a short format.. */
 
@@ -1059,12 +1231,21 @@
 	memset(dev->priv, 0, sizeof(struct smc_local));
 
 	/* Grab the IRQ */
-      	retval = request_irq(dev->irq, &smc_interrupt, 0, DRV_NAME, dev);
-      	if (retval) {
-		printk("%s: unable to get IRQ %d (irqval=%d).\n", DRV_NAME,
+#ifdef CONFIG_COLDFIRE
+	mcf_autovector(dev->irq);
+    retval = request_irq(dev->irq, &smc_interrupt, 0, dev->name, dev);
+#elif defined(CONFIG_M68EZ328) && !defined(CONFIG_CWEZ328) && !defined(CONFIG_CWVZ328)
+	retval = request_irq(IRQ_MACHSPEC | dev->irq, &smc_interrupt,
+			IRQ_FLG_STD, dev->name, dev);
+	if (retval) panic("Unable to attach Lan91C96 intr\n");
+#else
+	retval = request_irq(dev->irq, &smc_interrupt, 0, DRV_NAME, dev);
+#endif
+	if (retval) {
+		printk("%s: unable to get IRQ %d (irqval=%d).\n", dev->name,
 			dev->irq, retval);
   	  	goto err_out;
-      	}
+	}
 
 	dev->open		        = smc_open;
 	dev->stop		        = smc_close;
@@ -1074,6 +1255,9 @@
 	dev->get_stats			= smc_query_statistics;
 	dev->set_multicast_list 	= smc_set_multicast_list;
 
+#ifdef PHY_SETUP
+	setup_phy( ioaddr );
+#endif
 	return 0;
 
 err_out:
@@ -1126,7 +1310,7 @@
  */
 static int smc_open(struct net_device *dev)
 {
-	int	ioaddr = dev->base_addr;
+	smcio_t	ioaddr = dev->base_addr;
 
 	int	i;	/* used to set hw ethernet address */
 
@@ -1141,6 +1325,11 @@
 	/* Select which interface to use */
 
 	SMC_SELECT_BANK( 1 );
+#if defined(CONFIG_DISKtel) || defined(CONFIG_SH_KEYWEST)
+	/* Setup to use external PHY on smc91c110 */
+	outw( inw( ioaddr + CONFIG ) | CFG_NO_WAIT | CFG_MII_SELECT,
+		(ioaddr + CONFIG ));
+#else
 	if ( dev->if_port == 1 ) {
 		outw( inw( ioaddr + CONFIG ) & ~CFG_AUI_SELECT,
 			ioaddr + CONFIG );
@@ -1149,6 +1338,7 @@
 		outw( inw( ioaddr + CONFIG ) | CFG_AUI_SELECT,
 			ioaddr + CONFIG );
 	}
+#endif
 
 	/*
   		According to Becker, I have to set the hardware address
@@ -1165,6 +1355,18 @@
 	}
 	
 	netif_start_queue(dev);
+
+#if defined(CONFIG_LEDMAN) && defined(CONFIG_SNAPGEAR)
+	/*
+	 *	fix the link status LED's
+	 */
+	SMC_SELECT_BANK( 0 );
+	ledman_cmd((inw(ioaddr + EPH_STATUS) & ES_LINK_OK) == ES_LINK_OK ?
+			LEDMAN_CMD_ON : LEDMAN_CMD_OFF,
+			strcmp(dev->name, "eth0") ?
+					LEDMAN_LAN2_LINK : LEDMAN_LAN1_LINK);
+#endif
+
 	return 0;
 }
 
@@ -1206,10 +1408,9 @@
 static void smc_rcv(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
-	int 	ioaddr = dev->base_addr;
-	int 	packet_number;
-	word	status;
-	word	packet_length;
+	int ioaddr = dev->base_addr;
+	int packet_number;
+	word status, packet_length;
 
 	/* assume bank 2 */
 
@@ -1226,8 +1427,16 @@
 	outw( PTR_READ | PTR_RCV | PTR_AUTOINC, ioaddr + POINTER );
 
 	/* First two words are status and packet_length */
+#ifndef CONFIG_SH_KEYWEST
 	status 		= inw( ioaddr + DATA_1 );
 	packet_length 	= inw( ioaddr + DATA_1 );
+#else
+	{
+		unsigned int l = inl( ioaddr + DATA_1 );
+		status         = l & 0xffff;
+		packet_length  = l >> 16;
+	}
+#endif
 
 	packet_length &= 0x07ff;  /* mask off top bits */
 
@@ -1278,9 +1487,17 @@
 			packet_length >> 2, packet_length & 3 ));
 		insl(ioaddr + DATA_1 , data, packet_length >> 2 );
 		/* read the left over bytes */
+#ifndef CONFIG_SH_KEYWEST
 		insb( ioaddr + DATA_1, data + (packet_length & 0xFFFFFC),
 			packet_length & 0x3  );
 #else
+		if (packet_length & 3) {
+			union { unsigned int l; char data[4]; } l;
+			l.l = inl(ioaddr + DATA_1);
+			memcpy(data + (packet_length & ~0x3), l.data, packet_length & 0x3);
+		}
+#endif
+#else
 		PRINTK3((" Reading %d words and %d byte(s) \n",
 			(packet_length >> 1 ), packet_length & 1 ));
 		insw(ioaddr + DATA_1 , data, packet_length >> 1);
@@ -1331,7 +1548,7 @@
  ************************************************************************/
 static void smc_tx( struct net_device * dev )
 {
-	int	ioaddr = dev->base_addr;
+	int ioaddr = dev->base_addr;
 	struct smc_local *lp = netdev_priv(dev);
 	byte saved_packet;
 	byte packet_no;
@@ -1345,7 +1562,12 @@
 	packet_no &= 0x7F;
 
 	/* select this as the packet to read from */
-	outb( packet_no, ioaddr + PNR_ARR );
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outw( packet_no, ioaddr + PNR_ARR ); 
+#else
+	outb( packet_no, ioaddr + PNR_ARR ); 
+#endif
+	
 
 	/* read the first word from this packet */
 	outw( PTR_AUTOINC | PTR_READ, ioaddr + POINTER );
@@ -1356,8 +1578,10 @@
 	lp->stats.tx_errors++;
 	if ( tx_status & TS_LOSTCAR ) lp->stats.tx_carrier_errors++;
 	if ( tx_status & TS_LATCOL  ) {
+#if 0
 		printk(KERN_DEBUG CARDNAME
 			": Late collision occurred on last xmit.\n");
+#endif
 		lp->stats.tx_window_errors++;
 	}
 #if 0
@@ -1378,7 +1602,11 @@
 	/* one less packet waiting for me */
 	lp->packets_waiting--;
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+	outw( saved_packet, ioaddr + PNR_ARR );
+#else
 	outb( saved_packet, ioaddr + PNR_ARR );
+#endif
 	return;
 }
 
@@ -1524,6 +1752,11 @@
 	/* clear everything */
 	smc_shutdown( dev->base_addr );
 
+#if defined(CONFIG_LEDMAN) && defined(CONFIG_SNAPGEAR)
+	ledman_cmd(LEDMAN_CMD_OFF,
+		strcmp(dev->name, "eth0")?LEDMAN_LAN2_LINK : LEDMAN_LAN1_LINK);
+#endif
+
 	/* Update the statistics here. */
 	return 0;
 }
@@ -1548,7 +1781,7 @@
 */
 static void smc_set_multicast_list(struct net_device *dev)
 {
-	short ioaddr = dev->base_addr;
+	smcio_t ioaddr = dev->base_addr;
 
 	SMC_SELECT_BANK(0);
 	if ( dev->flags & IFF_PROMISC )
@@ -1595,6 +1828,12 @@
 	}
 }
 
+#ifdef PHY_SETUP
+static int phy_delay1 = 4;
+static int phy_delay2 = 1;
+static int phy_delay3 = 100;
+#endif
+
 #ifdef MODULE
 
 static struct net_device *devSMC9194;
@@ -1607,12 +1846,25 @@
 MODULE_PARM_DESC(irq, "SMC 99194 IRQ number");
 MODULE_PARM_DESC(ifport, "SMC 99194 interface port (0-default, 1-TP, 2-AUI)");
 
+#ifdef PHY_SETUP
+MODULE_PARM(phy_delay1, "i");
+MODULE_PARM(phy_delay2, "i");
+MODULE_PARM(phy_delay3, "i");
+MODULE_PARM_DESC(phy_delay1, "Per MII clock delay [4]");
+MODULE_PARM_DESC(phy_delay2, "General delay [1]");
+MODULE_PARM_DESC(phy_delay3, "pre probe delay [100]");
+#endif
+
 int init_module(void)
 {
 	if (io == 0)
 		printk(KERN_WARNING
 		CARDNAME": You shouldn't use auto-probing with insmod!\n" );
 
+#ifdef PHY_SETUP
+	printk(CARDNAME ": phy_delays %d %d %d\n", phy_delay1, phy_delay2,
+			phy_delay3);
+#endif
 	/* copy the parameters from insmod into the device structure */
 	devSMC9194 = smc_init(-1);
 	if (IS_ERR(devSMC9194))
@@ -1629,3 +1881,437 @@
 }
 
 #endif /* MODULE */
+
+
+#ifdef PHY_SETUP
+/*-----------------------------------------------------------
+ . PHY/MII setup routines
+ .
+*/
+
+#define phy_delay(x) ({ int d; for (d = 0; d < 100; d++) udelay((x) * 10); })
+
+/*
+ *	Ports for talking to the PHY/MII
+ */
+
+#define NV_CONTROL	0x10
+#define MIICTRL		0x30
+#define MIIDATA		0x34
+#define MIICFG		0x38
+
+#define MIIREAD		0x0001
+#define MIIWRITE	0x0002
+
+#define	MDO			0x01		/* MII Register bits */
+#define	MDI			0x02
+#define	MCLK		0x04
+#define	MDOE		0x08
+#define	MALL 		0x0F
+#define	OPWrite		0x01
+#define	OPRead		0x02
+
+
+#define PHY_CR			0		/* PHY Registers and bits */
+#define PHY_CR_Reset	0x8000
+#define PHY_CR_Speed	0x2000
+#define PHY_CR_Duplex	0x0100
+
+#define PHY_SR	1
+#define PHY_ID1	2
+#define PHY_ID2	3
+
+/*
+ *	PHY propietary registers
+ */
+
+#define PHY_NATIONAL_PAR			0x19
+#define PHY_NATIONAL_PAR_DUPLEX		0x0080
+#define PHY_NATIONAL_PAR_SPEED_10	0x0040
+
+#define PHY_TDK_DIAG				0x12
+#define PHY_TDK_DIAG_DUPLEX			0x0800
+#define PHY_TDK_DIAG_RATE			0x0400
+
+#define PHY_QSI_BASETX				0x1F
+#define PHY_QSI_BASETX_OPMODE_MASK	0x001c
+#define PHY_QSI_BASETX_OPMODE_10HD	(2<<0x1)
+#define PHY_QSI_BASETX_OPMODE_100HD	(2<<0x2)
+#define PHY_QSI_BASETX_OPMODE_10FD	(2<<0x5)
+#define PHY_QSI_BASETX_OPMODE_100FD	(2<<0x6)
+
+#define PHY_SEEQ_STATUS_OUTPUT		0x12
+#define PHY_SEEQ_SPD_DET			0x80
+#define PHY_SEEQ_DPLX_DET			0x40
+
+#define PHY_OUI_QSI			0x006051
+#define PHY_OUI_TDK			0x00C039
+#define PHY_OUI_MITELSMSC	0x00A087
+#define PHY_OUI_NATIONAL	0x080017
+#define PHY_OUI_SEEQSMSC	0x0005BE
+
+#define NWAY_TIMEOUT	10
+
+#define MAC_IS_FEAST()	(1)
+#define MAC_IS_EPIC()	(0)
+
+static void
+clkmdio(smcio_t ioaddr, unsigned int MGMTData)
+{
+	outw(MGMTData, ioaddr + MGMT);
+	udelay(phy_delay1);
+	outw(MGMTData | MCLK, ioaddr + MGMT);
+	udelay(phy_delay1);
+}
+
+
+static unsigned
+PHYAccess(
+	smcio_t ioaddr,
+	unsigned char PHYAdd,
+	unsigned char RegAdd,
+	unsigned char OPCode,
+	unsigned wData)
+{
+	int i;
+	unsigned MGMTval;
+
+	// Filter unused bits from input variables.
+
+	PHYAdd &= 0x1F;
+	RegAdd &= 0x1F;
+	OPCode &= 0x03;
+
+	if (MAC_IS_FEAST()) {
+		MGMTval = inw(ioaddr + MGMT) & (MALL ^ 0xFFFF);
+
+		// Output Preamble (32 '1's)
+
+		for (i = 0; i < 32; i++)
+			clkmdio(ioaddr, MGMTval | MDOE | MDO);
+
+		// Output Start of Frame ('01')
+
+		for (i = 0; i < 2; i++)
+			clkmdio(ioaddr, MGMTval | MDOE | i);
+
+		// Output OPCode ('01' for write or '10' for Read)
+
+		for (i = 1; i >= 0; i--)
+			clkmdio(ioaddr, MGMTval | MDOE | ((OPCode>>i) & 0x01) );
+
+		// Output PHY Address
+
+		for (i = 4; i >= 0; i--)
+			clkmdio(ioaddr, MGMTval | MDOE | ((PHYAdd>>i) & 0x01) );
+
+		// Output Register Address
+
+		for (i = 4; i >= 0; i--)
+			clkmdio(ioaddr, MGMTval | MDOE | ((RegAdd>>i) & 0x01) );
+
+		if (OPCode == OPRead) {
+			// Read Operation
+
+			// Implement Turnaround ('Z0')
+
+			clkmdio(ioaddr, MGMTval);
+			// clkmdio(ioaddr, MGMTval | MDOE);
+
+			// Read Data
+
+			wData = 0;
+
+			for (i = 15; i >= 0; i--) {
+				clkmdio(ioaddr, MGMTval);
+				wData |= (((inw(ioaddr + MGMT) & MDI) >> 1) << i);
+			}
+
+			// Add Idle state
+
+			clkmdio(ioaddr, MGMTval);
+
+			return (wData);
+		} else {
+			// Write Operation
+
+			// Implement Turnaround ('10')
+
+			for (i = 1; i >= 0; i--)
+				clkmdio(ioaddr, MGMTval | MDOE | ((2>>i) & 0x01));
+
+			// Write Data
+
+			for (i = 15; i >= 0; i--)
+				clkmdio(ioaddr, MGMTval | MDOE | ((wData>>i) & 0x01));
+
+			// Add Idle state
+
+			clkmdio(ioaddr, MGMTval);
+
+			return (1);
+		}
+	}
+
+	if (MAC_IS_EPIC()) {
+		if (OPCode == OPRead) {
+			// Read Operation
+			outw((((unsigned)PHYAdd)<<9) | (((unsigned)RegAdd)<<4) | MIIREAD,
+					ioaddr + MIICTRL);
+			phy_delay(phy_delay2);
+			wData = inw(MIIDATA);
+			return(wData);
+		} else {
+			// Write Operation
+			outw(wData, ioaddr + MIIDATA);
+			outw((((unsigned)PHYAdd)<<9) | (((unsigned)RegAdd)<<4) | MIIWRITE,
+					ioaddr + MIICTRL);
+			phy_delay(phy_delay2);
+			return(1);
+		}
+	}
+
+	return(1);
+
+}
+
+
+static unsigned char
+DetectPHY(
+	smcio_t ioaddr,
+	unsigned long *OUI,
+	unsigned char *Model,
+	unsigned char *Revision)
+{
+    unsigned int PhyId1, PhyId2;
+    unsigned char PhyAdd=0xff;
+    int Count;
+
+    for (Count=31; Count >= 0; Count--) {
+		PhyId1 = PHYAccess(ioaddr, Count, PHY_ID1, OPRead, 0);
+		PhyId1 = PHYAccess(ioaddr, Count, PHY_ID1, OPRead, 0);
+		PhyId2 = PHYAccess(ioaddr, Count, PHY_ID2, OPRead, 0);
+		PhyId2 = PHYAccess(ioaddr, Count, PHY_ID2, OPRead, 0);
+
+		if (PhyId1 > 0x0000 && PhyId1 < 0xffff && PhyId2 > 0x0000 &&
+			PhyId2 < 0xffff && PhyId1 != 0x8000 && PhyId2 != 0x8000) {
+			PhyAdd = (unsigned char) Count;
+			break;
+		}
+		phy_delay(phy_delay2);
+    }
+
+    *OUI =		(((unsigned long) PhyId1) << 6) | ((PhyId2 & 0xfc00) >> 10);
+    *Model =	(unsigned char) ((PhyId2 & 0x03f0) >> 4);
+    *Revision =	(unsigned char) (PhyId2 & 0x000f);
+
+    return(PhyAdd);
+}
+
+
+static int
+setup_phy(smcio_t ioaddr)
+{
+    int duplex = 0; /* 0 = Half,   !0 = Full */
+    int speed = 0;  /* 0 = 10Mbps, !0 = 100Mbps */
+    char *report = "";
+	unsigned long OUI;
+	unsigned char Model, Revision;
+
+    unsigned int i, PHYConfig, PHYConfig2, data;
+    unsigned char PHYAdd, ositech = 0;
+
+	printk("SMCPHY: ");
+#if 0
+	ositech = 1;
+#endif
+
+	//Setting the AUI Select Bit for 91C110 PCMCIA Design. 11/23/99 PG
+	if (ositech) {
+		SMC_SELECT_BANK( 1 );
+		data = inw(ioaddr + BANK_SELECT);
+		outw(data | 0x0100, ioaddr);
+	}
+
+    if (MAC_IS_FEAST())
+		SMC_SELECT_BANK ( 3 );
+
+	PHYAdd = DetectPHY(ioaddr, &OUI, &Model, &Revision);
+
+	if (PHYAdd > 31) {
+	    printk("UNRECOVERABLE ERROR: PHY is not present or not supported\n");
+	    return(-1);
+	}
+
+	//Setup NV_CONTROL for the cardbus card.
+	if (OUI == PHY_OUI_TDK)
+		outw(0x7c03, ioaddr + NV_CONTROL);
+
+	// Save Register 0.
+
+	if (OUI == PHY_OUI_TDK)
+		PHYAccess(ioaddr, PHYAdd, PHY_CR, OPRead, 0);
+	PHYConfig = PHYAccess(ioaddr, PHYAdd,PHY_CR,OPRead,0);
+
+	if (OUI == PHY_OUI_TDK) {
+		outw(0x0012, ioaddr + MIICFG);	/* Set ENABLE_694 */
+		/* if using EPIC, Hardware Reset the PHY from the MAC */
+		outw(inw(ioaddr + CONTROL) | 0x4000, ioaddr + CONTROL);
+		phy_delay(phy_delay2);
+		outw(inw(ioaddr + CONTROL) & (~0x4000), ioaddr + CONTROL);
+		phy_delay(phy_delay2);
+	}
+
+	/* Reset PHY */
+	PHYAccess(ioaddr, PHYAdd, PHY_CR, OPWrite, PHY_CR_Reset);
+	if (OUI == PHY_OUI_TDK)
+		PHYAccess(ioaddr, PHYAdd, PHY_CR, OPWrite, PHY_CR_Reset);
+
+	for (i = 0; i < 500; i++) {
+		if (OUI == PHY_OUI_TDK)
+			PHYAccess(ioaddr, PHYAdd, PHY_CR, OPRead, 0);
+
+		if (PHYAccess(ioaddr, PHYAdd, PHY_CR, OPRead, 0) & PHY_CR_Reset)
+			phy_delay(phy_delay2);
+		else
+			break;
+	}
+
+	if (i == 500) {
+		printk("UNRECOVERABLE ERROR: Could not reset PHY\n");
+		return(-1);
+	}
+
+	/* Write selected configuration to the PHY and verify it by reading back */
+	/* Set Advertising Register for all 10/100 and Half/Full combinations */
+
+	if (OUI == PHY_OUI_TDK)
+		PHYConfig = PHYAccess(ioaddr, PHYAdd, 4, OPRead, 0);
+	PHYConfig = PHYAccess(ioaddr, PHYAdd, 4, OPRead, 0);
+	PHYConfig |= 0x01e0;
+	PHYAccess(ioaddr, PHYAdd, 4, OPWrite, PHYConfig);
+	if (OUI == PHY_OUI_TDK)
+		PHYAccess(ioaddr, PHYAdd, 4, OPWrite, PHYConfig);
+
+	/* Start 1 */
+
+	/* National PHY requires clear before set 1 enable. */
+	PHYAccess(ioaddr, PHYAdd, 0, OPWrite, 0x0000);
+	PHYAccess(ioaddr, PHYAdd, 0, OPWrite, 0x1200);
+	if (OUI == PHY_OUI_TDK)
+		PHYAccess(ioaddr, PHYAdd, 0, OPWrite, 0x1200);
+
+	/* Wait for completion */
+	for (i = 0; i < NWAY_TIMEOUT * 10; i++) {
+		printk("%c\b", "|/-\\"[i&3]);
+
+		phy_delay(phy_delay3);
+
+		PHYConfig = PHYAccess(ioaddr, PHYAdd, 1, OPRead, 0);
+		PHYConfig2 = PHYAccess(ioaddr, PHYAdd, 1, OPRead, 0);
+
+		if (PHYConfig != PHYConfig2) /* Value is not stable */
+			continue;
+		if (PHYConfig & 0x0010) /* Remote Fault */
+			continue;
+		if ((PHYConfig == 0x0000) || (PHYConfig == 0xffff)) /* invalid value */
+			continue;
+		if (PHYConfig & 0x0020)
+			break;
+	}
+
+	/* Now read the results of the NWAY. */
+
+	if (OUI == PHY_OUI_TDK)
+		PHYConfig = PHYAccess(ioaddr, PHYAdd, 5, OPRead, 0);
+	PHYConfig = PHYAccess(ioaddr, PHYAdd, 5, OPRead, 0);
+
+	if (PHYConfig != 0) {
+		/* Got real NWAY information here */
+		report = "ANLPA";
+		speed = (PHYConfig & 0x0180);
+		duplex = (PHYConfig & 0x0140);
+	} else {
+		/*
+		 * ANLPA was 0 so NWAY did not complete or is not reported fine.
+		 * Get the info from propietary regs or from the control register.
+		 */
+		report = "Prop."; /* Proprietary Status */
+
+		switch (OUI) {
+		case PHY_OUI_NATIONAL:
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, PHY_NATIONAL_PAR, OPRead, 0);
+			duplex = (PHYConfig & PHY_NATIONAL_PAR_DUPLEX);
+			speed = ! (PHYConfig & PHY_NATIONAL_PAR_SPEED_10);
+			break;
+
+		case PHY_OUI_TDK:
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, PHY_TDK_DIAG, OPRead, 0);
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, PHY_TDK_DIAG, OPRead, 0);
+			speed = ((Revision < 7) && ((PHYConfig & 0x300) == 0x300)) ||
+					((Revision >= 7) && (PHYConfig & PHY_TDK_DIAG_RATE));
+			duplex = ((Revision >= 7) && (PHYConfig & PHY_TDK_DIAG_DUPLEX));
+			break;
+
+		case PHY_OUI_QSI:
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, PHY_QSI_BASETX, OPRead, 0);
+			PHYConfig &= PHY_QSI_BASETX_OPMODE_MASK;
+			duplex = (PHYConfig & PHY_QSI_BASETX_OPMODE_10FD) ||
+				(PHYConfig & PHY_QSI_BASETX_OPMODE_100FD);
+			speed = (PHYConfig & PHY_QSI_BASETX_OPMODE_100HD) ||
+				(PHYConfig & PHY_QSI_BASETX_OPMODE_100FD);
+			break;
+
+		case PHY_OUI_SEEQSMSC:
+			PHYConfig=PHYAccess(ioaddr,PHYAdd,PHY_SEEQ_STATUS_OUTPUT,OPRead,0);
+			duplex = (PHYConfig & PHY_SEEQ_DPLX_DET);
+			speed = (PHYConfig & PHY_SEEQ_SPD_DET);
+			break;
+
+		default:
+			report = "Command";
+			PHYConfig = PHYAccess(ioaddr, PHYAdd, 0, OPRead, 0);
+			speed = (PHYConfig & 0x2000);
+			duplex = (PHYConfig & 0x0100);
+			break;
+		}
+	}
+
+	/* Do we need to adjust the Carrier sense on full duplex FEAST issue ?  */
+
+	if (duplex && MAC_IS_FEAST() && (OUI == PHY_OUI_MITELSMSC))
+		PHYAccess(ioaddr, PHYAdd, 0x18, OPWrite,
+				0x0020 | PHYAccess(ioaddr, PHYAdd, 0x18, OPRead, 0));
+
+	/* Display what we learned */
+
+    printk(" %s-duplex %d Mbps ", duplex ? "Full" : "Half", speed ? 100 : 10);
+
+	if (MAC_IS_FEAST())
+		printk("FEAST ");
+	if (MAC_IS_EPIC())
+		printk("EPIC ");
+
+	switch (OUI) {
+	case PHY_OUI_QSI:       printk("QSI");                break;
+	case PHY_OUI_TDK:       printk("TDK");                break;
+	case PHY_OUI_MITELSMSC: printk("MITEL/SMSC180");      break;
+	case PHY_OUI_NATIONAL:  printk("NATIONAL");           break;
+	case PHY_OUI_SEEQSMSC:  printk("SEEQ/SMSC183");       break;
+	default:                printk("%06lX(UNKNOWN)",OUI); break;
+	}
+
+	printk(" Model=%02X Rev=%02X ", Model, Revision);
+#if DEBUG
+	printk("Addr=%02X ", PHYAdd);
+	printk("Conf=%s ", report);
+#endif
+	if (i == NWAY_TIMEOUT)
+		printk("TIMEOUT!\n");
+	else
+		printk("Done.\n");
+	return(0);
+}
+
+/*----------------------------------------------------------- */
+#endif /* PHY_SETUP */
diff -Naur linux-2.6.9/drivers/net/smc9194.h linux-2.6.9-uc0/drivers/net/smc9194.h
--- linux-2.6.9/drivers/net/smc9194.h	2004-10-28 11:07:44.000000000 +1000
+++ linux-2.6.9-uc0/drivers/net/smc9194.h	2004-10-28 11:12:52.000000000 +1000
@@ -96,6 +96,8 @@
 /* BANK 1 */
 #define CONFIG			0
 #define CFG_AUI_SELECT	 	0x100
+#define	CFG_NO_WAIT		0x1000
+#define	CFG_MII_SELECT		0x8000
 #define	BASE			2
 #define	ADDR0			4
 #define	ADDR1			6
@@ -208,6 +210,44 @@
 			inw( ioaddr + RCR );\
 			inw( ioaddr + RCR );  }
 
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_M68EZ328)
+
+/* this enables an interrupt in the interrupt mask register */
+#define SMC_ENABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = inb( ioaddr + INT_MASK );\
+		mask |= (x);\
+		outw( mask << 8, ioaddr + INTERRUPT ); \
+}
+
+/* this disables an interrupt from the interrupt mask register */
+
+#define SMC_DISABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = inb( ioaddr + INT_MASK );\
+		mask &= ~(x);\
+		outw( mask << 8, ioaddr + INTERRUPT ); \
+}
+
+/* set the interrupt mask register */
+#define	SMC_SET_INT(x) {\
+		SMC_SELECT_BANK(2);\
+		outw( ((unsigned short) (x)) << 8, ioaddr + INTERRUPT );\
+}
+
+/* acknowledge an interrupt */
+#define	SMC_ACK_INT(x) {\
+		unsigned short val;\
+		/* assume BANK 2 selected */\
+		val = inb( ioaddr + INT_MASK );\
+		val = (val << 8) | (x);\
+		outw( val, ioaddr + INTERRUPT );\
+}
+
+#else
+
 /* this enables an interrupt in the interrupt mask register */
 #define SMC_ENABLE_INT(x) {\
 		unsigned char mask;\
@@ -227,6 +267,17 @@
 		outb( mask, ioaddr + INT_MASK ); \
 }
 
+/* set the interrupt mask register */
+#define	SMC_SET_INT(x) {\
+		SMC_SELECT_BANK(2);\
+		outb( (x), ioaddr + INT_MASK );\
+}
+
+/* acknowledge an interrupt */
+#define	SMC_ACK_INT(x)	outb( (x), ioaddr + INTERRUPT )
+
+#endif
+
 /*----------------------------------------------------------------------
  . Define the interrupts that I want to receive from the card
  . 
diff -Naur linux-2.6.9/drivers/serial/68328serial.c linux-2.6.9-uc0/drivers/serial/68328serial.c
--- linux-2.6.9/drivers/serial/68328serial.c	2004-10-28 11:07:54.000000000 +1000
+++ linux-2.6.9-uc0/drivers/serial/68328serial.c	2004-10-28 11:13:21.000000000 +1000
@@ -34,6 +34,7 @@
 #include <linux/keyboard.h>
 #include <linux/init.h>
 #include <linux/pm.h>
+#include <linux/delay.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -1005,7 +1006,7 @@
         unsigned long flags;
         if (!info->port)
                 return;
-        current->state = TASK_INTERRUPTIBLE;
+        set_current_state(TASK_INTERRUPTIBLE);
         save_flags(flags);
         cli();
 #ifdef USE_INTS	
@@ -1197,8 +1198,7 @@
 #endif	
 	if (info->blocked_open) {
 		if (info->close_delay) {
-			current->state = TASK_INTERRUPTIBLE;
-			schedule_timeout(info->close_delay);
+			msleep_interruptible(jiffies_to_msecs(info->close_delay));
 		}
 		wake_up_interruptible(&info->open_wait);
 	}
diff -Naur linux-2.6.9/drivers/serial/Kconfig linux-2.6.9-uc0/drivers/serial/Kconfig
--- linux-2.6.9/drivers/serial/Kconfig	2004-10-28 11:07:54.000000000 +1000
+++ linux-2.6.9-uc0/drivers/serial/Kconfig	2004-10-28 11:13:21.000000000 +1000
@@ -219,6 +219,28 @@
 	  your boot loader (lilo or loadlin) about how to pass options to the
 	  kernel at boot time.)
 
+config SERIAL_T32
+	bool "T32 ARM JTAG serial emulation port support"
+	depends on ARM
+	select SERIAL_CORE
+	help
+	  This selects serial port emulation driver for Trace32 Jtag 
+	  debugger for ARM architecture. You should make an terminal with
+	  JTAG1 protocol.
+
+	  if unsure, say N.
+ 
+config SERIAL_T32_CONSOLE
+	bool "Support for console on T32 JTAG port"
+	depends on SERIAL_T32
+	select SERIAL_CORE_CONSOLE
+	help
+	  Say Y here if you wish to use T32 ARM JTAG serial emulation port
+	  as the system console. you can use command line option "console=ttyJ0"
+	  for manual console driver setup.
+
+	  if unsure, say N.
+
 config SERIAL_CLPS711X
 	tristate "CLPS711X serial port support"
 	depends on ARM && ARCH_CLPS711X
@@ -270,6 +292,27 @@
 	  Support for registerin the SuperIO chip on BAST board with
 	  the 8250/16550 uart code.
 
+config SERIAL_S3C4510B
+	tristate "Samsung S3C4510B Serial port support"
+	depends on ARM && CPU_S3C4510B
+	select SERIAL_CORE
+	help
+	  Support for the on-chip UARTs on the Samsung S3C4510B CPU,
+	  providing /dev/ttyS0 and 1.
+
+config SERIAL_S3C4510B_CONSOLE
+	bool "Support for console on S3C4510B serial port"
+	depends on SERIAL_S3C4510B=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Allow selection of the S3C4510B on-board serial ports for use as
+	  an virtual console.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttySx". 
+
 config SERIAL_DZ
 	bool "DECstation DZ serial driver"
 	depends on MACH_DECSTATION && MIPS32
@@ -595,6 +638,19 @@
 	  on your PowerMac as the console, you can do so by answering
 	  Y to this option.
 
+config SERIAL_ATMEL
+	bool "ATMEL uart support"
+	depends on ARCH_ATMEL
+	help
+	  This driver supports the uart ports of the ATMEL AT91 series.
+
+config SERIAL_ATMEL_CONSOLE
+	bool "Console on ATMEL uart"
+	depends on SERIAL_ATMEL
+	help
+	  If you would like to be able to use the ATMEL uart port
+	  as the console, say Y to this option.
+
 config SERIAL_LH7A40X
 	tristate "Sharp LH7A40X embedded UART support"
 	depends on ARM && ARCH_LH7A40X
@@ -715,6 +771,19 @@
 	  This value is only used if the bootloader doesn't pass in the
 	  console baudrate
 
+config SERIAL_ATMEL
+	bool "ATMEL uart support"
+	depends on ARCH_ATMEL
+	help
+	  This driver supports the uart ports of the ATMEL AT91 series.
+
+config SERIAL_ATMEL_CONSOLE
+	bool "Console on ATMEL uart"
+	depends on SERIAL_ATMEL
+	help
+	  If you would like to be able to use the ATMEL uart port
+	  as the console, say Y to this option.
+
 config SERIAL_ICOM
 	tristate "IBM Multiport Serial Adapter"
 	depends on PPC_ISERIES || PPC_PSERIES
diff -Naur linux-2.6.9/drivers/serial/Makefile linux-2.6.9-uc0/drivers/serial/Makefile
--- linux-2.6.9/drivers/serial/Makefile	2004-10-28 11:07:54.000000000 +1000
+++ linux-2.6.9-uc0/drivers/serial/Makefile	2004-10-28 11:13:21.000000000 +1000
@@ -32,6 +32,9 @@
 obj-$(CONFIG_SERIAL_68360) += 68360serial.o
 obj-$(CONFIG_SERIAL_COLDFIRE) += mcfserial.o
 obj-$(CONFIG_V850E_UART) += v850e_uart.o
+obj-$(CONFIG_SERIAL_T32) += t32.o
+obj-$(CONFIG_SERIAL_ATMEL) += serial_atmel.o
+obj-$(CONFIG_SERIAL98) += serial98.o
 obj-$(CONFIG_SERIAL_PMACZILOG) += pmac_zilog.o
 obj-$(CONFIG_SERIAL_LH7A40X) += serial_lh7a40x.o
 obj-$(CONFIG_SERIAL_AU1X00) += au1x00_uart.o
@@ -41,3 +44,4 @@
 obj-$(CONFIG_SERIAL_SGI_L1_CONSOLE) += sn_console.o
 obj-$(CONFIG_SERIAL_CPM) += cpm_uart/
 obj-$(CONFIG_SERIAL_MPC52xx) += mpc52xx_uart.o
+obj-$(CONFIG_SERIAL_S3C4510B) += serial_s3c4510b.o
diff -Naur linux-2.6.9/drivers/serial/mcfserial.c linux-2.6.9-uc0/drivers/serial/mcfserial.c
--- linux-2.6.9/drivers/serial/mcfserial.c	2004-10-28 11:07:54.000000000 +1000
+++ linux-2.6.9-uc0/drivers/serial/mcfserial.c	2004-10-28 11:13:21.000000000 +1000
@@ -34,6 +34,7 @@
 #include <linux/serialP.h>
 #include <linux/console.h>
 #include <linux/init.h>
+#include <linux/delay.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -41,7 +42,6 @@
 #include <asm/segment.h>
 #include <asm/semaphore.h>
 #include <asm/bitops.h>
-#include <asm/delay.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
 #include <asm/mcfuart.h>
@@ -57,11 +57,16 @@
  *	keep going.  Perhaps one day the cflag settings for the
  *	console can be used instead.
  */
-#if defined(CONFIG_ARNEWSH) || defined(CONFIG_MOTOROLA) || defined(CONFIG_senTec)
+#if defined(CONFIG_ARNEWSH) || defined(CONFIG_MOTOROLA) || defined(CONFIG_senTec) || defined(CONFIG_SNEHA)
 #define	CONSOLE_BAUD_RATE	19200
 #define	DEFAULT_CBAUD		B19200
 #endif
 
+#if defined(CONFIG_HW_FEITH)
+  #define	CONSOLE_BAUD_RATE	38400
+  #define	DEFAULT_CBAUD		B38400
+#endif
+
 #ifndef CONSOLE_BAUD_RATE
 #define	CONSOLE_BAUD_RATE	9600
 #define	DEFAULT_CBAUD		B9600
@@ -85,8 +90,8 @@
 #undef SERIAL_DEBUG_OPEN
 #undef SERIAL_DEBUG_FLOW
 
-#ifdef CONFIG_M5282
-#define	IRQBASE	77
+#if defined(CONFIG_M527x) || defined(CONFIG_M528x)
+#define	IRQBASE	(MCFINT_VECBASE+MCFINT_UART0)
 #else
 #define	IRQBASE	73
 #endif
@@ -336,20 +341,24 @@
 #endif
 
 		tty->flip.count++;
-		if (status & MCFUART_USR_RXERR)
+		if (status & MCFUART_USR_RXERR) {
 			uartp[MCFUART_UCR] = MCFUART_UCR_CMDRESETERR;
-		if (status & MCFUART_USR_RXBREAK) {
-			info->stats.rxbreak++;
-			*tty->flip.flag_buf_ptr++ = TTY_BREAK;
-		} else if (status & MCFUART_USR_RXPARITY) {
-			info->stats.rxparity++;
-			*tty->flip.flag_buf_ptr++ = TTY_PARITY;
-		} else if (status & MCFUART_USR_RXOVERRUN) {
-			info->stats.rxoverrun++;
-			*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
-		} else if (status & MCFUART_USR_RXFRAMING) {
-			info->stats.rxframing++;
-			*tty->flip.flag_buf_ptr++ = TTY_FRAME;
+			if (status & MCFUART_USR_RXBREAK) {
+				info->stats.rxbreak++;
+				*tty->flip.flag_buf_ptr++ = TTY_BREAK;
+			} else if (status & MCFUART_USR_RXPARITY) {
+				info->stats.rxparity++;
+				*tty->flip.flag_buf_ptr++ = TTY_PARITY;
+			} else if (status & MCFUART_USR_RXOVERRUN) {
+				info->stats.rxoverrun++;
+				*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+			} else if (status & MCFUART_USR_RXFRAMING) {
+				info->stats.rxframing++;
+				*tty->flip.flag_buf_ptr++ = TTY_FRAME;
+			} else {
+				/* This should never happen... */
+				*tty->flip.flag_buf_ptr++ = 0;
+			}
 		} else {
 			*tty->flip.flag_buf_ptr++ = 0;
 		}
@@ -723,13 +732,25 @@
 	if (serial_paranoia_check(info, tty->name, "mcfrs_flush_chars"))
 		return;
 
+	uartp = (volatile unsigned char *) info->addr;
+
+	/*
+	 * re-enable receiver interrupt
+	 */
+	local_irq_save(flags);
+	if ((!(info->imr & MCFUART_UIR_RXREADY)) &&
+	    (info->flags & ASYNC_INITIALIZED) ) {
+		info->imr |= MCFUART_UIR_RXREADY;
+		uartp[MCFUART_UIMR] = info->imr;
+	}
+	local_irq_restore(flags);
+
 	if (info->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
 	    !info->xmit_buf)
 		return;
 
 	/* Enable transmitter */
 	local_irq_save(flags);
-	uartp = info->addr;
 	info->imr |= MCFUART_UIR_TXREADY;
 	uartp[MCFUART_UIMR] = info->imr;
 	local_irq_restore(flags);
@@ -990,12 +1011,12 @@
 
 	if (!info->addr)
 		return;
-	current->state = TASK_INTERRUPTIBLE;
+	set_current_state(TASK_INTERRUPTIBLE);
 	uartp = info->addr;
 
 	local_irq_save(flags);
 	uartp[MCFUART_UCR] = MCFUART_UCR_CMDBREAKSTART;
-	schedule_timeout(jiffies + duration);
+	schedule_timeout(duration);
 	uartp[MCFUART_UCR] = MCFUART_UCR_CMDBREAKSTOP;
 	local_irq_restore(flags);
 }
@@ -1242,8 +1263,7 @@
 #endif	
 	if (info->blocked_open) {
 		if (info->close_delay) {
-			current->state = TASK_INTERRUPTIBLE;
-			schedule_timeout(info->close_delay);
+			msleep_interruptible(jiffies_to_msecs(info->close_delay));
 		}
 		wake_up_interruptible(&info->open_wait);
 	}
@@ -1308,8 +1328,7 @@
 			fifo_cnt++;
 		if (fifo_cnt == 0)
 			break;
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(char_time);
+		msleep_interruptible(jiffies_to_msecs(char_time));
 		if (signal_pending(current))
 			break;
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
@@ -1519,7 +1538,7 @@
 	*portp = (*portp & ~0x000000ff) | 0x00000055;
 	portp = (volatile unsigned long *) (MCF_MBAR + MCFSIM_PDCNT);
 	*portp = (*portp & ~0x000003fc) | 0x000002a8;
-#elif defined(CONFIG_M5282)
+#elif defined(CONFIG_M527x) || defined(CONFIG_M528x)
 	volatile unsigned char *icrp, *uartp;
 	volatile unsigned long *imrp;
 
@@ -1531,7 +1550,7 @@
 
 	imrp = (volatile unsigned long *) (MCF_MBAR + MCFICM_INTC0 +
 		MCFINTC_IMRL);
-	*imrp &= ~((1 << (info->irq - 64)) | 1);
+	*imrp &= ~((1 << (info->irq - MCFINT_VECBASE)) | 1);
 #else
 	volatile unsigned char	*icrp, *uartp;
 
diff -Naur linux-2.6.9/drivers/serial/serial_atmel.c linux-2.6.9-uc0/drivers/serial/serial_atmel.c
--- linux-2.6.9/drivers/serial/serial_atmel.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/drivers/serial/serial_atmel.c	2004-10-28 11:13:21.000000000 +1000
@@ -0,0 +1,1887 @@
+/* serial port driver for the Atmel AT91 series builtin USARTs
+ *
+ * Copyright (C) 2000, 2001  Erik Andersen <andersen@lineo.com>
+ * Copyright (C) 2004 Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * Based on:
+ * drivers/char/68302serial.c
+ * and also based on trioserial.c from Aplio, though this driver
+ * has been extensively changed since then.  No author was 
+ * listed in trioserial.c.
+ * 
+ * Phil Wilshire 12/31/2002  Fixed multiple ^@ chars on TCSETA 
+ * Hyok S. Choi  03/22/2004  2.6 port
+ */
+
+/* Enable this to force this driver to always operate at 57600 */
+#undef FORCE_57600
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/serial.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/config.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/console.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/arch/irq.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/bitops.h>
+#include <asm/delay.h>
+#include <asm/uaccess.h>
+
+#include "serial_atmel.h"
+
+#define USE_INTS	1
+
+static volatile struct atmel_usart_regs *usarts[AT91_USART_CNT] = {
+	(volatile struct atmel_usart_regs *) AT91_USART0_BASE,
+	(volatile struct atmel_usart_regs *) AT91_USART1_BASE
+};
+
+#define SERIAL_XMIT_SIZE	PAGE_SIZE
+#define RX_SERIAL_SIZE		256
+
+static struct atmel_serial atmel_info[AT91_USART_CNT];
+static struct tty_struct *serial_table[AT91_USART_CNT];
+struct atmel_serial *atmel_consinfo = 0;
+
+#define UART_CLOCK	(ARM_CLK/16)
+
+static struct work_struct serialpoll;
+
+#ifdef CONFIG_CONSOLE
+extern wait_queue_head_t keypress_wait; 
+#endif
+
+struct tty_driver *serial_driver;
+
+/* serial subtype definitions */
+#define SERIAL_TYPE_NORMAL	1
+
+/* number of characters left in xmit buffer before we ask for more */
+#define WAKEUP_CHARS 256
+
+/* Debugging... DEBUG_INTR is bad to use when one of the zs
+ * lines is your console ;(
+ */
+#undef SERIAL_DEBUG_INTR
+#undef SERIAL_DEBUG_OPEN
+#undef SERIAL_DEBUG_FLOW
+
+#define RS_ISR_PASS_LIMIT 256
+
+#define _INLINE_ inline
+
+#ifndef MIN
+#define MIN(a,b)	((a) < (b) ? (a) : (b))
+#endif
+
+
+
+/*
+ * tmp_buf is used as a temporary buffer by serial_write.  We need to
+ * lock it in case the memcpy_fromfs blocks while swapping in a page,
+ * and some other program tries to do a serial write at the same time.
+ * Since the lock will only come under contention when the system is
+ * swapping and available memory is low, it makes sense to share one
+ * buffer across all the serial ports, since it significantly saves
+ * memory if large numbers of serial ports are open.
+ */
+static unsigned char tmp_buf[SERIAL_XMIT_SIZE];	/* This is cheating */
+DECLARE_MUTEX(tmp_buf_sem);
+
+static inline int serial_paranoia_check(struct atmel_serial *info,
+					char *name, const char *routine)
+{
+#ifdef SERIAL_PARANOIA_CHECK
+	static const char *badmagic =
+		"Warning: bad magic number for serial struct %s in %s\n";
+	static const char *badinfo =
+		"Warning: null atmel_serial struct for %s in %s\n";
+
+	if (!info) {
+		printk(badinfo, name, routine);
+		return 1;
+	}
+	if (info->magic != SERIAL_MAGIC) {
+		printk(badmagic, name, routine);
+		return 1;
+	}
+#endif
+	return 0;
+}
+
+static unsigned char * rx_buf_table[AT91_USART_CNT];
+
+static unsigned char rx_buf1[RX_SERIAL_SIZE];
+static unsigned char rx_buf2[RX_SERIAL_SIZE];
+
+/* Console hooks... */
+
+static void serpoll(void *data);
+
+static void change_speed(struct atmel_serial *info);
+
+static char prompt0;
+static void xmit_char(struct atmel_serial *info, char ch);
+static void xmit_string(struct atmel_serial *info, char *p, int len);
+static void start_rx(struct atmel_serial *info);
+static void wait_EOT(volatile struct atmel_usart_regs *);
+static void uart_init(struct atmel_serial *info);
+static void uart_speed(struct atmel_serial *info, unsigned cflag);
+
+static void tx_enable(volatile struct atmel_usart_regs *uart);
+static void rx_enable(volatile struct atmel_usart_regs *uart);
+static void tx_disable(volatile struct atmel_usart_regs *uart);
+static void rx_disable(volatile struct atmel_usart_regs *uart);
+static void tx_stop(volatile struct atmel_usart_regs *uart);
+static void tx_start(volatile struct atmel_usart_regs *uart, int ints);
+static void rx_stop(volatile struct atmel_usart_regs *uart);
+static void rx_start(volatile struct atmel_usart_regs *uart, int ints);
+static void set_ints_mode(int yes, struct atmel_serial *info);
+static irqreturn_t rs_interrupt(struct atmel_serial *info);
+extern void show_net_buffers(void);
+extern void hard_reset_now(void);
+static void handle_termios_tcsets(struct termios * ptermios, struct atmel_serial * ptty);
+
+static int global;
+
+static void coucou1(void)
+{
+	global = 0;
+}
+
+static void coucou2(void)
+{
+	global = 1;
+}
+static void _INLINE_ tx_enable(volatile struct atmel_usart_regs *uart)
+{
+	uart->ier = US_TXEMPTY;
+}
+static void _INLINE_ rx_enable(volatile struct atmel_usart_regs *uart)
+{
+	uart->ier = US_ENDRX | US_TIMEOUT;
+}
+static void _INLINE_ tx_disable(volatile struct atmel_usart_regs *uart)
+{
+	uart->idr = US_TXEMPTY;
+}
+static void _INLINE_ rx_disable(volatile struct atmel_usart_regs *uart)
+{
+	uart->idr = US_ENDRX | US_TIMEOUT;
+}
+static void _INLINE_ tx_stop(volatile struct atmel_usart_regs *uart)
+{
+	tx_disable(uart);
+	uart->tcr = 0;
+	uart->cr = US_TXDIS;
+}
+static void _INLINE_ tx_start(volatile struct atmel_usart_regs *uart, int ints)
+{
+	if (ints) {
+		tx_enable(uart);
+	}
+	uart->cr = US_TXEN;
+}
+static void _INLINE_ rx_stop(volatile struct atmel_usart_regs *uart)
+{
+	rx_disable(uart);
+	uart->rtor = 0;
+	// PSW fixes slew of ^@ chars on a TCSETA ioctl 
+        //uart->rcr = 0;
+	uart->cr = US_RXDIS;
+}
+static void _INLINE_ rx_start(volatile struct atmel_usart_regs *uart, int ints)
+{
+	uart->cr = US_RXEN | US_STTO;
+	uart->rtor = 20;
+	if (ints) {
+		rx_enable(uart);
+	}
+}
+static void _INLINE_ reset_status(volatile struct atmel_usart_regs *uart)
+{
+	uart->cr = US_RSTSTA;
+}
+static void set_ints_mode(int yes, struct atmel_serial *info)
+{
+	info->use_ints = yes;
+// FIXME: check
+#if 0
+	(yes) ? unmask_irq(info->irq) : mask_irq(info->irq);
+#endif
+}
+
+#ifdef US_RTS
+static void atmel_cts_off(struct atmel_serial *info)
+{
+	volatile struct atmel_usart_regs *uart;
+
+	uart = info->usart;
+	uart->mc &= ~(unsigned long) US_RTS;
+	info->cts_state = 0;
+}
+static void atmel_cts_on(struct atmel_serial *info)
+{
+	volatile struct atmel_usart_regs *uart;
+
+	uart = info->usart;
+	uart->mc |= US_RTS;
+	info->cts_state = 1;
+}
+/* Sets or clears DTR/RTS on the requested line */
+static inline void atmel_rtsdtr(struct atmel_serial *ss, int set)
+{
+        volatile struct atmel_usart_regs *uart;
+
+        uart = ss->usart;
+        if (set) {
+              uart->mc |= US_DTR | US_RTS;
+        } else {
+              uart->mc &= ~(unsigned long) (US_DTR | US_RTS);
+        }
+        return;
+}
+#endif	/* US_RTS */
+
+/*
+ * ------------------------------------------------------------
+ * rs_stop() and rs_start()
+ *
+ * This routines are called before setting or resetting tty->stopped.
+ * They enable or disable transmitter interrupts, as necessary.
+ * ------------------------------------------------------------
+ */
+static void rs_stop(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->name, "rs_stop"))
+		return;
+
+	save_flags(flags); cli();
+	tx_stop(info->usart);
+	rx_stop(info->usart);
+	restore_flags(flags);
+}
+
+static void rs_put_char(struct atmel_serial *info, char ch)
+{
+	int flags = 0;
+
+	save_flags(flags); cli();
+	xmit_char(info, ch);
+	wait_EOT(info->usart);
+	restore_flags(flags);
+}
+
+static void rs_start(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->name, "rs_start"))
+		return;
+
+	save_flags(flags); cli();
+	tx_start(info->usart, info->use_ints);
+	rx_start(info->usart, info->use_ints);
+	/* FIXME */
+//	start_rx(info);
+	restore_flags(flags);
+}
+
+/* Drop into either the boot monitor or kadb upon receiving a break
+ * from keyboard/console input.
+ */
+static void batten_down_hatches(void)
+{
+	/* Drop into the debugger */
+}
+
+static _INLINE_ void status_handle(struct atmel_serial *info, unsigned long status)
+{
+#if 0
+	if (status & DCD) {
+		if ((info->tty->termios->c_cflag & CRTSCTS) &&
+			((info->curregs[3] & AUTO_ENAB) == 0)) {
+			info->curregs[3] |= AUTO_ENAB;
+			info->pendregs[3] |= AUTO_ENAB;
+			write_zsreg(info->atmel_channel, 3, info->curregs[3]);
+		}
+	} else {
+		if ((info->curregs[3] & AUTO_ENAB)) {
+			info->curregs[3] &= ~AUTO_ENAB;
+			info->pendregs[3] &= ~AUTO_ENAB;
+			write_zsreg(info->atmel_channel, 3, info->curregs[3]);
+		}
+	}
+#endif
+	/* Whee, if this is console input and this is a
+	 * 'break asserted' status change interrupt, call
+	 * the boot prom.
+	 */
+	if ((status & US_RXBRK) && info->break_abort)
+		batten_down_hatches();
+
+	/* XXX Whee, put in a buffer somewhere, the status information
+	 * XXX whee whee whee... Where does the information go...
+	 */
+	reset_status(info->usart);
+	return;
+}
+
+static _INLINE_ void receive_chars(struct atmel_serial *info, unsigned long status)
+{
+	int count;
+	volatile struct atmel_usart_regs *uart = info->usart;
+
+	struct tty_struct *tty = info->tty;
+
+	if (!(info->flags & S_INITIALIZED))
+		return;
+	count = RX_SERIAL_SIZE - uart->rcr;
+	// hack to receive chars by polling only BD fields
+	if (!count) {
+		return;
+	}
+
+	if (!tty)
+		goto clear_and_exit;
+
+	if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+		schedule_work(&tty->flip.work);
+
+	if ((count tty->flip.count) >= TTY_FLIPBUF_SIZE) {
+#ifdef US_RTS
+		atmel_cts_off(info);
+#endif
+		serialpoll.data = (void *) info;
+		schedule_work(&serialpoll);
+	}
+	memset(tty->flip.flag_buf_ptr, 0, count);
+	memcpy(tty->flip.char_buf_ptr, info->rx_buf, count);
+	tty->flip.char_buf_ptr += count;
+
+	if (status & US_PARE)
+		*(tty->flip.flag_buf_ptr - 1) = TTY_PARITY;
+	else if (status & US_OVRE)
+		*(tty->flip.flag_buf_ptr - 1) = TTY_OVERRUN;
+	else if (status & US_FRAME)
+		*(tty->flip.flag_buf_ptr - 1) = TTY_FRAME;
+
+	tty->flip.count += count;
+
+	schedule_work(&tty->flip.work);
+
+  clear_and_exit:
+	start_rx(info);
+	return;
+}
+
+static _INLINE_ void transmit_chars(struct atmel_serial *info)
+{
+	if (info->x_char) {
+		/* Send next char */
+		xmit_char(info, info->x_char);
+		info->x_char = 0;
+		goto clear_and_return;
+	}
+
+	if ((info->xmit_cnt <= 0) || info->tty->stopped) {
+		/* That's peculiar... */
+		tx_stop(info->usart);
+		goto clear_and_return;
+	}
+
+	if (info->xmit_tail info->xmit_cnt < SERIAL_XMIT_SIZE) {
+		xmit_string(info, info->xmit_buf info->xmit_tail,
+					info->xmit_cnt);
+		info->xmit_tail =
+			(info->xmit_tail info->xmit_cnt) & (SERIAL_XMIT_SIZE - 1);
+		info->xmit_cnt = 0;
+	} else {
+		coucou1();
+		xmit_string(info, info->xmit_buf info->xmit_tail,
+					SERIAL_XMIT_SIZE - info->xmit_tail);
+		//xmit_string(info, info->xmit_buf, info->xmit_tail info->xmit_cnt - SERIAL_XMIT_SIZE);
+		info->xmit_cnt =
+			info->xmit_cnt - (SERIAL_XMIT_SIZE - info->xmit_tail);
+		info->xmit_tail = 0;
+	}
+
+	if (info->xmit_cnt < WAKEUP_CHARS)
+		schedule_work(&info->tqueue);
+
+	if (info->xmit_cnt <= 0) {
+		//tx_stop(info->usart);
+		goto clear_and_return;
+	}
+
+  clear_and_return:
+	/* Clear interrupt (should be auto) */
+	return;
+}
+
+/*
+ * This is the serial driver's generic interrupt routine
+ */
+static irqreturn_t rs_interrupta(int irq, void *dev_id, struct pt_regs *regs)
+{
+	return rs_interrupt(&atmel_info[0]);
+}
+static irqreturn_t rs_interruptb(int irq, void *dev_id, struct pt_regs *regs)
+{
+	return rs_interrupt(&atmel_info[1]);
+}
+static irqreturn_t rs_interrupt(struct atmel_serial *info)
+{
+	unsigned long status;
+
+	status = info->usart->csr;
+	if (status & (US_ENDRX | US_TIMEOUT)) {
+		receive_chars(info, status);
+	}
+	if (status & (US_TXEMPTY)) {
+		transmit_chars(info);
+	}
+	status_handle(info, status);
+
+#ifdef US_RTS
+	if (!info->cts_state) {
+		if (info->tty->flip.count < TTY_FLIPBUF_SIZE - RX_SERIAL_SIZE) {
+			atmel_cts_on(info);
+		}
+	}
+#endif
+	if (!info->use_ints) {
+		serialpoll.data = (void *) info;
+		schedule_work(&serialpoll);
+	}
+	return IRQ_HANDLED;
+}
+static void serpoll(void *data)
+{
+	struct atmel_serial *info = data;
+
+	rs_interrupt(info);
+}
+
+/*
+ * -------------------------------------------------------------------
+ * Here ends the serial interrupt routines.
+ * -------------------------------------------------------------------
+ */
+
+
+static void do_softint(void *private_)
+{
+	struct atmel_serial *info = (struct atmel_serial *) private_;
+	struct tty_struct *tty;
+
+	tty = info->tty;
+	if (!tty)
+		return;
+#if 0 	// FIXME - CHECK
+	if (clear_bit(RS_EVENT_WRITE_WAKEUP, &info->event)) {
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+			tty->ldisc.write_wakeup) (tty->ldisc.write_wakeup) (tty);
+		wake_up_interruptible(&tty->write_wait);
+	}
+#endif
+}
+
+/*
+ * This routine is called from the scheduler tqueue when the interrupt
+ * routine has signalled that a hangup has occurred.  The path of
+ * hangup processing is:
+ *
+ * 	serial interrupt routine -> (scheduler tqueue) ->
+ * 	do_serial_hangup() -> tty->hangup() -> rs_hangup()
+ *
+ */
+static void do_serial_hangup(void *private_)
+{
+	struct atmel_serial *info = (struct atmel_serial *) private_;
+	struct tty_struct *tty;
+
+	tty = info->tty;
+	if (!tty)
+		return;
+
+	tty_hangup(tty);
+}
+
+
+/*
+ * This subroutine is called when the RS_TIMER goes off.  It is used
+ * by the serial driver to handle ports that do not have an interrupt
+ * (irq=0).  This doesn't work at all for 16450's, as a sun has a Z8530.
+ */
+#if 0
+static void rs_timer(void)
+{
+	panic("rs_timer called\n");
+	return;
+}
+#endif
+
+static unsigned long calcCD(unsigned long br)
+{
+	return (UART_CLOCK / br);
+}
+
+static void uart_init(struct atmel_serial *info)
+{
+	volatile struct atmel_usart_regs *uart;
+
+	if (info) {
+		uart = info->usart;
+	} else {
+		uart = usarts[0];
+	}
+
+	/* Reset the USART */
+	uart->cr = US_TXDIS | US_RXDIS | US_RSTTX | US_RSTRX;
+	/* clear Rx receive and Tx sent counters */
+	uart->rcr = 0;
+	uart->tcr = 0;
+
+	/* Disable interrups till we say we want them */
+	tx_disable(info->usart);
+	rx_disable(info->usart);
+	
+	/* Set the serial port into a safe sane state */
+	uart->mr = US_USCLKS(0) | US_CLK0 | US_CHMODE(0) | US_NBSTOP(0) |
+		    US_PAR(4) | US_CHRL(3);
+
+#ifndef FORCE_57600
+	uart->brgr = calcCD(9600);
+#else
+	uart->brgr = calcCD(57600);
+#endif
+
+	uart->rtor = 20;			// timeout = value * 4 *bit period
+	uart->ttgr = 0;				// no guard time
+	uart->rcr = 0;
+	uart->rpr = 0;
+	uart->tcr = 0;
+	uart->tpr = 0;
+#ifdef US_RTS
+	uart->mc = 0; 
+#endif
+}
+
+/* It is the responsibilty of whoever calls this function to be sure
+ * that that have called
+ *	tx_stop(uart); rx_stop(uart);
+ * before calling the function.  Failure to do this will cause messy
+ * things to happen.  You have been warned.   */
+static void uart_speed(struct atmel_serial *info, unsigned cflag)
+{
+	unsigned baud = info->baud;
+	volatile struct atmel_usart_regs *uart = info->usart;
+
+	// disable tx and rx
+	uart->cr = US_TXDIS | US_RXDIS;
+	
+	// disable interrupts
+	tx_disable(uart);
+	rx_disable(uart);
+	
+#ifndef FORCE_57600
+	uart->brgr = calcCD(baud);
+#else
+	uart->brgr = calcCD(57600);
+#endif
+/* FIXME */
+#if 0
+	/* probably not needed */
+	uart->US_RTOR = 20;			// timeout = value * 4 *bit period
+	uart->US_TTGR = 0;				// no guard time
+	uart->US_RPR = 0;
+	uart->US_RCR = 0;
+	uart->US_TPR = 0;
+	uart->US_TCR = 0;
+#endif
+
+
+/* FIXME */
+#if 0
+	uart->mc = 0;
+	if (cflag != 0xffff) {
+		uart->mr = US_USCLKS(0) | US_CLK0 | US_CHMODE(0) | US_NBSTOP(0) |
+		    US_PAR(0);
+
+		if ((cflag & CSIZE) == CS8)
+			uart->mr |= US_CHRL(3);	// 8 bit char
+		else
+			uart->mr |= US_CHRL(2);	// 7 bit char
+
+		if (cflag & CSTOPB)
+			uart->mr |= US_NBSTOP(2);	// 2 stop bits
+
+		if (!(cflag & PARENB))
+			uart->mr |= US_PAR(4);	// parity disabled
+		else if (cflag & PARODD)
+			uart->mr |= US_PAR(1);	// odd parity
+	}
+#endif	
+	
+/* FIXME */
+#if 0
+	// enable tx and rx
+	uart->cr = US_TXEN | US_RXEN;
+	
+	// enable interrupts
+	tx_enable();
+	rx_enable();
+#endif
+	tx_start(uart, info->use_ints);
+	start_rx(info);
+}
+
+static void wait_EOT(volatile struct atmel_usart_regs *uart)
+{
+	// make sure tx is enabled
+	uart->cr = US_TXEN;
+	
+	// wait until all chars sent FIXME - is this sane ?
+	while (1) {
+		if (uart->csr & US_TXEMPTY)
+			break;
+	}
+}
+static int startup(struct atmel_serial *info)
+{
+	unsigned long flags;
+
+	if (info->flags & S_INITIALIZED)
+		return 0;
+
+	if (!info->xmit_buf) {
+		info->xmit_buf = (unsigned char *) __get_free_page(GFP_KERNEL);
+		if (!info->xmit_buf)
+			return -ENOMEM;
+	}
+	if (!info->rx_buf) {
+	    //info->rx_buf = (unsigned char *) ))__get_free_page(GFP_KERNEL);
+		//info->rx_buf = rx_buf1;
+		if (!info->rx_buf)
+			return -ENOMEM;
+	}
+	save_flags(flags);
+	cli();
+#ifdef SERIAL_DEBUG_OPEN
+	printk("starting up ttyS%d (irq %d)...\n", info->line, info->irq);
+#endif
+	/*
+	 * Clear the FIFO buffers and disable them
+	 * (they will be reenabled in change_speed())
+	 */
+
+	if (info->tty)
+		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
+
+	/*
+	 * and set the speed of the serial port
+	 */
+
+	uart_init(info);
+	//set_ints_mode(0, info);
+	change_speed(info);
+	info->flags |= S_INITIALIZED;
+	restore_flags(flags);
+	return 0;
+}
+
+/*
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ */
+static void shutdown(struct atmel_serial *info)
+{
+	unsigned long flags;
+
+	tx_disable(info->usart);
+	rx_disable(info->usart);
+	rx_stop(info->usart);		/* All off! */
+	if (!(info->flags & S_INITIALIZED))
+		return;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("Shutting down serial port %d (irq %d)....\n", info->line,
+		   info->irq);
+#endif
+
+	save_flags(flags);
+	cli();						/* Disable interrupts */
+
+	if (info->xmit_buf) {
+		free_page((unsigned long) info->xmit_buf);
+		info->xmit_buf = 0;
+	}
+
+	if (info->tty)
+		set_bit(TTY_IO_ERROR, &info->tty->flags);
+
+	info->flags &= ~S_INITIALIZED;
+	restore_flags(flags);
+}
+
+/* rate = 1036800 / ((65 - prescale) * (1<<divider)) */
+
+static int baud_table[] = {
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
+	9600, 19200, 38400, 57600, 115200, 0
+};
+
+/*
+ * This routine is called to set the UART divisor registers to match
+ * the specified baud rate for a serial port.
+ */
+static void change_speed(struct atmel_serial *info)
+{
+	unsigned cflag;
+	int      i;
+
+	if (!info->tty || !info->tty->termios)
+		return;
+	cflag = info->tty->termios->c_cflag;
+
+	// disable tx and rx
+	info->usart->cr = US_TXDIS | US_RXDIS;
+	
+	/* First disable the interrupts */
+	tx_stop(info->usart);
+	rx_stop(info->usart);
+
+	/* set the baudrate */
+	i = cflag & CBAUD;
+
+	info->baud = baud_table[i];
+	uart_speed(info, cflag);
+	tx_start(info->usart, info->use_ints);
+	rx_start(info->usart, info->use_ints);
+
+	// enable tx and rx
+	info->usart->cr = US_TXEN | US_RXEN;
+	
+	return;
+}
+
+static void start_rx(struct atmel_serial *info)
+{
+	volatile struct atmel_usart_regs *uart = info->usart;
+
+	rx_stop(uart);
+/*  FIXME - rehnberg
+	if (info->rx_buf == rx_buf1) {
+		info->rx_buf = rx_buf2;
+	} else {
+		info->rx_buf = rx_buf1;
+	}
+*/
+	uart->rpr = (unsigned long) info->rx_buf;
+	uart->rcr = (unsigned long) RX_SERIAL_SIZE;
+	rx_start(uart, info->use_ints);
+}
+static void xmit_char(struct atmel_serial *info, char ch)
+{
+	prompt0 = ch;
+	xmit_string(info, &prompt0, 1);
+}
+static void xmit_string(struct atmel_serial *info, char *p, int len)
+{
+	info->usart->tcr = 0;
+	info->usart->tpr = (unsigned long) p;
+	info->usart->tcr = (unsigned long) len;
+	tx_start(info->usart, info->use_ints);
+}
+
+/*
+ * atmel_console_print is registered for printk.
+ */
+int atmel_console_initialized;
+
+static void init_console(struct atmel_serial *info)
+{
+	memset(info, 0, sizeof(struct atmel_serial));
+
+#ifdef CONFIG_SWAP_ATMEL_PORTS
+	info->usart = (volatile struct atmel_usart_regs *) AT91_USART1_BASE;
+	info->irqmask = AIC_URT1;
+	info->irq = IRQ_USART1;
+#else
+	info->usart = (volatile struct atmel_usart_regs *) AT91_USART0_BASE;
+	info->irqmask = 1<<IRQ_USART0;
+	info->irq = IRQ_USART0;
+#endif
+	info->tty = 0;
+	info->port = 0;
+	info->use_ints = 0;
+	info->cts_state = 1;
+	info->is_cons = 1;
+	atmel_console_initialized = 1;
+}
+
+
+void console_print_atmel(const char *p)
+{
+	char c;
+	struct atmel_serial *info;
+
+#ifdef CONFIG_SWAP_ATMEL_PORTS
+	info = &atmel_info[1];
+#else
+	info = &atmel_info[0];
+#endif
+
+	if (!atmel_console_initialized) {
+		init_console(info);
+		uart_init(info);
+		info->baud = 9600;
+		tx_stop(info->usart);
+		rx_stop(info->usart);
+		uart_speed(info, 0xffff);
+		tx_start(info->usart, info->use_ints);
+		rx_start(info->usart, info->use_ints);
+	}
+
+	while ((c = *(p++)) != 0) {
+		if (c == '\n')
+			rs_put_char(info, '\r');
+		rs_put_char(info, c);
+	}
+
+	/* Comment this if you want to have a strict interrupt-driven output */
+#if 0
+	if (!info->use_ints)
+	    rs_fair_output(info);
+#endif
+
+	return;
+}
+
+static void rs_set_ldisc(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->name, "rs_set_ldisc"))
+		return;
+
+	info->is_cons = (tty->termios->c_line == N_TTY);
+
+	printk("ttyS%d console mode %s\n", info->line,
+		   info->is_cons ? "on" : "off");
+}
+
+static void rs_flush_chars(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->name, "rs_flush_chars"))
+		return;
+	if (!info->use_ints) {
+		for (;;) {
+			if (info->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
+				!info->xmit_buf) return;
+
+			/* Enable transmitter */
+			save_flags(flags);
+			cli();
+			tx_start(info->usart, info->use_ints);
+		}
+	} else {
+		if (info->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
+			!info->xmit_buf) return;
+
+		/* Enable transmitter */
+		save_flags(flags);
+		cli();
+		tx_start(info->usart, info->use_ints);
+	}
+
+	if (!info->use_ints)
+		wait_EOT(info->usart);
+	/* Send char */
+	xmit_char(info, info->xmit_buf[info->xmit_tail++]);
+	info->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE - 1);
+	info->xmit_cnt--;
+
+	restore_flags(flags);
+}
+
+extern void console_printn(const char *b, int count);
+
+static int rs_write(struct tty_struct *tty, int from_user,
+					const unsigned char *buf, int count)
+{
+	int c, total = 0;
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->name, "rs_write"))
+		return 0;
+
+	if (!tty || !info->xmit_buf)
+		return 0;
+
+	save_flags(flags);
+	while (1) {
+		cli();
+		c = MIN(count, MIN(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+						   SERIAL_XMIT_SIZE - info->xmit_head));
+		if (c <= 0)
+			break;
+
+		if (from_user) {
+			down(&tmp_buf_sem);
+			copy_from_user(tmp_buf, buf, c);
+			memcpy(info->xmit_buf info->xmit_head, tmp_buf, c);
+			up(&tmp_buf_sem);
+		} else {
+			memcpy(info->xmit_buf info->xmit_head, buf, c);
+		}
+		info->xmit_head = (info->xmit_head c) & (SERIAL_XMIT_SIZE - 1);
+		info->xmit_cnt += c;
+		restore_flags(flags);
+		buf += c;
+		count -= c;
+		total += c;
+	}
+
+	if (info->xmit_cnt && !tty->stopped && !tty->hw_stopped) {
+		/* Enable transmitter */
+
+		cli();
+		/*printk("Enabling transmitter\n"); */
+
+		if (!info->use_ints) {
+			while (info->xmit_cnt) {
+				wait_EOT(info->usart);
+				/* Send char */
+				xmit_char(info, info->xmit_buf[info->xmit_tail++]);
+				wait_EOT(info->usart);
+				info->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE - 1);
+				info->xmit_cnt--;
+			}
+		} else {
+			if (info->xmit_cnt) {
+				/* Send char */
+				wait_EOT(info->usart);
+				if (info->xmit_tail info->xmit_cnt < SERIAL_XMIT_SIZE) {
+					xmit_string(info, info->xmit_buf info->xmit_tail,
+								info->xmit_cnt);
+					info->xmit_tail =
+						(info->xmit_tail +
+						 info->xmit_cnt) & (SERIAL_XMIT_SIZE - 1);
+					info->xmit_cnt = 0;
+				} else {
+					coucou2();
+					xmit_string(info, info->xmit_buf info->xmit_tail,
+								SERIAL_XMIT_SIZE - info->xmit_tail);
+					//xmit_string(info, info->xmit_buf, info->xmit_tail info->xmit_cnt - SERIAL_XMIT_SIZE);
+					info->xmit_cnt =
+						info->xmit_cnt - (SERIAL_XMIT_SIZE - info->xmit_tail);
+					info->xmit_tail = 0;
+				}
+			}
+		}
+	} else {
+		/*printk("Skipping transmit\n"); */
+	}
+
+#if 0
+	printk("Enabling stuff anyhow\n");
+	tx_start(0);
+
+	if (SCC_EOT(0, 0)) {
+		printk("TX FIFO empty.\n");
+		/* Send char */
+		atmel_xmit_char(info->usart, info->xmit_buf[info->xmit_tail++]);
+		info->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE - 1);
+		info->xmit_cnt--;
+	}
+#endif
+
+	restore_flags(flags);
+	return total;
+}
+
+static int rs_write_room(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	int ret;
+
+	if (serial_paranoia_check(info, tty->name, "rs_write_room"))
+		return 0;
+	ret = SERIAL_XMIT_SIZE - info->xmit_cnt - 1;
+	if (ret < 0)
+		ret = 0;
+	return ret;
+}
+
+static int rs_chars_in_buffer(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->name, "rs_chars_in_buffer"))
+		return 0;
+	return info->xmit_cnt;
+}
+
+static void rs_flush_buffer(struct tty_struct *tty)
+{
+	unsigned long flags;
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->name, "rs_flush_buffer"))
+		return;
+	save_flags(flags);
+	cli();
+	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
+	restore_flags(flags);
+	wake_up_interruptible(&tty->write_wait);
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+		tty->ldisc.write_wakeup) (tty->ldisc.write_wakeup) (tty);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_throttle()
+ *
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled.
+ * ------------------------------------------------------------
+ */
+static void rs_throttle(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+#ifdef SERIAL_DEBUG_THROTTLE
+	char buf[64];
+
+	printk("throttle %s: %d....\n", _tty_name(tty, buf),
+		   tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (serial_paranoia_check(info, tty->name, "rs_throttle"))
+		return;
+
+	if (I_IXOFF(tty))
+		info->x_char = STOP_CHAR(tty);
+
+	/* Turn off RTS line (do this atomic) */
+}
+
+static void rs_unthrottle(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+#ifdef SERIAL_DEBUG_THROTTLE
+	char buf[64];
+
+	printk("unthrottle %s: %d....\n", _tty_name(tty, buf),
+		   tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (serial_paranoia_check(info, tty->name, "rs_unthrottle"))
+		return;
+
+	if (I_IXOFF(tty)) {
+		if (info->x_char)
+			info->x_char = 0;
+		else
+			info->x_char = START_CHAR(tty);
+	}
+
+	/* Assert RTS line (do this atomic) */
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_ioctl() and friends
+ * ------------------------------------------------------------
+ */
+
+static int get_serial_info(struct atmel_serial *info,
+						   struct serial_struct *retinfo)
+{
+	struct serial_struct tmp;
+
+	if (!retinfo)
+		return -EFAULT;
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.type = info->type;
+	tmp.line = info->line;
+	tmp.port = info->port;
+	tmp.irq = info->irq;
+	tmp.flags = info->flags;
+	tmp.baud_base = info->baud_base;
+	tmp.close_delay = info->close_delay;
+	tmp.closing_wait = info->closing_wait;
+	tmp.custom_divisor = info->custom_divisor;
+	copy_to_user(retinfo, &tmp, sizeof(*retinfo));
+	return 0;
+}
+
+static int set_serial_info(struct atmel_serial *info,
+						   struct serial_struct *new_info)
+{
+	struct serial_struct new_serial;
+	struct atmel_serial old_info;
+	int retval = 0;
+
+	if (!new_info)
+		return -EFAULT;
+	copy_from_user(&new_serial, new_info, sizeof(new_serial));
+	old_info = *info;
+
+	if (!capable(CAP_SYS_ADMIN)) {
+		if ((new_serial.baud_base != info->baud_base) ||
+			(new_serial.type != info->type) ||
+			(new_serial.close_delay != info->close_delay) ||
+			((new_serial.flags & ~S_USR_MASK) !=
+		     (info->flags & ~S_USR_MASK)))
+			return -EPERM;
+		info->flags = ((info->flags & ~S_USR_MASK) |
+					   (new_serial.flags & S_USR_MASK));
+		info->custom_divisor = new_serial.custom_divisor;
+		goto check_and_exit;
+	}
+
+	if (info->count > 1)
+		return -EBUSY;
+
+	/*
+	 * OK, past this point, all the error checking has been done.
+	 * At this point, we start making changes.....
+	 */
+
+	info->baud_base = new_serial.baud_base;
+	info->flags = ((info->flags & ~S_FLAGS) |
+				   (new_serial.flags & S_FLAGS));
+	info->type = new_serial.type;
+	info->close_delay = new_serial.close_delay;
+	info->closing_wait = new_serial.closing_wait;
+
+  check_and_exit:
+	//retval = startup(info);
+	change_speed(info);
+	retval = 0;
+	return retval;
+}
+
+/*
+ * get_lsr_info - get line status register info
+ *
+ * Purpose: Let user call ioctl() to get info when the UART physically
+ * 	    is emptied.  On bus types like RS485, the transmitter must
+ * 	    release the bus after transmitting. This must be done when
+ * 	    the transmit shift register is empty, not be done when the
+ * 	    transmit holding register is empty.  This functionality
+ * 	    allows an RS485 driver to be written in user space.
+ */
+static int get_lsr_info(struct atmel_serial *info, unsigned int *value)
+{
+	unsigned char status;
+
+	cli();
+	status = info->usart->csr;
+	status &= US_TXEMPTY;
+	sti();
+	put_user(status, value);
+	return 0;
+}
+
+/*
+ * This routine sends a break character out the serial port.
+ */
+static void send_break(struct atmel_serial *info, int duration)
+{
+        unsigned long flags;
+        if (!info->port)  return;
+
+	current->state = TASK_INTERRUPTIBLE;
+	save_flags(flags); cli();
+	info->usart->cr = US_STTBRK;
+	if (!info->use_ints) {
+		while (US_TXRDY != (info->usart->csr & US_TXRDY)) {
+			;					// this takes max 2ms at 9600
+		}
+		info->usart->cr = US_STPBRK;
+	}
+	restore_flags(flags);
+}
+
+static int rs_ioctl(struct tty_struct *tty, struct file *file,
+					unsigned int cmd, unsigned long arg)
+{
+	int error;
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	int retval;
+
+	if (serial_paranoia_check(info, tty->name, "rs_ioctl"))
+		return -ENODEV;
+
+	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+		(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGWILD) &&
+		(cmd != TIOCSERSWILD) && (cmd != TIOCSERGSTRUCT)) {
+		if (tty->flags & (1 << TTY_IO_ERROR))
+			return -EIO;
+	}
+
+	switch (cmd) {
+	case TCSBRK:				/* SVID version: non-zero arg --> no break */
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		if (!arg)
+			send_break(info, HZ / 4);	/* 1/4 second */
+		return 0;
+	case TCSBRKP:				/* support for POSIX tcsendbreak() */
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		send_break(info, arg ? arg * (HZ / 10) : HZ / 4);
+		return 0;
+	case TIOCGSOFTCAR:
+		error = verify_area(VERIFY_WRITE, (void *) arg, sizeof(long));
+		if (error)
+			return error;
+		put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long *) arg);
+		return 0;
+	case TIOCSSOFTCAR:
+		arg = get_user(arg,(unsigned long *) arg);
+		tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) | (arg ? CLOCAL : 0));
+		return 0;
+	case TIOCGSERIAL:
+		error = verify_area(VERIFY_WRITE, (void *) arg, sizeof(struct serial_struct));
+		if (error)
+			return error;
+		return get_serial_info(info, (struct serial_struct *) arg);
+	case TIOCSSERIAL:
+		return set_serial_info(info, (struct serial_struct *) arg);
+	case TIOCSERGETLSR:		/* Get line status register */
+		error = verify_area(VERIFY_WRITE, (void *) arg,
+			sizeof(unsigned int));
+		if (error)
+			return error;
+		else
+			return get_lsr_info(info, (unsigned int *) arg);
+
+	case TIOCSERGSTRUCT:
+		error = verify_area(VERIFY_WRITE, (void *) arg,
+			sizeof(struct atmel_serial));
+		if (error)
+			return error;
+		copy_to_user((struct atmel_serial *) arg, info,
+			sizeof(struct atmel_serial));
+		return 0;
+
+	case TCSETS:	
+		handle_termios_tcsets((struct termios *)arg, info);
+		//		return set_serial_info(info, (struct serial_struct *) arg);
+		break;	
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+static void handle_termios_tcsets(struct termios * ptermios, struct atmel_serial * pinfo )
+{
+	/*
+	 * hmmmm....
+	 */
+	if (pinfo->tty->termios->c_cflag != ptermios->c_cflag)
+		pinfo->tty->termios->c_cflag = ptermios->c_cflag;
+	change_speed(pinfo);
+}
+	  
+static void rs_set_termios(struct tty_struct *tty,
+	struct termios *old_termios)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (tty->termios->c_cflag == old_termios->c_cflag)
+		return;
+
+	change_speed(info);
+
+	if ((old_termios->c_cflag & CRTSCTS) &&
+		!(tty->termios->c_cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		rs_start(tty);
+	}
+
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_close()
+ *
+ * This routine is called when the serial port gets closed.  First, we
+ * wait for the last remaining data to be sent.  Then, we unlink its
+ * S structure from the interrupt chain if necessary, and we free
+ * that IRQ if nothing is left in the chain.
+ * ------------------------------------------------------------
+ */
+static void rs_close(struct tty_struct *tty, struct file *filp)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+	unsigned long flags;
+
+	if (!info || serial_paranoia_check(info, tty->name, "rs_close"))
+		return;
+
+	save_flags(flags);
+	cli();
+
+	if (tty_hung_up_p(filp)) {
+		restore_flags(flags);
+		return;
+	}
+#ifdef SERIAL_DEBUG_OPEN
+	printk("rs_close ttyS%d, count = %d\n", info->line, info->count);
+#endif
+	if ((tty->count == 1) && (info->count != 1)) {
+		/*
+		 * Uh, oh.  tty->count is 1, which means that the tty
+		 * structure will be freed.  Info->count should always
+		 * be one in these conditions.  If it's greater than
+		 * one, we've got real problems, since it means the
+		 * serial port won't be shutdown.
+		 */
+		printk("rs_close: bad serial port count; tty->count is 1, "
+			   "info->count is %d\n", info->count);
+		info->count = 1;
+	}
+	if (--info->count < 0) {
+		printk("rs_close: bad serial port count for ttyS%d: %d\n",
+			   info->line, info->count);
+		info->count = 0;
+	}
+	if (info->count) {
+		restore_flags(flags);
+		return;
+	}
+	// closing port so disable interrupts
+	set_ints_mode(0, info);
+
+	info->flags |= S_CLOSING;
+	/*
+	 * Now we wait for the transmit buffer to clear; and we notify
+	 * the line discipline to only process XON/XOFF characters.
+	 */
+	tty->closing = 1;
+	if (info->closing_wait != S_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->closing_wait);
+	/*
+	 * At this point we stop accepting input.  To do this, we
+	 * disable the receive line status interrupts, and tell the
+	 * interrupt driver to stop checking the data ready bit in the
+	 * line status register.
+	 */
+
+	shutdown(info);
+	if (tty->driver->flush_buffer)
+		tty->driver->flush_buffer(tty);
+	if (tty->ldisc.flush_buffer)
+		tty->ldisc.flush_buffer(tty);
+	tty->closing = 0;
+	info->event = 0;
+	info->tty = 0;
+	if (tty->ldisc.num != ldiscs[N_TTY].num) {
+		if (tty->ldisc.close)
+			(tty->ldisc.close) (tty);
+		tty->ldisc = ldiscs[N_TTY];
+		tty->termios->c_line = N_TTY;
+		if (tty->ldisc.open)
+			(tty->ldisc.open) (tty);
+	}
+	if (info->blocked_open) {
+		if (info->close_delay) {
+			current->state = TASK_INTERRUPTIBLE;
+			schedule_timeout(info->close_delay);
+		}
+		wake_up_interruptible(&info->open_wait);
+	}
+	info->flags &= ~(S_NORMAL_ACTIVE | S_CALLOUT_ACTIVE | S_CLOSING);
+	wake_up_interruptible(&info->close_wait);
+	restore_flags(flags);
+}
+
+/*
+ * rs_hangup() --- called by tty_hangup() when a hangup is signaled.
+ */
+static void rs_hangup(struct tty_struct *tty)
+{
+	struct atmel_serial *info = (struct atmel_serial *) tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->name, "rs_hangup"))
+		return;
+
+	rs_flush_buffer(tty);
+	shutdown(info);
+	info->event = 0;
+	info->count = 0;
+	info->flags &= ~S_NORMAL_ACTIVE;
+	info->tty = 0;
+	wake_up_interruptible(&info->open_wait);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_open() and friends
+ * ------------------------------------------------------------
+ */
+static int block_til_ready(struct tty_struct *tty, struct file *filp,
+						   struct atmel_serial *info)
+{
+	DECLARE_WAITQUEUE(wait, current); 
+	int retval;
+	int do_clocal = 0;
+
+	/*
+	 * If the device is in the middle of being closed, then block
+	 * until it's done, and then try again.
+	 */
+	if (info->flags & S_CLOSING) {
+		interruptible_sleep_on(&info->close_wait);
+#ifdef SERIAL_DO_RESTART
+		if (info->flags & S_HUP_NOTIFY)
+			return -EAGAIN;
+		else
+			return -ERESTARTSYS;
+#else
+		return -EAGAIN;
+#endif
+	}
+
+	/*
+	 * If non-blocking mode is set, or the port is not enabled,
+	 * then make the check up front and then exit.
+	 */
+	if ((filp->f_flags & O_NONBLOCK) ||
+	    (tty->flags & (1 << TTY_IO_ERROR))) {
+		info->flags |= S_NORMAL_ACTIVE;
+		return 0;
+	}
+
+	if (tty->termios->c_cflag & CLOCAL)
+		do_clocal = 1;
+
+	/*
+	 * Block waiting for the carrier detect and the line to become
+	 * free (i.e., not in use by the callout).  While we are in
+	 * this loop, info->count is dropped by one, so that
+	 * rs_close() knows when to free things.  We restore it upon
+	 * exit, either normal or abnormal.
+	 */
+	retval = 0;
+	add_wait_queue(&info->open_wait, &wait);
+#ifdef SERIAL_DEBUG_OPEN
+	printk("block_til_ready before block: ttyS%d, count = %d\n",
+		   info->line, info->count);
+#endif
+	info->count--;
+	info->blocked_open++;
+	while (1) {
+#ifdef US_RTS
+		save_flags(flags);
+		cli();
+		atmel_rtsdtr(info, 1);
+		restore_flags(flags);
+#endif
+		current->state = TASK_INTERRUPTIBLE;
+		if (tty_hung_up_p(filp) ||
+	    	     !(info->flags & S_INITIALIZED)) {
+#ifdef SERIAL_DO_RESTART
+			if (info->flags & S_HUP_NOTIFY)
+				retval = -EAGAIN;
+			else
+				retval = -ERESTARTSYS;
+#else
+			retval = -EAGAIN;
+#endif
+			break;
+		}
+		if (!(info->flags & S_CLOSING) && do_clocal)
+			break;
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			break;
+		}
+#ifdef SERIAL_DEBUG_OPEN
+		printk("block_til_ready blocking: ttyS%d, count = %d\n",
+			   info->line, info->count);
+#endif
+		schedule();
+	}
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&info->open_wait, &wait);
+	if (!tty_hung_up_p(filp))
+		info->count++;
+	info->blocked_open--;
+#ifdef SERIAL_DEBUG_OPEN
+	printk("block_til_ready after blocking: ttyS%d, count = %d\n",
+		   info->line, info->count);
+#endif
+	if (retval)
+		return retval;
+	info->flags |= S_NORMAL_ACTIVE;
+	if (!info->use_ints) {
+		serialpoll.data = (void *) info;
+		schedule_work(&serialpoll);
+	}
+	return 0;
+}
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port, linking in its S structure into
+ * the IRQ chain.   It also performs the serial-specific
+ * initialization for the tty structure.
+ */
+int rs_open(struct tty_struct *tty, struct file *filp)
+{
+	struct atmel_serial *info;
+	int retval, line;
+
+	line = tty->index;
+
+	// check if line is sane
+	if (line < 0 || line >= AT91_USART_CNT)
+		return -ENODEV;
+
+	info = &atmel_info[line];
+	if (serial_paranoia_check(info, tty->name, "rs_open"))
+		return -ENODEV;
+
+	info->count++;
+	tty->driver_data = info;
+	info->tty = tty;
+
+	/*
+	 * Start up serial port
+	 */
+	set_ints_mode(1, info);
+	
+	retval = startup(info);
+	if (retval)
+		return retval;
+
+	return block_til_ready(tty, filp, info);
+}
+
+
+static struct irqaction irq_usart0 =
+	{ rs_interrupta, 0, 0, "usart0", NULL, NULL };
+static struct irqaction irq_usart1 =
+	{ rs_interruptb, 0, 0, "usart1", NULL, NULL };
+
+static void interrupts_init(void)
+{
+	setup_irq(IRQ_USART0, &irq_usart0);
+	setup_irq(IRQ_USART1, &irq_usart1);
+}
+
+static void show_serial_version(void)
+{
+	printk("Atmel USART driver version 0.99\n");
+}
+
+static struct tty_operations rs_ops = {
+	.open = rs_open,
+	.close = rs_close,
+	.write = rs_write,
+	.flush_chars = rs_flush_chars,
+	.write_room = rs_write_room,
+	.chars_in_buffer = rs_chars_in_buffer,
+	.flush_buffer = rs_flush_buffer,
+	.ioctl = rs_ioctl,
+	.throttle = rs_throttle,
+	.unthrottle = rs_unthrottle,
+	.set_termios = rs_set_termios,
+	.stop = rs_stop,
+	.start = rs_start,
+	.hangup = rs_hangup,
+	.set_ldisc = rs_set_ldisc,
+};
+
+/* rs_init inits the driver */
+static int __init
+rs_atmel_init(void)
+{
+	int flags, i;
+	struct atmel_serial *info;
+
+	/* initialise PIO for serial port */
+	HW_AT91_USART_INIT 
+
+	serial_driver = alloc_tty_driver(2);
+	if (!serial_driver)
+		return -ENOMEM;
+
+	// FIXME - do this right
+	rx_buf_table[0] = rx_buf1;
+	rx_buf_table[1] = rx_buf2;
+	
+	show_serial_version();
+
+	/* Initialize the tty_driver structure */
+
+	// set the tty_struct pointers to NULL to let the layer
+	// above allocate the structs.
+	for (i=0; i < AT91_USART_CNT; i++)
+		serial_table[i] = NULL;
+		
+	serial_driver->name = "ttyS";
+	serial_driver->major = TTY_MAJOR;
+	serial_driver->minor_start = 64;
+	serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	serial_driver->subtype = SERIAL_TYPE_NORMAL;
+	serial_driver->init_termios = tty_std_termios;
+	serial_driver->init_termios.c_cflag = 
+		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	serial_driver->flags = TTY_DRIVER_REAL_RAW;
+	tty_set_operations(serial_driver, &rs_ops);
+
+	if (tty_register_driver(serial_driver)) {
+		put_tty_driver(serial_driver);
+		printk(KERN_ERR "Couldn't register serial driver\n");
+		return -ENOMEM;
+	}
+
+	save_flags(flags); cli();
+	for (i = 0; i < 2; i++) {
+		info = &atmel_info[i];
+		info->magic = SERIAL_MAGIC;
+		info->usart = usarts[i];
+		info->tty = 0;
+		info->irqmask = (i) ? (1<<IRQ_USART1) : (1<<IRQ_USART0);
+		info->irq = (i) ? IRQ_USART1 : IRQ_USART0;
+#ifdef CONFIG_SWAP_ATMEL_PORTS
+		info->port = (i) ? 2 : 1;
+		info->line = !i;
+#ifdef CONFIG_ATMEL_CONSOLE
+		info->is_cons = i;
+#else
+		info->is_cons = 0;
+#endif	
+#else
+		info->port = (i) ? 1 : 2;
+		info->line = i;
+#ifdef CONFIG_ATMEL_CONSOLE
+		info->is_cons = !i;
+#else
+		info->is_cons = 0;
+#endif	
+#endif
+#ifdef CONFIG_CONSOLE_ON_SC28L91
+		info->line += 1;
+#endif
+		set_ints_mode(0, info);
+		info->custom_divisor = 16;
+		info->close_delay = 50;
+		info->closing_wait = 3000;
+		info->cts_state = 1;
+		info->x_char = 0;
+		info->event = 0;
+		info->count = 0;
+		info->blocked_open = 0;
+	    	INIT_WORK(&info->tqueue, do_softint, info);
+	    	INIT_WORK(&info->tqueue_hangup, do_serial_hangup, info);
+		init_waitqueue_head(&info->open_wait);
+		init_waitqueue_head(&info->close_wait);
+		info->rx_buf = rx_buf_table[i];
+
+		printk("%s%d at 0x%p (irq = %d)", serial_driver->name, info->line,
+			   info->usart, info->irq);
+		printk(" is a builtin Atmel APB USART\n");
+	}
+	
+	// FIXME
+	info->usart->cr = 0x1ac; // reset, disable
+	info->usart->idr = 0xffffffff; // disable all interrupts
+	info->usart->tcr = 0; // stop transmit
+	info->usart->rcr = 0; // stop receive
+	
+	interrupts_init();
+
+	restore_flags(flags);
+	// hack to do polling
+	serialpoll.func = serpoll;
+	serialpoll.data = 0;
+
+	return 0;
+}
+
+module_init(rs_atmel_init);
+
+#if 0
+/*
+ * register_serial and unregister_serial allows for serial ports to be
+ * configured at run-time, to support PCMCIA modems.
+ */
+/* SPARC: Unused at this time, just here to make things link. */
+static int register_serial(struct serial_struct *req)
+{
+	return -1;
+}
+
+static void unregister_serial(int line)
+{
+	return;
+}
+
+static void dbg_putc(int ch)
+{
+	static char tmp[2];
+#define US_TPR  (0x38) /* Transmit Pointer Register */
+#define US_TCR  (0x3C) /* Transmit Counter Register */
+
+	tmp[0] = ch;
+
+	outl_t((unsigned long) tmp, (USART0_BASE US_TPR) );
+	outl_t(1, (USART0_BASE US_TCR) );
+
+	while (inl_t((USART0_BASE US_TCR) )) {
+	}
+}
+
+static void dbg_print(const char *str)
+{
+	const char *p;
+
+	for (p = str; *p; p++) {
+		if (*p == '\n') {
+			dbg_putc('\r');
+		}
+		dbg_putc(*p);
+	}
+}
+
+static void dbg_printk(const char *fmt, ...)
+{
+	char tmp[256];
+	va_list args;
+
+	va_start(args, fmt);
+	vsprintf(tmp, fmt, args);
+	va_end(args);
+	dbg_print(tmp);
+}
+
+static void rs_atmel_print(const char *str)
+{
+	dbg_printk(str);
+}
+
+static void dump_a(unsigned long a, unsigned int s)
+{
+	unsigned long q;
+
+	for (q = 0; q < s; q++) {
+		if (q % 16 == 0) {
+			dbg_printk("%08X: ", q a);
+		}
+		if (q % 16 == 7) {
+			dbg_printk("%02X-", *(unsigned char *) (q a));
+		} else {
+			dbg_printk("%02X ", *(unsigned char *) (q a));
+		}
+		if (q % 16 == 15) {
+			dbg_printk(" :\n");
+		}
+	}
+	if (q % 16) {
+		dbg_printk(" :\n");
+	}
+}
+#endif
+
+int atmel_console_setup(struct console *cp, char *arg)
+{
+  if (!cp)
+       return(-1);
+  HW_AT91_USART_INIT
+  return 0;
+}
+
+static struct tty_driver *atmel_console_device(struct console *c, int *index)
+{
+	*index = c->index;
+	return serial_driver;
+}
+
+void atmel_console_write (struct console *co, const char *str,
+			   unsigned int count)
+{
+	struct atmel_serial *info;
+
+#ifdef CONFIG_SWAP_ATMEL_PORTS
+	info = &atmel_info[1];
+#else
+	info = &atmel_info[0];
+#endif
+
+	if (!atmel_console_initialized) {
+		init_console(info);
+		uart_init(info);
+		info->baud = 9600;
+		tx_stop(info->usart);
+		rx_stop(info->usart);
+		uart_speed(info, 0xffff);
+		tx_start(info->usart, info->use_ints);
+		rx_start(info->usart, info->use_ints);
+	}
+
+    	while (count--) {
+        	if (*str == '\n')
+           		rs_put_char(info,'\r');
+        	rs_put_char(info, *str+);
+    	}
+}
+
+static struct console atmel_driver = {
+	name:		"ttyS",
+	write:		atmel_console_write,
+	device:		atmel_console_device,
+	setup:		atmel_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+
+static int __init atmel_console_init(void)
+{
+	register_console(&atmel_driver);
+	return 0;
+}
+
+console_initcall(atmel_console_init);
diff -Naur linux-2.6.9/drivers/serial/serial_atmel.h linux-2.6.9-uc0/drivers/serial/serial_atmel.h
--- linux-2.6.9/drivers/serial/serial_atmel.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/drivers/serial/serial_atmel.h	2004-10-28 11:13:21.000000000 +1000
@@ -0,0 +1,125 @@
+/* serial-atmel.h: Definitions for the Atmel serial driver.
+ *
+ * Copyright (C) 1998  Kenneth Albanowski <kjahds@kjahds.com>,
+ *                     D. Jeff Dionne <jeff@uClinux.org>,
+ *                     The Silver Hammer Group, Ltd.
+ * Copyright (C) 2004 Hyok S. Choi <hyok.choi@samsung.com>
+ *			   2.6 port
+ *
+ * Based on:
+ *
+ * drivers/char/68328serial.h
+ *
+ * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
+ */
+
+#ifndef _ATMEL_SERIAL_H
+#define _ATMEL_SERIAL_H
+
+#include <linux/config.h>
+#include <asm/page.h>
+#include <asm/arch/hardware.h>
+
+/*
+ * For the close wait times, 0 means wait forever for serial port to
+ * flush its output.  65535 means don't wait at all.
+ */
+#define S_CLOSING_WAIT_INF	0
+#define S_CLOSING_WAIT_NONE	65535
+
+/*
+ * Definitions for S_struct (and serial_struct) flags field
+ */
+#define S_HUP_NOTIFY 0x0001 /* Notify getty on hangups and closes 
+				   on the callout port */
+#define S_FOURPORT  0x0002	/* Set OU1, OUT2 per AST Fourport settings */
+#define S_SAK	0x0004	/* Secure Attention Key (Orange book) */
+#define S_SPLIT_TERMIOS 0x0008 /* Separate termios for dialin/callout */
+
+#define S_SPD_MASK	0x0030
+#define S_SPD_HI	0x0010	/* Use 56000 instead of 38400 bps */
+
+#define S_SPD_VHI	0x0020  /* Use 115200 instead of 38400 bps */
+#define S_SPD_CUST	0x0030  /* Use user-specified divisor */
+
+#define S_SKIP_TEST	0x0040 /* Skip UART test during autoconfiguration */
+#define S_AUTO_IRQ  0x0080 /* Do automatic IRQ during autoconfiguration */
+#define S_SESSION_LOCKOUT 0x0100 /* Lock out cua opens based on session */
+#define S_PGRP_LOCKOUT    0x0200 /* Lock out cua opens based on pgrp */
+#define S_CALLOUT_NOHUP   0x0400 /* Don't do hangups for cua device */
+
+#define S_FLAGS	0x0FFF	/* Possible legal S flags */
+#define S_USR_MASK 0x0430	/* Legal flags that non-privileged
+				 * users can set or reset */
+
+/* Internal flags used only by kernel/chr_drv/serial.c */
+#define S_INITIALIZED	0x80000000 /* Serial port was initialized */
+#define S_CALLOUT_ACTIVE	0x40000000 /* Call out device is active */
+#define S_NORMAL_ACTIVE	0x20000000 /* Normal device is active */
+#define S_BOOT_AUTOCONF	0x10000000 /* Autoconfigure port on bootup */
+#define S_CLOSING		0x08000000 /* Serial port is closing */
+#define S_CTS_FLOW		0x04000000 /* Do CTS flow control */
+#define S_CHECK_CD		0x02000000 /* i.e., CLOCAL */
+
+#define RS_EVENT_WRITE_WAKEUP   0
+#define SERIAL_MAGIC 0x5301
+
+/* Software state per channel */
+
+/*
+ * This is our internal structure for each serial port's state.
+ * 
+ * Many fields are paralleled by the structure used by the serial_struct
+ * structure.
+ *
+ * For definitions of the flags field, see tty.h
+ */
+
+struct atmel_serial {
+	char soft_carrier;  /* Use soft carrier on this channel */
+	char break_abort;   /* Is serial console in, so process brk/abrt */
+	char is_cons;       /* Is this our console. */
+
+	/* We need to know the current clock divisor
+	 * to read the bps rate the chip has currently
+	 * loaded.
+	 */
+	unsigned char clk_divisor;  /* May be 1, 16, 32, or 64 */
+	int baud;
+	int			magic;
+	int			baud_base;
+	int			port;
+	int			irq;
+	int			irqmask;
+	int			flags; 		/* defined in tty.h */
+	int			type; 		/* UART type */
+	int			use_ints;
+	volatile struct atmel_usart_regs	*usart;
+	int			cts_state;
+	struct tty_struct 	*tty;
+	int			read_status_mask;
+	int			ignore_status_mask;
+	int			timeout;
+	int			xmit_fifo_size;
+	int			custom_divisor;
+	int			x_char;	/* xon/xoff character */
+	int			close_delay;
+	unsigned short		closing_wait;
+	unsigned short		closing_wait2;
+	unsigned long		event;
+	unsigned long		last_active;
+	int			line;
+	int			count;	    /* # of fd on device */
+	int			blocked_open; /* # of blocked opens */
+	unsigned char 		*xmit_buf;
+	unsigned char 		*rx_buf;
+	int			xmit_head;
+	int			xmit_tail;
+	int			xmit_cnt;
+	struct work_struct	tqueue;
+	struct work_struct	tqueue_hangup;
+	wait_queue_head_t	open_wait;
+	wait_queue_head_t	close_wait;
+};
+
+#endif /* !(_ATMEL_SERIAL_H) */
diff -Naur linux-2.6.9/drivers/serial/serial_s3c4510b.c linux-2.6.9-uc0/drivers/serial/serial_s3c4510b.c
--- linux-2.6.9/drivers/serial/serial_s3c4510b.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/drivers/serial/serial_s3c4510b.c	2004-10-28 11:13:21.000000000 +1000
@@ -0,0 +1,638 @@
+/*
+ *  linux/drivers/serial/serial_s3c4510b.c
+ *
+ *  Driver for S3C4510B serial ports
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Based on drivers/char/serial_amba.c
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/serial_core.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/uart.h>
+
+#define __DRIVER_NAME    "Samsung S3C4510B Internal UART"
+
+#define _SDEBUG
+#ifdef _SDEBUG
+#  define _DPRINTK(format, args...)  \
+          printk (KERN_INFO "%s():%05d "format".\n" , __FUNCTION__ , __LINE__ , ## args);
+#else
+#  define _DPRINTK(format, args...)
+#endif
+
+/**
+ **
+ ** Internal(private) helper functions
+ **
+ **/
+
+static void __xmit_char(struct uart_port *port, const char ch) {
+
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+
+	while( !uart->m_stat.bf.txBufEmpty);
+
+	uart->m_tx = ch;
+
+	if ( ch == '\n') {
+		while( !uart->m_stat.bf.txBufEmpty);
+		uart->m_tx = '\r';
+	}
+
+}
+
+static void __xmit_string(struct uart_port *port, const char *p, int len)
+{
+	while( len-- > 0) {
+		__xmit_char( port, *p++);
+	}
+}
+
+static void __s3c4510b_init(const struct uart_port *port, int baud)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+	UART_CTRL      uctrl;
+	UART_LINE_CTRL ulctrl;
+	UART_BAUD_DIV  ubd;
+
+	/* Reset the UART */
+	/* control register */
+	uctrl.ui = 0x0;
+	uctrl.bf.rxMode = 0x1;
+	uctrl.bf.rxIrq = 0x1;
+	uctrl.bf.txMode = 0x1;
+	uctrl.bf.DSR = 0x1;
+	uctrl.bf.sendBreak = 0x0;
+	uctrl.bf.loopBack = 0x0;
+	uart->m_ctrl.ui = uctrl.ui;
+	
+	/* Set the line control register into a safe sane state */
+	ulctrl.ui  = 0x0;
+	ulctrl.bf.wordLen   = 0x3; /* 8 bit data */
+	ulctrl.bf.nStop     = 0x0; /* 1 stop bit */
+	ulctrl.bf.parity    = 0x0; /* no parity */
+	ulctrl.bf.clk       = 0x0; /* internal clock */
+	ulctrl.bf.infra_red = 0x0; /* no infra_red */
+	uart->m_lineCtrl.ui = ulctrl.ui;
+
+	ubd.ui = 0x0;
+
+	/* see table on page 10-15 in SAMSUNG S3C4510B manual */
+	/* get correct divisor */
+	switch( baud ? baud : 19200) {
+
+	case 1200:
+		ubd.bf.cnt0 = 1301;
+		break;
+
+	case 2400:
+		ubd.bf.cnt0 = 650;
+		break;
+
+	case 4800:
+		ubd.bf.cnt0 = 324;
+		break;
+
+	case 9600:
+		ubd.bf.cnt0 = 162;
+		break;
+
+	case 19200:
+		ubd.bf.cnt0 = 80;
+		break;
+
+	case 38400:
+		ubd.bf.cnt0 = 40;
+		break;
+
+	case 57600:
+		ubd.bf.cnt0 = 26;
+		break;
+
+	case 115200:
+		ubd.bf.cnt0 = 13;
+		break;
+	}
+
+	uart->m_baudDiv.ui = ubd.ui;
+	uart->m_baudCnt = 0x0;
+	uart->m_baudClk = 0x0;
+
+}
+
+/**
+ **
+ ** struct uart_ops functions below
+ **
+ **/
+
+static void __s3c4510b_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+
+}
+
+
+static void __s3c4510b_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	int count;
+
+	// _DPRINTK("called with info = 0x%08x", (unsigned int) port);
+
+	if ( port->x_char) {
+		__xmit_char( port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+
+	if (uart_circ_empty( xmit) || uart_tx_stopped( port)) {
+		__s3c4510b_stop_tx( port, 0);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		__xmit_char( port, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup( port);
+
+	if (uart_circ_empty(xmit))
+		__s3c4510b_stop_tx( port, 0);
+}
+
+static void __s3c4510b_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+	__s3c4510b_tx_chars( port);
+}
+
+static void __s3c4510b_send_xchar(struct uart_port *port, char ch)
+{
+	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static void __s3c4510b_stop_rx(struct uart_port *port)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+	UART_CTRL      uctrl;
+
+	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	uctrl.ui = uart->m_ctrl.ui;
+	uctrl.bf.rxMode = 0x0;
+	uart->m_ctrl.ui = uctrl.ui;
+}
+
+static void __s3c4510b_enable_ms(struct uart_port *port)
+{
+	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static void __s3c4510b_rx_char(struct uart_port *port)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+	struct tty_struct *tty = port->info->tty;
+	unsigned int ch;
+	UART_STAT status;
+
+	status.ui = uart->m_stat.ui;
+	if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+		tty->flip.work.func((void *)tty);
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+			printk(KERN_WARNING "TTY_DONT_FLIP set\n");
+			return;
+		}
+	}
+
+	ch = uart->m_rx & 0xFF;
+
+	*tty->flip.char_buf_ptr = ch;
+	*tty->flip.flag_buf_ptr = TTY_NORMAL;
+	port->icount.rx++;
+
+	/*
+	 * Note that the error handling code is
+	 * out of the main execution path
+	 */
+	if ( status.bf.breakIrq) {
+		port->icount.brk++;
+		if (uart_handle_break(port))
+			goto ignore_char;
+		*tty->flip.flag_buf_ptr = TTY_BREAK;
+	}
+	else if ( status.bf.parity) {
+		port->icount.parity++;
+		*tty->flip.flag_buf_ptr = TTY_PARITY;
+	}
+	else if ( status.bf.frame) {
+		port->icount.frame++;
+		*tty->flip.flag_buf_ptr = TTY_FRAME;
+	}
+	else if ( status.bf.overrun) {
+		port->icount.overrun++;
+		if ( tty->flip.count < TTY_FLIPBUF_SIZE) {
+			/*
+			 * Overrun is special, since it's reported
+			 * immediately, and doesn't affect the current
+			 * character
+			 */
+			*tty->flip.char_buf_ptr++ = 0;
+			*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+			tty->flip.count++;
+		}
+	}
+	else {
+		/* no errors */
+		tty->flip.flag_buf_ptr++;
+		tty->flip.char_buf_ptr++;
+		tty->flip.count++;
+	}
+
+ignore_char:
+
+	tty_flip_buffer_push(tty);
+
+
+}
+
+static irqreturn_t __s3c4510b_rx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+//	_DPRINTK("called with irq = 0x%08x", irq);
+
+	struct uart_port *port = dev_id;
+
+	LED_SET(2);
+	__s3c4510b_rx_char( port);		
+	LED_CLR(2);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t __s3c4510b_tx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+//	_DPRINTK("called with irq = 0x%08x", irq);
+
+	struct uart_port *port = dev_id;
+
+	LED_SET(1);
+	__s3c4510b_start_tx( port, 0);		
+	LED_CLR(1);
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int __s3c4510b_tx_empty(struct uart_port *port)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	return uart->m_stat.bf.txBufEmpty ? 1 : 0;
+}
+
+static unsigned int __s3c4510b_get_mctrl(struct uart_port *port)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	return 0;
+}
+
+static void __s3c4510b_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+//	_DPRINTK("called with port = 0x%08x, mctrl = 0x%08x", (unsigned int) port, mctrl);
+}
+
+static void __s3c4510b_break_ctl(struct uart_port *port, int break_state)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static struct irqaction __rx_irqaction[UART_NR] = {
+	{
+		name:	  "serial0_rx",
+		flags:	  SA_INTERRUPT,
+		handler:  __s3c4510b_rx_int,
+	},
+	{
+		name:	  "serial1_rx",
+		flags:	  SA_INTERRUPT,
+		handler:  __s3c4510b_rx_int,
+	},
+};
+
+static struct irqaction __tx_irqaction[UART_NR] = {
+	{
+		name:	  "serial0_tx",
+		flags:	  SA_INTERRUPT,
+		handler:  __s3c4510b_tx_int,
+	},
+	{
+		name:	  "serial1_tx",
+		flags:	  SA_INTERRUPT,
+		handler:  __s3c4510b_tx_int,
+	},
+};
+
+static int __s3c4510b_startup(struct uart_port *port)
+{
+	int status;
+
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	__s3c4510b_init(port, 19200);
+
+	/*
+	 * Allocate the IRQs for TX and RX
+	 */
+	__tx_irqaction[port->line].dev_id = (void *)port;
+	__rx_irqaction[port->line].dev_id = (void *)port;
+
+	status = setup_irq( port->irq, &__tx_irqaction[port->line]);
+	if ( status) {
+		printk( KERN_ERR "Unabled to hook interrupt for serial %d TX\n", port->line);
+		return status;
+	}
+
+	status = setup_irq( port->irq+1, &__rx_irqaction[port->line]);
+	if ( status) {
+		printk( KERN_ERR "Unabled to hook interrupt for serial %d RX\n", port->line);
+		return status;
+	}
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	spin_lock_irq( &port->lock);
+	INT_ENABLE( port->irq);
+	INT_ENABLE( port->irq+1);
+	spin_unlock_irq( &port->lock);
+
+	return 0;
+}
+
+static void __s3c4510b_shutdown(struct uart_port *port)
+{
+	struct uart_regs *uart = (struct uart_regs *)port->iobase;
+
+	// _DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	INT_DISABLE( port->irq);
+	INT_DISABLE( port->irq+1);
+
+	/* turn off TX/RX */
+	uart->m_ctrl.ui = 0x0;
+
+}
+
+static void __s3c4510b_set_termios(struct uart_port *port, struct termios *termios, struct termios *old)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+
+	/**
+	 ** Ignore -- only 19200 baud supported
+	 **/
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, 19200);
+
+}
+
+static void __s3c4510b_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+//	_DPRINTK("called with port = 0x%08x, state = %u", (unsigned int) port, state);
+}
+
+static int __s3c4510b_set_wake(struct uart_port *port, unsigned int state)
+{
+//	_DPRINTK("called with port = 0x%08x, state = %u", (unsigned int) port, state);
+	return 0;
+}
+
+static const char *__s3c4510b_type(struct uart_port *port)
+{
+	return __DRIVER_NAME;
+}
+
+
+static void __s3c4510b_release_port(struct uart_port *port)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static int __s3c4510b_request_port(struct uart_port *port)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+	return 0;
+}
+
+static void __s3c4510b_config_port(struct uart_port *port, int config)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+}
+
+static int __s3c4510b_verify_port(struct uart_port *port, struct serial_struct *serial)
+{
+//	_DPRINTK("called with port = 0x%08x", (unsigned int) port);
+	return 0;
+}
+
+#if 0
+static int __s3c4510b_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+//	_DPRINTK("called with port = 0x%08x, cmd %u, arg 0x%08lx", (unsigned int) port, cmd, arg);
+	return 0;
+}
+#endif
+
+static struct uart_ops s3c4510b_pops = {
+	tx_empty:	__s3c4510b_tx_empty,
+	set_mctrl:	__s3c4510b_set_mctrl,
+	get_mctrl:	__s3c4510b_get_mctrl,
+	stop_tx:	__s3c4510b_stop_tx,
+	start_tx:	__s3c4510b_start_tx,
+	send_xchar:     __s3c4510b_send_xchar,
+	stop_rx:	__s3c4510b_stop_rx,
+	enable_ms:	__s3c4510b_enable_ms,
+	break_ctl:	__s3c4510b_break_ctl,
+	startup:	__s3c4510b_startup,
+	shutdown:	__s3c4510b_shutdown,
+	set_termios:    __s3c4510b_set_termios,
+	pm:             __s3c4510b_pm,
+	set_wake:       __s3c4510b_set_wake,
+	type:           __s3c4510b_type,
+	release_port:   __s3c4510b_release_port,
+	request_port:   __s3c4510b_request_port,
+	config_port:    __s3c4510b_config_port,
+	verify_port:    __s3c4510b_verify_port,
+//	ioctl:          __s3c4510b_ioctl,
+};
+
+
+static struct uart_port __s3c4510b_ports[UART_NR] = {
+	{
+		iobase:			UART0_BASE,
+		line: 			0,
+		irq:			INT_UARTTX0,
+		fifosize:		1,
+		ops:			&s3c4510b_pops,
+		ignore_status_mask:	0x0000000F,
+		type:			PORT_S3C4510B,
+	},
+	{
+		iobase:			UART1_BASE,
+		line:			1,
+		irq:			INT_UARTTX1,
+		fifosize:		1,
+		ops:			&s3c4510b_pops,
+		ignore_status_mask:	0x0000000F,
+		type:			PORT_S3C4510B,
+	}
+};
+
+#ifdef CONFIG_SERIAL_S3C4510B_CONSOLE
+/************** console driver *****************/
+
+static void __s3c4510b_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = &__s3c4510b_ports[co->index];
+
+	__xmit_string( port, s, count);
+
+}
+
+static int __init __s3c4510b_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 19200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 0;
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	port = uart_get_console(__s3c4510b_ports, UART_NR, co);
+
+//	_DPRINTK("using port = 0x%08x", (unsigned int) port);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	__s3c4510b_init(port, baud);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver __s3c4510b_driver;
+static struct console __s3c4510b_console = {
+	name:           "ttyS",
+	write:		__s3c4510b_console_write,
+	device:		uart_console_device,
+	setup:		__s3c4510b_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+	data:           &__s3c4510b_driver,
+};
+
+static int __init __s3c4510b_console_init(void)
+{
+	register_console(&__s3c4510b_console);
+	return 0;
+}
+
+console_initcall(__s3c4510b_console_init);
+
+#endif /* CONFIG_SERIAL_S3C4510B_CONSOLE */
+
+
+static struct uart_driver __s3c4510b_driver = {
+	owner:           THIS_MODULE,
+	driver_name:     __DRIVER_NAME,
+	dev_name:        "ttyS",
+	major:           TTY_MAJOR,
+	minor:           64,
+	nr:              UART_NR,
+#ifdef CONFIG_SERIAL_S3C4510B_CONSOLE
+	cons:            &__s3c4510b_console,
+#endif
+};
+
+static int __init __s3c4510b_serial_init(void)
+{
+
+	int    status, i;
+
+//	_DPRINTK("initializing driver with drv = 0x%08x", (unsigned int) &__s3c4510b_driver);
+
+	status = uart_register_driver( &__s3c4510b_driver);
+
+	if ( status) {
+		_DPRINTK("uart_register_driver() returned %d", status);
+	}
+
+	for ( i = 0; i < UART_NR; i++) {
+		status = uart_add_one_port( &__s3c4510b_driver, &__s3c4510b_ports[i]);
+		if ( status) {
+			_DPRINTK("uart_add_one_port(%d) returned %d", i, status);
+		}
+	}
+	
+	return 0;
+}
+
+module_init(__s3c4510b_serial_init);
+
diff -Naur linux-2.6.9/drivers/serial/t32.c linux-2.6.9-uc0/drivers/serial/t32.c
--- linux-2.6.9/drivers/serial/t32.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/drivers/serial/t32.c	2004-10-28 11:13:21.000000000 +1000
@@ -0,0 +1,550 @@
+/*
+ *  linux/drivers/serial/t32.c
+ *
+ *  serial port emulation driver for the TRACE32 Terminal.
+ *
+ * JTAG1 protocol version for ICD:
+ * 	Copyright (C) 2003, 2004 Hyok S. Choi (hyok.choi@samsung.com)
+ * 	SAMSUNG ELECTRONICS Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   Oct-2003 Hyok S. Choi	Created
+ *   Feb-2004 Hyok S. Choi 	Updated for serial_core.c and 2.6 kernel
+ *   Apr-2004 Hyok S. Choi 	xmit_string_CR added
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/major.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <linux/serial_core.h>
+
+#if 0
+	/* real irq interrupt used */
+	#define T32_IRQ_USED
+#else
+	/* scheduled work used */
+	#undef T32_IRQ_USED
+#endif
+
+#ifndef  T32_IRQ_USED
+static struct work_struct t32_poll_task;
+static void t32_poll(void *data);
+#endif
+
+#define UART_NR			1	/* we have only one JTAG port */
+
+#define SERIAL_T32_NAME	"ttyJ"
+#define SERIAL_T32_MAJOR	4
+#define SERIAL_T32_MINOR	64
+
+static int __inline__ __check_JTAG_RX_FLAG(void)
+{
+	int __ret=0;
+	__asm__ __volatile__(
+		"	mrc		p14, 0, %0, c0, c0 	@ read comms control reg\n"
+		"	and		%0, %0, #1		@ jtag read buffer status"
+		: "=r" (__ret)
+		);
+
+	/* if   __ret 	== 0 : no input yet
+				== 1 : a character pending */
+	return __ret;	
+}
+
+static void __inline__ __get_JTAG_RX(volatile char *p)
+{
+	__asm__ __volatile__(
+		"	mrc		p14, 0, r3, c1, c0 	@ read comms data reg to r5\n"
+		"	strb 		r3, 	[%0]		@ str a char"
+		: /* no output */
+		: "r" (p)
+		: "r3",  "memory");
+}
+
+
+static int __inline__ __check_JTAG_TX_FLAG(void)
+{
+	int __ret=0;
+	__asm__ __volatile__(
+		"	mrc		p14, 0, %0, c0, c0 	@ read comms control reg\n"
+		"	and 		%0, %0, #2		@ the read buffer status"
+		: "=r" (__ret)
+		);
+
+	/* if   __ret 	== 0 : tx is available
+				== 2 : tx busy */
+	return __ret;	
+}
+
+void xmit_string(char *p, int len)
+{
+#ifndef CONFIG_JTAG_T32_OUTPUT_DISABLE
+	/*
+		r0 = string	; string address
+		r1 = 2		; state check bit (write)
+		r4 = *string	; character
+		r7 = 0		; count
+	*/
+		__asm__ __volatile__(
+			"	mov r7, #0\n"
+			"1: 	mrc	p14, 0, r3, c0, c0 	@ read comms control reg\n"
+			"	and r3, r3, #2			@ the write buffer status\n"
+			"	cmp r3, #2			@ is it available?\n"
+			"	beq 1b				@ is not, wait till then\n"
+			"	ldrb r4, [%0]			@ load a char\n"
+			"	mcr p14, 0, r4, c1, c0	@ write it\n"
+			"	add %0, %0, #1		@ str address increase one\n"
+			"	add r7, r7, #1			@ count increase\n"
+			"	cmp r7, %1			@ compare with str length\n"
+			"	bne 1b				@ if it is not yet, loop"
+			: /* no output register */
+			: "r" (p), "r" (len)
+			: "r7", "r3", "r4");
+#endif
+}
+
+void xmit_string_CR(char *p, int len)
+{
+#ifndef CONFIG_JTAG_T32_OUTPUT_DISABLE
+	/*
+		r0 = string	; string address
+		r1 = 2		; state check bit (write)
+		r4 = *string	; character
+		r7 = 0		; count
+	*/
+		__asm__ __volatile__(
+			"	mov r7, #0\n"
+			"	ldrb r4, [%0]			@ load a char\n"
+			"1: 	mrc	p14, 0, r3, c0, c0 	@ read comms control reg\n"
+			"	and r3, r3, #2			@ the write buffer status\n"
+			"	cmp r3, #2			@ is it available?\n"
+			"	beq 1b				@ is not, wait till then\n"
+			"	mcr p14, 0, r4, c1, c0	@ write it\n"
+			"	cmp r4, #0x0a		@ is it LF?\n"
+			"	bne 2f				@ if it is not, continue\n"
+			"	mov r4, #0x0d		@ set the CR\n"
+			"	b   1b				@ loop for writing CR\n"			
+			"2:	ldrb r4, [%0, #1]!		@ load a char\n"
+			"	add r7, r7, #1			@ count increase\n"
+			"	cmp r7, %1			@ compare with str length\n"
+			"	bne 1b				@ if it is not yet, loop"
+			: /* no output register */
+			: "r" (p), "r" (len)
+			: "r7", "r3", "r4");
+#endif
+}
+
+
+static void
+t32_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+}
+
+static inline void
+t32_transmit_buffer(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+
+	int pendings = uart_circ_chars_pending(xmit);
+
+	if(pendings + xmit->tail > UART_XMIT_SIZE)
+	{
+		xmit_string(&(xmit->buf[xmit->tail]), UART_XMIT_SIZE - xmit->tail);
+		xmit_string(&(xmit->buf[0]), xmit->head);
+	} else
+		xmit_string(&(xmit->buf[xmit->tail]), pendings);
+	
+	xmit->tail = (xmit->tail + pendings) & (UART_XMIT_SIZE-1);
+        port->icount.tx += pendings;
+
+	if (uart_circ_empty(xmit))
+		t32_stop_tx(port, 0); 
+}
+
+static inline void
+t32_transmit_x_char(struct uart_port *port)
+{
+	xmit_string(&port->x_char, 1);
+	port->icount.tx++;
+	port->x_char = 0;
+}
+
+static void
+t32_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+    t32_transmit_buffer(port);
+}
+
+static void
+t32_stop_rx(struct uart_port *port)
+{
+}
+
+static void
+t32_enable_ms(struct uart_port *port)
+{
+}
+
+static inline void
+t32_rx_chars(struct uart_port *port)
+{
+	unsigned char ch;
+	struct tty_struct *tty = port->info->tty;
+
+	/*
+	 * check input.
+	 * checking JTAG flag is better to resolve the status test.
+	 * incount is NOT used for JTAG1 protocol.
+	 */
+
+	if (__check_JTAG_RX_FLAG())
+		/* if   __ret 	== 0 : no input yet
+					== 1 : a character pending */
+	{
+		/* for JTAG 1 protocol, incount is always 1. */
+		__get_JTAG_RX(&ch);
+		if (tty->flip.count < TTY_FLIPBUF_SIZE) {
+			*tty->flip.char_buf_ptr++ = ch;
+			*tty->flip.flag_buf_ptr++ = TTY_NORMAL;
+			port->icount.rx++;
+			tty->flip.count++;
+		} 
+		tty_flip_buffer_push(tty);
+	}
+}
+
+static inline void
+t32_overrun_chars(struct uart_port *port)
+{
+	port->icount.overrun++;
+}
+
+static inline void
+t32_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+
+	if (port->x_char) {
+		t32_transmit_x_char(port);
+		return; 
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		t32_stop_tx(port, 0);
+		return;
+	}
+
+	t32_transmit_buffer(port);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+}
+
+#ifdef T32_IRQ_USED /* real IRQ used */
+static irqreturn_t
+t32_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_port *port = dev_id;
+	int handled = 0;
+
+	spin_lock(&port->lock);
+	
+	t32_rx_chars(port);
+	t32_tx_chars(port);
+
+	handled = 1;
+	spin_unlock(&port->lock);
+	
+	return IRQ_RETVAL(handled);
+}
+
+#else /* emulation by scheduled work */
+static void
+t32_poll(void *data)
+{
+	struct uart_port *port = data;
+
+	spin_lock(&port->lock);
+	
+	t32_rx_chars(port);
+	t32_tx_chars(port);
+
+	schedule_delayed_work(&t32_poll_task, 1);
+
+	spin_unlock(&port->lock);
+	
+}
+#endif /* end of T32_IRQ_USED */
+
+static unsigned int
+t32_tx_empty(struct uart_port *port)
+{
+	return TIOCSER_TEMT;
+}
+
+static unsigned int
+t32_get_mctrl(struct uart_port *port)
+{
+	return 0;
+}
+
+static void
+t32_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static void
+t32_break_ctl(struct uart_port *port, int break_state)
+{
+}
+
+static int t32_startup(struct uart_port *port)
+{
+#ifdef T32_IRQ_USED /* real IRQ used */
+	int retval;
+
+	/* Allocate the IRQ */
+	retval = request_irq(port->irq, t32_int, SA_INTERRUPT,
+			     "serial_t32", port);
+	if (retval)
+		return retval;
+#else /* emulation */
+	/* Initialize the work, and shcedule it. */
+	INIT_WORK(&t32_poll_task, t32_poll, port);
+	schedule_delayed_work(&t32_poll_task, 1);
+#endif
+
+	return 0;
+}
+
+static void t32_shutdown(struct uart_port *port)
+{
+}
+
+static void
+t32_set_termios(struct uart_port *port, struct termios *termios,
+		   struct termios *old)
+{
+#ifdef T32_IRQ_USED
+	unsigned long flags;
+#endif
+	unsigned int baud, quot;
+
+	/*
+	 * We don't support parity, stop bits, or anything other
+	 * than 8 bits, so clear these termios flags.
+	 */
+	termios->c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD | CREAD);
+	termios->c_cflag |= CS8;
+
+	/*
+	 * We don't appear to support any error conditions either.
+	 */
+	termios->c_iflag &= ~(INPCK | IGNPAR | IGNBRK | BRKINT);
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); 
+	quot = uart_get_divisor(port, baud);
+
+#ifdef T32_IRQ_USED
+	spin_lock_irqsave(&port->lock, flags);
+#endif
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+#ifdef T32_IRQ_USED
+	spin_unlock_irqrestore(&port->lock, flags);
+#endif
+}
+
+static const char *t32_type(struct uart_port *port)
+{
+	return port->type == PORT_T32_JTAG1 ? "T32" : NULL;
+}
+
+static void t32_release_port(struct uart_port *port)
+{
+}
+
+static int t32_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void t32_config_port(struct uart_port *port, int flags)
+{
+        if (flags & UART_CONFIG_TYPE) {
+                port->type = PORT_T32_JTAG1;
+                t32_request_port(port);
+        }
+}
+        
+/*      
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */     
+static int t32_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+        int ret = 0;
+        if (ser->type != PORT_UNKNOWN && ser->type != PORT_T32_JTAG1)
+                ret = -EINVAL;
+        if (ser->irq < 0 || ser->irq >= NR_IRQS)
+                ret = -EINVAL;
+        if (ser->baud_base < 9600)
+                ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops t32_pops = {
+	.tx_empty	= t32_tx_empty,
+	.set_mctrl	= t32_set_mctrl,
+	.get_mctrl	= t32_get_mctrl,
+	.stop_tx	= t32_stop_tx,
+	.start_tx	= t32_start_tx,
+	.stop_rx	= t32_stop_rx,
+	.enable_ms	= t32_enable_ms,
+	.break_ctl	= t32_break_ctl,
+	.startup	= t32_startup,
+	.shutdown	= t32_shutdown,
+	.set_termios	= t32_set_termios,
+	.type		= t32_type,
+	.release_port  = t32_release_port,
+	.request_port = t32_request_port,
+	.config_port = t32_config_port,
+	.verify_port = t32_verify_port,
+};
+
+static struct uart_port t32_ports[UART_NR] = {
+	{
+		.membase	= (char*)0x12345678,	/* we need these garbages */
+		.mapbase	= 0x12345678,		/* for serial_core.c */
+		.iotype		= SERIAL_IO_MEM,	
+#ifdef T32_IRQ_USED
+		.irq			= INT_N_EXT0,
+#else
+		.irq			= 0,
+#endif
+		.uartclk		= 14745600,			 
+		.fifosize		= 0,
+		.ops			= &t32_pops,
+		.flags		= ASYNC_BOOT_AUTOCONF,
+		.line			= 0,
+	},
+};
+
+
+#ifdef CONFIG_SERIAL_T32_CONSOLE
+
+static void
+t32_console_write(struct console *co, const char *s, unsigned int count)
+{
+	xmit_string_CR((char*)s, count);
+}
+
+/*
+ * Read the current UART setup.
+ */
+static void __init
+t32_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	*baud = 9600;
+	*parity = 'n';
+	*bits = 8;
+}
+
+static int __init
+t32_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index >= UART_NR)
+		co->index = 0;
+	port = &t32_ports[co->index];
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		t32_console_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver t32_reg;
+static struct console t32_console = {
+	.name		= SERIAL_T32_NAME,
+	.write		= t32_console_write,
+	.device		= uart_console_device,
+	.setup		= t32_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &t32_reg,
+};
+
+static int __init t32_console_init(void)
+{
+	register_console(&t32_console);
+	return 0;
+}
+console_initcall(t32_console_init);
+
+#define T32_CONSOLE		&t32_console
+#else
+#define T32_CONSOLE		NULL
+#endif
+
+static struct uart_driver t32_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= SERIAL_T32_NAME,
+	.dev_name		= SERIAL_T32_NAME,
+	.major			= SERIAL_T32_MAJOR,
+	.minor			= SERIAL_T32_MINOR,
+	.nr				= UART_NR,
+	.cons			= T32_CONSOLE,
+};
+
+static int __init
+t32_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "T32: JTAG1 Serial emulation driver driver $Revision: 1.1 $\n");
+
+	ret = uart_register_driver(&t32_reg);
+	if (ret == 0) {
+		int i;
+
+		for (i = 0; i < UART_NR; i++)
+			uart_add_one_port(&t32_reg, &t32_ports[i]);
+	}
+	return ret;
+}
+
+__initcall(t32_init);
+
+MODULE_DESCRIPTION("T32 JTAG1 serial and console emulation driver");
+MODULE_AUTHOR("Hyok S. Choi <hyok.choi@samsung.com>");
+MODULE_SUPPORTED_DEVICE("ttyJ");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.9/include/asm-armnommu/a.out.h linux-2.6.9-uc0/include/asm-armnommu/a.out.h
--- linux-2.6.9/include/asm-armnommu/a.out.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/a.out.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/a.out.h>
diff -Naur linux-2.6.9/include/asm-armnommu/apm.h linux-2.6.9-uc0/include/asm-armnommu/apm.h
--- linux-2.6.9/include/asm-armnommu/apm.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/apm.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/apm.h>
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/at91x40.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/at91x40.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/at91x40.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/at91x40.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1,57 @@
+/*
+ ******************* AT91x40xxx ********************
+ */
+
+#define ARM_CLK	CONFIG_ARM_CLK
+
+#define AT91_USART_CNT 2
+#define AT91_USART0_BASE	(0xfffd0000)
+#define AT91_USART1_BASE	(0xfffcc000)
+#define AT91_TC_BASE		(0xfffe0000)
+#define AIC_BASE		(0xfffff000)	
+#define AT91_PIOA_BASE		(0xffff0000)
+#define AT91_SF_CIDR		(0xfff00000)
+
+#define HARD_RESET_NOW()
+
+#define HW_AT91_TIMER_INIT(timer)	/* no PMC */
+
+/* use TC0 as hardware timer to create high resolution timestamps for debugging.
+ *  Timer 0 must be set up as a free running counter, e.g. in the bootloader
+ */
+#define HW_COUNTER  (((struct at91_timers *)AT91_TC_BASE)->chans[0].ch.cv)
+
+/* enable US0,US1 */
+#define HW_AT91_USART_INIT ((volatile struct pio_regs *)AT91_PIOA_BASE)->pdr = \
+				PIOA_RXD0|PIOA_TXD0|PIOA_RXD1|PIOA_TXD1; 
+/* PIOA bit allocation */
+#define PIOA_TCLK0	(1<<0)					
+#define PIOA_TI0A0	(1<<1)					
+#define PIOA_TI0B0	(1<<2)					
+#define PIOA_TCLK1	(1<<3)					
+#define PIOA_TIOA1	(1<<4)				
+#define PIOA_TIOB1	(1<<5)				
+#define PIOA_TCLK2	(1<<6)					
+#define PIOA_TIOA2	(1<<7)				
+#define PIOA_TIOB2	(1<<8)				
+#define PIOA_IRQ0	(1<<9)				
+#define PIOA_IRQ1	(1<<10)				
+#define PIOA_IRQ2	(1<<11)				
+#define PIOA_FIQ	(1<<12)					
+#define PIOA_SCK0	(1<<13)					
+#define PIOA_TXD0	(1<<14)					
+#define PIOA_RXD0	(1<<15)
+
+#define PIOA_SCK1	(1<<20)					
+#define PIOA_TXD1	(1<<21)					
+#define PIOA_RXD1	(1<<22)
+
+#define PIOA_MCK0	(1<<25)	
+#define PIOA_NCS2	(1<<26)
+#define PIOA_NCS3	(1<<27)	
+
+#define PIOA_A20_CS7	(1<<28)
+#define PIOA_A21_CS6	(1<<29)	
+#define PIOA_A22_CS5	(1<<30)
+#define PIOA_A23_CS4	(1<<31)
+
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/at91x63.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/at91x63.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/at91x63.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/at91x63.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1,73 @@
+/*
+ ******************* AT91x63xxx ********************
+ */
+
+#define ARM_CLK		CONFIG_ARM_CLK
+
+#define AT91_USART_CNT 2
+#define AT91_USART0_BASE	(0xfffc0000)
+#define AT91_USART1_BASE	(0xfffc4000)
+#define AT91_TC_BASE		(0xfffd0000)
+#define AIC_BASE		(0xfffff000)
+#define AT91_PIOA_BASE 		(0xfffec000)
+#define AT91_PIOB_BASE 		(0xffff0000)
+#define AT91_PMC_BASE		(0xffff4000)
+
+/* enable US0,US1 */
+#define HW_AT91_USART_INIT ((volatile struct pmc_regs *)AT91_PMC_BASE)->pcer = \
+				(1<<2) | (1<<3) | (1<<13); \
+			   ((volatile struct pio_regs *)AT91_PIOA_BASE)->pdr = \
+				PIOA_RXD0|PIOA_TXD0|PIOA_RXD1|PIOA_TXD1; 
+
+#define HW_AT91_TIMER_INIT(timer) ((volatile struct pmc_regs *)AT91_PMC_BASE)->pcer = \
+				1<<(timer+6);
+
+/* PIOA bit allocation */
+#define PIOA_TCLK3	(1<<0)					
+#define PIOA_TI0A3	(1<<1)					
+#define PIOA_TI0B3	(1<<2)					
+#define PIOA_TCLK4	(1<<3)					
+#define PIOA_TI0A4	(1<<4)					
+#define PIOA_TI0B4	(1<<5)					
+#define PIOA_TCLK5	(1<<6)					
+#define PIOA_TI0A5	(1<<7)					
+#define PIOA_TI0B5	(1<<8)					
+#define PIOA_IRQ0	(1<<9)
+#define PIOA_IRQ1	(1<<10)
+#define PIOA_IRQ2	(1<<11)
+#define PIOA_IRQ3	(1<<12)
+#define PIOA_FIQ	(1<<13)
+#define PIOA_SCK0	(1<<14)	
+#define PIOA_TXD0	(1<<15)
+#define PIOA_RXD0	(1<<16)
+#define PIOA_SCK1	(1<<17)	
+#define PIOA_TXD1	(1<<18)
+#define PIOA_RXD1	(1<<19)
+#define PIOA_SCK2	(1<<20)	
+#define PIOA_TXD2	(1<<21)
+#define PIOA_RXD2	(1<<22)
+#define PIOA_SPCK	(1<<23)					
+#define PIOA_MISO	(1<<24)					
+#define PIOA_MOSI	(1<<25)					
+#define PIOA_NPCS0	(1<<26)					
+#define PIOA_NPCS1	(1<<27)					
+#define PIOA_NPCS2	(1<<28)					
+#define PIOA_NPCS3	(1<<29)					
+
+/* PIOB bit allocation */
+#define PIOB_MPI_NOE	(1<<0)					
+#define PIOB_MPI_NLB	(1<<1)				
+#define PIOB_MPI_NUB	(1<<2)				
+
+#define PIOB_MCK0	(1<<17)				
+#define PIOB_BMS	(1<<18)				
+#define PIOB_TCLK0	(1<<19)				
+#define PIOB_TIOA0	(1<<20)				
+#define PIOB_TIOB0	(1<<21)				
+#define PIOB_TCLK1	(1<<22)				
+#define PIOB_TIOA1	(1<<23)				
+#define PIOB_TIOB1	(1<<24)				
+#define PIOB_TCLK2	(1<<25)				
+#define PIOB_TIOA2	(1<<26)				
+#define PIOB_TIOB2	(1<<27)		
+
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/dma.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/dma.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/dma.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/dma.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/dma.h
+ *
+ * Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_ATMEL_ARCH_DMA_H
+#define __ASM_ATMEL_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ * 
+ */
+#define MAX_DMA_ADDRESS		0x01000000
+/*
+ * The atmel has 13 internal DMA channels.
+ */
+#define MAX_DMA_CHANNELS        13
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#define arch_dma_init(dma_chan) 
+#endif /* _ASM_ATMEL_ARCH_DMA_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/hardware.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/hardware.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/hardware.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/hardware.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1,255 @@
+/*
+ * linux/include/asm-arm/arch-atmel/hardware.h
+ *
+ * for Atmel AT91 series
+ * 2001 Erwin Authried
+ * 
+ * modified for linux 2.6 by Hyok S. Choi, 2004
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+
+#ifndef __ASSEMBLY__
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(1)
+
+#endif
+
+#define ATMEL_MEM_SIZE     (CONFIG_DRAM_SIZE) 
+#define MEM_SIZE            ATMEL_MEM_SIZE
+#define PA_SDRAM_BASE         CONFIG_DRAM_BASE
+
+/* 0=TC0, 1=TC1, 2=TC2 */
+#define KERNEL_TIMER 1	
+
+#ifdef CONFIG_CPU_AT91X40
+#include "at91x40.h"
+#elif CONFIG_CPU_AT91X63
+#include "at91x63.h"
+#else 
+  #error "Configuration error: No CPU defined"
+#endif
+
+/*
+ ******************* COMMON PART ********************
+ */
+#define AIC_SMR(i)  (AIC_BASE+i*4)
+#define AIC_IVR	    (AIC_BASE+0x100)
+#define AIC_FVR	    (AIC_BASE+0x104)
+#define AIC_ISR	    (AIC_BASE+0x108)
+#define AIC_IPR	    (AIC_BASE+0x10C)
+#define AIC_IMR	    (AIC_BASE+0x110)
+#define AIC_CISR	(AIC_BASE+0x114)
+#define AIC_IECR	(AIC_BASE+0x120)
+#define AIC_IDCR	(AIC_BASE+0x124)
+#define AIC_ICCR	(AIC_BASE+0x128)
+#define AIC_ISCR	(AIC_BASE+0x12C)
+#define AIC_EOICR   (AIC_BASE+0x130)
+
+
+#ifndef __ASSEMBLER__
+struct at91_timer_channel
+{
+	unsigned long ccr;				// channel control register		(WO)
+	unsigned long cmr;				// channel mode register		(RW)
+	unsigned long reserved[2];		
+	unsigned long cv;				// counter value				(RW)
+	unsigned long ra;				// register A					(RW)
+	unsigned long rb;				// register B					(RW)
+	unsigned long rc;				// register C					(RW)
+	unsigned long sr;				// status register				(RO)
+	unsigned long ier;				// interrupt enable register	(WO)
+	unsigned long idr;				// interrupt disable register	(WO)
+	unsigned long imr;				// interrupt mask register		(RO)
+};
+
+struct at91_timers
+{
+	struct {
+		struct at91_timer_channel ch;
+		unsigned char padding[0x40-sizeof(struct at91_timer_channel)];
+	} chans[3];
+	unsigned  long bcr;				// block control register		(WO)
+	unsigned  long bmr;				// block mode	 register		(RW)
+};
+#endif
+
+/*  TC control register */
+#define TC_SYNC	(1)
+
+/*  TC mode register */
+#define TC2XC2S(x)	(x & 0x3)
+#define TC1XC1S(x)	(x<<2 & 0xc)
+#define TC0XC0S(x)	(x<<4 & 0x30)
+#define TCNXCNS(timer,v) ((v) << (timer<<1))
+
+/* TC channel control */
+#define TC_CLKEN	(1)			
+#define TC_CLKDIS	(1<<1)			
+#define TC_SWTRG	(1<<2)			
+
+/* TC interrupts enable/disable/mask and status registers */
+#define TC_MTIOB	(1<<18)
+#define TC_MTIOA	(1<<17)
+#define TC_CLKSTA	(1<<16)
+
+#define TC_ETRGS	(1<<7)
+#define TC_LDRBS	(1<<6)
+#define TC_LDRAS	(1<<5)
+#define TC_CPCS		(1<<4)
+#define TC_CPBS		(1<<3)
+#define TC_CPAS		(1<<2)
+#define TC_LOVRS	(1<<1)
+#define TC_COVFS	(1)
+
+/*
+ *	USART registers
+ */
+
+
+/*  US control register */
+#define US_SENDA	(1<<12)
+#define US_STTO		(1<<11)
+#define US_STPBRK	(1<<10)
+#define US_STTBRK	(1<<9)
+#define US_RSTSTA	(1<<8)
+#define US_TXDIS	(1<<7)
+#define US_TXEN		(1<<6)
+#define US_RXDIS	(1<<5)
+#define US_RXEN		(1<<4)
+#define US_RSTTX	(1<<3)
+#define US_RSTRX	(1<<2)
+
+/* US mode register */
+#define US_CLK0		(1<<18)
+#define US_MODE9	(1<<17)
+#define US_CHMODE(x)(x<<14 & 0xc000)
+#define US_NBSTOP(x)(x<<12 & 0x3000)
+#define US_PAR(x)	(x<<9 & 0xe00)
+#define US_SYNC		(1<<8)
+#define US_CHRL(x)	(x<<6 & 0xc0)
+#define US_USCLKS(x)(x<<4 & 0x30)
+
+/* US interrupts enable/disable/mask and status register */
+#define US_DMSI		(1<<10)
+#define US_TXEMPTY	(1<<9)
+#define US_TIMEOUT	(1<<8)
+#define US_PARE		(1<<7)
+#define US_FRAME	(1<<6)
+#define US_OVRE		(1<<5)
+#define US_ENDTX	(1<<4)
+#define US_ENDRX	(1<<3)
+#define US_RXBRK	(1<<2)
+#define US_TXRDY	(1<<1)
+#define US_RXRDY	(1)
+
+#define US_ALL_INTS (US_DMSI|US_TXEMPTY|US_TIMEOUT|US_PARE|US_FRAME|US_OVRE|US_ENDTX|US_ENDRX|US_RXBRK|US_TXRDY|US_RXRDY)
+
+#ifndef __ASSEMBLER__
+struct atmel_usart_regs{
+	unsigned long cr;		// control 
+	unsigned long mr;		// mode
+	unsigned long ier;		// interrupt enable
+	unsigned long idr;		// interrupt disable
+	unsigned long imr;		// interrupt mask
+	unsigned long csr;		// channel status
+	unsigned long rhr;		// receive holding 
+	unsigned long thr;		// tramsmit holding		
+	unsigned long brgr;		// baud rate generator		
+	unsigned long rtor;		// rx time-out
+	unsigned long ttgr;		// tx time-guard
+	unsigned long res1;
+	unsigned long rpr;		// rx pointer
+	unsigned long rcr;		// rx counter
+	unsigned long tpr;		// tx pointer
+	unsigned long tcr;		// tx counter
+};
+
+static inline void at91_usart_init(volatile struct atmel_usart_regs *uart, int baudrate)
+{
+
+        uart->cr = US_TXDIS | US_RXDIS | US_RSTTX | US_RSTRX;
+        /* clear Rx receive and Tx sent counters */
+        uart->rcr = 0;
+        uart->tcr = 0;
+
+	uart->idr = US_TXEMPTY;		/* tx disable */
+	uart->idr = US_ENDRX | US_TIMEOUT; /* rx disable */
+	
+        /* Set the serial port into a safe sane state */
+        uart->mr = US_USCLKS(0) | US_CLK0 | US_CHMODE(0) | US_NBSTOP(0) |
+                    US_PAR(4) | US_CHRL(3);
+
+        uart->brgr = ARM_CLK/16/baudrate;
+
+        uart->rtor = 20;                        // timeout = value * 4 *bit period
+        uart->ttgr = 0;                         // no guard time
+        uart->rcr = 0;
+        uart->rpr = 0;
+        uart->tcr = 0;
+        uart->tpr = 0;
+#ifdef US_RTS
+        uart->mc = 0;
+#endif
+}
+
+static inline void at91_usart_putc(volatile struct atmel_usart_regs *uart, unsigned char c)
+{
+       uart->cr=US_TXEN;
+       uart->thr=c;
+       while(1) {
+                if (uart->csr & US_TXEMPTY) break;
+       }
+}
+#endif
+		
+#define PIO(i)		(1<<i)
+
+#ifndef __ASSEMBLER__
+struct pio_regs{
+	unsigned long per;
+	unsigned long pdr;
+	unsigned long psr;
+	unsigned long res1;
+	unsigned long oer;
+	unsigned long odr;
+	unsigned long osr;
+	unsigned long res2;
+	unsigned long ifer;
+	unsigned long ifdr;
+	unsigned long ifsr;
+	unsigned long res3;
+	unsigned long sodr;
+	unsigned long codr;
+	unsigned long odsr;
+	unsigned long pdsr;
+	unsigned long ier;
+	unsigned long idr;
+	unsigned long imr;
+	unsigned long isr;
+};
+#endif
+
+#ifndef __ASSEMBLER__
+struct pmc_regs{
+	unsigned long scer;
+	unsigned long scdr;
+	unsigned long scsr;
+	unsigned long reserved;
+	unsigned long pcer;
+	unsigned long pcdr;
+	unsigned long pcsr;
+};
+#endif
+
+#endif  /* _ASM_ARCH_HARDWARE_H */
+
+
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/io.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/io.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/io.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/io.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1,40 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/io.h
+ *
+ * Copyright (C) 1997-1999 Russell King
+ * modified for 2.6 by Hyok S. Choi
+ *
+ * Modifications:
+ *  06-12-1997	RMK	Created.
+ *  07-04-1999	RMK	Major cleanup
+ *  02-19-2001  gjm     Leveraged for armnommu/dsc21
+ *  03-15-2004  hsc     modified 
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a) (CONFIG_IO16_BASE + (a))
+#define __iob(a) (CONFIG_IO8_BASE + (a))	// byte io address
+#define __mem_pci(a)	((unsigned long)(a))	 
+
+/*
+ * Defining these two gives us ioremap for free. See asm/io.h.
+ * --gmcnutt
+ */
+#define iomem_valid_addr(iomem,sz) (1)
+#define iomem_to_phys(iomem) (iomem)
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+# error not_yet_supported
+#define __io_noswap 1
+#endif
+
+#endif
+
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/irq.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/irq.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/irq.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/irq.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1,22 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/irq.h:
+ * 2001 Erwin Authried
+ */
+
+#ifndef __ASM_ARCH_IRQ_H__
+#define __ASM_ARCH_IRQ_H__
+
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+
+#define fixup_irq(x) (x)
+
+extern void at91_mask_irq(unsigned int irq);
+extern void at91_unmask_irq(unsigned int irq);
+extern void at91_mask_ack_irq(unsigned int irq);
+
+#endif /* __ASM_ARCH_IRQ_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/irqs.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/irqs.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/irqs.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/irqs.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1,65 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/irqs.h:
+ * 2001 Mindspeed
+ */
+#ifndef __ASM_ARCH_IRQS_H__
+#define __ASM_ARCH_IRQS_H__
+
+
+#ifdef CONFIG_CPU_AT91X40
+/*
+ ******************* AT91x40xxx ********************
+ */
+
+#define NR_IRQS		24
+#define VALID_IRQ(i)	(i<=8 ||(i>=16 && i<NR_IRQS))
+
+
+#define IRQ_FIQ		0
+#define IRQ_SWI		1
+#define IRQ_USART0	2
+#define IRQ_USART1	3
+#define IRQ_TC0		4
+#define IRQ_TC1		5
+#define IRQ_TC2		6
+#define IRQ_WD		7
+#define IRQ_PIOA	8
+
+#define IRQ_EXT0	16
+#define IRQ_EXT1	17
+#define IRQ_EXT2	18
+
+#elif CONFIG_CPU_AT91X63
+/*
+ ******************* AT91x63xxx ********************
+ */
+
+#define NR_IRQS		32
+#define VALID_IRQ(i)	(i<=14 ||(i>=28 && i<NR_IRQS))
+
+#define IRQ_FIQ		0
+#define IRQ_SWI		1
+#define IRQ_USART0	2
+#define IRQ_USART1	3
+#define IRQ_USART2	4
+#define IRQ_SP		5
+#define IRQ_TC0		6
+#define IRQ_TC1		7
+#define IRQ_TC2		8
+#define IRQ_TC3		9
+#define IRQ_TC4		10
+#define IRQ_TC5		11
+#define IRQ_WD		12
+#define IRQ_PIOA	13
+#define IRQ_PIOB	14
+
+#define IRQ_EXT0	31
+#define IRQ_EXT1	30
+#define IRQ_EXT2	29
+#define IRQ_EXT3	28
+
+#else 
+  #error "Configuration error: No CPU defined"
+#endif
+
+#endif /* __ASM_ARCH_IRQS_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/keyboard.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/keyboard.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/keyboard.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/keyboard.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/keyboard.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  just a cite from other architecture :)
+ */
+#ifndef __ASM_ARM_ARCH_ATMEL_KEYBOARD_H
+#define __ASM_ARM_ARCH_ATMEL_KEYBOARD_H
+
+#define kbd_setkeycode(sc,kc) (-EINVAL)
+#define kbd_getkeycode(sc) (-EINVAL)
+#define kbd_translate(sc,kcp,rm) ({ *(kcp) = (sc); 1; })
+#define kbd_unexpected_up(kc) (0200)
+#define kbd_leds(leds)
+#define kbd_init_hw()
+#define kbd_enable_irq()
+#define kbd_disable_irq()
+
+#endif /* __ASM_ARM_ARCH_ATMEL_KEYBOARD_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/memory.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/memory.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/memory.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/memory.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1,30 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/memory.h
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *		Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x01a00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((unsigned long) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((unsigned long) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/param.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/param.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/param.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/param.h	2004-10-28 11:14:23.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/sizes.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/sizes.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/sizes.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/sizes.h	2004-10-28 11:14:23.000000000 +1000
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/system.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/system.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/system.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/system.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,42 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/system.h
+ *
+ *  Copyright (C) 2002 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+static void arch_idle(void)
+{
+	 cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+ 	/* machine should reboot */
+ 	mdelay(5000);
+ 	panic("Watchdog timer reset failed!\n");
+ 	printk(" Jump to address 0 \n");
+ 	cpu_reset(0);
+}
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/time.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/time.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/time.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/time.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,88 @@
+/*
+ * linux/include/asm-armnommu/arch-atmel/time.h
+ *
+ * Copyright (C) 2001/02 Erwin Authried <eauth@softsys.co.at>
+ * Modified by Hyok S. Choi for 2.6, 2004.
+ */
+
+#ifndef __ASM_ARCH_TIME_H__
+#define __ASM_ARCH_TIME_H__
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/timex.h>
+
+#define CLOCKS_PER_USEC	(CONFIG_ARM_CLK/1000000)
+
+#if (KERNEL_TIMER==0)
+#   define KERNEL_TIMER_IRQ_NUM IRQ_TC0
+#elif (KERNEL_TIMER==1)
+#   define KERNEL_TIMER_IRQ_NUM IRQ_TC1
+#elif (KERNEL_TIMER==2)
+#   define KERNEL_TIMER_IRQ_NUM IRQ_TC2
+#else
+#error Wierd -- KERNEL_TIMER is not defined or something....
+#endif
+
+unsigned long atmel_gettimeoffset (void)
+{
+	volatile struct at91_timers* tt = (struct at91_timers*) (AT91_TC_BASE);
+	volatile struct at91_timer_channel* tc = &tt->chans[KERNEL_TIMER].ch;
+	return tc->cv * (1000*1000)/(ARM_CLK/128);
+}
+
+static irqreturn_t
+atmel_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+        do_timer(regs);
+        do_profile(regs);
+
+    return IRQ_HANDLED;
+}
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+
+void __init  time_init (void)
+{
+        register volatile struct at91_timers* tt = (struct at91_timers*) (AT91_TC_BASE);
+        register volatile struct at91_timer_channel* tc = &tt->chans[KERNEL_TIMER].ch;
+        unsigned long v;
+
+	/* enable Kernel timer */
+	HW_AT91_TIMER_INIT(KERNEL_TIMER)
+
+        /* No SYNC */
+        tt->bcr = 0;
+        /* program NO signal on XC1 */
+        v = tt->bmr;
+	v &= ~TCNXCNS(KERNEL_TIMER,3);
+	v |= TCNXCNS(KERNEL_TIMER,1);
+        tt->bmr = v;
+
+        tc->ccr = 2;  /* disable the channel */
+
+        /* select ACLK/128 as inupt frequency for TC1 and enable CPCTRG */
+        tc->cmr = 3 | (1 << 14);
+
+        tc->idr = ~0ul;  /* disable all interrupt */
+        tc->rc = ((ARM_CLK/128)/HZ - 1);   /* load the count limit into the CR register */
+        tc->ier = TC_CPCS;  /* enable CPCS interrupt */
+
+	/*
+	 * @todo do those really need to be function pointers ?
+	 */
+        gettimeoffset = atmel_gettimeoffset;
+        timer_irq.handler = atmel_timer_interrupt;
+
+	/* set up the interrupt */
+        setup_irq(KERNEL_TIMER_IRQ_NUM, &timer_irq);
+
+        /* enable the channel */
+        tc->ccr = TC_SWTRG|TC_CLKEN;
+}
+
+#endif
+
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/timex.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/timex.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/timex.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/timex.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,10 @@
+/*
+ * timex.h:
+ * 2001 Mindspeed
+ */
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#define CLOCK_TICK_RATE	   0x270f
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/uncompress.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/uncompress.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/uncompress.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/uncompress.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,58 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/uncompress.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm-armnommu/hardware/t32.h>
+
+#ifndef __UNCOMPRESS_H__
+#define __UNCOMPRESS_H__
+
+/*
+ * just use T32 JTAG1 port
+ */
+static inline void puts(const char *s)
+{
+	t32_puts(s);
+}
+
+static void puts_hex(unsigned long i)
+{
+	char lhex_buf[]="0x00000000";
+	unsigned long ii,v;
+
+	for(ii=9;ii>1;ii--)
+	{
+		v=(((0x0000000F << ((9-ii)*4)) & i) >> ((9-ii)*4));
+		if(v>9)
+			lhex_buf[ii]=(char)('A'+v-10);
+		else
+			lhex_buf[ii]=(char)('0'+v);
+	}
+
+	t32_puts(lhex_buf);
+}
+
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-atmel/vmalloc.h linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/vmalloc.h
--- linux-2.6.9/include/asm-armnommu/arch-atmel/vmalloc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/vmalloc.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-armnommu/arch-atmel/vmalloc.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_ATMEL_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_ATMEL_SDRAM_SIZE)   
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/dma.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/dma.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/dma.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/dma.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,29 @@
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/dma.h
+ *
+ * Currently this is not used for the s3c4510b port
+ *
+ * Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_S3C4510B_ARCH_DMA_H
+#define __ASM_S3C4510B_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ * 
+ */
+#define MAX_DMA_ADDRESS		0x03000000
+/*
+ * The S3C4510B has 2 internal DMA channels.
+ */
+#define MAX_DMA_CHANNELS	2
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#endif /* __ASM_S3C4510B_ARCH_DMA_H */
+
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/hardware.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/hardware.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/hardware.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/hardware.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/hardware.h
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                   Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+#include <asm/arch/s3c4510b.h>
+
+#ifndef __ASSEMBLY__
+
+#define HARD_RESET_NOW()
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(1)
+
+#endif
+
+#endif  /*   END OF __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/io.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/io.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/io.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/io.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,67 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/io.h
+ *
+ * Copyright (C) 2003 Thomas Eschenbacher <eschenbacher@sympat.de>
+ * Modified by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+/*
+ * We have the this routine to use usb host device driver
+ */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a)			(PCI_IO_VADDR + (a))
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(PCI_MEMORY_VADDR + (unsigned long)(a))
+
+
+/*
+ * These macros were copied from arch/armnommu/io.h and are used instead
+ * of the definitions found there, because we want to do 16/32 bit i/o
+ * without byte swapping.
+ * --the
+ */
+
+#undef __io
+
+#ifndef __iob
+  #define __iob(a) __io(a)
+#endif
+
+#define outb(v,p)       __raw_writeb(v, p)
+#define outw(v,p)       __raw_writew(v, p)
+#define outl(v,p)       __raw_writel(v, p)
+
+#define inb(p)          ({ unsigned int __v = __raw_readb(p); __v; })
+#define inw(p)          ({ unsigned int __v = __raw_readw(p); __v; })
+#define inl(p)          ({ unsigned int __v = __raw_readl(p); __v; })
+
+#define outsb(p,d,l)    __raw_writesb(p, d, l)
+#define outsw(p,d,l)    __raw_writesw(p, d, l)
+#define outsl(p,d,l)    __raw_writesl(p, d, l)
+
+#define insb(p,d,l)     __raw_readsb(p, d, l)
+#define insw(p,d,l)     __raw_readsw(p, d, l)
+#define insl(p,d,l)     __raw_readsl(p, d, l)
+
+/*
+ * Validate the pci memory address for ioremap.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ */
+#define iomem_to_phys(iomem)	(iomem)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/irq.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/irq.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/irq.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/irq.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/irq.h
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __ARCH_S3C4510B_irq_h
+#define __ARCH_S3C4510B_irq_h
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+extern unsigned  int fixup_irq(int i);
+
+extern void do_IRQ(int irq, struct pt_regs *regs);
+
+extern void s3c4510b_init_irq(void);
+
+#define 	irq_init_irq 	s3c4510b_init_irq
+
+#endif 
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/irqs.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/irqs.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/irqs.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/irqs.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,42 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/irqs.h
+ *
+ *  Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ *  Curt Brune <curt@cucy.com>
+ *
+ *  Based on:
+ *  linux-2.4.x/asm/arch-samsung/irqs.h:
+ *  Mac Wang <mac@os.nctu.edu.tw>
+ *
+ */
+#ifndef __ASM_ARCH_IRQS_H__
+#define __ASM_ARCH_IRQS_H__
+#define NR_IRQS		21
+#define VALID_IRQ(i)	(i<=8 ||(i>=16 && i<NR_IRQS))
+
+#define INT_EXTINT0	0
+#define INT_EXTINT1	1
+#define INT_EXTINT2	2
+#define INT_EXTINT3	3
+#define INT_UARTTX0	4
+#define INT_UARTRX0	5
+#define INT_UARTTX1	6
+#define INT_UARTRX1	7
+#define INT_GDMA0	8
+#define INT_GDMA1	9
+#define INT_TIMER0	10
+#define INT_TIMER1	11
+#define INT_HDLCTXA	12
+#define INT_HDLCRXA	13
+#define INT_HDLCTXB	14
+#define INT_HDLCRXB	15
+#define INT_BDMATX	16
+#define INT_BDMARX	17
+#define INT_MACTX	18
+#define INT_MACRX	19
+#define INT_IIC		20
+#define INT_GLOBAL	21
+
+#define IRQ_TIMER	INT_TIMER0
+
+#endif /* __ASM_ARCH_IRQS_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/keyboard.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/keyboard.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/keyboard.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/keyboard.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/keyboard.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  just a cite from other architecture :)
+ */
+#ifndef __ASM_ARMNOMMU_ARCH_S3C4510B_KEYBOARD_H
+#define __ASM_ARMNOMMU_ARCH_S3C4510B_KEYBOARD_H
+
+#define kbd_setkeycode(sc,kc) (-EINVAL)
+#define kbd_getkeycode(sc) (-EINVAL)
+#define kbd_translate(sc,kcp,rm) ({ *(kcp) = (sc); 1; })
+#define kbd_unexpected_up(kc) (0200)
+#define kbd_leds(leds)
+#define kbd_init_hw()
+#define kbd_enable_irq()
+#define kbd_disable_irq()
+
+#endif /* __ASM_ARMNOMMU_ARCH_S3C4510B_KEYBOARD_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/memory.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/memory.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/memory.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/memory.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,25 @@
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/memory.h
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *		Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x01a00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((void *) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((void *) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/param.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/param.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/param.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/param.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/s3c4510b.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/s3c4510b.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/s3c4510b.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/s3c4510b.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,255 @@
+#ifndef __HW_S3C4510_H
+#define __HW_S3C4510_H
+
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/s3c4510b.h
+ *
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * MODULE:        $Id: s3c4510b.h,v 1.1 2004/08/25 13:52:35 gerg Exp $
+ * Description:   Samsung S3C4510B register layout
+ * Runtime Env:   ARM7TDMI
+ * Change History:
+ *     03-02-04    Create (Curt Brune) curt@cucy.com
+ */
+
+/*------------------------------------------------------------------------
+ *	  ASIC Address Definition
+ *----------------------------------------------------------------------*/
+
+
+#define S3C4510B_MEM_SIZE     (CONFIG_DRAM_SIZE) 
+#define MEM_SIZE              S3C4510B_MEM_SIZE
+#define PA_SDRAM_BASE         CONFIG_DRAM_BASE
+
+/* L1 8KB on chip SRAM base address */
+#define SRAM_BASE       (0x03fe0000)
+
+/* Special Register Start Address After System Reset */
+#define REG_BASE	(0x03ff0000)
+#define SPSTR      	(REG_BASE)
+
+/* *********************** */
+/* System Manager Register */
+/* *********************** */
+#define REG_SYSCFG	(REG_BASE+0x0000)
+
+#define REG_CLKCON      (REG_BASE+0x3000)
+#define REG_EXTACON0	(REG_BASE+0x3008)
+#define REG_EXTACON1	(REG_BASE+0x300c)
+#define REG_EXTDBWTH	(REG_BASE+0x3010)
+#define REG_ROMCON0	(REG_BASE+0x3014)
+#define REG_ROMCON1	(REG_BASE+0x3018)
+#define REG_ROMCON2	(REG_BASE+0x301c)
+#define REG_ROMCON3	(REG_BASE+0x3020)
+#define REG_ROMCON4	(REG_BASE+0x3024)
+#define REG_ROMCON5	(REG_BASE+0x3028)
+#define REG_DRAMCON0	(REG_BASE+0x302c)
+#define REG_DRAMCON1	(REG_BASE+0x3030)
+#define REG_DRAMCON2	(REG_BASE+0x3034)
+#define REG_DRAMCON3	(REG_BASE+0x3038)
+#define REG_REFEXTCON	(REG_BASE+0x303c)
+
+/* *********************** */
+/* Ethernet BDMA Register  */
+/* *********************** */
+#define REG_BDMATXCON	(REG_BASE+0x9000)
+#define REG_BDMARXCON	(REG_BASE+0x9004)
+#define REG_BDMATXPTR	(REG_BASE+0x9008)
+#define REG_BDMARXPTR	(REG_BASE+0x900c)
+#define REG_BDMARXLSZ	(REG_BASE+0x9010)
+#define REG_BDMASTAT	(REG_BASE+0x9014)
+
+/* Content Address Memory */
+#define REG_CAM_BASE	(REG_BASE+0x9100)
+
+#define REG_BDMATXBUF	(REG_BASE+0x9200)
+#define REG_BDMARXBUF	(REG_BASE+0x9800)
+
+/* *********************** */
+/* Ethernet MAC Register   */
+/* *********************** */
+#define REG_MACCON	(REG_BASE+0xa000)
+#define REG_CAMCON	(REG_BASE+0xa004)
+#define REG_MACTXCON	(REG_BASE+0xa008)
+#define REG_MACTXSTAT	(REG_BASE+0xa00c)
+#define REG_MACRXCON	(REG_BASE+0xa010)
+#define REG_MACRXSTAT	(REG_BASE+0xa014)
+#define REG_STADATA	(REG_BASE+0xa018)
+#define REG_STACON	(REG_BASE+0xa01c)
+#define REG_CAMEN	(REG_BASE+0xa028)
+#define REG_EMISSCNT	(REG_BASE+0xa03c)
+#define REG_EPZCNT	(REG_BASE+0xa040)
+#define REG_ERMPZCNT	(REG_BASE+0xa044)
+#define REG_ETXSTAT	(REG_BASE+0x9040)
+#define REG_MACRXDESTR	(REG_BASE+0xa064)
+#define REG_MACRXSTATEM	(REG_BASE+0xa090)
+#define REG_MACRXFIFO	(REG_BASE+0xa200)
+ 
+/********************/
+/* I2C Bus Register */
+/********************/
+#define REG_I2C_CON	(REG_BASE+0xf000)
+#define REG_I2C_BUF	(REG_BASE+0xf004)
+#define REG_I2C_PS	(REG_BASE+0xf008)
+#define REG_I2C_COUNT 	(REG_BASE+0xf00c)
+
+/********************/
+/*    GDMA 0        */
+/********************/
+#define REG_GDMACON0	(REG_BASE+0xb000)
+#define REG_GDMA0_RUN_ENABLE (REG_BASE+0xb020)
+#define REG_GDMASRC0	(REG_BASE+0xb004)
+#define REG_GDMADST0	(REG_BASE+0xb008)
+#define REG_GDMACNT0	(REG_BASE+0xb00c)
+
+/********************/
+/*    GDMA 1        */
+/********************/
+#define REG_GDMACON1	(REG_BASE+0xc000)
+#define REG_GDMA1_RUN_ENABLE (REG_BASE+0xc020)
+#define REG_GDMASRC1	(REG_BASE+0xc004)
+#define REG_GDMADST1	(REG_BASE+0xc008)
+#define REG_GDMACNT1	(REG_BASE+0xc00c)
+
+#define UART_CNT        (2)
+/********************/
+/*      UART 0      */
+/********************/
+#define UART0_BASE       (REG_BASE+0xd000)
+#define REG_UART0_LCON   (REG_BASE+0xd000)
+#define REG_UART0_CTRL   (REG_BASE+0xd004)
+#define REG_UART0_STAT   (REG_BASE+0xd008)
+#define REG_UART0_TXB    (REG_BASE+0xd00c)
+#define REG_UART0_RXB    (REG_BASE+0xd010)
+#define REG_UART0_BAUD_DIV    (REG_BASE+0xd014)
+#define REG_UART0_BAUD_CNT    (REG_BASE+0xd018)
+#define REG_UART0_BAUD_CLK    (REG_BASE+0xd01C)
+
+/********************/
+/*     UART 1       */
+/********************/
+#define UART1_BASE       (REG_BASE+0xe000)
+#define REG_UART1_LCON   (REG_BASE+0xe000)
+#define REG_UART1_CTRL   (REG_BASE+0xe004)
+#define REG_UART1_STAT   (REG_BASE+0xe008)
+#define REG_UART1_TXB    (REG_BASE+0xe00c)
+#define REG_UART1_RXB    (REG_BASE+0xe010)
+#define REG_UART1_BAUD_DIV    (REG_BASE+0xe014)
+#define REG_UART1_BAUD_CNT    (REG_BASE+0xe018)
+#define REG_UART1_BAUD_CLK    (REG_BASE+0xe01C)
+
+/********************/
+/*  Timer Register  */
+/********************/
+#define REG_TMOD  	(REG_BASE+0x6000)
+#define REG_TDATA0	(REG_BASE+0x6004)
+#define REG_TDATA1	(REG_BASE+0x6008)
+#define REG_TCNT0	(REG_BASE+0x600c)
+#define REG_TCNT1	(REG_BASE+0x6010)
+
+/**********************/
+/* I/O Port Interface */
+/**********************/
+#define REG_IOPMODE	(REG_BASE+0x5000)
+#define REG_IOPCON  	(REG_BASE+0x5004)
+#define REG_IOPDATA 	(REG_BASE+0x5008)
+
+/*********************************/
+/* Interrupt Controller Register */
+/*********************************/
+#define REG_INTMODE     (REG_BASE+0x4000)
+#define REG_INTPEND     (REG_BASE+0x4004)
+#define REG_INTMASK     (REG_BASE+0x4008)
+
+#define REG_INTPRI0     (REG_BASE+0x400c)
+#define REG_INTPRI1	(REG_BASE+0x4010)
+#define REG_INTPRI2	(REG_BASE+0x4014)
+#define REG_INTPRI3	(REG_BASE+0x4018)
+#define REG_INTPRI4	(REG_BASE+0x401c)
+#define REG_INTPRI5	(REG_BASE+0x4020)
+#define REG_INTOFFSET	(REG_BASE+0x4024)
+#define REG_INTPNDPRI	(REG_BASE+0x4028)
+#define REG_INTPNDTST	(REG_BASE+0x402C)
+#define REG_INTOSET_FIQ	(REG_BASE+0x4030)
+#define REG_INTOSET_IRQ	(REG_BASE+0x4034)
+
+#define INT_MODE_IRQ	0x000000
+#define INT_MODE_FIQ	0x1FFFFF
+#define INT_MASK_DIS	0x1FFFFF
+#define INT_MASK_ENA	0x000000
+
+/*********************************/
+/* CACHE CONTROL MASKS           */
+/*********************************/
+#define CACHE_STALL      (0x00000001) 
+#define CACHE_ENABLE     (0x00000002)
+#define CACHE_WRITE_BUFF (0x00000004)
+#define CACHE_MODE       (0x00000030)
+#define CACHE_MODE_00    (0x00000000)
+#define CACHE_MODE_01    (0x00000010)
+#define CACHE_MODE_10    (0x00000020)
+
+/*********************************/
+/* CACHE RAM BASE ADDRESSES      */
+/*********************************/
+#define CACHE_SET0_RAM   (0x10000000)
+#define CACHE_SET1_RAM   (0x10800000)
+#define CACHE_TAG_RAM    (0x11000000)
+
+/*********************************/
+/* CACHE_DISABLE MASK            */
+/*********************************/
+#define CACHE_DISABLE_MASK (0x04000000)
+
+/*********************************************************/
+/*	       TIMER MODE REGISTER                       */
+/*********************************************************/
+#define  TM0_RUN      0x01  /* Timer 0 enable */
+#define  TM0_TOGGLE   0x02  /* 0, interval mode */
+#define  TM0_OUT_1    0x04  /* Timer 0 Initial TOUT0 value */
+#define  TM1_RUN      0x08  /* Timer 1 enable */
+#define  TM1_TOGGLE   0x10  /* 0, interval mode */
+#define  TM1_OUT_1    0x20  /* Timer 0 Initial TOUT0 value */
+
+/*********************************************************
+ *	       INTERRUPT CONTROL                         
+ *
+ * An interrupt is enabled when mask bit is clear.
+ * An interrupt is disabled when mask bit is set. 
+ *********************************************************/
+#define INT_ENABLE(n)		outl( inl(REG_INTMASK) & ~( 1 << (n)), REG_INTMASK)
+#define INT_DISABLE(n)		outl( inl(REG_INTMASK) | ( 1 << (n)), REG_INTMASK)
+#define CLEAR_PEND_INT(n)	outl( (1 << (n)), REG_INTPEND)
+#define SET_PEND_INT(n)		outl( inl(REG_INTPNDTST) | ( 1 << (n)), REG_INTPNDMASK)
+
+#ifdef CONFIG_ARCH_ESPD_4510B
+#define LED_SET(n)              outl( inl(REG_IOPDATA) & ~(1<<(n)), REG_IOPDATA)
+#define LED_CLR(n)              outl( inl(REG_IOPDATA) |  (1<<(n)), REG_IOPDATA)
+#define LED_TOGGLE(n)		outl( inl(REG_IOPDATA) ^  (1<<(n)), REG_IOPDATA)
+#else
+#define LED_SET(n)
+#define LED_CLR(n)
+#define LED_TOGGLE(n)
+#endif
+
+#endif /* __S3C4510_h */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/sizes.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/sizes.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/sizes.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/sizes.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/system.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/system.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/system.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/system.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/system.h
+ *
+ *  Copyright (C) 2002 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+extern void __do_dump( const char *s);
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+ 	printk(KERN_ERR"arch_reset() not implemented\n");
+ 	BUG();
+}
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/time.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/time.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/time.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/time.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,109 @@
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/time.h
+ *
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * 2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ * modifed by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * Setup for 32 bit timer 0, used as system timer.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_TIME_H__
+#define __ASM_ARCH_TIME_H__
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/timex.h>
+#include <asm/mach/irq.h>
+
+#define CLOCKS_PER_USEC	(CONFIG_ARM_CLK/1000000)
+
+static volatile unsigned long timer_cnt;
+
+unsigned long s3c4510b_gettimeoffset (void)
+{
+	unsigned long usec;
+
+	/* returns microseconds -- timer 1 is free running in countdown mode */
+	usec = 0xFFFFFFFF - inl( REG_TCNT1);
+	usec /= CLOCKS_PER_USEC;
+	
+	return usec;
+}
+
+static irqreturn_t
+s3c4510b_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+
+	timer_cnt++;
+
+#ifdef CONFIG_ARCH_ESPD_4510B
+	if ( ! (timer_cnt % (HZ/4))) {
+		LED_TOGGLE(0);
+	}
+#endif
+	do_timer(regs);
+	do_profile(regs);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Set up timer interrupt
+ */
+
+void __init  time_init (void)
+{
+	u_int32_t period;
+	
+	/*
+	 * disable and clear timers 0 and 1.  set both timers to
+	 * interval mode.
+	 */
+	outl( 0x0, REG_TMOD);
+	/* clear any pending interrupts */
+	outl( 0x1FFFFF, REG_INTPEND);
+
+	timer_cnt = 0;
+
+	/* initialize the timer period */
+	period = (CLOCK_TICK_RATE / HZ);
+	outl( period, REG_TDATA0);
+
+	/* set timer1 to continually count down from FFFFFFFF */
+	outl( 0xFFFFFFFF, REG_TDATA1);
+
+//	printk(KERN_INFO "time_init():  TICK_RATE: %u, HZ: %u, period: %u\n", CLOCK_TICK_RATE, HZ, period);
+
+	gettimeoffset     = s3c4510b_gettimeoffset;
+	timer_irq.handler = s3c4510b_timer_interrupt;
+
+	/* set up the interrupt vevtor for timer 0 match */
+	setup_irq( INT_TIMER0, &timer_irq);
+	
+	/* enable the timer IRQ */
+	INT_ENABLE( INT_TIMER0);
+
+	/* let timer 0 run... */
+	outl( TM0_RUN | TM1_RUN, REG_TMOD);
+}
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/timex.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/timex.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/timex.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/timex.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/timex.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                           Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#define CLOCK_TICK_RATE (CONFIG_ARM_CLK)
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/uart.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/uart.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/uart.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/uart.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,114 @@
+#ifndef _SC34510B_UART_H
+#define _SC34510B_UART_H
+
+/*
+ * linux/include/asm-armnommu/arch-espd_4510b/uart.h
+ *
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Description:   S3C4510B UART register layout
+ * Runtime Env:   ARM7TDMI
+ * Change History:
+ *     03-03-04    Create (Curt Brune)
+ */
+
+/* UART LINE CONTROL register */
+typedef struct __BF_UART_LINE_CTRL {
+	u32    wordLen: 2;
+	u32      nStop: 1;
+	u32     parity: 3;
+	u32        clk: 1;
+	u32  infra_red: 1;
+	u32     unused:24;
+} BF_UART_LINE_CTRL;
+
+typedef union _UART_LINE_CTRL {
+	u32               ui;
+	BF_UART_LINE_CTRL bf;
+} UART_LINE_CTRL;
+
+/* UART CONTROL register */
+typedef struct __BF_UART_CTRL {
+	u32     rxMode: 2;
+	u32      rxIrq: 1;
+	u32     txMode: 2;
+	u32        DSR: 1;
+	u32  sendBreak: 1;
+	u32   loopBack: 1;
+	u32     unused:24;
+} BF_UART_CTRL;
+
+typedef union _UART_CTRL {
+	u32            ui;
+	BF_UART_CTRL   bf;
+} UART_CTRL;
+
+/* UART STATUS register */
+typedef struct __BF_UART_STAT {
+	u32      overrun: 1;
+	u32       parity: 1;
+	u32        frame: 1;
+	u32     breakIrq: 1;
+	u32          DTR: 1;
+	u32      rxReady: 1;
+	u32   txBufEmpty: 1;
+	u32   txComplete: 1;
+	u32       unused:24;
+} BF_UART_STAT;
+
+typedef union _UART_STAT {
+	u32            ui;
+	BF_UART_STAT   bf;
+} UART_STAT;
+
+/* UART BAUD_DIV register */
+typedef struct __BF_UART_BAUD_DIV {
+	u32      cnt1: 4;
+	u32      cnt0:12;
+	u32    unused:16;
+} BF_UART_BAUD_DIV;
+
+typedef union _UART_BAUD_DIV {
+	u32                ui;
+	BF_UART_BAUD_DIV   bf;
+} UART_BAUD_DIV;
+
+/* UART register block */
+struct uart_regs {
+	volatile UART_LINE_CTRL  m_lineCtrl;
+	volatile UART_CTRL           m_ctrl;
+	volatile UART_STAT           m_stat;
+	volatile u32                   m_tx;
+	volatile u32                   m_rx;
+	volatile UART_BAUD_DIV    m_baudDiv;
+	volatile u32              m_baudCnt;
+	volatile u32              m_baudClk;
+};
+
+#define NL          0x0A
+#define CR          0x0D
+#define BSP         0x08
+#define ESC         0x1B
+#define CTRLZ       0x1A
+#define RUBOUT      0x7F
+
+#define UART_ANY_RX (0x2F)
+#define UART_NR    (2)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-espd_4510b/vmalloc.h linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/vmalloc.h
--- linux-2.6.9/include/asm-armnommu/arch-espd_4510b/vmalloc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/vmalloc.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-armnommu/arch-espd_4510b/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King. 
+ *  modified by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_S3C3410_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_S3C3410_SDRAM_SIZE)   
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/dma.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/dma.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/dma.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/dma.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-armnommu/arch-s3c3410/dma.h
+ *
+ * Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_S3C3410_ARCH_DMA_H
+#define __ASM_S3C3410_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ * 
+ */
+#define MAX_DMA_ADDRESS		0x03000000
+/*
+ * The S3C3410 has 2 internal DMA channels.
+ */
+#define MAX_DMA_CHANNELS	2
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#endif /* _ASM_S3C3410_ARCH_DMA_H */
+
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/hardware.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/hardware.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/hardware.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/hardware.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/hardware.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                   Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+#include <asm/arch/s3c3410.h>
+
+#ifndef __ASSEMBLY__
+
+#define HARD_RESET_NOW()
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(1)
+
+#endif
+
+#endif  /*   END OF __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/io.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/io.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/io.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/io.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,67 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/io.h
+ *
+ * Copyright (C) 2003 Thomas Eschenbacher <eschenbacher@sympat.de>
+ * Modified by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+/*
+ * We have the this routine to use usb host device driver
+ */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a)			(PCI_IO_VADDR + (a))
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(PCI_MEMORY_VADDR + (unsigned long)(a))
+
+
+/*
+ * These macros were copied from arch/armnommu/io.h and are used instead
+ * of the definitions found there, because we want to do 16/32 bit i/o
+ * without byte swapping.
+ * --the
+ */
+
+#undef __io
+
+#ifndef __iob
+  #define __iob(a) __io(a)
+#endif
+
+#define outb(v,p)       __raw_writeb(v, p)
+#define outw(v,p)       __raw_writew(v, p)
+#define outl(v,p)       __raw_writel(v, p)
+
+#define inb(p)          ({ unsigned int __v = __raw_readb(p); __v; })
+#define inw(p)          ({ unsigned int __v = __raw_readw(p); __v; })
+#define inl(p)          ({ unsigned int __v = __raw_readl(p); __v; })
+
+#define outsb(p,d,l)    __raw_writesb(p, d, l)
+#define outsw(p,d,l)    __raw_writesw(p, d, l)
+#define outsl(p,d,l)    __raw_writesl(p, d, l)
+
+#define insb(p,d,l)     __raw_readsb(p, d, l)
+#define insw(p,d,l)     __raw_readsw(p, d, l)
+#define insl(p,d,l)     __raw_readsl(p, d, l)
+
+/*
+ * Validate the pci memory address for ioremap.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ */
+#define iomem_to_phys(iomem)	(iomem)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/irq.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/irq.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/irq.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/irq.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,24 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/irq.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __S3C3410_irq_h
+#define __S3C3410_irq_h
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+extern unsigned  int fixup_irq(int i);
+
+extern void do_IRQ(int irq, struct pt_regs *regs);
+
+extern void s3c3410_init_irq(void);
+
+#define 	irq_init_irq 	s3c3410_init_irq
+
+#endif 
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/irqs.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/irqs.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/irqs.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/irqs.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,48 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/irqs.h
+ *
+ * 2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ *
+ * All IRQ numbers of the S3C3410X CPUs.
+ *
+ */
+
+#ifndef __S3C3410_irqs_h
+#define __S3C3410_irqs_h                        1
+
+#define NR_IRQS		32
+	
+#define S3C3410X_INTERRUPT_EINT0	 0	/* External int. 0 */
+#define S3C3410X_INTERRUPT_EINT1	 1	/* External int. 1 */
+#define S3C3410X_INTERRUPT_URX  	 2	/* UART receive */
+#define S3C3410X_INTERRUPT_UTX  	 3	/* UART transmit */
+#define S3C3410X_INTERRUPT_UERR 	 4	/* UART error */
+#define S3C3410X_INTERRUPT_DMA0 	 5	/* DMA 0 */
+#define S3C3410X_INTERRUPT_DMA1 	 6	/* DMA 1 */
+#define S3C3410X_INTERRUPT_TOF0 	 7	/* Timer 0 overflow */
+#define S3C3410X_INTERRUPT_TMC0 	 8	/* Timer 0 match/capture */
+#define S3C3410X_INTERRUPT_TOF1 	 9	/* Timer 1 overflow */
+#define S3C3410X_INTERRUPT_TMC1 	10	/* Timer 1 match/capture */
+#define S3C3410X_INTERRUPT_TOF2 	11	/* Timer 2 overflow */
+#define S3C3410X_INTERRUPT_TMC2 	12	/* Timer 2 match/capture */
+#define S3C3410X_INTERRUPT_TOF3 	13	/* Timer 3 overflow */
+#define S3C3410X_INTERRUPT_TMC3 	14	/* Timer 3 match/capture */
+#define S3C3410X_INTERRUPT_TOF4 	15	/* Timer 4 overflow */
+#define S3C3410X_INTERRUPT_TMC4 	16	/* Timer 4 match/capture */
+#define S3C3410X_INTERRUPT_BT   	17	/* Basic Timer */
+#define S3C3410X_INTERRUPT_SIO0 	18	/* SIO 0 */
+#define S3C3410X_INTERRUPT_SIO1 	19	/* SIO 1 */
+#define S3C3410X_INTERRUPT_IIC  	20	/* IIC */
+#define S3C3410X_INTERRUPT_RTCA 	21	/* RTC alarm */
+#define S3C3410X_INTERRUPT_RTCT 	22	/* RTC time (SEC/MIN/HOUR) */
+#define S3C3410X_INTERRUPT_TF   	23	/* Timer4 FIFO interrupt */
+#define S3C3410X_INTERRUPT_EINT2	24	/* External int. 2 */
+#define S3C3410X_INTERRUPT_EINT3	25	/* External int. 3 */
+#define S3C3410X_INTERRUPT_EINT4567	26	/* External int. 4/5/6/7 */
+#define S3C3410X_INTERRUPT_ADC   	27	/* ADC interrupt */
+#define S3C3410X_INTERRUPT_EINT8	28	/* External int. 8 */
+#define S3C3410X_INTERRUPT_EINT9	29	/* External int. 9 */
+#define S3C3410X_INTERRUPT_EINT10	30	/* External int. 10 */
+#define S3C3410X_INTERRUPT_EINT11	31	/* External int. 11 */
+
+#endif /* End of __irqs_h */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/keyboard.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/keyboard.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/keyboard.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/keyboard.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/keyboard.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ *  just a cite from other architecture :)
+ */
+#ifndef __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H
+#define __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H
+
+#define kbd_setkeycode(sc,kc) (-EINVAL)
+#define kbd_getkeycode(sc) (-EINVAL)
+#define kbd_translate(sc,kcp,rm) ({ *(kcp) = (sc); 1; })
+#define kbd_unexpected_up(kc) (0200)
+#define kbd_leds(leds)
+#define kbd_init_hw()
+#define kbd_enable_irq()
+#define kbd_disable_irq()
+
+#endif /* __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/memory.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/memory.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/memory.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/memory.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,25 @@
+/*
+ * linux/include/asm-arm/arch-s3c3410/memory.h
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *		Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x01a00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((void *) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((void *) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/param.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/param.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/param.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/param.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/s3c3410.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/s3c3410.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/s3c3410.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/s3c3410.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,384 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/s3c3410.h
+ *
+ * Special function registers of the Samsung S3C3410X
+ *
+ * (C) 2003 sympat GmbH
+ * by Thomas Eschenbacher <thomas.eschenbacher@sympat.de>
+ *
+ */
+
+#ifndef __ASM_ARCH_S3C3410_H
+#define __ASM_ARCH_S3C3410_H
+
+#define S3C3410_MEM_SIZE     (CONFIG_DRAM_SIZE) 
+#define MEM_SIZE            S3C3410_MEM_SIZE
+#define PA_SDRAM_BASE         CONFIG_DRAM_BASE
+
+/* Address offset for accessing external memory uncached (A27=1) */
+#define S3C3410X_UNCACHED        0x08000000             /* (1 << 27) */
+
+/*
+ * SFR Base Address
+ */
+#define S3C3410X_BASE            0x07FF0000
+
+/* ************************ */
+/* System Manager Registers */
+/* ************************ */
+#define S3C3410X_SYSCFG          (S3C3410X_BASE+0x1000) /* System Configuration */
+
+#define S3C3410X_SYSCFG_ST       0x00000001		/* Stall enable */
+#define S3C3410X_SYSCFG_CE       0x00000002		/* Cache enable*/
+#define S3C3410X_SYSCFG_WE       0x00000004		/* Write Buffer enable */
+#define S3C3410X_SYSCFG_SFRSA    0x00007FF0		/* SYSCFG Address (SFR Start Address) */
+
+#define S3C3410X_SYSCFG_CM_MASK  0x00018000		/* Cache Mode (MASK) */
+#define S3C3410X_SYSCFG_CM_22    0x00000000		/* (Cache Mode) 2k Cache / 2k SRAM */
+#define S3C3410X_SYSCFG_CM_CACHE 0x00008000		/* (Cache Mode) 4k Cache */
+#define S3C3410X_SYSCFG_CM_SRAM  0x00010000		/* (Cache Mode) 4k SRAM */
+
+#define S3C3410X_SYSCFG_AME      0x00020000		/* Address Mux Enable */
+#define S3C3410X_SYSCFG_MT0_RFS  0x00000000		/* Memory Type 0 ROM/Flash/SRAM */
+#define S3C3410X_SYSCFG_MT0_FP   0x00040000		/* Memory Type 0 FP DRAM */
+#define S3C3410X_SYSCFG_MT0_EDO  0x00080000		/* Memory Type 0 EDO DRAM */
+#define S3C3410X_SYSCFG_MT0_SD   0x000C0000		/* Memory Type 0 Sync. DRAM */
+#define S3C3410X_SYSCFG_MT1_RFS  0x00000000		/* Memory Type 1 ROM/Flash/SRAM */
+#define S3C3410X_SYSCFG_MT1_FP   0x00100000		/* Memory Type 1 FP DRAM */
+#define S3C3410X_SYSCFG_MT1_EDO  0x00200000		/* Memory Type 1 EDO DRAM */
+#define S3C3410X_SYSCFG_MT1_SD   0x00300000		/* Memory Type 1 Sync. DRAM */
+
+#define S3C3410X_BANKCON0	(S3C3410X_BASE+0x2000) /* Memory Bank 0 Control */
+#define S3C3410X_BANKCON1	(S3C3410X_BASE+0x2004) /* Memory Bank 1 Control */
+#define S3C3410X_BANKCON2	(S3C3410X_BASE+0x2008) /* Memory Bank 2 Control */
+#define S3C3410X_BANKCON3	(S3C3410X_BASE+0x200C) /* Memory Bank 3 Control */
+#define S3C3410X_BANKCON4	(S3C3410X_BASE+0x2010) /* Memory Bank 4 Control */
+#define S3C3410X_BANKCON5	(S3C3410X_BASE+0x2014) /* Memory Bank 5 Control */
+#define S3C3410X_BANKCON6	(S3C3410X_BASE+0x2018) /* Memory Bank 6 Control */
+#define S3C3410X_BANKCON7	(S3C3410X_BASE+0x201C) /* Memory Bank 7 Controlr */
+
+#define S3C3410X_BANKCON_DBW	    0x00000001 	    	/* Data Bus Width (16Bit enable) else 8Bit */
+#define S3C3410X_BANKCON_PMC_1D	    0x00000000 	    	/* Page Mode 1Data */
+#define S3C3410X_BANKCON_PMC_4D	    0x00000002 	    	/* Page Mode 4Data */
+#define S3C3410X_BANKCON_PMC_8D	    0x00000004 	    	/* Page Mode 8Data */
+#define S3C3410X_BANKCON_PMC_16D    0x00000006 	    	/* Page Mode 16Data */
+#define S3C3410X_BANKCON_SM	    0x00000008 	    	/* UB/LB Byte selection enable (see nWE,WE in Chipdesign) */
+#define S3C3410X_BANKCON_TACC_DIS   0x00000000 	    	/* Access Cycle Timing Disabled */
+#define S3C3410X_BANKCON_TACC_2C    0x00000010 	    	/* Access Cycle Timing 2Clocks */
+#define S3C3410X_BANKCON_TACC_3C    0x00000020 	    	/* Access Cycle Timing 3Clocks */
+#define S3C3410X_BANKCON_TACC_4C    0x00000030 	    	/* Access Cycle Timing 4Clocks */
+#define S3C3410X_BANKCON_TACC_5C    0x00000040 	    	/* Access Cycle Timing 5Clocks */
+#define S3C3410X_BANKCON_TACC_6C    0x00000050 	    	/* Access Cycle Timing 6Clocks */
+#define S3C3410X_BANKCON_TACC_7C    0x00000060 	    	/* Access Cycle Timing 7Clocks */
+#define S3C3410X_BANKCON_TACC_10C   0x00000070 	    	/* Access Cycle Timing 10Clocks */
+#define S3C3410X_BANKCON_TACP_2C    0x00000080 	    	/* Page Mode Access Cycle Timing 2Clocks */
+#define S3C3410X_BANKCON_TACP_3C    0x00000100 	    	/* Page Mode Access Cycle Timing 3Clocks */
+#define S3C3410X_BANKCON_TACP_4C    0x00000180 	    	/* Page Mode Access Cycle Timing 4Clocks */
+#define S3C3410X_BANKCON_TACP_5C    0x00000000 	    	/* Page Mode Access Cycle Timing 5Clocks */
+
+#define S3C3410X_REFCON  	(S3C3410X_BASE+0x2020) /* DRAM Refresh Control */
+
+#define S3C3410X_EXTCON0 	(S3C3410X_BASE+0x2030) /* Extra device control 0 */
+#define S3C3410X_EXTCON1 	(S3C3410X_BASE+0x2034) /* Extra device control 1 */
+#define S3C3410X_EXTPORT 	(S3C3410X_BASE+0x203E) /* External port data */
+
+#define S3C3410X_EXTDAT0 	(S3C3410X_BASE+0x202C) /* Extra chip selection data 0 */
+#define S3C3410X_EXTDAT1 	(S3C3410X_BASE+0x202E) /* Extra chip selection data 1 */
+
+/* ************* */
+/* DMA Registers */
+/* ************* */
+#define S3C3410X_DMACON0 	(S3C3410X_BASE+0x300C) /* DMA 0 control */
+#define S3C3410X_DMASRC0 	(S3C3410X_BASE+0x3000) /* DMA 0 source address */
+#define S3C3410X_DMADST0 	(S3C3410X_BASE+0x3004) /* DMA 0 destination address */
+#define S3C3410X_DMACNT0 	(S3C3410X_BASE+0x3008) /* DMA 0 transfer count */
+
+#define S3C3410X_DMACON1 	(S3C3410X_BASE+0x400C) /* DMA 1 control */
+#define S3C3410X_DMASRC1 	(S3C3410X_BASE+0x4000) /* DMA 1 source address */
+#define S3C3410X_DMADST1 	(S3C3410X_BASE+0x4004) /* DMA 1 destination address */
+#define S3C3410X_DMACNT1 	(S3C3410X_BASE+0x4008) /* DMA 1 transfer count */
+
+/* ******************* */
+/* I/O Ports Registers */
+/* ******************* */
+#define S3C3410X_PDAT0   	(S3C3410X_BASE+0xB000) /* Port 0 data */
+#define S3C3410X_PDAT1   	(S3C3410X_BASE+0xB001) /* Port 1 data */
+#define S3C3410X_PDAT2   	(S3C3410X_BASE+0xB002) /* Port 2 data */
+#define S3C3410X_PDAT3   	(S3C3410X_BASE+0xB003) /* Port 3 data */
+#define S3C3410X_PDAT4   	(S3C3410X_BASE+0xB004) /* Port 4 data */
+#define S3C3410X_PDAT5   	(S3C3410X_BASE+0xB005) /* Port 5 data */
+#define S3C3410X_PDAT6   	(S3C3410X_BASE+0xB006) /* Port 6 data */
+#define S3C3410X_PDAT7   	(S3C3410X_BASE+0xB007) /* Port 7 data */
+#define S3C3410X_PDAT8   	(S3C3410X_BASE+0xB008) /* Port 8 data */
+#define S3C3410X_PDAT9   	(S3C3410X_BASE+0xB009) /* Port 9 data */
+
+#define S3C3410X_P7BR    	(S3C3410X_BASE+0xB00B) /* Port 7 buffer */
+
+#define S3C3410X_PCON0   	(S3C3410X_BASE+0xB010) /* Port 0 control */
+#define S3C3410X_PCON1   	(S3C3410X_BASE+0xB012) /* Port 1 control */
+#define S3C3410X_PCON2   	(S3C3410X_BASE+0xB014) /* Port 2 control */
+#define S3C3410X_PCON3   	(S3C3410X_BASE+0xB016) /* Port 3 control */
+#define S3C3410X_PCON4   	(S3C3410X_BASE+0xB018) /* Port 4 control */
+#define S3C3410X_PCON5   	(S3C3410X_BASE+0xB01C) /* Port 5 control */
+#define S3C3410X_PCON6   	(S3C3410X_BASE+0xB020) /* Port 6 control */
+#define S3C3410X_PCON7   	(S3C3410X_BASE+0xB024) /* Port 7 control */
+#define S3C3410X_PCON8   	(S3C3410X_BASE+0xB026) /* Port 8 control */
+#define S3C3410X_PCON9   	(S3C3410X_BASE+0xB027) /* Port 9 control */
+
+#define S3C3410X_PUR0    	(S3C3410X_BASE+0xB028) /* Port 0 pull-up control */
+#define S3C3410X_PDR1    	(S3C3410X_BASE+0xB029) /* Port 1 pull-down control */
+#define S3C3410X_PUR2    	(S3C3410X_BASE+0xB02A) /* Port 2 pull-up control */
+#define S3C3410X_PUR3    	(S3C3410X_BASE+0xB02B) /* Port 3 pull-up control */
+#define S3C3410X_PDR4    	(S3C3410X_BASE+0xB02C) /* Port 4 pull-down control */
+#define S3C3410X_PUR5    	(S3C3410X_BASE+0xB02D) /* Port 5 pull-up control */
+#define S3C3410X_PUR6    	(S3C3410X_BASE+0xB02E) /* Port 6 pull-up control */
+#define S3C3410X_PUR7    	(S3C3410X_BASE+0xB02F) /* Port 7 pull-up control */
+#define S3C3410X_PUR8    	(S3C3410X_BASE+0xB03C) /* Port 8 pull-up control */
+
+#define S3C3410X_EINTPND  	(S3C3410X_BASE+0xB031) /* External interrupt pending */
+#define S3C3410X_EINTCON  	(S3C3410X_BASE+0xB032) /* External interrupt control */
+#define S3C3410X_EINTMOD  	(S3C3410X_BASE+0xB034) /* External interrupt mode */
+
+/* *************** */
+/* Timer Registers */
+/* *************** */
+
+#define S3C3410X_TDAT0   	(S3C3410X_BASE+0x9000) /* Timer 0 data */
+#define S3C3410X_TPRE0   	(S3C3410X_BASE+0x9002) /* Timer 0 prescaler */
+#define S3C3410X_TCON0   	(S3C3410X_BASE+0x9003) /* Timer 0 control */
+#define S3C3410X_TCNT0   	(S3C3410X_BASE+0x9006) /* Timer 0 counter */
+
+#define S3C3410X_T16_ICS	0x00000004	/* 16Bit-Timer Input Select */
+#define S3C3410X_T16_OMS_MODE	0x00000038	/* 16Bit-Timer Mode bits */
+#define S3C3410X_T16_OMS_INTRV	0x00000000	/* 16Bit-Timer Mode (interval mode) */
+#define S3C3410X_T16_OMS_MAOF	0x00000008	/* 16Bit-Timer Mode (match & overflow mode) */
+#define S3C3410X_T16_OMS_MAD	0x00000010	/* 16Bit-Timer Mode (match & DMA mode) */
+#define S3C3410X_T16_OMS_CAPF	0x00000020	/* 16Bit-Timer Mode (capture on falling edge of TCAP 0,1,2) */
+#define S3C3410X_T16_OMS_CAPR	0x00000028	/* 16Bit-Timer Mode (capture on rising edge of TCAP 0,1,2) */
+#define S3C3410X_T16_OMS_CAPRF	0x00000030	/* 16Bit-Timer Mode (capture on rising/falling edge of TCAP 0,1,2) */
+#define S3C3410X_T16_CL		0x00000040	/* 16Bit-Timer Clear */
+#define S3C3410X_T16_TEN	0x00000080	/* 16Bit-Timer Enable */
+
+#define S3C3410X_TDAT1   	(S3C3410X_BASE+0x9010) /* Timer 1 data */
+#define S3C3410X_TPRE1   	(S3C3410X_BASE+0x9012) /* Timer 1 prescaler */
+#define S3C3410X_TCON1   	(S3C3410X_BASE+0x9013) /* Timer 1 control */
+#define S3C3410X_TCNT1   	(S3C3410X_BASE+0x9016) /* Timer 1 counter */
+
+#define S3C3410X_TDAT2   	(S3C3410X_BASE+0x9020) /* Timer 2 data */
+#define S3C3410X_TPRE2   	(S3C3410X_BASE+0x9022) /* Timer 2 prescaler */
+#define S3C3410X_TCON2   	(S3C3410X_BASE+0x9023) /* Timer 2 control */
+#define S3C3410X_TCNT2   	(S3C3410X_BASE+0x9026) /* Timer 2 counter */
+
+#define S3C3410X_TDAT3   	(S3C3410X_BASE+0x9030) /* Timer 3 data */
+#define S3C3410X_TPRE3   	(S3C3410X_BASE+0x9032) /* Timer 3 prescaler */
+#define S3C3410X_TCON3   	(S3C3410X_BASE+0x9033) /* Timer 3 control */
+#define S3C3410X_TCNT3   	(S3C3410X_BASE+0x9037) /* Timer 3 counter */
+
+#define S3C3410X_TDAT4   	(S3C3410X_BASE+0x9041) /* Timer 4 data */
+#define S3C3410X_TPRE4   	(S3C3410X_BASE+0x9042) /* Timer 4 prescaler */
+#define S3C3410X_TCON4   	(S3C3410X_BASE+0x9043) /* Timer 4 control */
+#define S3C3410X_TCNT4   	(S3C3410X_BASE+0x9047) /* Timer 4 counter */
+#define S3C3410X_TFCON   	(S3C3410X_BASE+0x904F) /* Timer 4 FIFO control */
+#define S3C3410X_TFSTAT  	(S3C3410X_BASE+0x904E) /* Timer 4 FIFO status */
+#define S3C3410X_TFB4    	(S3C3410X_BASE+0x904B) /* Timer 4 FIFO @ byte */
+#define S3C3410X_TFHW4   	(S3C3410X_BASE+0x904A) /* Timer 4 FIFO @ half-word */
+#define S3C3410X_TFW4    	(S3C3410X_BASE+0x9048) /* Timer 4 FIFO @ word */
+
+/* #define TDATA0	TDAT0
+   #define TMOD 	TCON0 */
+
+/* ************** */
+/* UART Registers */
+/* ************** */
+
+#define S3C3410X_UART_BASE	(S3C3410X_BASE) /* "virtual" start of UART registers */
+
+#define S3C3410X_ULCON   	(0x5003) /* UART line control */
+#define S3C3410X_UCON    	(0x5007) /* UART control */
+#define S3C3410X_USTAT   	(0x500B) /* UART status */
+#define S3C3410X_UFCON   	(0x500F) /* UART FIFO control */
+#define S3C3410X_UFSTAT  	(0x5012) /* UART FIFO status */
+#define S3C3410X_UTXH    	(0x5017) /* UART transmit holding */
+#define S3C3410X_UTXH_B  	(0x5017) /* UART transmit FIFO @ byte */
+#define S3C3410X_UTXH_HW 	(0x5016) /* UART transmit FIFO @ half-word */
+#define S3C3410X_UTXH_W  	(0x5014) /* UART transmit FIFO @ word */
+#define S3C3410X_URXH    	(0x501B) /* UART receive holding */
+#define S3C3410X_URXH_B  	(0x501B) /* UART receive FIFO @ byte */
+#define S3C3410X_URXH_HW 	(0x501A) /* UART receive FIFO @ half-word */
+#define S3C3410X_URXH_W  	(0x5018) /* UART receive FIFO @ word */
+#define S3C3410X_UBRDIV  	(0x501E) /* baud rate divisor */
+
+/* UART Line Control Register Bits */
+#define ULCON_WL_MASK		0x03	/* UART Word Length Mask */
+#define ULCON_WL_5		0x00	/* UART Word Length: 5 bits */
+#define ULCON_WL_6		0x01	/* UART Word Length: 6 bits */
+#define ULCON_WL_7		0x02	/* UART Word Length: 7 bits */
+#define ULCON_WL_8		0x03	/* UART Word Length: 8 bits */
+#define ULCON_SB		0x04	/* UART Stop Bits */
+#define ULCON_PMD_MASK		0x38	/* UART Parity Mode Mask */
+#define ULCON_PMD_NONE		0x00	/* UART Parity Mode: None */
+#define ULCON_PMD_ODD		0x20	/* UART Parity Mode: Odd */
+#define ULCON_PMD_EVEN		0x28	/* UART Parity Mode: Even */
+#define ULCON_IRM		0x40	/* UART Infrared Mode */
+/* 				0x80	   unused */
+
+
+/* UART Control Register Bits */
+#define UCON_RM_MASK		0x03	/* UART Mask for Receive Mode */
+#define UCON_RM_DISABLED	0x00	/* UART Receive Mode 0 : Disabled */
+#define UCON_RM_IRQ_POLL	0x01	/* UART Receive Mode 1 : Interrupt or Polling Mode */
+#define UCON_RM_DMA0		0x02	/* UART Receive Mode 2 : DMA0 request */
+#define UCON_RM_DMA1		0x03	/* UART Receive Mode 3 : DMA1 request */
+
+#define UCON_TM_MASK		0x0C	/* UART Mask for Transmit Mode */
+#define UCON_TM_DISABLED	0x00	/* UART Transmit Mode 0 : Disabled */
+#define UCON_TM_IRQ_POLL	0x04	/* UART Transmit Mode 1 : Interrupt or Polling Mode */
+#define UCON_TM_DMA0		0x08	/* UART Transmit Mode 2 : DMA0 request */
+#define UCON_TM_DMA1		0x0C	/* UART Transmit Mode 3 : DMA1 request */
+
+#define UCON_SBS		0x10	/* UART Send Break Signal */
+#define UCON_LBM		0x20	/* UART Loopback Mode */
+#define UCON_RSIE		0x40	/* UART Rx Status Interrupt Enable */
+#define UCON_RXTOEL		0x80	/* UART Rx Timeout Enable */
+
+/* UART Status Register Bits */
+#define USTAT_OE 		0x01	/* UART Overrun Error */
+#define USTAT_PE 		0x02	/* UART Parity Error */
+#define USTAT_FE 		0x04	/* UART Framing Error */
+#define USTAT_BD 		0x08	/* UART Break Detect */
+#define USTAT_RTO 		0x10	/* UART Receiver Time Out */
+#define USTAT_RFDR 		0x20	/* UART Receive FIFO Data Ready / Rx Buffer Data Ready */
+#define USTAT_TFE 		0x40	/* UART Transmit FIFO Empty / Tx Holding Register Empty */
+#define USTAT_TSE 		0x80	/* UART Transmit Shift Register Empty */
+
+/* UART FIFO Control Register Bits */
+#define UFCON_FE		0x01	/* UART FIFO Enable */
+#define UFCON_RFR		0x02	/* UART Rx FIFO Reset */
+#define UFCON_TFR		0x04	/* UART Tx FIFO Reset */
+/*				0x08	   reserved */
+#define UFCON_RFTL_MASK		0x30	/* UART Receive FIFO Trigger Level Mask */
+#define UFCON_RFTL_2		0x00	/* UART Receive FIFO Trigger Level: 2 byte */
+#define UFCON_RFTL_4		0x10	/* UART Receive FIFO Trigger Level: 4 byte */
+#define UFCON_RFTL_6		0x20	/* UART Receive FIFO Trigger Level: 6 byte */
+#define UFCON_RFTL_8		0x30	/* UART Receive FIFO Trigger Level: 8 byte */
+
+#define UFCON_TFTL_MASK		0x30	/* UART Transmit FIFO Trigger Level Mask */
+#define UFCON_TFTL_0		0x00	/* UART Transmit FIFO Trigger Level: 0 byte */
+#define UFCON_TFTL_2		0x10	/* UART Transmit FIFO Trigger Level: 2 byte */
+#define UFCON_TFTL_4		0x20	/* UART Transmit FIFO Trigger Level: 4 byte */
+#define UFCON_TFTL_6		0x30	/* UART Transmit FIFO Trigger Level: 6 byte */
+
+#define UFSTAT_RFC_MASK		0x07    /* UART FIFO STATUS Rx FIFO count */
+#define UFSTAT_TFC_MASK		0x38    /* UART FIFO STATUS Rx FIFO count */
+#define UFSTAT_RFF		0x20	/* UART FIFO STATUS Receive FIFO FULL */
+#define UFSTAT_TFF		0x40	/* UART FIFO STATUS Transmit FIFO FULL */
+#define UFSTAT_EIF		0x80	/* UART FIFO STATUS Error in FIFO */
+
+
+/* *********** */
+/* SIO 0 and 1 */
+/* *********** */
+
+#define S3C3410X_ITVCNT0  	(S3C3410X_BASE+0x6000) /* SIO 0 interval counter */
+#define S3C3410X_SBRDR0   	(S3C3410X_BASE+0x6001) /* SIO 0 baud rate prescaler */
+#define S3C3410X_SIODAT0  	(S3C3410X_BASE+0x6002) /* SIO 0 data */
+#define S3C3410X_SIOCON0  	(S3C3410X_BASE+0x6003) /* SIO 0 control */
+
+#define S3C3410X_ITVCNT1  	(S3C3410X_BASE+0x7000) /* SIO 1 interval counter */
+#define S3C3410X_SBRDR1   	(S3C3410X_BASE+0x7001) /* SIO 1 baud rate prescaler */
+#define S3C3410X_SIODAT1  	(S3C3410X_BASE+0x7002) /* SIO 1 data */
+#define S3C3410X_SIOCON1  	(S3C3410X_BASE+0x7003) /* SIO 1 control */
+
+/* ****************************** */
+/* Interrupt Controller Registers */
+/* ****************************** */
+
+#define S3C3410X_INTMOD		(S3C3410X_BASE+0xC000) /* Interrupt mode */
+#define S3C3410X_INTPND		(S3C3410X_BASE+0xC004) /* Interrupt pending */
+#define S3C3410X_INTMSK		(S3C3410X_BASE+0xC008) /* Interrupt mask */
+
+#define S3C3410X_INTPRI0	(S3C3410X_BASE+0xC00C) /* Interrupt priority 0 */
+#define S3C3410X_INTPRI1	(S3C3410X_BASE+0xC010) /* Interrupt priority 1 */
+#define S3C3410X_INTPRI2	(S3C3410X_BASE+0xC014) /* Interrupt priority 2 */
+#define S3C3410X_INTPRI3	(S3C3410X_BASE+0xC018) /* Interrupt priority 3 */
+#define S3C3410X_INTPRI4	(S3C3410X_BASE+0xC01C) /* Interrupt priority 4 */
+#define S3C3410X_INTPRI5	(S3C3410X_BASE+0xC020) /* Interrupt priority 5 */
+#define S3C3410X_INTPRI6	(S3C3410X_BASE+0xC024) /* Interrupt priority 6 */
+#define S3C3410X_INTPRI7	(S3C3410X_BASE+0xC028) /* Interrupt priority 7 */
+
+/* *** */
+/* ADC */
+/* *** */
+
+#define S3C3410X_ADCCON   	(S3C3410X_BASE+0x8002) /* A/D Converter control */
+#define S3C3410X_ADCDAT   	(S3C3410X_BASE+0x8006) /* A/D Converter data */
+
+/* *********** */
+/* Basic Timer */
+/* *********** */
+
+#define S3C3410X_BTCON    	(S3C3410X_BASE+0xA002)	/* Basic Timer control */
+#define S3C3410X_BTCON_WDTC     0x00000001		/* Watchdog Timer Clear */
+#define S3C3410X_BTCON_BTC      0x00000002		/* Basic Timer Clear */
+#define S3C3410X_BTCON_CS_13	0x00000000		/* Watchdog Clock source Fin / 2^13 */
+#define S3C3410X_BTCON_CS_12	0x00000040		/* Watchdog Clock source Fin / 2^12 */
+#define S3C3410X_BTCON_CS_11	0x00000080		/* Watchdog Clock source Fin / 2^11 */
+#define S3C3410X_BTCON_CS_9	0x000000C0		/* Watchdog Clock source Fin / 2^9 */
+
+/* When this value is written into BTCON it will disable the Timer. Any other value will enable it. */
+#define S3C3410X_BTCON_WDTD     0x0000A500		/* Watchdog Timer Disable */
+#define S3C3410X_BTCON_WDTE     0x0000FF00		/* Watchdog Timer Enable */
+
+#define S3C3410X_BTCNT   	(S3C3410X_BASE+0xA007)	/* Basic Timer count */
+
+/* ***************** */
+/* I2C Bus Registers */
+/* ***************** */
+
+#define S3C3410X_IICCON   	(S3C3410X_BASE+0xE000) /* IIC-bus control */
+#define S3C3410X_IICSTAT   	(S3C3410X_BASE+0xE001) /* IIC-bus status */
+#define S3C3410X_IICDS    	(S3C3410X_BASE+0xE002) /* IIC-bus tx/rx data shift reg. */
+#define S3C3410X_IICADD   	(S3C3410X_BASE+0xE003) /* IIC-bus tx/rx address */
+#define S3C3410X_IICPC    	(S3C3410X_BASE+0xE004) /* IIC-bus Prescaler */
+#define S3C3410X_IICPCNT  	(S3C3410X_BASE+0xE005) /* IIC-bus Prescaler counter */
+
+/* *********************** */
+/* System control register */
+/* *********************** */
+
+#define S3C3410X_SYSCON   	(S3C3410X_BASE+0xD003) /* System control */
+
+#define S3C3410X_SYSCON_STOP      0x00000001 /* STOP-Mode */
+#define S3C3410X_SYSCON_IDLE      0x00000002 /* IDLE-Mode */
+#define S3C3410X_SYSCON_DMAIDLE   0x00000004 /* DMA-IDLE-Mode */
+#define S3C3410X_SYSCON_MCLK16    0x00000000 /* system clock = MCLOCK / 16 */
+#define S3C3410X_SYSCON_MCLK2     0x00000010 /* system clock = MCLOCK / 2 */
+#define S3C3410X_SYSCON_MCLK1024  0x00000020 /* system clock = MCLOCK / 1024 */
+#define S3C3410X_SYSCON_MCLK8     0x00000008 /* system clock = MCLOCK / 8 */
+#define S3C3410X_SYSCON_MCLK      0x00000018 /* system clock = MCLOCK */
+#define S3C3410X_SYSCON_GIE       0x00000040 /* Global Interrupt Enable (set when enabled !!) */
+
+/* ************** */
+/* Realtime Clock */
+/* ************** */
+
+#define S3C3410X_RTCCON   	(S3C3410X_BASE+0xA013) /* RTC control */
+#define S3C3410X_RTCALM   	(S3C3410X_BASE+0xA012) /* RTC alarm control */
+#define S3C3410X_ALMSEC   	(S3C3410X_BASE+0xA033) /* Alarm second */
+#define S3C3410X_ALMMIN    	(S3C3410X_BASE+0xA032) /* Alarm minute */
+#define S3C3410X_ALMHOUR    	(S3C3410X_BASE+0xA031) /* Alarm hour */
+#define S3C3410X_ALMDAY   	(S3C3410X_BASE+0xA037) /* Alarm day */
+#define S3C3410X_ALMMON   	(S3C3410X_BASE+0xA036) /* Alarm month */
+#define S3C3410X_ALMYEAR   	(S3C3410X_BASE+0xA035) /* Alarm year */
+#define S3C3410X_BCDSEC   	(S3C3410X_BASE+0xA023) /* BCD second */
+#define S3C3410X_BCDMIN   	(S3C3410X_BASE+0xA022) /* BCD minute */
+#define S3C3410X_BCDHOUR   	(S3C3410X_BASE+0xA021) /* BCD hour */
+#define S3C3410X_BCDDAY   	(S3C3410X_BASE+0xA027) /* BCD day */
+#define S3C3410X_BCDDATE   	(S3C3410X_BASE+0xA020) /* BCD date */
+#define S3C3410X_BCDMON   	(S3C3410X_BASE+0xA026) /* BCD month */
+#define S3C3410X_BCDYEAR   	(S3C3410X_BASE+0xA025) /* BCD year */
+
+#define S3C3410X_RINTPND   	(S3C3410X_BASE+0xA010) /* RTC time interrupt pending */
+#define S3C3410X_RINTCON   	(S3C3410X_BASE+0xA011) /* RTC time interrupt control */
+
+#endif /* __ASM_ARCH_S3C3410_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/sizes.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/sizes.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/sizes.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/sizes.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/system.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/system.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/system.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/system.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,29 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/system.h
+ *
+ *  Copyright (C) 2002 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+ 	/* machine should reboot */
+ 	mdelay(5000);
+ 	panic("Watchdog timer reset failed!\n");
+ 	printk(" Jump to address 0 \n");
+ 	cpu_reset(0);
+}
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/time.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/time.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/time.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/time.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,76 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/time.h
+ *
+ * 2003 Thomas Eschenbacher <thomas.eschenbacher@gmx.de>
+ * modifed by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * Setup for 16 bit timer 0, used as system timer.
+ *
+ */
+
+#ifndef __ASM_ARCH_TIME_H__
+#define __ASM_ARCH_TIME_H__
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/timex.h>
+
+#define CLOCKS_PER_USEC	(CONFIG_ARM_CLK/1000000)
+
+unsigned long s3c3410_gettimeoffset (void)
+{
+	return (inw(S3C3410X_TCNT0) / CLOCKS_PER_USEC);
+}
+
+static irqreturn_t
+s3c3410_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+    do_timer(regs);
+    do_profile(regs);
+
+    return IRQ_HANDLED;
+}
+
+#define S3C3410X_TIMER0_PRESCALER 100
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+
+void __init  time_init (void)
+{
+	u_int8_t tmod;
+	u_int16_t period;
+	
+	/*
+	 * disable and clear timer 0, set to
+	 * internal clock and interval mode
+	 */
+	tmod = S3C3410X_T16_OMS_INTRV | S3C3410X_T16_CL;
+	outb(tmod, S3C3410X_TCON0);
+
+	/* initialize the timer period and prescaler */
+	period = (CONFIG_ARM_CLK/S3C3410X_TIMER0_PRESCALER)/HZ;
+	outw(period, S3C3410X_TDAT0);
+	outb(S3C3410X_TIMER0_PRESCALER-1, S3C3410X_TPRE0);
+
+	/*
+	 * @todo do those really need to be function pointers ?
+	 */
+	gettimeoffset     = s3c3410_gettimeoffset;
+	timer_irq.handler = s3c3410_timer_interrupt;
+
+	/* set up the interrupt vevtor for timer 0 match */
+	setup_irq(S3C3410X_INTERRUPT_TMC0, &timer_irq);
+	
+	/* enable the timer IRQ */
+	s3c3410_unmask_irq(S3C3410X_INTERRUPT_TMC0);
+
+	/* let timer 0 run... */
+	tmod |= S3C3410X_T16_TEN;
+	tmod &= ~S3C3410X_T16_CL;
+	outb(tmod, S3C3410X_TCON0);
+}
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/timex.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/timex.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/timex.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/timex.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/timex.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                           Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#define CLOCK_TICK_RATE (CONFIG_ARM_CLK)
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c3410/vmalloc.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/vmalloc.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c3410/vmalloc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/vmalloc.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King. 
+ *  modified by Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_S3C3410_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_S3C3410_SDRAM_SIZE)   
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/dma.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/dma.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/dma.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/dma.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,20 @@
+/*
+ * linux/include/asm-armnommu/arch-s3c44b0x/dma.h
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_S3C44B0X_ARCH_DMA_H
+#define __ASM_S3C44B0X_ARCH_DMA_H
+
+// TODO: include dma support
+
+#define MAX_DMA_ADDRESS		0x0D000000
+
+#define MAX_DMA_CHANNELS	0
+#define MAX_DMA_TRANSFER_SIZE   0x100000 
+
+#endif /* _ASM_S3C44B0X_ARCH_DMA_H */
+
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/hardware.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/hardware.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/hardware.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/hardware.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-arm/arch-s3c44b0x/hardware.h
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+#include <asm/arch/s3c44b0x.h>
+
+#ifndef __ASSEMBLY__
+
+#define HARD_RESET_NOW()
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(1)
+
+#endif
+
+#define MEM_SIZE	CONFIG_DRAM_SIZE
+#define PA_SDRAM_BASE	CONFIG_DRAM_BASE
+
+/* The default system speed this box runs */
+#if	!defined(CONFIG_ARM_CLK)
+#define	CONFIG_ARM_CLK	60000000
+#endif
+
+#if	!defined(CONFIG_ARM_CLK_FIN) 
+#define	CONFIG_ARM_CLK_FIN	8000000
+#endif
+
+#endif  /*   END OF __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/io.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/io.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/io.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/io.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,63 @@
+/*
+ *  linux/include/asm-arm/arch-s3c3410/io.h
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+/*
+ * We have the this routine to use usb host device driver
+ */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a)			(PCI_IO_VADDR + (a))
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(PCI_MEMORY_VADDR + (unsigned long)(a))
+
+
+/*
+ * These macros were copied from arch/armnommu/io.h and are used instead
+ * of the definitions found there, because we want to do 16/32 bit i/o
+ * without byte swapping.
+ * --the
+ */
+
+#undef __io
+
+#ifndef __iob
+  #define __iob(a) __io(a)
+#endif
+
+#define outb(v,p)       __raw_writeb(v, p)
+#define outw(v,p)       __raw_writew(v, p)
+#define outl(v,p)       __raw_writel(v, p)
+
+#define inb(p)          ({ unsigned int __v = __raw_readb(p); __v; })
+#define inw(p)          ({ unsigned int __v = __raw_readw(p); __v; })
+#define inl(p)          ({ unsigned int __v = __raw_readl(p); __v; })
+
+#define outsb(p,d,l)    __raw_writesb(p, d, l)
+#define outsw(p,d,l)    __raw_writesw(p, d, l)
+#define outsl(p,d,l)    __raw_writesl(p, d, l)
+
+#define insb(p,d,l)     __raw_readsb(p, d, l)
+#define insw(p,d,l)     __raw_readsw(p, d, l)
+#define insl(p,d,l)     __raw_readsl(p, d, l)
+
+/*
+ * Validate the pci memory address for ioremap.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ */
+#define iomem_to_phys(iomem)	(iomem)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/irq.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/irq.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/irq.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/irq.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/irq.h
+ */
+#ifndef __S3C3410_irq_h
+#define __S3C3410_irq_h
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+extern unsigned  int fixup_irq(int i);
+
+extern void do_IRQ(int irq, struct pt_regs *regs);
+
+extern void s3c3410_init_irq(void);
+
+#define 	irq_init_irq 	s3c3410_init_irq
+
+#endif 
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/irqs.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/irqs.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/irqs.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/irqs.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,37 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c44b0x/irqs.h
+ */
+
+#ifndef _S3C44B0X_IRQS_H
+#define _S3C44B0X_IRQS_H                        1
+
+#define NR_IRQS	26
+
+#define S3C44B0X_INTERRUPT_EINT0      25      /* External int. 0 */
+#define S3C44B0X_INTERRUPT_EINT1      24      /* External int. 1 */
+#define S3C44B0X_INTERRUPT_EINT2      23      /* External int. 2 */
+#define S3C44B0X_INTERRUPT_EINT3      22      /* External int. 3 */
+#define S3C44B0X_INTERRUPT_EINT4567   21      /* External int. 4,5,6 and 7 */
+#define S3C44B0X_INTERRUPT_TICK       20      /* Clock Tick int. */
+#define S3C44B0X_INTERRUPT_ZDMA0      19      /* ZDMA 0 */
+#define S3C44B0X_INTERRUPT_ZDMA1      18      /* ZDMA 1 */
+#define S3C44B0X_INTERRUPT_BDMA0      17      /* BDMA 0 */
+#define S3C44B0X_INTERRUPT_BDMA1      16      /* BDMA 1 */
+#define S3C44B0X_INTERRUPT_WDT        15      /* Watchdog timer */
+#define S3C44B0X_INTERRUPT_UERR       14      /* UART error */
+#define S3C44B0X_INTERRUPT_TIMER0     13      /* Timer 0 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER1     12      /* Timer 1 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER2     11      /* Timer 2 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER3     10      /* Timer 3 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER4      9      /* Timer 4 zero-crossing */
+#define S3C44B0X_INTERRUPT_TIMER5      8      /* Timer 5 zero-crossing */
+#define S3C44B0X_INTERRUPT_URX0        7      /* UART0 receive */
+#define S3C44B0X_INTERRUPT_URX1        6      /* UART1 receive */
+#define S3C44B0X_INTERRUPT_IIC         5      /* IIC */
+#define S3C44B0X_INTERRUPT_SIO         4      /* SIO */
+#define S3C44B0X_INTERRUPT_UTX0        3      /* UART0 transmit */
+#define S3C44B0X_INTERRUPT_UTX1        2      /* UART1 transmit */
+#define S3C44B0X_INTERRUPT_RTCT        1      /* RTC time */
+#define S3C44B0X_INTERRUPT_ADC         0      /* ADC interrupt */
+
+#endif /* End of _S3C44B0X_IRQS_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/keyboard.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/keyboard.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/keyboard.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/keyboard.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,16 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/keyboard.h
+ */
+#ifndef __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H
+#define __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H
+
+#define kbd_setkeycode(sc,kc) (-EINVAL)
+#define kbd_getkeycode(sc) (-EINVAL)
+#define kbd_translate(sc,kcp,rm) ({ *(kcp) = (sc); 1; })
+#define kbd_unexpected_up(kc) (0200)
+#define kbd_leds(leds)
+#define kbd_init_hw()
+#define kbd_enable_irq()
+#define kbd_disable_irq()
+
+#endif /* __ASM_ARMNOMMU_ARCH_S3C3410_KEYBOARD_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/memory.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/memory.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/memory.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/memory.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,24 @@
+/*
+ * linux/include/asm-arm/arch-s3c3410/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x0cc00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((void *) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((void *) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/param.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/param.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/param.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/param.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/s3c44b0x.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/s3c44b0x.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/s3c44b0x.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/s3c44b0x.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,704 @@
+#ifndef _S3C44B0X_H_
+#define _S3C44B0X_H_
+
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+#include <asm/io.h>
+
+/* macros defined to easy the operation of system registers */
+#define SYSREG_GET(r)			inl(r)
+#define SYSREG_SET(r, v)		outl((v), r)
+#define SYSREG_AND_SET(r, v)		outl(SYSREG_GET(r) & (v), r)
+#define SYSREG_OR_SET(r, v)		outl(SYSREG_GET(r) | (v), r)
+#define SYSREG_CLR(r, v)		SYSREG_AND_SET(r, ~(v))
+
+#define SYSREG_GETB(r)			inb(r)
+#define SYSREG_SETB(r, v)		outb((v), r)
+#define SYSREG_AND_SETB(r, v)		outb(SYSREG_GETB(r) & (v), r)
+#define SYSREG_OR_SETB(r, v)		outb(SYSREG_GETB(r) | (v), r)
+#define SYSREG_CLRB(r, v)		SYSREG_AND_SETB(r, ~(v))
+
+#define SYSREG_GETW(r)			inw(r)
+#define SYSREG_SETW(r, v)		outw((v), r)
+#define SYSREG_AND_SETW(r, v)		outw(SYSREG_GETW(r) & (v), r)
+#define SYSREG_OR_SETW(r, v)		outw(SYSREG_GETW(r) | (v), r)
+#define SYSREG_CLRW(r, v)		SYSREG_AND_SETW(r, ~(v))
+
+#endif
+
+/**
+ * register definitions for SAMSUNG S3C44B0X
+ *
+ * Copyright (C) 2003 Christian Schulte <schulte@sympat.de>
+ *
+ */
+ 
+/*******************/
+/*** CPU WRAPPER ***/
+/*******************/
+
+#define S3C44B0X_SYSCFG			0x01c00000
+#define S3C44B0X_NCACHBE0		0x01c00004 /* configuration of non-cachable areas */
+#define S3C44B0X_NCACHBE1		0x01c00008 /* configuration of non-cachable areas */
+#define S3C44B0X_SBUSCON		0x01c40000 /* bus configuration */
+
+/* SYSCFG */
+#define S3C44B0X_SYSCFG_DA		0x00000020 /* Data Abort disable */
+#define S3C44B0X_SYSCFG_RSE		0x00000010 /* Read Stall Option enable */
+#define S3C44B0X_SYSCFG_WE		0x00000008 /* Write Buffer enable */
+
+#define S3C44B0X_SYSCFG_CM_NONE		0x00000000 /* Cache Mode */
+#define S3C44B0X_SYSCFG_CM_4K		0x00000002
+#define S3C44B0X_SYSCFG_CM_8K		0x00000006
+
+#define S3C44B0X_SYSCFG_SE		0x00000001 /* Stall Option enable */
+
+/* SBUSCON */
+#define S3C44B0X_SBUSCON_FIX		0x80000000 /* use the fixed configuration that follows (instead of round-robin) */
+#define S3C44B0X_SBUSCON_S_LCD_DMA_1	0x00000000 /* read the bus priority of LCD-DMA */
+#define S3C44B0X_SBUSCON_S_LCD_DMA_2	0x00004000
+#define S3C44B0X_SBUSCON_S_LCD_DMA_3	0x00008000
+#define S3C44B0X_SBUSCON_S_LCD_DMA_4	0x0000c000
+#define S3C44B0X_SBUSCON_S_ZDMA_1	0x00000000 /* read the bus priority of Z DMA */
+#define S3C44B0X_SBUSCON_S_ZDMA_2	0x00001000
+#define S3C44B0X_SBUSCON_S_ZDMA_3	0x00002000
+#define S3C44B0X_SBUSCON_S_ZDMA_4	0x00003000
+#define S3C44B0X_SBUSCON_S_BDMA_1	0x00000000 /* read the bus priority of B DMA */
+#define S3C44B0X_SBUSCON_S_BDMA_2	0x00000400
+#define S3C44B0X_SBUSCON_S_BDMA_3	0x00000800
+#define S3C44B0X_SBUSCON_S_BDMA_4	0x00000c00
+#define S3C44B0X_SBUSCON_S_BREQ_1	0x00000000 /* read the bus priority of external BREAK REQUEST */
+#define S3C44B0X_SBUSCON_S_BREQ_2	0x00000100
+#define S3C44B0X_SBUSCON_S_BREQ_3	0x00000200
+#define S3C44B0X_SBUSCON_S_BREQ_4	0x00000300
+
+#define S3C44B0X_SBUSCON_LCD_DMA_1	0x00000000 /* set the bus priority of LCD-DMA */
+#define S3C44B0X_SBUSCON_LCD_DMA_2	0x00000040
+#define S3C44B0X_SBUSCON_LCD_DMA_3	0x00000080
+#define S3C44B0X_SBUSCON_LCD_DMA_4	0x000000c0
+#define S3C44B0X_SBUSCON_ZDMA_1		0x00000000 /* set the bus priority of Z DMA */
+#define S3C44B0X_SBUSCON_ZDMA_2		0x00000010
+#define S3C44B0X_SBUSCON_ZDMA_3		0x00000020
+#define S3C44B0X_SBUSCON_ZDMA_4		0x00000030
+#define S3C44B0X_SBUSCON_BDMA_1		0x00000000 /* set the bus priority of B DMA */
+#define S3C44B0X_SBUSCON_BDMA_2		0x00000004
+#define S3C44B0X_SBUSCON_BDMA_3		0x00000008
+#define S3C44B0X_SBUSCON_BDMA_4		0x0000000c
+#define S3C44B0X_SBUSCON_BREQ_1		0x00000000 /* set the bus priority of external BREAK REQUEST */
+#define S3C44B0X_SBUSCON_BREQ_2		0x00000001
+#define S3C44B0X_SBUSCON_BREQ_3		0x00000002
+#define S3C44B0X_SBUSCON_BREQ_4		0x00000003
+
+  /*************************/
+  /*** MEMORY CONTROLLER ***/
+  /*************************/
+
+#define S3C44B0X_BWSCON			0x01c80000 /* Bank size, width and type of memory */
+#define S3C44B0X_BANKCON0		0x01c80004 /* timing and page modes */
+#define S3C44B0X_BANKCON1		0x01c80008
+#define S3C44B0X_BANKCON2		0x01c8000c
+#define S3C44B0X_BANKCON3		0x01c80010
+#define S3C44B0X_BANKCON4		0x01c80014
+#define S3C44B0X_BANKCON5		0x01c80018
+#define S3C44B0X_BANKCON6		0x01c8001c
+#define S3C44B0X_BANKCON7		0x01c80020
+#define S3C44B0X_REFRESH		0x01c80024 /* refresh timing */
+#define S3C44B0X_BANKSIZE		0x01c80028 /* bank sizes 2,4,8,16,32 MB */
+#define S3C44B0X_MRSRB6			0x01c8002c /* burst settings, CAS latency */
+#define S3C44B0X_MRSRB7			0x01c80030
+
+/* BWSCON */
+#define S3C44B0X_BWSCON_ST7		0x80000000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS7		0x40000000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW7_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW7_16		0x10000000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW7_32		0x20000000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST6		0x08000000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS6		0x04000000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW6_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW6_16		0x01000000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW6_32		0x02000000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST5		0x00800000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS5		0x00400000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW5_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW5_16		0x00100000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW5_32		0x00200000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST4		0x00080000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS4		0x00040000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW4_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW4_16		0x00010000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW4_32		0x00020000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST3		0x00008000 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS3		0x00004000 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW3_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW3_16		0x00001000 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW3_32		0x00002000 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST2		0x00000800 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS2		0x00000400 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW2_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW2_16		0x00000100 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW2_32		0x00000200 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ST1		0x00000080 /* use UB/LB addressing */
+#define S3C44B0X_BWSCON_WS1		0x00000040 /* waitstate enable */
+#define S3C44B0X_BWSCON_DW1_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW1_16		0x00000010 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW1_32		0x00000020 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_DW0_8		0x00000000 /* data bus width 8bit */
+#define S3C44B0X_BWSCON_DW0_16		0x00000002 /* data bus width 16bit */
+#define S3C44B0X_BWSCON_DW0_32		0x00000004 /* data bus width 32bit */
+
+#define S3C44B0X_BWSCON_ENDIAN_BIG	0x00000001 /* read-only, samples the endianess input pin */
+
+/* BANKCON */
+#define S3C44B0X_BANKCON_TACS_0		0x00000000 /* time, adress setup to CS (in clocks) */
+#define S3C44B0X_BANKCON_TACS_1		0x00002000
+#define S3C44B0X_BANKCON_TACS_2		0x00004000
+#define S3C44B0X_BANKCON_TACS_4		0x00006000
+
+#define S3C44B0X_BANKCON_TCOS_0		0x00000000 /* time, CS to nOE (in clocks) */
+#define S3C44B0X_BANKCON_TCOS_1		0x00000800
+#define S3C44B0X_BANKCON_TCOS_2		0x00001000
+#define S3C44B0X_BANKCON_TCOS_4		0x00001800
+
+#define S3C44B0X_BANKCON_TACC_1		0x00000000 /* access cycle in clocks (in clocks) */
+#define S3C44B0X_BANKCON_TACC_2		0x00000100
+#define S3C44B0X_BANKCON_TACC_3		0x00000200
+#define S3C44B0X_BANKCON_TACC_4		0x00000300
+#define S3C44B0X_BANKCON_TACC_6		0x00000400
+#define S3C44B0X_BANKCON_TACC_8		0x00000500
+#define S3C44B0X_BANKCON_TACC_10	0x00000600
+#define S3C44B0X_BANKCON_TACC_14	0x00000700
+
+#define S3C44B0X_BANKCON_TOCH_0		0x00000000 /* time, CS hold on nOE (in clocks) */
+#define S3C44B0X_BANKCON_TOCH_1		0x00000040
+#define S3C44B0X_BANKCON_TOCH_2		0x00000080
+#define S3C44B0X_BANKCON_TOCH_4		0x000000c0
+
+#define S3C44B0X_BANKCON_TCAH_0		0x00000000 /* address hold on after CS (in clocks) */
+#define S3C44B0X_BANKCON_TCAH_1		0x00000010
+#define S3C44B0X_BANKCON_TCAH_2		0x00000020
+#define S3C44B0X_BANKCON_TCAH_4		0x00000030
+
+#define S3C44B0X_BANKCON_TPAC_2		0x00000000 /* page mode access cycle (in clocks) */
+#define S3C44B0X_BANKCON_TPAC_3		0x00000004
+#define S3C44B0X_BANKCON_TPAC_4		0x00000008
+#define S3C44B0X_BANKCON_TPAC_6		0x0000000c
+
+#define S3C44B0X_BANKCON_PMC_1		0x00000000 /* page mode config (in datawords) */
+#define S3C44B0X_BANKCON_PMC_4		0x00000001
+#define S3C44B0X_BANKCON_PMC_8		0x00000002
+#define S3C44B0X_BANKCON_PMC_16		0x00000003
+
+#define S3C44B0X_BANKCON_MT_SRAM	0x00000000 /* memory type selection */
+#define S3C44B0X_BANKCON_MT_DRAM	0x00004000
+#define S3C44B0X_BANKCON_MT_EDO		0x00008000
+#define S3C44B0X_BANKCON_MT_SDRAM	0x00018000
+
+/* only for FP-DRAM or EDO-DRAM */
+#define S3C44B0X_BANKCON_TRCD_1		0x00000000 /* RAS to CAS delay */
+#define S3C44B0X_BANKCON_TRCD_2		0x00000010
+#define S3C44B0X_BANKCON_TRCD_3		0x00000020
+#define S3C44B0X_BANKCON_TRCD_4		0x00000030
+
+#define S3C44B0X_BANKCON_TCAS_1		0x00000000 /* CAS pulse width (in clocks) */
+#define S3C44B0X_BANKCON_TCAS_2		0x00000008
+
+#define S3C44B0X_BANKCON_TCP_1		0x00000000 /* CAS precharge (in clocks) */
+#define S3C44B0X_BANKCON_TCP_2		0x00000004
+
+#define S3C44B0X_BANKCON_CAN_8		0x00000000 /* column address number (in bits) */
+#define S3C44B0X_BANKCON_CAN_9		0x00000001
+#define S3C44B0X_BANKCON_CAN_10		0x00000002
+#define S3C44B0X_BANKCON_CAN_11		0x00000003
+
+/* only for SDRAM */
+#define S3C44B0X_BANKCON_SDRAM_TRCD_2	0x00000000 /* RAS to CAS delay */
+#define S3C44B0X_BANKCON_SDRAM_TRCD_3	0x00000004
+#define S3C44B0X_BANKCON_SDRAM_TRCD_4	0x00000008
+
+#define S3C44B0X_BANKCON_SCAN_8		0x00000000 /* column address number (in bits) */
+#define S3C44B0X_BANKCON_SCAN_9		0x00000001
+#define S3C44B0X_BANKCON_SCAN_10	0x00000002
+
+
+/* REFRESH */
+#define S3C44B0X_REFRESH_REFEN		0x00800000
+#define S3C44B0X_REFRESH_TREFMD		0x00400000
+
+
+#define S3C44B0X_REFRESH_TRP_1_5	0x00000000 /* for DRAM */
+#define S3C44B0X_REFRESH_TRP_2_5	0x00000000
+#define S3C44B0X_REFRESH_TRP_3_5	0x00000000
+#define S3C44B0X_REFRESH_TRP_4_5	0x00000000
+#define S3C44B0X_REFRESH_TRP_2		0x00000000 /* for SDRAM */
+#define S3C44B0X_REFRESH_TRP_3		0x00000000
+#define S3C44B0X_REFRESH_TRP_4		0x00000000
+#define S3C44B0X_REFRESH_TRP_NONE	0x00000000
+
+#define S3C44B0X_REFRESH_TRC_4		0x00000000 /* SDRAM RC minimum time */
+#define S3C44B0X_REFRESH_TRC_5		0x00040000
+#define S3C44B0X_REFRESH_TRC_6		0x00080000
+#define S3C44B0X_REFRESH_TRC_7		0x000c0000
+
+#define S3C44B0X_REFRESH_TCHR_1		0x00000000 /* CAS Hold Time (DRAM) */
+#define S3C44B0X_REFRESH_TCHR_2		0x00010000
+#define S3C44B0X_REFRESH_TCHR_3		0x00020000
+#define S3C44B0X_REFRESH_TCHR_4		0x00030000
+
+#define S3C44B0X_REFRESH_COUNTER	0x000003FF /* mask for the refresh counter (bit 0-10) */
+
+/* BANKSIZE */
+#define S3C44B0X_BANKSIZE_SCLKEN	0x00000010
+#define S3C44B0X_BANKSIZE_BK76MAP_2	0x00000004
+#define S3C44B0X_BANKSIZE_BK76MAP_4	0x00000005
+#define S3C44B0X_BANKSIZE_BK76MAP_8	0x00000006
+#define S3C44B0X_BANKSIZE_BK76MAP_16	0x00000007
+#define S3C44B0X_BANKSIZE_BK76MAP_32	0x00000000
+
+/* MRSRB */
+#define S3C44B0X_MRSRB_WBL		0x00000200
+#define S3C44B0X_MRSRB_CL_1		0x00000000
+#define S3C44B0X_MRSRB_CL_2		0x00000020
+#define S3C44B0X_MRSRB_CL_3		0x00000030
+#define S3C44B0X_MRSRB_BT_SEQ		0x00000000
+#define S3C44B0X_MRSRB_BT_NONSEQ	0x00000008
+#define S3C44B0X_MRSRB_BL_1		0x00000000
+
+  /************/
+  /*** UART ***/
+  /************/
+  
+#define S3C44B0X_ULCON0			0x01d00000
+#define S3C44B0X_UCON0			0x01d00004
+#define S3C44B0X_UFCON0			0x01d00008
+#define S3C44B0X_UMCON0			0x01d0000c
+#define S3C44B0X_UTRSTAT0		0x01d00010
+#define S3C44B0X_UERSTAT0		0x01d00014
+#define S3C44B0X_UFSTAT0		0x01d00018
+#define S3C44B0X_UMSTAT0		0x01d0001c
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+#define S3C44B0X_UTXH0			0x01d00023
+#define S3C44B0X_URXH0			0x01d00027
+#else
+#define S3C44B0X_UTXH0			0x01d00020
+#define S3C44B0X_URXH0			0x01d00024
+#endif
+
+#define S3C44B0X_UBRDIV0		0x01d00028
+
+#define S3C44B0X_ULCON1			0x01d04000
+#define S3C44B0X_UCON1			0x01d04004
+#define S3C44B0X_UFCON1			0x01d04008
+#define S3C44B0X_UMCON1			0x01d0400c
+#define S3C44B0X_UTRSTAT1		0x01d04010
+#define S3C44B0X_UERSTAT1		0x01d04014
+#define S3C44B0X_UFSTAT1		0x01d04018
+#define S3C44B0X_UMSTAT1		0x01d0401c
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+#define S3C44B0X_UTXH1			0x01d04023
+#define S3C44B0X_URXH1			0x01d04027
+#else
+#define S3C44B0X_UTXH1			0x01d04020
+#define S3C44B0X_URXH1			0x01d04024
+#endif
+
+#define S3C44B0X_UBRDIV1		0x01d04028
+
+/* ULCON */
+#define S3C44B0X_ULCON_IR		0x00000040
+
+#define S3C44B0X_ULCON_PAR_NO		0x00000000
+#define S3C44B0X_ULCON_PAR_ODD		0x00000020
+#define S3C44B0X_ULCON_PAR_EVEN		0x00000028
+#define S3C44B0X_ULCON_PAR_1		0x00000030
+#define S3C44B0X_ULCON_PAR_0		0x00000038
+
+#define S3C44B0X_ULCON_STOPB_1		0x00000000
+#define S3C44B0X_ULCON_STOPB_2		0x00000004
+
+#define S3C44B0X_ULCON_WORDLN_5		0x00000000
+#define S3C44B0X_ULCON_WORDLN_6		0x00000001
+#define S3C44B0X_ULCON_WORDLN_7		0x00000002
+#define S3C44B0X_ULCON_WORDLN_8		0x00000003
+
+/* UCON */
+#define S3C44B0X_UCON_TXINT_LEVEL	0x00000200
+#define S3C44B0X_UCON_RXINT_LEVEL	0x00000100
+#define S3C44B0X_UCON_TXINT_PULSE	0x00000000
+#define S3C44B0X_UCON_RXINT_PULSE	0x00000000
+#define S3C44B0X_UCON_RX_TIMEOUT_EN	0x00000080
+#define S3C44B0X_UCON_RX_ERR_INT_EN	0x00000040
+#define S3C44B0X_UCON_LOOP		0x00000020
+#define S3C44B0X_UCON_SEND_BREAK	0x00000010
+
+#define S3C44B0X_UCON_TX_DIS		0x00000000
+#define S3C44B0X_UCON_TX_MODE_INT_POLL	0x00000004
+#define S3C44B0X_UCON_TX_MODE_BDMA0	0x00000008
+#define S3C44B0X_UCON_TX_MODE_BDMA1	0x0000000c
+
+#define S3C44B0X_UCON_RX_DIS		0x00000000
+#define S3C44B0X_UCON_RX_MODE_INT_POLL	0x00000001
+#define S3C44B0X_UCON_RX_MODE_BDMA0	0x00000002
+#define S3C44B0X_UCON_RX_MODE_BDMA1	0x00000003
+
+/* UFCON */
+#define S3C44B0X_UFCON_TX_FIFO_0	0x00000000 /* TX FIFO byte size */
+#define S3C44B0X_UFCON_TX_FIFO_4	0x00000040
+#define S3C44B0X_UFCON_TX_FIFO_8	0x00000080
+#define S3C44B0X_UFCON_TX_FIFO_12	0x000000c0
+
+#define S3C44B0X_UFCON_RX_FIFO_4	0x00000000 /* RX FIFO byte size */
+#define S3C44B0X_UFCON_RX_FIFO_8	0x00000010
+#define S3C44B0X_UFCON_RX_FIFO_12	0x00000020
+#define S3C44B0X_UFCON_RX_FIFO_16	0x00000030
+
+#define S3C44B0X_UFCON_TX_FIFO_RST	0x00000004
+#define S3C44B0X_UFCON_RX_FIFO_RST	0x00000002
+#define S3C44B0X_UFCON_FIFO_EN		0x00000001 /* global FIFO enable */
+
+/* UMCON */
+#define S3C44B0X_UMCON_AFC		0x00000010  /* auto flow control */
+#define S3C44B0X_UMCON_RQST_SEND	0x00000001  /* request to send 1=L(active RTS) 0=H(inactive RTS) */
+
+/* UTRSTAT */
+#define S3C44B0X_UTRSTAT_TSE		0x00000004  /* transmitter shifter empty */
+#define S3C44B0X_UTRSTAT_TBE		0x00000002  /* transmitt buffer empty */
+#define S3C44B0X_UTRSTAT_RBDR		0x00000001  /* receive buffer data ready */
+
+/* UERSTAT */
+#define S3C44B0X_UERSTAT_BREAK_DETECT	0x00000008
+#define S3C44B0X_UERSTAT_FRAME_ERROR	0x00000004
+#define S3C44B0X_UERSTAT_PARITY_ERROR	0x00000002
+#define S3C44B0X_UERSTAT_OVERRUN_ERROR	0x00000001
+
+/* UFSTAT */
+#define S3C44B0X_UFSTAT_TX_FIFO_FULL	0x00000200
+#define S3C44B0X_UFSTAT_RX_FIFO_FULL	0x00000100
+#define S3C44B0X_UFSTAT_TX_FIFO_COUNT	0x000000F0
+#define S3C44B0X_UFSTAT_RX_FIFO_COUNT	0x0000000F
+
+  /***********/
+  /*** SIO ***/
+  /***********/
+
+#define S3C44B0X_SIOCON			0x01d14000
+#define S3C44B0X_SIODAT			0x01d14004
+#define S3C44B0X_SBRDR			0x01d14008
+#define S3C44B0X_ITVCNT			0x01d1400c
+#define S3C44B0X_DNCTZ			0x01d14010
+
+  /****************************/
+  /*** IIS (Inter IC Sound) ***/
+  /****************************/
+
+#define S3C44B0X_IISCON			0x01d18000
+#define S3C44B0X_IISMOD			0x01d18004
+#define S3C44B0X_IISPSR			0x01d18008
+#define S3C44B0X_IISFIFCON		0x01d1800c
+#define S3C44B0X_IISFIF			0x01d18010
+
+  /*****************/
+  /*** I/O ports ***/
+  /*****************/
+
+#define S3C44B0X_PCONA			0x01d20000
+#define S3C44B0X_PDATA			0x01d20004
+#define S3C44B0X_PCONB			0x01d20008
+#define S3C44B0X_PDATB			0x01d2000c
+
+#define S3C44B0X_PCONC			0x01d20010
+#define S3C44B0X_PDATC			0x01d20014
+#define S3C44B0X_PUPC			0x01d20018
+#define S3C44B0X_PCOND			0x01d2001c
+#define S3C44B0X_PDATD			0x01d20020
+#define S3C44B0X_PUPD			0x01d20024
+#define S3C44B0X_PCONE			0x01d20028
+#define S3C44B0X_PDATE			0x01d2002c
+#define S3C44B0X_PUPE			0x01d20030
+#define S3C44B0X_PCONF			0x01d20034
+#define S3C44B0X_PDATF			0x01d20038
+#define S3C44B0X_PUPF			0x01d2003c
+#define S3C44B0X_PCONG			0x01d20040
+#define S3C44B0X_PDATG			0x01d20044
+#define S3C44B0X_PUPG			0x01d20048
+#define S3C44B0X_SPUCR			0x01d2004c
+
+  /***************************/
+  /*** external interrupts ***/
+  /***************************/
+
+#define S3C44B0X_EXTINT			0x01d20050
+#define S3C44B0X_EXTINPND		0x01d20054
+
+  /**********************/
+  /*** WATCHDOG TIMER ***/
+  /**********************/
+
+#define S3C44B0X_WTCON			0x01d30000
+#define S3C44B0X_WTDAT			0x01d30004
+#define S3C44B0X_WTCNT			0x01d30008
+
+  /*********************/
+  /*** A/D CONVERTER ***/
+  /*********************/
+
+#define S3C44B0X_ADCCON			0x01d40000
+#define S3C44B0X_ADCPSR			0x01d40004
+#define S3C44B0X_ADCDAT			0x01d40008
+
+  /*****************/
+  /*** PWM TIMER ***/
+  /*****************/
+
+#define S3C44B0X_TCFG0			0x01d50000 /* prescaler configuration */
+#define S3C44B0X_TCFG1			0x01d50004 /* MUX-input for PWM and DMA */
+#define S3C44B0X_TCON			0x01d50008 /* timer control register (start/stop, PWM-out, auto-reload, dead-zone) */
+#define S3C44B0X_TCNTB0 		0x01d5000c /* timer counter "buffer" register (read-write) to update the timer counter */
+#define S3C44B0X_TCMPB0			0x01d50010 /* timer compare register */
+#define S3C44B0X_TCNTO0			0x01d50014 /* timer counter "observation" register (real counter value, read-only) */
+#define S3C44B0X_TCNTB1			0x01d50018
+#define S3C44B0X_TCMPB1			0x01d5001c
+#define S3C44B0X_TCNTO1			0x01d50020
+#define S3C44B0X_TCNTB2			0x01d50024
+#define S3C44B0X_TCMPB2			0x01d50028
+#define S3C44B0X_TCNTO2			0x01d5002c
+#define S3C44B0X_TCNTB3			0x01d50030
+#define S3C44B0X_TCMPB3			0x01d50034
+#define S3C44B0X_TCNTO3			0x01d50038
+#define S3C44B0X_TCNTB4			0x01d5003c
+#define S3C44B0X_TCMPB4			0x01d50040
+#define S3C44B0X_TCNTO4			0x01d50044
+#define S3C44B0X_TCNTB5			0x01d50048
+#define S3C44B0X_TCNTO5			0x01d5004c
+
+/* TCON */
+#define S3C44B0X_TCON_T5_AUTO		0x04000000 /* automatically reload the timer register (cycle) */
+#define S3C44B0X_TCON_T5_MAN_UPDATE	0x02000000 /* manualy update the counter (read from TCNTBn) */
+#define S3C44B0X_TCON_T5_START		0x01000000 /* start the timer (normal modus) if bit not set -> no decrement of counter */
+
+#define S3C44B0X_TCON_T4_AUTO		0x00800000
+#define S3C44B0X_TCON_T4_OUTPUT		0x00400000 /* enable output to the PWM-pin (controlled by TCMPBn and TCNTBn) */
+#define S3C44B0X_TCON_T4_MAN_UPDATE	0x00200000
+#define S3C44B0X_TCON_T4_START		0x00100000
+
+#define S3C44B0X_TCON_T3_AUTO		0x00080000
+#define S3C44B0X_TCON_T3_OUTPUT		0x00040000
+#define S3C44B0X_TCON_T3_MAN_UPDATE	0x00020000
+#define S3C44B0X_TCON_T3_START		0x00010000
+
+#define S3C44B0X_TCON_T2_AUTO		0x00008000
+#define S3C44B0X_TCON_T2_OUTPUT		0x00004000
+#define S3C44B0X_TCON_T2_MAN_UPDATE	0x00002000
+#define S3C44B0X_TCON_T2_START		0x00001000
+
+#define S3C44B0X_TCON_T1_AUTO		0x00000800
+#define S3C44B0X_TCON_T1_OUTPUT		0x00000400
+#define S3C44B0X_TCON_T1_MAN_UPDATE	0x00000200
+#define S3C44B0X_TCON_T1_START		0x00000100
+
+#define S3C44B0X_TCON_DEAD_ZONE_EN	0x00000010 /* enable the dead zone for PWM-mode */
+
+#define S3C44B0X_TCON_T0_AUTO		0x00000008
+#define S3C44B0X_TCON_T0_OUTPUT		0x00000004
+#define S3C44B0X_TCON_T0_MAN_UPDATE	0x00000002
+#define S3C44B0X_TCON_T0_START		0x00000001
+
+  /***********/
+  /*** IIC ***/
+  /***********/
+
+#define S3C44B0X_IICCON			0x01d60000
+#define S3C44B0X_IICSTAT		0x01d60004
+#define S3C44B0X_IICADD			0x01d60008
+#define S3C44B0X_IICDS			0x01d6000c
+
+  /***********/
+  /*** RTC ***/
+  /***********/
+
+#define S3C44B0X_RTCCON			0x01d70040
+#define S3C44B0X_RTCALM			0x01d70050
+#define S3C44B0X_ALMSEC			0x01d70054
+#define S3C44B0X_ALMMIN			0x01d70058
+#define S3C44B0X_ALMHOUR		0x01d7005c
+#define S3C44B0X_ALMDAY			0x01d70060
+#define S3C44B0X_ALMMON			0x01d70064
+#define S3C44B0X_ALMYEAR		0x01d70068
+#define S3C44B0X_RTCRST			0x01d7006c
+#define S3C44B0X_BCDSEC			0x01d70070
+#define S3C44B0X_BCDMIN			0x01d70074
+#define S3C44B0X_BCDHOUR		0x01d70078
+#define S3C44B0X_BCDDAY			0x01d7007c
+#define S3C44B0X_BCDDATE		0x01d70080
+#define S3C44B0X_BCDMON			0x01d70084
+#define S3C44B0X_BCDYEAR		0x01d70088
+#define S3C44B0X_TICINT			0x01d7008c
+
+  /********************************/
+  /*** CLOCK & POWER MANAGEMENT ***/
+  /********************************/
+
+#define S3C44B0X_PLLCON			0x01d80000
+#define S3C44B0X_CLKCON			0x01d80004
+#define S3C44B0X_CLKSLOW		0x01d80008
+#define S3C44B0X_LOCKTIME		0x01d8000c
+
+#define S3C44B0X_CLKCON_IIS		0x4000
+#define S3C44B0X_CLKCON_IIC		0x2000
+#define S3C44B0X_CLKCON_ADC		0x1000
+#define S3C44B0X_CLKCON_RTC		0x0800
+#define S3C44B0X_CLKCON_GPIO		0x0400
+#define S3C44B0X_CLKCON_UART1		0x0200
+#define S3C44B0X_CLKCON_UART0		0x0100
+#define S3C44B0X_CLKCON_BDMA		0x0080
+#define S3C44B0X_CLKCON_LCDC		0x0040
+#define S3C44B0X_CLKCON_SIO		0x0020
+#define S3C44B0X_CLKCON_ZDMA		0x0010
+#define S3C44B0X_CLKCON_PWMTIMER	0x0008
+#define S3C44B0X_CLKCON_IDLE_BIT	0x0004
+#define S3C44B0X_CLKCON_SL_IDLE		0x0002
+#define S3C44B0X_CLKCON_STOP_BIT	0x0001
+
+#define S3C44B0X_CLKSLOW_PLL_OFF	0x00000010
+#define S3C44B0X_CLKSLOW_SLOW_BIT	0x00000008
+#define S3C44B0X_CLKSLOW_VAL_0		0x00000000
+#define S3C44B0X_CLKSLOW_VAL_1		0x00000001
+#define S3C44B0X_CLKSLOW_VAL_2		0x00000002
+#define S3C44B0X_CLKSLOW_VAL_3		0x00000003
+
+  /****************************/
+  /*** INTERRUPT CONTROLLER ***/
+  /****************************/
+
+#define S3C44B0X_INTCON			0x01e00000
+#define S3C44B0X_INTPND			0x01e00004
+#define S3C44B0X_INTMOD			0x01e00008
+#define S3C44B0X_INTMSK			0x01e0000c
+#define S3C44B0X_I_PSLV			0x01e00010
+#define S3C44B0X_I_PMST			0x01e00014
+#define S3C44B0X_I_CSLV			0x01e00018
+#define S3C44B0X_I_CMST			0x01e0001c
+#define S3C44B0X_I_ISPR			0x01e00020
+#define S3C44B0X_I_ISPC			0x01e00024
+#define S3C44B0X_F_ISPR			0x01e00038
+#define S3C44B0X_F_ISPC			0x01e0003c
+
+  /***********/
+  /*** DMA ***/
+  /***********/
+
+#define S3C44B0X_ZDCON0			0x01e80000
+#define S3C44B0X_ZDISRC0		0x01e80004
+#define S3C44B0X_ZDIDES0		0x01e80008
+#define S3C44B0X_ZDICNT0		0x01e8000c
+#define S3C44B0X_ZDCSRC0		0x01e80010
+#define S3C44B0X_ZDCDES0		0x01e80014
+#define S3C44B0X_ZDCCNT0		0x01e80018
+#define S3C44B0X_ZDCON1			0x01e80020
+#define S3C44B0X_ZDISRC1		0x01e80024
+#define S3C44B0X_ZDIDES1		0x01e80028
+#define S3C44B0X_ZDICNT1		0x01e8002c
+#define S3C44B0X_ZDCSRC1		0x01e80030
+#define S3C44B0X_ZDCDES1		0x01e80034
+#define S3C44B0X_ZDCCNT1		0x01e80038
+
+#define S3C44B0X_BDCON0			0x01f80000
+#define S3C44B0X_BDISRC0		0x01f80004
+#define S3C44B0X_BDIDES0		0x01f80008
+#define S3C44B0X_BDICNT0		0x01f8000c
+#define S3C44B0X_BDCSRC0		0x01f80010
+#define S3C44B0X_BDCDES0		0x01f80014
+#define S3C44B0X_BDCCNT0		0x01f80018
+#define S3C44B0X_BDCON1			0x01f80020
+#define S3C44B0X_BDISRC1		0x01f80024
+#define S3C44B0X_BDIDES1		0x01f80028
+#define S3C44B0X_BDICNT1		0x01f8002c
+#define S3C44B0X_BDCSRC1		0x01f80030
+#define S3C44B0X_BDCDES1		0x01f80034
+#define S3C44B0X_BDCCNT1		0x01f80038
+
+#define S3C44B0X_ZDCON_STE_RDY		0x00000000
+#define S3C44B0X_ZDCON_STE_NTC		0x00000040
+#define S3C44B0X_ZDCON_STE_TC		0x00000080
+
+#define S3C44B0X_ZDCON_QDS_EN		0x00000000
+#define S3C44B0X_ZDCON_QDS_DIS		0x0000000c
+
+#define S3C44B0X_ZDCON_CMD_NONE		0x00000000
+#define S3C44B0X_ZDCON_CMD_START	0x00000001
+#define S3C44B0X_ZDCON_CMD_PAUSE	0x00000002
+#define S3C44B0X_ZDCON_CMD_CANCEL	0x00000003
+
+
+/*********************
+ *   LCD controller  *
+ *********************/
+#define S3C44B0X_LCD_MEM		0x0c060000
+
+#define S3C44B0X_LCDCON1                0x01f00000
+#define S3C44B0X_LCDCON2                0x01f00004
+#define S3C44B0X_LCDCON3                0x01f00040
+#define S3C44B0X_LCDSADDR1              0x01f00008
+#define S3C44B0X_LCDSADDR2              0x01f0000c
+#define S3C44B0X_LCDSADDR3              0x01f00010
+
+#define S3C44B0X_REDLUT                 0x01f00014
+#define S3C44B0X_GREENLUT               0x01f00018
+#define S3C44B0X_BLUELUT                0x01f0001c
+#define S3C44B0X_DP1_2                  0x01f00020
+#define S3C44B0X_DP4_7                  0x01f00024
+#define S3C44B0X_DP3_5                  0x01f00028
+#define S3C44B0X_DP2_3                  0x01f0002c
+#define S3C44B0X_DP5_7                  0x01f00030
+#define S3C44B0X_DP3_4                  0x01f00034
+#define S3C44B0X_DP4_5                  0x01f00038
+#define S3C44B0X_DP6_7                  0x01f0003c
+
+#define S3C44B0X_DITHMODE               0x01f00044
+
+/* LCDCON1 */
+#define S3C44B0X_LCDCON1_WLH_4          0x00000000
+#define S3C44B0X_LCDCON1_WLH_8          0x00000400
+#define S3C44B0X_LCDCON1_WLH_12         0x00000800
+#define S3C44B0X_LCDCON1_WLH_16         0x00000c00
+
+#define S3C44B0X_LCDCON1_WDLY_4         0x00000000
+#define S3C44B0X_LCDCON1_WDLY_8         0x00000100
+#define S3C44B0X_LCDCON1_WDLY_12        0x00000200
+#define S3C44B0X_LCDCON1_WDLY_16        0x00000300
+
+#define S3C44B0X_LCDCON1_MMODE          0x00000080
+
+#define S3C44B0X_LCDCON1_DISMODE_4D     0x00000000
+#define S3C44B0X_LCDCON1_DISMODE_4S     0x00000020
+#define S3C44B0X_LCDCON1_DISMODE_8S     0x00000040
+
+#define S3C44B0X_LCDCON1_INVCLK         0x00000010
+#define S3C44B0X_LCDCON1_INVLINE        0x00000008
+#define S3C44B0X_LCDCON1_INVFRAME       0x00000004
+#define S3C44B0X_LCDCON1_INVVD          0x00000002
+#define S3C44B0X_LCDCON1_ENVID          0x00000001
+
+
+/* LCDCON3 */
+#define S3C44B0X_LCDCON3_SELFREFRESH	0x00000001
+
+
+/* LCDSADDR1 */
+#define S3C44B0X_LCDSADDR1_MONO		0x00000000
+#define S3C44B0X_LCDSADDR1_GRAY_4	0x08000000
+#define S3C44B0X_LCDSADDR1_GRAY_16	0x10000000
+#define S3C44B0X_LCDSADDR1_COLOR	0x18000000
+
+/* LCDSADDR2 */
+#define S3C44B0X_LCDSADDR2_BSWP     	0x20000000
+#endif /* _S3C44B0X_H_ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/sizes.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/sizes.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/sizes.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/sizes.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/system.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/system.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/system.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/system.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,25 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/system.h
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+ 	/* machine should reboot */
+ 	mdelay(5000);
+ 	panic("Watchdog timer reset failed!\n");
+ 	printk(" Jump to address 0 \n");
+ 	cpu_reset(0);
+}
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/time.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/time.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/time.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/time.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,66 @@
+/*
+ *  linux/include/asm-arm/arch-s3c44b0x/time.h
+ */
+
+#ifndef __ASM_ARCH_TIME_H__
+#define __ASM_ARCH_TIME_H__
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/timex.h>
+
+/*
+ * Set up timer interrupt.
+ */
+#if	CONFIG_ARM_CLK_ADJUST
+void s3c44b0x_systimer_setup(void);
+void s3c44b0x_led_off(int);
+void s3c44b0x_led_on(int);
+#else
+void __init s3c44b0x_systimer_setup(void);
+#endif
+
+void __inline__ s3c44b0x_systimer_start(void);
+
+unsigned long s3c44b0x_gettimeoffset (void)
+{
+	return SYSREG_GETW(S3C44B0X_TCNTB5);
+}
+
+static irqreturn_t s3c44b0x_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+#if	CONFIG_DEBUG_NICKMIT
+	static int cnt = 0;
+	++cnt;
+	if (cnt == HZ) {
+		static int stat = 0;
+		cnt = 0;
+		if (stat)
+			s3c44b0x_led_on(0);
+		else
+			s3c44b0x_led_off(0);
+		stat = 1 - stat;
+	}
+#endif
+	do_timer(regs);
+	do_profile(regs);
+	return IRQ_HANDLED;
+}
+
+void __init time_init(void) 
+{
+	s3c44b0x_systimer_setup();
+	/*
+	 * @todo do those really need to be function pointers ?
+	 */
+	gettimeoffset     = s3c44b0x_gettimeoffset;
+	timer_irq.handler = s3c44b0x_timer_interrupt;
+
+	setup_irq(S3C44B0X_INTERRUPT_TIMER5, &timer_irq);
+	s3c44b0x_clear_pb(S3C44B0X_INTERRUPT_TIMER5);
+	s3c44b0x_unmask_irq(S3C44B0X_INTERRUPT_TIMER5);
+
+	s3c44b0x_systimer_start();
+}
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/timex.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/timex.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/timex.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/timex.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,10 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c3410/timex.h
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H__
+#define __ASM_ARCH_TIMEX_H__
+
+#define CLOCK_TICK_RATE (CONFIG_ARM_CLK)
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/uncompress.c linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/uncompress.c
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/uncompress.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/uncompress.c	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,23 @@
+/*
+ * linux/include/asm/arch-samsung/uncompress.c
+ */
+
+#include <asm/hardware.h>
+
+static int s3c44b0x_decomp_setup()
+{
+}
+
+static int s3c44b0x_putc(char c)
+{
+	while (!(SYSREG_GET(S3C44B0X_UTRSTAT0) & 0x2));
+	SYSREG_SETB(S3C44B0X_UTXH0, c);
+	if(c == '\n')
+		s3c44b0x_putc('\r');
+}
+
+static void s3c44b0x_puts(const char *s)
+{
+	while(*s != '\0')
+		s3c44b0x_putc(*s++);
+}
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/uncompress.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/uncompress.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/uncompress.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/uncompress.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,51 @@
+/*
+ * asm/arch/uncompress.c:
+ *         Optional routines to aid in debugging the decompression phase
+ *         of kernel boot.
+ * copyright:
+ *         (C) 2001 RidgeRun, Inc. (http://www.ridgerun.com)
+ * author: Gordon McNutt <gmcnutt@ridgerun.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ * WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ * USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <asm/arch/uncompress.c>
+/*
+ * This is used by arch/armnommu/boot/compressed/misc.c to write progress info
+ * out the serial port so that the user can see debug messages up to the point
+ * where the kernel is decompressed. The STANDALONE_DEBUG macro chooses between
+ * this and the standard printf. Punt.
+ * --gmcnutt
+ */
+#define puts(s)			s3c44b0x_puts(s)
+
+/*
+ * Not sure what this is for. Probably an optional watchdog to check if the
+ * decompress got hung so we can warn the user. Punt.
+ */
+#define arch_decomp_wdog()
+
+/*
+ * If we need to do some setup prior to decompression (like initializing the
+ * UART if we want to use puts() above) then we define it here. Punt.
+ */
+#define arch_decomp_setup()	s3c44b0x_decomp_setup()
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/vmalloc.h linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/vmalloc.h
--- linux-2.6.9/include/asm-armnommu/arch-s3c44b0x/vmalloc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/vmalloc.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-armnommu/arch-s3c44b0x/vmalloc.h
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_S3C44B0X_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_S3C44B0X_SDRAM_SIZE)   
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/blkmem.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/blkmem.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/blkmem.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/blkmem.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,25 @@
+/*
+ * linux/include/asm-armnommu/arch-s5c7375/blkmem.h
+ *
+ * Copyright (c) 2003 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ * <hyok.choi@samsung.com>
+ *
+ * Contains configuration settings for the blkmem driver.
+ */
+#ifndef __ASM_ARCH_BLKMEM_H
+#define __ASM_ARCH_BLKMEM_H
+
+#define CAT_ROMARRAY
+
+
+#ifndef HYOK_ROMFS_BOOT	
+    extern char _end[];
+    #define FIXUP_ARENAS \
+	arena[0].address = ((unsigned long)_end + DRAM_BASE + 0x2000);	// ram
+#else
+    extern char __bss_start[];
+    #define FIXUP_ARENAS \
+	arena[0].address = ((unsigned long)__bss_start + FLASH_MEM_BASE); // rom
+#endif
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/dma.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/dma.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/dma.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/dma.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,141 @@
+/*
+ * linux/include/asm-arm/arch-s5c7375/dma-s5c7375.h
+ * Generic S5C7375  DMA support
+ * Copyright (C) 2002 SW.LEE <hitchcar@sec.samsung.com>
+ * Copyright (C) 2003 Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#include <linux/config.h>
+#include <asm/hardware.h>
+#include <linux/wait.h>
+
+#ifndef __ASM_S5C7375_ARCH_DMA_H
+#define __ASM_S5C7375_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ * 
+ */
+#define MAX_DMA_ADDRESS		0x20000000
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+/*
+ * The regular generic DMA interface is inappropriate for the
+ * S5C7375 DMA model.  None of the S5C7375 specific drivers using
+ * DMA are portable anyway so it's pointless to try to twist the
+ * regular DMA API to accommodate them.
+ */
+
+/***************************************************************************/
+/* this means that We will use arch/arm/mach/dma.h i.e generic dma module  */
+#define MAX_DMA_CHANNELS	0
+/****************************************************************************/
+
+/*
+ * The S5C7375 has four internal DMA channels.
+ */
+#define S5C7375_DMA_CHANNELS     6
+
+#define MAX_S5C7375_DMA_CHANNELS S5C7375_DMA_CHANNELS
+
+
+/*
+ * All possible S5C7375 devices the specific DMA channel can be attached to.
+ * I'm sorry for only DMA Device Address
+ * DMA request sources would be controlled by H/W DMA mode selected by DCON register
+ */
+
+typedef enum {
+      DMA0_SOURCE0 ,		/* EXT device 0 */
+      DMA0_SOURCE1 ,		/* UART1  */
+      DMA0_SOURCE2 ,		/* USB  */
+      DMA0_SOURCE3 ,		/* PPIC  */
+      DMA0_SOURCE4 ,		/* UART0 */
+      DMA0_SOURCE5 ,		/* EXT device 1 */
+} dma_device_t;
+
+
+/*
+ * DMA buffer structure
+ */
+
+typedef struct dma_buf_s {
+	int size;		/* buffer size */
+	dma_addr_t dma_start;	/* starting DMA address */
+	dma_addr_t dma_ptr;	/* next DMA pointer to use */
+	int ref;		/* number of DMA references */
+	void *id;		/* to identify buffer from outside */
+	struct dma_buf_s *next;	/* next buffer to process */
+} dma_buf_t;
+
+
+/*
+ * DMA channel structure.
+ */
+
+/*
+ * DMA control register structure
+ * one channel S5C7375 DMA control register is 0x40 byte
+ *
+ */
+ 
+typedef void (*dma_callback_t)( void *buf_id, int size);
+
+typedef struct {
+	volatile u_long DISRC;
+	volatile u_long DISRCC;
+	volatile u_long DIDST;
+	volatile u_long DIDSTC;
+	volatile u_long DCON;
+	volatile u_long DSTAT;
+	volatile u_long DCSRC;
+	volatile u_long DCDST;
+	volatile u_long DMASKTRIG;
+} dma_regs_t;
+
+#define DOUBLE_BUFFER_COUNT 3
+typedef struct {
+	unsigned int in_use;	/* Device is allocated */
+	const char *device_id;	/* Device name */
+	dma_device_t device;	/* ... to which this channel is attached */
+	dma_buf_t *head;	/* where to insert buffers */
+	dma_buf_t *tail;	/* where to remove buffers */
+	dma_buf_t *curr;	/* buffer currently DMA'ed */
+	int stopped;		/* 1 if DMA is stalled */
+	dma_regs_t *regs;	/* points to appropriate DMA registers */
+	int irq;		/* IRQ used by the channel */
+	dma_callback_t callback; /* ... to call when buffers are done */
+
+	unsigned int queueCnt;
+	unsigned int usedQueueCnt;	
+	int	isSleeping;
+	int spin_size;		/* > 0 when DMA should spin when no more buffer */
+	dma_addr_t spin_addr;	/* DMA address to spin onto */
+	int spin_ref;		/* number of spinning references */
+
+        unsigned char already_init;	/* S5C7375 specific  */
+} s5c7375_dma_t;
+
+/* S5C7375 DMA API */
+extern int s5c7375_request_dma( dmach_t channel, const char *device_id,
+			       dma_device_t device );
+extern int s5c7375_dma_set_callback( dmach_t channel, dma_callback_t cb );
+extern int s5c7375_dma_set_spin( dmach_t channel, dma_addr_t addr, int size );
+extern int s5c7375_dma_queue_buffer( dmach_t channel, void *buf_id,
+				    dma_addr_t data, int size );
+extern int s5c7375_dma_get_current( dmach_t channel, void **buf_id, dma_addr_t *addr );
+extern int s5c7375_dma_stop( dmach_t channel );
+extern int s5c7375_dma_resume( dmach_t channel );
+extern int s5c7375_dma_flush_all( dmach_t channel );
+extern void s5c7375_free_dma( dmach_t channel );
+extern int s5c7375_dma_sleep( dmach_t channel );
+extern int s5c7375_dma_wakeup( dmach_t channel );
+extern void s5c7375_dma_done (s5c7375_dma_t *dma);
+
+#endif /* _ASM_S5C7375_ARCH_DMA_H */
+
+
+
+
+
+
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/hardware.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/hardware.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/hardware.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/hardware.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,31 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/hardware.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                   Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/sizes.h>
+#include <asm/arch/s5c7375.h>
+
+#ifndef __ASSEMBLY__
+
+#define HARD_RESET_NOW()
+
+/* the machine dependent  bootmem reserve and free routines */
+#define MACH_RESERVE_BOOTMEM()  do { \
+	/* we need to keep the section table for mmu */ \
+	reserve_bootmem_node(pgdat, 0x00004000, 0x4000); \
+	} while(0)
+
+#define MACH_FREE_BOOTMEM()
+
+/* yes, freeing initmem is okay */
+#define DO_FREE_INITMEM() 	(1)
+
+#endif
+
+#endif  /*   END OF __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/io.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/io.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/io.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/io.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,69 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/io.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS
+ *			Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+	/* Used in kernel/resource.c */
+
+/*
+ * We have the this routine to use usb host device driver
+ *
+ */
+
+
+#define PCI_IO_VADDR      (0x0)
+#define PCI_MEMORY_VADDR  (0x0)
+
+#define __io(a)			(PCI_IO_VADDR + (a))
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(PCI_MEMORY_VADDR + (unsigned long)(a))
+
+
+/*
+ * Generic virtual read/write
+ */
+#if 0
+#define __arch_getw(a)		(*(volatile unsigned short *)(a))
+#define __arch_putw(v,a)	(*(volatile unsigned short *)(a) = (v))
+#endif
+/*
+ * Validate the pci memory address for ioremap.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+
+/* 
+ * For example, 
+ * CS8900A Net Device Driver
+ * for asm/io.h 
+ */
+/*
+#define __io 
+*/
+
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ */
+#define iomem_to_phys(iomem)	(iomem)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/irq.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/irq.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/irq.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/irq.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/irq.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __S5C7375_irq_h
+#define __S5C7375_irq_h
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/irqs.h>
+
+/* To understand S5C7375 irq 
+ * Look hard at "fixup_irq definition in irq.c file "
+ */
+extern unsigned  int fixup_irq(int i);
+
+extern void do_IRQ(int irq, struct pt_regs *regs);
+
+extern void s5c7375_init_irq(void);
+
+#define 	irq_init_irq 	s5c7375_init_irq
+
+#endif 
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/irqs.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/irqs.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/irqs.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/irqs.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,124 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/irqs.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONIS  
+ *                        Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __S5C7375_irqs_h
+#define __S5C7375_irqs_h                        1
+
+	#define iSRAMBase    0x06000000    // internal SRAM base address
+	#define iSRAMTop     0x06001FFC    // top address of interanl SRAM
+	#define SDRAMBase    0x00000000
+	#define SDRAMTop     0x003FFFFC
+	
+#define SHORTNUMOFINT	
+	/* the number of interrupt source */
+  #ifdef SHORTNUMOFINT
+	#define NumOfInt	16
+  #else
+	#define NumOfInt	32
+  #endif
+	/* for compatibility for linux */
+	#define NR_IRQS (NumOfInt)
+	
+	/* Interrupt Vector table address */
+#ifdef SHORTNUMOFINT
+	#define IntVectorTable          iSRAMTop-(NumOfInt << 3)  //internal SRAM area
+#else
+	#define IntVectorTable          iSRAMTop-(NumOfInt << 2)  //internal SRAM area
+#endif
+	#define IntVectorTableEnd       iSRAMTop
+	//#define IntVectorTable          SDRAMTop-(NumOfInt << 2)  //SDRAM area
+	//#define IntVectorTableEnd       SDRAMTop
+	
+	/*
+	 * Interrupt Vector Table
+	 */
+	
+	#define pIVT_TIMER0     (*(volatile unsigned *)(IntVectorTable))
+	#define pIVT_TIMER2     (*(volatile unsigned *)(IntVectorTable+0x04))
+	#define pIVT_TIMER3     (*(volatile unsigned *)(IntVectorTable+0x08))
+	#define pIVT_USB        (*(volatile unsigned *)(IntVectorTable+0x0C))
+	#define pIVT_TIMER4     (*(volatile unsigned *)(IntVectorTable+0x10))	 // ADD BY HIS
+	#define pIVT_DMA        (*(volatile unsigned *)(IntVectorTable+0x14))
+	#define pIVT_TIMER1     (*(volatile unsigned *)(IntVectorTable+0x18))
+	#define pIVT_I2C        (*(volatile unsigned *)(IntVectorTable+0x1C))
+	#define pIVT_COMMRX     (*(volatile unsigned *)(IntVectorTable+0x20))
+	#define pIVT_COMMTX     (*(volatile unsigned *)(IntVectorTable+0x24))
+	#define pIVT_GPIO       (*(volatile unsigned *)(IntVectorTable+0x28))
+	#define pIVT_EXT0       (*(volatile unsigned *)(IntVectorTable+0x2C))
+	#define pIVT_EXT1       (*(volatile unsigned *)(IntVectorTable+0x30))
+	#define pIVT_EXT2       (*(volatile unsigned *)(IntVectorTable+0x34))
+	#define pIVT_EXT3       (*(volatile unsigned *)(IntVectorTable+0x38))
+	
+	
+	/*
+	 *  define the interrupt source corresponing to each interrupt register bits 
+	 */
+	
+	#define INT_TIMER0      0x00000001
+	#define INT_TIMER2      0x00000002
+	#define INT_TIMER3      0x00000004
+	#define INT_USB	        0x00000008
+	#define INT_TIMER4      0x00000010	
+	#define INT_DMA	        0x00000020
+	#define INT_TIMER1      0x00000040
+	#define INT_I2C	        0x00000080
+	#define INT_COMMRX      0x00000100
+	#define INT_COMMTX      0x00000200
+	#define INT_GPIO        0x00000400
+	#define INT_EXT0        0x00000800
+	#define INT_EXT1        0x00001000
+	#define INT_EXT2        0x00002000
+	#define INT_EXT3        0x00004000
+
+	#define INT_N_TIMER0    	0
+	#define INT_N_TIMER2      1
+	#define INT_N_TIMER3      2
+	#define INT_N_USB	     	3
+	#define INT_N_TIMER4      4
+	#define INT_N_DMA	      	5
+	#define INT_N_TIMER1      6
+	#define INT_N_I2C	      	7
+	#define INT_N_COMMRX    	8
+	#define INT_N_COMMTX   	9
+	#define INT_N_GPIO        	10
+	#define INT_N_EXT0        	11
+	#define INT_N_EXT1        	12
+	#define INT_N_EXT2        	13
+	#define INT_N_EXT3        	14
+
+	
+	
+	#define EnableFIQ()     (rINTCON = ((rINTCON) & (0x0E)))
+	#define DisableFIQ()    (rINTCON = ((rINTCON) | (0x01)))
+	
+	#define EnableIRQ()     (rINTCON = ((rINTCON )& (0x0D)))
+	#define DisableIRQ()    (rINTCON = ((rINTCON) | (0x02)))
+	
+	#define EnableGMask()   (rINTCON = ((rINTCON) | (0x08)))
+	#define DisableGMask()  (rINTCON = ((rINTCON) & (0x07)))
+	
+	#define EnableInt(x)    (rINTMSK = ((rINTMSK) & (~(x))))
+	#define DisableInt(x)   (rINTMSK = ((rINTMSK) | (x)))
+
+
+//	#define OS_TIMER        INT_TIMER4 // used in irq.c?
+
+#endif /* End of __irqs_h */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/memory.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/memory.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/memory.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/memory.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,30 @@
+/*
+ * linux/include/asm-arm/arch-s5c7375/memory.h
+ *
+ * Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *		Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+#define TASK_SIZE	(0x01a00000UL)
+#define TASK_SIZE_26	TASK_SIZE
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+
+#define PHYS_OFFSET	(CONFIG_DRAM_BASE)
+#define PAGE_OFFSET 	(PHYS_OFFSET)
+#define END_MEM     	(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((unsigned long) (ppage))
+#define __virt_to_bus(vpage) ((unsigned long) (vpage))
+#define __bus_to_virt(ppage) ((unsigned long) (ppage))
+
+#endif /*  __ASM_ARCH_MEMORY_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/param.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/param.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/param.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/param.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef __ARCH_ASM_PARAM_H__
+#define __ARCH_ASM_PARAM_H__
+
+/* nothing for now */
+
+#endif /* __ARCH_ASM_PARAM_H__ */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/s5c7375.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/s5c7375.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/s5c7375.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/s5c7375.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,384 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/s5c7375.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS
+ *                         Hyok S. Choi (hyok.choi@samsung.com)
+ *
+ */
+
+#ifndef __S5C7375_H
+#define __S5C7375_H
+
+/* keywoard : ClockParameter */
+#define  FCLK 162000000
+#define ECLK 27000000
+#define  BUSWIDTH (32)
+
+
+/* keywoard : Phy2Vir */
+#define S5C7375_MEM_SIZE     (CONFIG_DRAM_SIZE) 
+#define MEM_SIZE            S5C7375_MEM_SIZE
+
+#define PA_SDRAM_BASE         CONFIG_DRAM_BASE/* used in asm/arch/arch.c     */
+
+#ifndef HYOK_ROMFS_BOOT
+#define ZIP_RAMDISK_SIZE      (256*1024)  /* used in asm/arch/arch.c  */
+#define RAMDISK_DN_ADDR       (PA_SDRAM_BASE + 0x00400000 - ZIP_RAMDISK_SIZE) /* used in asm/arch/arch.c     */
+#else
+#define ZIP_RAMDISK_SIZE	(0x00040000)  /* used in asm/arch/arch.c  */
+#define RAMDISK_DN_ADDR	(0x00400000 - ZIP_RAMDISK_SIZE)
+#endif
+
+/* if CONFIG_BLK_DEV_RAM_SIZE not defined */
+#define BLK_DEV_RAM_SIZE      (256*1024)  
+
+	#define rSCRBase     0x40000000     /* base of the System Configuration register */
+	#define rASICBase    0x0C000000	    /* base of all I/O module register */
+	#define rPTEAKBase   0x08F00000     /* preload TeakLite base address */
+	
+	
+	/* define the base of each I/O devices */
+	#define rARM920T     rASICBase
+	#define rMEMBase     (rASICBase+0x10000) /* Memory controller */
+	#define rDMABase     (rASICBase+0x20000) /* DMA controller */
+	#define rLCDBase     (rASICBase+0x30000) /* LCD controller */
+	#define rEMACBase    (rASICBase+0x40000) /* Ethernet MAC controller */
+	#define rXMEMBase    (rASICBase+0x50000) /* TeakLite X memory(16KB) */
+	#define rYMEMBase    (rASICBase+0x60000) /* TeakLite Y memory(8KB) */
+	#define rPMEMBase    (rASICBase+0x70000) /* TeakLite P memory(32KB) */
+	#define rAPBBase     (rASICBase+0x80000) /* AHB2APB bridge */
+	
+	/* Preload TeakLite address */
+	#define rPPDataArea  (rPTEAKBase+0x00)   /* preload TeakLite P data area */
+	#define rPXDataArea  (rPTEAKBase+0x40000)/* preload TeakLite X data area */
+	#define rPYDataArea  (rPTEAKBase+0x60000)/* preload TeakLite Y data area */
+	
+	/************ AHB2APB bridge I/O device register *************/ 
+	#define rBRIDGEBase  (rAPBBase+0x000)    /* APB Bridge interface */
+	#define rSCIBase     (rAPBBase+0x400)    /* Smart card interface */
+	#define rUSBBase     (rAPBBase+0x5800)    /* USB */
+	#define rPPIBase     (rAPBBase+0xC00)    /* IEE1284, Parallel port */
+	#define rIICBase     (rAPBBase+0x1000)   /* IIC */
+	#define rTIMEBase    (rAPBBase+0x1400)   /* Timer */
+	#define rRTCBase     (rAPBBase+0x1800)   /* Real time clock */
+	#define rWDTBase     (rAPBBase+0x1C00)   /* Watch Dog Timer */
+	#define rIOPBase     (rAPBBase+0x2000)   /* Programmable I/O port */
+	#define rRPCBase     (rAPBBase+0x2400)   /* Memory remap */ 
+	#define rINTBase     (rAPBBase+0x2800)   /* Interrupt controller */
+	#define rSSPBase     (rAPBBase+0x2C00)   /* SSP interface */
+	#define rKMI0Base    (rAPBBase+0x3000)   /* KMI0 */
+	#define rUART0Base   (rAPBBase+0x3400)   /* UART0 */
+	#define rUART1Base   (rAPBBase+0x3800)   /* UART1 */
+	#define rPMBase      (rAPBBase+0x3C00)   /* Power manager */
+	#define rTEAKBase    (rAPBBase+0x4000)   /* Teaklite Z space */
+	#define rKMI1Base    (rAPBBase+0x4800)   /* KMI1 */
+	#define rMISCBase    (rAPBBase+0x4C00)   /* Miscellaneous */
+	#define rEXT0Base    (rAPBBase+0x5000)   /* External 0 */
+	#define rEXT1Base    (rAPBBase+0x5400)   /* External 1 */
+	#define rEXT2Base    (rAPBBase+0x5800)   /* External 2 */
+	#define rEXT3Base    (rAPBBase+0x5C00)   /* External 3 */
+	#define rPCMCIABase  (rAPBBase+0x9000)   /* Programmable I/O port */
+	
+	/* Memory Controller(32bit)*/
+	#define rSDRAMCFG0    (*(volatile unsigned *)(rMEMBase+0x00))	/* SDRAM config0 register */
+	#define rSDRAMCFG1    (*(volatile unsigned *)(rMEMBase+0x04))	/* SDRAM config1 register */
+	#define rSDRAMRefresh (*(volatile unsigned *)(rMEMBase+0x08))	/* SDRAM refresh register */
+	#define rSDRAMWB      (*(volatile unsigned *)(rMEMBase+0x0C))	/* SDRAM WB timeout register */
+	// new static memory controller version
+	#define rSMCBANK0     (*(volatile unsigned *)(rMEMBase+0x10))
+	#define rSMCBANK1     (*(volatile unsigned *)(rMEMBase+0x14))
+	#define rSMCBANK2     (*(volatile unsigned *)(rMEMBase+0x18))
+	#define rSMCBANK3     (*(volatile unsigned *)(rMEMBase+0x1C))
+	
+	/* DMA Controller(32bit)*/ 
+	// DMA control register 
+	#define rDMACON0     (*(volatile unsigned *)(rDMABase+0x00))	
+	#define rDMACON1     (*(volatile unsigned *)(rDMABase+0x40))	
+	#define rDMACON2     (*(volatile unsigned *)(rDMABase+0x80))	
+	#define rDMACON3     (*(volatile unsigned *)(rDMABase+0xC0))	
+	#define rDMACON4     (*(volatile unsigned *)(rDMABase+0x100))	
+	#define rDMACON5     (*(volatile unsigned *)(rDMABase+0x140))	
+	
+	// DMA Source Start address register 
+	#define rDMASAR0     (*(volatile unsigned *)(rDMABase+0x04))	
+	#define rDMASAR1     (*(volatile unsigned *)(rDMABase+0x44))	
+	#define rDMASAR2     (*(volatile unsigned *)(rDMABase+0x84))	
+	#define rDMASAR3     (*(volatile unsigned *)(rDMABase+0xC4))	
+	#define rDMASAR4     (*(volatile unsigned *)(rDMABase+0x104))	
+	#define rDMASAR5     (*(volatile unsigned *)(rDMABase+0x144))	
+	
+	// DMA Destination address register
+	#define rDMADAR0     (*(volatile unsigned *)(rDMABase+0x08))
+	#define rDMADAR1     (*(volatile unsigned *)(rDMABase+0x48))
+	#define rDMADAR2     (*(volatile unsigned *)(rDMABase+0x88))
+	#define rDMADAR3     (*(volatile unsigned *)(rDMABase+0xC8))
+	#define rDMADAR4     (*(volatile unsigned *)(rDMABase+0x108))
+	#define rDMADAR5     (*(volatile unsigned *)(rDMABase+0x148))
+	
+	// DMA Terminal Counter register 
+	#define rDMATCR0     (*(volatile unsigned *)(rDMABase+0x0C))
+	#define rDMATCR1     (*(volatile unsigned *)(rDMABase+0x4C))
+	#define rDMATCR2     (*(volatile unsigned *)(rDMABase+0x8C))
+	#define rDMATCR3     (*(volatile unsigned *)(rDMABase+0xCC))
+	#define rDMATCR4     (*(volatile unsigned *)(rDMABase+0x10C))
+	#define rDMATCR5     (*(volatile unsigned *)(rDMABase+0x14C))
+	
+	// DMA pending & priority register
+	#define rDMAPRI      (*(volatile unsigned *)(rDMABase+0x1F8))
+	#define rDMAPND      (*(volatile unsigned *)(rDMABase+0x1FC))
+	
+	/* LCD(primecell) Controller(32bit)*/
+	
+	/* APB Base register map */ 
+	/* 1.APB pulse width control register */
+	#define rAPBCON0     (*(volatile unsigned *)(rBRIDGEBase+0x00))
+	#define rAPBCON1     (*(volatile unsigned *)(rBRIDGEBase+0x04))
+	#define rAPBCON2     (*(volatile unsigned *)(rBRIDGEBase+0x08))
+	#define rAPBCON3     (*(volatile unsigned *)(rBRIDGEBase+0x0C))
+	
+	/* 2.Smart card interface */
+	
+	
+	/* 3.USB register(8bit)*/
+
+	
+	// Non indexed registers
+	#define USB_R0       (volatile unsigned *)(rUSBBase+0x00)    // 0x00 - Function address register 
+	#define USB_R1       (volatile unsigned *)(rUSBBase+0x04)    // 0x01 - Power management register 
+	
+	#define USB_R2       (volatile unsigned *)(rUSBBase+0x08)    // 0x02 - Endpoint interrupt1 register (EP0-EP7) 
+	#define USB_R3       (volatile unsigned *)(rUSBBase+0x0c)    // 0x03 - Endpoint interrupt2 register (EP8-EP15)
+	#define USB_R4       (volatile unsigned *)(rUSBBase+0x10)    //- Out interrupt register bank1 
+	#define USB_R5       (volatile unsigned *)(rUSBBase+0x14)    //- Out interrupt register bank2
+	#define USB_R6       (volatile unsigned *)(rUSBBase+0x18)    // 0x06 - USB interrpt register 
+	
+	#define USB_R7       (volatile unsigned *)(rUSBBase+0x1C)    // 0x07 - Endpoint interrupt enable1 register (EP0-EP7)
+	#define USB_R8       (volatile unsigned *)(rUSBBase+0x20)    // 0x08 - Endpoint interrupt enable2 register (EP8-EP15) 
+	#define USB_R9       (volatile unsigned *)(rUSBBase+0x24)    //- Out interrupt enable register bank1 
+	#define USB_R10      (volatile unsigned *)(rUSBBase+0x28)    //- Out interrupt enable register bank2 
+	#define USB_R11      (volatile unsigned *)(rUSBBase+0x2C)    // 0x0B - USB interrupt enable register 
+	
+	#define USB_R12      (volatile unsigned *)(rUSBBase+0x30)    // 0x0C - Frame number1 register 
+	#define USB_R13      (volatile unsigned *)(rUSBBase+0x34)    // 0x0D - Frame number2 register 
+	#define USB_R14      (volatile unsigned *)(rUSBBase+0x38)    // 0x0E - Index register 
+	
+	// Common indexed registers
+	#define USB_IR1      (volatile unsigned *)(rUSBBase+0x40)    // 0x10 - Max packet register 
+	
+	// In indexed registers
+	#define USB_IR2      (volatile unsigned *)(rUSBBase+0x44)    // 0x11 - IN CSR1 register (EP0 CSR register)
+	#define USB_IR3      (volatile unsigned *)(rUSBBase+0x48)    // 0x12 - IN CSR2 register 
+	
+	// Out indexed registers 
+	#define USB_OR1      (volatile unsigned *)(rUSBBase+0x4C)    //- OUT max packet register 
+	#define USB_OR2      (volatile unsigned *)(rUSBBase+0x50)    // 0x14 - OUT CSR1 register 
+	#define USB_OR3      (volatile unsigned *)(rUSBBase+0x54)    // 0x15 - OUT CSR2 register 
+	#define USB_OR4      (volatile unsigned *)(rUSBBase+0x58)    // 0x16 - OUT FIFO write Count1 register 
+	#define USB_OR5      (volatile unsigned *)(rUSBBase+0x5c)    // 0x17 - OUT FIFO write Count2 register 
+	
+	// FIFO registers
+	#define EP0_FIFO     (volatile unsigned *)(rUSBBase+0x80)    // 0x20 - EP0 FIFO
+	#define EP1_FIFO     (volatile unsigned *)(rUSBBase+0x84)	 // 0x21 - EP1 FIFO
+	#define EP2_FIFO     (volatile unsigned *)(rUSBBase+0x88)	 // 0x22 - EP2 FIFO
+	#define EP3_FIFO     (volatile unsigned *)(rUSBBase+0x8C)	 // 0x23 - EP3 FIFO
+
+	
+	/* 4.IEEE 1284(PPI)(8bit)*/
+	
+	/* 5.IIC register(8bit)*/
+	/* 6.TIMER register(16bit)*/
+	#define rT0CTR       (*(volatile int *)(rTIMEBase+0x00))
+	#define rT0PSR       (*(volatile int *)(rTIMEBase+0x04))
+	#define rT0LDR       (*(volatile int *)(rTIMEBase+0x08))
+	#define rT0ISR       (*(volatile int *)(rTIMEBase+0x0C))
+	
+	#define rT1CTR       (*(volatile int *)(rTIMEBase+0x10))
+	#define rT1PSR       (*(volatile int *)(rTIMEBase+0x14))
+	#define rT1LDR       (*(volatile int *)(rTIMEBase+0x18))
+	#define rT1ISR       (*(volatile int *)(rTIMEBase+0x1C))
+	
+	#define rT2CTR       (*(volatile int *)(rTIMEBase+0x20))
+	#define rT2PSR       (*(volatile int *)(rTIMEBase+0x24))
+	#define rT2LDR       (*(volatile int *)(rTIMEBase+0x28))
+	#define rT2ISR       (*(volatile int *)(rTIMEBase+0x2C))
+	
+	#define rT3CTR       (*(volatile int *)(rTIMEBase+0x30))
+	#define rT3PSR       (*(volatile int *)(rTIMEBase+0x34))
+	#define rT3LDR       (*(volatile int *)(rTIMEBase+0x38))
+	#define rT3ISR       (*(volatile int *)(rTIMEBase+0x3C))
+	
+	#define rT4CTR       (*(volatile int *)(rTIMEBase+0x40))
+	#define rT4PSR       (*(volatile int *)(rTIMEBase+0x44))
+	#define rT4LDR       (*(volatile int *)(rTIMEBase+0x48))
+	#define rT4ISR       (*(volatile int *)(rTIMEBase+0x4C))
+	
+	#define rTTMR       (*(volatile int *)(rTIMEBase+0x80))
+	#define rTTIR       (*(volatile int *)(rTIMEBase+0x84))
+	#define rTTCR       (*(volatile int *)(rTIMEBase+0x88))
+	
+	
+	/* 7.RTC register(8bit)*/
+	#define rRTCCON	     (*(volatile unsigned *)(rRTCBase+0x00)) /* RTC control register */
+	#define rRTCRST	     (*(volatile unsigned *)(rRTCBase+0x04)) /* RTC round reset register */
+	#define rRTCALM	     (*(volatile unsigned *)(rRTCBase+0x08)) /* RTC alarm register */
+	#define rALMSEC	     (*(volatile unsigned *)(rRTCBase+0x0C)) /* Alarm second data register */
+	#define rALMMIN	     (*(volatile unsigned *)(rRTCBase+0x10))
+	#define rALMHOUR     (*(volatile unsigned *)(rRTCBase+0x14)) /* Alarm hour data register */
+	#define rALMDATE     (*(volatile unsigned *)(rRTCBase+0x18)) /* Alarm date data register */
+	#define rALMDAY	     (*(volatile unsigned *)(rRTCBase+0x1C)) /* Alarm day data register */
+	#define rALMMON	     (*(volatile unsigned *)(rRTCBase+0x20)) /* Alarm mon data register */
+	#define rALMYEAR     (*(volatile unsigned *)(rRTCBase+0x24)) /* Alarm year data register */
+	#define rBCDSEC	     (*(volatile unsigned *)(rRTCBase+0x28)) /* BCD second data register */
+	#define rBCDMIN	     (*(volatile unsigned *)(rRTCBase+0x2C)) /* BCD minute data register */
+	#define rBCDHOUR     (*(volatile unsigned *)(rRTCBase+0x30)) /* BCD hour data register */
+	#define rBCDDATE     (*(volatile unsigned *)(rRTCBase+0x34)) /* BCD day data register */
+	#define rBCDDAY	     (*(volatile unsigned *)(rRTCBase+0x38)) /* BCD day data register */
+	#define rBCDMON	     (*(volatile unsigned *)(rRTCBase+0x3C)) /* BCD month data register */
+	#define rBCDYEAR     (*(volatile unsigned *)(rRTCBase+0x40)) /* BCD year  data register */
+	#define rRTCIM       (*(volatile unsigned *)(rRTCBase+0x44)) /* BCD year  data register */
+	#define rRTCPEND     (*(volatile unsigned *)(rRTCBase+0x48)) /* BCD year  data register */
+	
+	
+	/* 8.Watch Dog Timer register(8bit)*/
+	
+	/* 9.Programmable I/O port */
+	#define rGIOPCON     (*(volatile unsigned *)(rIOPBase+0x00)) /* Port direction register */
+	#define rGIOPDATA    (*(volatile unsigned *)(rIOPBase+0x04)) /* Data register */
+	#define rGIOPINTEN   (*(volatile unsigned *)(rIOPBase+0x08)) /* Interrupt enable register */
+	#define rGIOPLEVEL   (*(volatile unsigned *)(rIOPBase+0x0C)) /* Ative level indication register */
+	#define rGIOPPEND    (*(volatile unsigned *)(rIOPBase+0x10)) /* Interrupt pending register */
+	
+	
+	/* 10.Interrupt controller */		//0xc082800
+	#define rINTCON      (*(volatile unsigned *)(rINTBase+0x00)) /* interrupt control register */
+	#define rINTPND	     (*(volatile unsigned *)(rINTBase+0x04)) /* interrupt pending register */
+	#define rINTMOD	     (*(volatile unsigned *)(rINTBase+0x08)) /* interrupt mode register */
+	#define rINTMSK	     (*(volatile unsigned *)(rINTBase+0x0C)) /* interrupt mask register */
+	#define rINTLEVEL    (*(volatile unsigned *)(rINTBase+0x10)) 
+	#define rIRQPSLV0    (*(volatile unsigned *)(rINTBase+0x14)) /* IRQ priority of slave register0 */
+	#define rIRQPSLV1    (*(volatile unsigned *)(rINTBase+0x18)) /* IRQ priority of slave register1 */
+	#define rIRQPSLV2    (*(volatile unsigned *)(rINTBase+0x1C)) /* IRQ priority of slave register2 */
+	#define rIRQPSLV3    (*(volatile unsigned *)(rINTBase+0x20)) /* IRQ priority of slave register3 */
+	#define rIRQPMST     (*(volatile unsigned *)(rINTBase+0x24)) /* IRQ priority of master register */
+	#define rIRQCSLV0    (*(volatile unsigned *)(rINTBase+0x28)) /* current IRQ priority of slave register0 */
+	#define rIRQCSLV1    (*(volatile unsigned *)(rINTBase+0x2C)) /* current IRQ priority of slave register1 */
+	#define rIRQCSLV2    (*(volatile unsigned *)(rINTBase+0x30)) /* current IRQ priority of slave register2 */
+	#define rIRQCSLV3    (*(volatile unsigned *)(rINTBase+0x34)) /* current IRQ priority of slave register3 */
+	#define rIRQCMST     (*(volatile unsigned *)(rINTBase+0x38)) /* current IRQ priority of master register */
+	#define rIRQISPR     (*(volatile unsigned *)(rINTBase+0x3C)) /* IRQ service pending register */
+	#define rIRQISPC     (*(volatile unsigned *)(rINTBase+0x40)) /* IRQ service clear register */
+	#define rFIQPSLV0    (*(volatile unsigned *)(rINTBase+0x44)) /* FIQ priority of slave register0 */
+	#define rFIQPSLV1    (*(volatile unsigned *)(rINTBase+0x48)) /* FIQ priority of slave register1 */
+	#define rFIQPSLV2    (*(volatile unsigned *)(rINTBase+0x4C)) /* FIQ priority of slave register2 */
+	#define rFIQPSLV3    (*(volatile unsigned *)(rINTBase+0x50)) /* FIQ priority of slave register3 */
+	#define rFIQPMST     (*(volatile unsigned *)(rINTBase+0x54)) /* FIQ priority of master register */
+	#define rFIQCSLV0    (*(volatile unsigned *)(rINTBase+0x58)) /* current FIQ priority of slave register0 */
+	#define rFIQCSLV1    (*(volatile unsigned *)(rINTBase+0x5C)) /* current FIQ priority of slave register1 */
+	#define rFIQCSLV2    (*(volatile unsigned *)(rINTBase+0x60)) /* current FIQ priority of slave register2 */
+	#define rFIQCSLV3    (*(volatile unsigned *)(rINTBase+0x64)) /* current FIQ priority of slave register3 */
+	#define rFIQCMST     (*(volatile unsigned *)(rINTBase+0x68)) /* current FIQ priority of master register */
+	#define rFIQISPR     (*(volatile unsigned *)(rINTBase+0x6C)) /* FIQ service pending register */
+	#define rFIQISPC     (*(volatile unsigned *)(rINTBase+0x70)) /* FIQ service clear register */
+	#define rPOLARITY    (*(volatile unsigned *)(rINTBase+0x74))
+	#define rIVEC_ADDR   (*(volatile unsigned *)(rINTBase+0x78))
+	#define rFVEC_ADDR   (*(volatile unsigned *)(rINTBase+0x7C))
+	
+	/* 11.SSP(prime cell) Synchronous serial port register(16bit) */
+	
+	
+	/* 12.KMI0(prime cell) Keyboard/Mouse interface register(8bit) */
+	
+	/* 13.KMI1(prime cell) Keyboard/Mouse interface register(8bit) */
+	
+	
+	/* 14.UART0(prime cell) register(8bit)*/
+	
+	
+	/* 15.UART1(prime cell) register(8bit)*/
+	
+	
+	/* 16.Power manager register */
+	#define rPLLCON      (*(volatile unsigned *)(rPMBase+0x00)) /* pll configuration register */
+	#define rMODCON      (*(volatile unsigned *)(rPMBase+0x04)) /* mode control register */
+	#define rLOCKCON     (*(volatile unsigned *)(rPMBase+0x08)) /* Lock-up timer */
+	#define rHCLKCON     (*(volatile unsigned *)(rPMBase+0x0C)) /* Normal system clock control register */
+	
+	
+	/* 17.Teak base register */
+	
+	//-    timer register 
+	/*
+	 *	Bits 	Name 	Type 	Function 	 
+	 *	15:12 	-	Read 	Reserved. Read only as zero 	 
+	 *	11:10 	M 	Read/write 	Operating mode :
+	 *				00 : Free running timer mode(default) 	01 : Periodic timer mode. 	 
+	 *				10 : Free running counter mode. 		11 : Periodic counter mode. 	 
+	 *	9:8 	ES 	Read/write 	External input active edge selection. 
+	 *				00 : Positive edge(default). 01 : Negative edge.
+	 *				10 : Both positive and negative edge. 11 : unused. 	 
+	 *	7 	-	Read 	Reserved. Read only as zero 	 
+	 *	6 	OM 	Read/write 	Time output mode. 0 : Toggle mode(default). 1 : Pulse mode. 	 
+	 *	5 	UDS 	Read/write 	Up/down counting control selection. 
+	 *				0 : Up/down is controlled by UD field of TxCTR register(default).
+	 *				1 : Up/down is controlled by EXTUD[4:0]input register. 	 
+	 *	4 	UD 	Read/write 	Up/down counting selection. 
+	 *				0 : Down counting(default). 1 : Up counting. 	 
+	 *				This bit affects the counting of timer only when UDS bit is LOW. 	 
+	 *	3 	-	Read 	Reserved. Read only as zero 	 
+	 *	2 	OE 	Read/write 	Output enable.
+	 *				0 : Disable timer outputs(default). 1 : Enable timer outputs. 	 
+	 *				This bit affects the generation of timer interrupt only when TE bit is HIGH. 	 
+	 *	1 	IE 	Read/write 	Interrupt enable. 0 : Toggle mode(default). 1 : Pulse mode. 	 
+	 *				This bit affects the generation of timer output only when TE bit is HIGH. 	 
+	 *	0 	TE 	Read/write 	Timer enable. 0 : Diable timer(default). 1 : Enable timer. 	 
+	 */
+	#define TMR_TE_DISABLE				0x0000
+	#define TMR_TE_ENABLE				0x0001
+	
+	#define TMR_IE_TOGGLE				0x0000
+	#define TMR_IE_PULSE				0x0002
+	
+	#define TMR_OE_DISABLE				0x0000
+	#define TMR_OE_ENABLE				0x0004
+	
+	#define TMR_UD_DOWN				0x0000
+	#define TMR_UD_UP					0x0010
+	
+	#define TMR_UDS_TxCTR				0x0000
+	#define TMR_UDS_EXTUD				0x0020
+	
+	#define TMR_OM_TOGGLE				0x0000
+	#define TMR_OM_PULSE				0x0040
+	
+	#define TMR_ES_POS					0x0000
+	#define TMR_ES_NEG					0x0100
+	#define TMR_ES_BOTH				0x0200
+	
+	#define TMR_M_FREE_TIMER			0x0000
+	#define TMR_M_PERIODIC_TIMER		0x0400
+	#define TMR_M_FREE_COUNTER		0x0800
+	#define TMR_M_PERIODIC_COUNTER	0x0C00
+
+	
+	/* 18.memory stick Host controller-External Device 1*/
+	#define COMD_REG  (*(volatile unsigned short *)(rEXT1Base+0x0))     /* Command Register */
+	#define STAT_REG  (*(volatile unsigned short *)(rEXT1Base+0x4))  /* Status Register */
+	#define CONT_REG  (*(volatile unsigned short *)(rEXT1Base+0x4))  /* Control Register */
+	#define RECV_REG  (*(volatile unsigned short *)(rEXT1Base+0x8))  /* Receive Data Register */
+	#define SEND_REG  (*(volatile unsigned short *)(rEXT1Base+0x8))  /* Send Data Register */
+	#define INTD_REG  (*(volatile unsigned short *)(rEXT1Base+0xc))  /* Interrupt Data Register */
+	#define INTC_REG  (*(volatile unsigned short *)(rEXT1Base+0xc))  /* Interrupt Control Register */
+	#define PARD_REG  (*(volatile unsigned short *)(rEXT1Base+0x10)) /* Parallel Data Register */
+	#define PARC_REG  (*(volatile unsigned short *)(rEXT1Base+0x10)) /* Parallel Control Register */
+	#define CONT2_REG  (*(volatile unsigned short *)(rEXT1Base+0x14))
+	#define ACD_REG  (*(volatile unsigned short *)(rEXT1Base+0x18))
+
+
+	/* Searching Keyword: OS_Timer */
+	#define SYS_TIMER03_PRESCALER   0x6B      /* for System Timer, 4usec(3.996)  */
+	#define SYS_TIMER03_DIVIDER	0x01
+
+	#define RESCHED_PERIOD          10      /* 10 ms */
+	#define __KERNEL_HZ			100
+
+#endif /* __S5C7375_H */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/sizes.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/sizes.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/sizes.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/sizes.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/system.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/system.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/system.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/system.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,63 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/system.h
+ *
+ *  Copyright (C) 2002 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+/* 
+ * This functions used in arm/kernel/process.c 
+ */
+
+#ifdef CONFIG_LEDS
+extern void Led_Display(int);
+#endif
+
+static void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+#ifndef CONFIG_LEDS
+	cpu_do_idle();
+#else
+	int i;
+	Led_Display(1);
+	rCLKCON |= (1<<2);	/* Enter IDLE Mode */
+	for ( i = 0; i <100;i++);
+	rCLKCON &= ~(1<<2);
+	Led_Display(4);
+#endif
+
+}
+
+static inline void arch_reset(char mode)
+{
+ 	/* machine should reboot..... */
+ 	mdelay(5000);
+ 	panic("Watchdog timer reset failed!\n");
+ 	printk(" Jump to address 0 \n");
+ 	cpu_reset(0);
+}
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/time.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/time.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/time.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/time.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,147 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/time.h
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *                      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/arch/s5c7375.h>
+/*
+ *	Bits 	Name 	Type 	Function 	 
+ *	15:12 	-	Read 	Reserved. Read only as zero 	 
+ *	11:10 	M 	Read/write 	Operating mode :
+ *				00 : Free running timer mode(default) 	01 : Periodic timer mode. 	 
+ *				10 : Free running counter mode. 		11 : Periodic counter mode. 	 
+ *	9:8 	ES 	Read/write 	External input active edge selection. 
+ *				00 : Positive edge(default). 01 : Negative edge.
+ *				10 : Both positive and negative edge. 11 : unused. 	 
+ *	7 	-	Read 	Reserved. Read only as zero 	 
+ *	6 	OM 	Read/write 	Time output mode. 0 : Toggle mode(default). 1 : Pulse mode. 	 
+ *	5 	UDS 	Read/write 	Up/down counting control selection. 
+ *				0 : Up/down is controlled by UD field of TxCTR register(default).
+ *				1 : Up/down is controlled by EXTUD[4:0]input register. 	 
+ *	4 	UD 	Read/write 	Up/down counting selection. 
+ *				0 : Down counting(default). 1 : Up counting. 	 
+ *				This bit affects the counting of timer only when UDS bit is LOW. 	 
+ *	3 	-	Read 	Reserved. Read only as zero 	 
+ *	2 	OE 	Read/write 	Output enable.
+ *				0 : Disable timer outputs(default). 1 : Enable timer outputs. 	 
+ *				This bit affects the generation of timer interrupt only when TE bit is HIGH. 	 
+ *	1 	IE 	Read/write 	Interrupt enable. 0 : Toggle mode(default). 1 : Pulse mode. 	 
+ *				This bit affects the generation of timer output only when TE bit is HIGH. 	 
+ *	0 	TE 	Read/write 	Timer enable. 0 : Diable timer(default). 1 : Enable timer. 	 
+ */
+
+#define TMR_TE_DISABLE				0x0000
+#define TMR_TE_ENABLE				0x0001
+
+#define TMR_IE_TOGGLE				0x0000
+#define TMR_IE_PULSE				0x0002
+
+#define TMR_OE_DISABLE				0x0000
+#define TMR_OE_ENABLE				0x0004
+
+#define TMR_UD_DOWN				0x0000
+#define TMR_UD_UP					0x0010
+
+#define TMR_UDS_TxCTR				0x0000
+#define TMR_UDS_EXTUD				0x0020
+
+#define TMR_OM_TOGGLE				0x0000
+#define TMR_OM_PULSE				0x0040
+
+#define TMR_ES_POS					0x0000
+#define TMR_ES_NEG					0x0100
+#define TMR_ES_BOTH				0x0200
+
+#define TMR_M_FREE_TIMER			0x0000
+#define TMR_M_PERIODIC_TIMER		0x0400
+#define TMR_M_FREE_COUNTER		0x0800
+#define TMR_M_PERIODIC_COUNTER	0x0C00
+
+
+
+
+/*
+ * simpler new version of gettimeoffset
+ * by Hyok S. Choi
+ */
+#define TICKS_PER_uSEC                  24
+#define CLOCKS_PER_USEC	(2* ECLK/ (SYS_TIMER03_PRESCALER +1))
+							//(ECLK/1000000) /* (ARM_CLK/1000000) */
+							/* this is the newer version */
+
+unsigned long s5c7375_gettimeoffset (void)
+{
+	return (((RESCHED_PERIOD  * CLOCKS_PER_USEC) /1000) - rT3LDR)  / CLOCKS_PER_USEC;
+}
+
+static irqreturn_t
+s5c7375_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+    /* clear interrupt pending bit */
+    rT3ISR = 0;
+    do_timer(regs);
+    do_profile(regs);
+
+    return IRQ_HANDLED;
+}
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+
+void __init  time_init (void)
+{
+	//- APB bus speed setting
+	/*
+	 * Number of AHB clock cycles allocated in the ENABLE or
+	 * SETUP state of the 2-nd APB peripheral minus one.
+	 */
+	rAPBCON2=(unsigned long)0x00010000; 
+
+	gettimeoffset = s5c7375_gettimeoffset;
+	timer_irq.handler = s5c7375_timer_interrupt;
+
+	/*
+	 * Timer 3 is used for OS_timer by external clock.
+	 */
+	rT3CTR = TMR_TE_DISABLE | TMR_IE_PULSE | TMR_OE_ENABLE | TMR_UD_DOWN \
+			| TMR_UDS_TxCTR | TMR_OM_PULSE | TMR_ES_POS | TMR_M_PERIODIC_TIMER;
+
+	/*
+	 * prescaler to 0x6B 'cause : 
+	 * 	27M / (0x6B +1) = 4usec
+	 */
+	rT3PSR = SYS_TIMER03_PRESCALER; // 0x6B
+	/* rT3LDR  =  X second * (frequency/second ) */
+	rT3LDR = RESCHED_PERIOD  * CLOCKS_PER_USEC /1000;
+			/* is equal to 
+			 *	RESCHED_PERIOD * 1000    // for msec to usec
+			 * 	   * (ECLK/ (SYS_TIMER03_PRESCALER +1)) /1000000;
+			 *	= 2500
+			 */
+   	/* clear interrupt pending bit */
+	rT3ISR = 0;
+
+	setup_irq(INT_N_TIMER3, &timer_irq);
+
+	/* timer 3 enable it! */
+	rT3CTR |= TMR_TE_ENABLE;
+
+}
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/timex.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/timex.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/timex.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/timex.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-arm/arch-s5c7375/timex.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS 
+ *                           Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/arch/s5c7375.h>
+
+#define CLOCK_TICK_RATE	 (ECLK/ (SYS_TIMER03_PRESCALER +1))
+
+	/*
+	 * 27M / (0x6B +1) = 4usec
+	 */
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/uncompress.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/uncompress.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/uncompress.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/uncompress.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,58 @@
+/*
+ *  linux/include/asm-armnommu/arch-s5c7375/uncompress.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm-armnommu/hardware/t32.h>
+
+#ifndef __UNCOMPRESS_H__
+#define __UNCOMPRESS_H__
+
+/*
+ * just use T32 JTAG1 port
+ */
+static inline void puts(const char *s)
+{
+	t32_puts(s);
+}
+
+static void puts_hex(unsigned long i)
+{
+	char lhex_buf[]="0x00000000";
+	unsigned long ii,v;
+
+	for(ii=9;ii>1;ii--)
+	{
+		v=(((0x0000000F << ((9-ii)*4)) & i) >> ((9-ii)*4));
+		if(v>9)
+			lhex_buf[ii]=(char)('A'+v-10);
+		else
+			lhex_buf[ii]=(char)('0'+v);
+	}
+
+	t32_puts(lhex_buf);
+}
+
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/arch-s5c7375/vmalloc.h linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/vmalloc.h
--- linux-2.6.9/include/asm-armnommu/arch-s5c7375/vmalloc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/vmalloc.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-armnommu/arch-s5c7375/vmalloc.h
+ *
+ *  Copyright (C) 2003 SAMSUNG ELECTRONICS
+ *                       Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define MAX_S5C7375_SDRAM_SIZE (0x10000000)
+
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + MAX_S5C7375_SDRAM_SIZE)   
diff -Naur linux-2.6.9/include/asm-armnommu/assembler.h linux-2.6.9-uc0/include/asm-armnommu/assembler.h
--- linux-2.6.9/include/asm-armnommu/assembler.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/assembler.h	2004-10-28 11:14:22.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/assembler.h>
diff -Naur linux-2.6.9/include/asm-armnommu/atomic.h linux-2.6.9-uc0/include/asm-armnommu/atomic.h
--- linux-2.6.9/include/asm-armnommu/atomic.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/atomic.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/atomic.h>
diff -Naur linux-2.6.9/include/asm-armnommu/bitops.h linux-2.6.9-uc0/include/asm-armnommu/bitops.h
--- linux-2.6.9/include/asm-armnommu/bitops.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/bitops.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/bitops.h>
diff -Naur linux-2.6.9/include/asm-armnommu/bug.h linux-2.6.9-uc0/include/asm-armnommu/bug.h
--- linux-2.6.9/include/asm-armnommu/bug.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/bug.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/bug.h>
diff -Naur linux-2.6.9/include/asm-armnommu/bugs.h linux-2.6.9-uc0/include/asm-armnommu/bugs.h
--- linux-2.6.9/include/asm-armnommu/bugs.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/bugs.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,16 @@
+/*
+ *  linux/include/asm-armnommu/bugs.h
+ *
+ *  Copyright (C) 2003 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_BUGS_H
+#define __ASM_BUGS_H
+
+#define check_bugs() do { }while(0)
+
+#endif
+
diff -Naur linux-2.6.9/include/asm-armnommu/byteorder.h linux-2.6.9-uc0/include/asm-armnommu/byteorder.h
--- linux-2.6.9/include/asm-armnommu/byteorder.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/byteorder.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,41 @@
+/*
+ *  linux/include/asm-arm/byteorder.h
+ *
+ * ARM Endian-ness.  In little endian mode, the data bus is connected such
+ * that byte accesses appear as:
+ *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
+ * and word accesses (data or instruction) appear as:
+ *  d0...d31
+ *
+ * When in big endian mode, byte accesses appear as:
+ *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
+ * and word accesses (data or instruction) appear as:
+ *  d0...d31
+ * 
+ * modified for some compatibility problem by Hyok S. Choi
+ */
+#ifndef __ASM_ARM_BYTEORDER_H
+#define __ASM_ARM_BYTEORDER_H
+
+
+#include <asm/types.h>
+
+#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#if !defined(__KERNEL__)
+# ifndef __attribute_const__
+#  define __attribute_const__    /* unimplemented */
+# endif
+#endif
+
+#ifdef __ARMEB__
+#include <linux/byteorder/big_endian.h>
+#else
+#include <linux/byteorder/little_endian.h>
+#endif
+
+#endif
+
diff -Naur linux-2.6.9/include/asm-armnommu/cacheflush.h linux-2.6.9-uc0/include/asm-armnommu/cacheflush.h
--- linux-2.6.9/include/asm-armnommu/cacheflush.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/cacheflush.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,240 @@
+/*
+ *  linux/include/asm-armnommu/cacheflush.h
+ *
+ *  Copyright (C) 1999-2002 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_CACHEFLUSH_H
+#define _ASMARM_CACHEFLUSH_H
+
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+
+#include <asm/mman.h>
+#include <asm/glue.h>
+
+/*
+ *	Cache Model
+ *	===========
+ */
+#undef _CACHE
+#undef MULTI_CACHE
+
+#if defined(CONFIG_CPU_ARM610) || defined(CONFIG_CPU_ARM710)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE v3
+# endif
+#endif
+
+#if defined(CONFIG_CPU_ARM720T)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE v4
+# endif
+#endif
+
+#if defined(CONFIG_CPU_S3C4510B)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE s3c4510b
+# endif
+#endif
+
+#if defined(CONFIG_CPU_ARM920T) || defined(CONFIG_CPU_ARM922T) || \
+    defined(CONFIG_CPU_ARM1020)
+# define MULTI_CACHE 1
+#endif
+
+#if defined(CONFIG_CPU_ARM926T)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE arm926
+# endif
+#endif
+
+#if !defined(_CACHE) && !defined(MULTI_CACHE)
+#error Unknown cache maintainence model
+#endif
+
+/*
+ * This flag is used to indicate that the page pointed to by a pte
+ * is dirty and requires cleaning before returning it to the user.
+ */
+#define PG_dcache_dirty PG_arch_1
+
+/*
+ *	MM Cache Management
+ *	===================
+ *
+ *	The arch/arm/mm/cache-*.S and arch/arm/mm/proc-*.S files
+ *	implement these methods.
+ *
+ *	Start addresses are inclusive and end addresses are exclusive;
+ *	start addresses should be rounded down, end addresses up.
+ *
+ *	See linux/Documentation/cachetlb.txt for more information.
+ *	Please note that the implementation of these, and the required
+ *	effects are cache-type (VIVT/VIPT/PIPT) specific.
+ *
+ *	flush_cache_kern_all()
+ *
+ *		Unconditionally clean and invalidate the entire cache.
+ *
+ *	flush_cache_user_mm(mm)
+ *
+ *		Clean and invalidate all user space cache entries
+ *		before a change of page tables.
+ *
+ *	flush_cache_user_range(start, end, flags)
+ *
+ *		Clean and invalidate a range of cache entries in the
+ *		specified address space before a change of page tables.
+ *		- start - user start address (inclusive, page aligned)
+ *		- end   - user end address   (exclusive, page aligned)
+ *		- flags - vma->vm_flags field
+ *
+ *	coherent_kern_range(start, end)
+ *
+ *		Ensure coherency between the Icache and the Dcache in the
+ *		region described by start, end.  If you have non-snooping
+ *		Harvard caches, you need to implement this function.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ *
+ *	DMA Cache Coherency
+ *	===================
+ *
+ *	dma_inv_range(start, end)
+ *
+ *		Invalidate (discard) the specified virtual address range.
+ *		May not write back any entries.  If 'start' or 'end'
+ *		are not cache line aligned, those lines must be written
+ *		back.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ *
+ *	dma_clean_range(start, end)
+ *
+ *		Clean (write back) the specified virtual address range.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ *
+ *	dma_flush_range(start, end)
+ *
+ *		Clean and invalidate the specified virtual address range.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ */
+
+struct cpu_cache_fns {
+	void (*flush_kern_all)(void);
+	void (*flush_user_all)(void);
+	void (*flush_user_range)(unsigned long, unsigned long, unsigned int);
+
+	void (*coherent_kern_range)(unsigned long, unsigned long);
+	void (*flush_kern_dcache_page)(void *);
+
+	void (*dma_inv_range)(unsigned long, unsigned long);
+	void (*dma_clean_range)(unsigned long, unsigned long);
+	void (*dma_flush_range)(unsigned long, unsigned long);
+};
+
+/*
+ * Select the calling method
+ */
+#ifdef MULTI_CACHE
+
+extern struct cpu_cache_fns cpu_cache;
+
+#define __cpuc_flush_kern_all		cpu_cache.flush_kern_all
+#define __cpuc_flush_user_all		cpu_cache.flush_user_all
+#define __cpuc_flush_user_range		cpu_cache.flush_user_range
+#define __cpuc_coherent_kern_range	cpu_cache.coherent_kern_range
+#define __cpuc_flush_dcache_page	cpu_cache.flush_kern_dcache_page
+
+/*
+ * These are private to the dma-mapping API.  Do not use directly.
+ * Their sole purpose is to ensure that data held in the cache
+ * is visible to DMA, or data written by DMA to system memory is
+ * visible to the CPU.
+ */
+#define dmac_inv_range			cpu_cache.dma_inv_range
+#define dmac_clean_range		cpu_cache.dma_clean_range
+#define dmac_flush_range		cpu_cache.dma_flush_range
+
+#else
+
+#define __cpuc_flush_kern_all		__glue(_CACHE,_flush_kern_cache_all)
+#define __cpuc_flush_user_all		__glue(_CACHE,_flush_user_cache_all)
+#define __cpuc_flush_user_range		__glue(_CACHE,_flush_user_cache_range)
+#define __cpuc_coherent_kern_range	__glue(_CACHE,_coherent_kern_range)
+#define __cpuc_flush_dcache_page	__glue(_CACHE,_flush_kern_dcache_page)
+
+extern void __cpuc_flush_kern_all(void);
+extern void __cpuc_flush_user_all(void);
+extern void __cpuc_flush_user_range(unsigned long, unsigned long, unsigned int);
+extern void __cpuc_coherent_kern_range(unsigned long, unsigned long);
+extern void __cpuc_flush_dcache_page(void *);
+
+/*
+ * These are private to the dma-mapping API.  Do not use directly.
+ * Their sole purpose is to ensure that data held in the cache
+ * is visible to DMA, or data written by DMA to system memory is
+ * visible to the CPU.
+ */
+#define dmac_inv_range			__glue(_CACHE,_dma_inv_range)
+#define dmac_clean_range		__glue(_CACHE,_dma_clean_range)
+#define dmac_flush_range		__glue(_CACHE,_dma_flush_range)
+
+extern void dmac_inv_range(unsigned long, unsigned long);
+extern void dmac_clean_range(unsigned long, unsigned long);
+extern void dmac_flush_range(unsigned long, unsigned long);
+
+#endif
+
+/*
+ * Convert calls to our calling convention.
+ */
+#define flush_cache_all()	__cpuc_flush_kern_all()
+
+#define flush_cache_mm(mm) __cpuc_flush_user_all()
+#define flush_cache_range(vma, start, end)	\
+	__cpuc_flush_user_range((start) & PAGE_MASK, \
+	PAGE_ALIGN(end), (vma)->vm_flags)
+
+#define flush_dcache_range(start,len)		flush_cache_all()
+#define flush_dcache_page(page)			flush_cache_all()
+/*
+ * Perform necessary cache operations to ensure that data previously
+ * stored within this range of addresses can be executed by the CPU.
+ */
+#define flush_icache_range(s,e)		__cpuc_coherent_kern_range(s,e)
+#define flush_icache_page(vma,pg)		do { } while (0)
+#define flush_icache_user_range(vma,pg,adr,len)	flush_cache_all()
+
+#define flush_cache_vmap(start, end)		flush_cache_all()
+#define flush_cache_vunmap(start, end)		flush_cache_all()
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+
+static inline void
+flush_cache_page(struct vm_area_struct *vma, unsigned long user_addr)
+{
+	unsigned long addr = user_addr & PAGE_MASK;
+	__cpuc_flush_user_range(addr, addr + PAGE_SIZE, vma->vm_flags);
+}
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/cache.h linux-2.6.9-uc0/include/asm-armnommu/cache.h
--- linux-2.6.9/include/asm-armnommu/cache.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/cache.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,15 @@
+/*
+ *  linux/include/asm-armnommu/cache.h
+ */
+#ifndef __ASMARM_CACHE_H
+#define __ASMARM_CACHE_H
+
+#define L1_CACHE_SHIFT		5
+#define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
+
+/*
+ * largest L1 which this arch supports
+ */
+#define L1_CACHE_SHIFT_MAX		5
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/checksum.h linux-2.6.9-uc0/include/asm-armnommu/checksum.h
--- linux-2.6.9/include/asm-armnommu/checksum.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/checksum.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/checksum.h>
diff -Naur linux-2.6.9/include/asm-armnommu/cpumask.h linux-2.6.9-uc0/include/asm-armnommu/cpumask.h
--- linux-2.6.9/include/asm-armnommu/cpumask.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/cpumask.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef _ASM_ARMNOMMU_CPUMASK_H
+#define _ASM_ARMNOMMU_CPUMASK_H
+
+#include <asm-generic/cpumask.h>
+
+#endif /* _ASM_ARMNOMMU_CPUMASK_H */
diff -Naur linux-2.6.9/include/asm-armnommu/cpu-multi32.h linux-2.6.9-uc0/include/asm-armnommu/cpu-multi32.h
--- linux-2.6.9/include/asm-armnommu/cpu-multi32.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/cpu-multi32.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,66 @@
+/*
+ *  linux/include/asm-armnommu/cpu-multi32.h
+ *
+ *  Copyright (C) 2000 Russell King
+ *  Modified by Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASSEMBLY__
+
+#include <asm/memory.h>
+#include <asm/page.h>
+
+struct mm_struct;
+
+/*
+ * Don't change this structure - ASM code
+ * relies on it.
+ */
+extern struct processor {
+	/* MISC
+	 * get data abort address/flags
+	 */
+	void (*_data_abort)(unsigned long pc);
+	/*
+	 * Set up any processor specifics
+	 */
+	void (*_proc_init)(void);
+	/*
+	 * Disable any processor specifics
+	 */
+	void (*_proc_fin)(void);
+	/*
+	 * Special stuff for a reset
+	 */
+	volatile void (*reset)(unsigned long addr);
+	/*
+	 * Idle the processor
+	 */
+	int (*_do_idle)(void);
+	/*
+	 * Processor architecture specific
+	 */
+	/*
+	 * clean a virtual address range from the
+	 * D-cache without flushing the cache.
+	 */
+	void (*dcache_clean_area)(void *addr, int size);
+
+	/*
+	 * Set the page table
+	 */
+	void (*switch_mm)(unsigned long pgd_phys, struct mm_struct *mm);
+} processor;
+
+#define cpu_proc_init()			processor._proc_init()
+#define cpu_proc_fin()			processor._proc_fin()
+#define cpu_reset(addr)			processor.reset(addr)
+#define cpu_do_idle()			processor._do_idle()
+#define cpu_dcache_clean_area(addr,sz)	processor.dcache_clean_area(addr,sz)
+
+#define cpu_switch_mm(pgd,mm)	processor.switch_mm(__virt_to_phys((unsigned long)(pgd)),mm)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/cpu-single.h linux-2.6.9-uc0/include/asm-armnommu/cpu-single.h
--- linux-2.6.9/include/asm-armnommu/cpu-single.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/cpu-single.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,51 @@
+/*
+ *  linux/include/asm-armnommu/cpu-single.h
+ *
+ *  Copyright (C) 2000 Russell King
+ *  Modified by Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/*
+ * Single CPU
+ */
+#ifdef __STDC__
+#define __catify_fn(name,x)	name##x
+#else
+#define __catify_fn(name,x)	name/**/x
+#endif
+#define __cpu_fn(name,x)	__catify_fn(name,x)
+
+/*
+ * If we are supporting multiple CPUs, then we must use a table of
+ * function pointers for this lot.  Otherwise, we can optimise the
+ * table away.
+ */
+#define cpu_proc_init			__cpu_fn(CPU_NAME,_proc_init)
+#define cpu_proc_fin			__cpu_fn(CPU_NAME,_proc_fin)
+#define cpu_reset			__cpu_fn(CPU_NAME,_reset)
+#define cpu_do_idle			__cpu_fn(CPU_NAME,_do_idle)
+#define cpu_dcache_clean_area		__cpu_fn(CPU_NAME,_dcache_clean_area)
+#define cpu__switch_mm			__cpu_fn(CPU_NAME,_switch_mm)
+
+#ifndef __ASSEMBLY__
+
+#include <asm/memory.h>
+#include <asm/page.h>
+
+struct mm_struct;
+
+/* declare all the functions as extern */
+extern void cpu_proc_init(void);
+extern void cpu_proc_fin(void);
+extern int cpu_do_idle(void);
+extern void cpu_dcache_clean_area(void *, int);
+extern void cpu__switch_mm(unsigned long pgd_phys, struct mm_struct *mm);
+
+extern volatile void cpu_reset(unsigned long addr);
+
+#define cpu_switch_mm(pgd,mm) cpu__switch_mm(__virt_to_phys((unsigned long)(pgd)),mm)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/current.h linux-2.6.9-uc0/include/asm-armnommu/current.h
--- linux-2.6.9/include/asm-armnommu/current.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/current.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/current.h>
diff -Naur linux-2.6.9/include/asm-armnommu/delay.h linux-2.6.9-uc0/include/asm-armnommu/delay.h
--- linux-2.6.9/include/asm-armnommu/delay.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/delay.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/delay.h>
diff -Naur linux-2.6.9/include/asm-armnommu/div64.h linux-2.6.9-uc0/include/asm-armnommu/div64.h
--- linux-2.6.9/include/asm-armnommu/div64.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/div64.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/div64.h>
diff -Naur linux-2.6.9/include/asm-armnommu/dma.h linux-2.6.9-uc0/include/asm-armnommu/dma.h
--- linux-2.6.9/include/asm-armnommu/dma.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/dma.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/dma.h>
diff -Naur linux-2.6.9/include/asm-armnommu/dma-mapping.h linux-2.6.9-uc0/include/asm-armnommu/dma-mapping.h
--- linux-2.6.9/include/asm-armnommu/dma-mapping.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/dma-mapping.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,12 @@
+#ifndef _ARMNOMMU_DMA_MAPPING_H
+#define _ARMNOMMU_DMA_MAPPING_H
+
+#include <linux/config.h>
+
+#ifdef CONFIG_PCI
+#include <asm-generic/dma-mapping.h>
+#else
+#include <asm-generic/dma-mapping-broken.h>
+#endif
+
+#endif /* _ARMNOMMU_DMA_MAPPING_H */
diff -Naur linux-2.6.9/include/asm-armnommu/domain.h linux-2.6.9-uc0/include/asm-armnommu/domain.h
--- linux-2.6.9/include/asm-armnommu/domain.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/domain.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,43 @@
+/*
+ *  linux/include/asm-armnommu/domain.h
+ *
+ *  Copyright (C) 1999 Russell King.
+ *  Copyright (C) 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_DOMAIN_H
+#define __ASM_PROC_DOMAIN_H
+
+/*
+ * Domain numbers
+ *
+ *  DOMAIN_IO     - domain 2 includes all IO only
+ *  DOMAIN_KERNEL - domain 1 includes all kernel memory only
+ *  DOMAIN_USER   - domain 0 includes all user memory only
+ */
+#define DOMAIN_USER	0
+#define DOMAIN_KERNEL	1
+#define DOMAIN_TABLE	1
+#define DOMAIN_IO	2
+
+/*
+ * Domain types
+ */
+#define DOMAIN_NOACCESS	0
+#define DOMAIN_CLIENT	1
+#define DOMAIN_MANAGER	3
+
+#define domain_val(dom,type)	((type) << 2*(dom))
+
+#define modify_domain(dom,type)					\
+	do {							\
+	struct thread_info *thread = current_thread_info();	\
+	unsigned int domain = thread->cpu_domain;		\
+	domain &= ~domain_val(dom, DOMAIN_MANAGER);		\
+	thread->cpu_domain = domain | domain_val(dom, type);	\
+	} while (0)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/ecard.h linux-2.6.9-uc0/include/asm-armnommu/ecard.h
--- linux-2.6.9/include/asm-armnommu/ecard.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/ecard.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/ecard.h>
diff -Naur linux-2.6.9/include/asm-armnommu/elf.h linux-2.6.9-uc0/include/asm-armnommu/elf.h
--- linux-2.6.9/include/asm-armnommu/elf.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/elf.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/elf.h>
diff -Naur linux-2.6.9/include/asm-armnommu/errno.h linux-2.6.9-uc0/include/asm-armnommu/errno.h
--- linux-2.6.9/include/asm-armnommu/errno.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/errno.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef _ARM_ERRNO_H
+#define _ARM_ERRNO_H
+
+#include <asm-generic/errno.h>
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/fcntl.h linux-2.6.9-uc0/include/asm-armnommu/fcntl.h
--- linux-2.6.9/include/asm-armnommu/fcntl.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/fcntl.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/fcntl.h>
diff -Naur linux-2.6.9/include/asm-armnommu/fiq.h linux-2.6.9-uc0/include/asm-armnommu/fiq.h
--- linux-2.6.9/include/asm-armnommu/fiq.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/fiq.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/fiq.h>
diff -Naur linux-2.6.9/include/asm-armnommu/flat.h linux-2.6.9-uc0/include/asm-armnommu/flat.h
--- linux-2.6.9/include/asm-armnommu/flat.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/flat.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,20 @@
+/*
+ * include/asm-armnommu/flat.h -- uClinux flat-format executables
+ *
+ * Copyright (C) 2003, Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ */
+
+#ifndef __ARMNOMMU_FLAT_H__
+#define __ARMNOMMU_FLAT_H__
+
+#define	flat_stack_align(sp)			/* nothing needed */
+#define	flat_argvp_envp_on_stack()		1
+#define	flat_old_ram_flag(flags)		(flags)
+#define	flat_reloc_valid(reloc, size)		((reloc) <= (size))
+#define	flat_get_addr_from_rp(rp, relval, flags)	get_unaligned(rp)
+#define	flat_put_addr_at_rp(rp, val, relval)	put_unaligned(val,rp)
+#define	flat_get_relocate_addr(rel)		(rel)
+
+#endif /* __ARMNOMMU_FLAT_H__ */
+
diff -Naur linux-2.6.9/include/asm-armnommu/floppy.h linux-2.6.9-uc0/include/asm-armnommu/floppy.h
--- linux-2.6.9/include/asm-armnommu/floppy.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/floppy.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/floppy.h>
diff -Naur linux-2.6.9/include/asm-armnommu/fpstate.h linux-2.6.9-uc0/include/asm-armnommu/fpstate.h
--- linux-2.6.9/include/asm-armnommu/fpstate.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/fpstate.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/fpstate.h>
diff -Naur linux-2.6.9/include/asm-armnommu/glue.h linux-2.6.9-uc0/include/asm-armnommu/glue.h
--- linux-2.6.9/include/asm-armnommu/glue.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/glue.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,114 @@
+/*
+ *  linux/include/asm-arm/glue.h
+ *
+ *  Copyright (C) 1997-1999 Russell King
+ *  Copyright (C) 2000-2002 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This file provides the glue to stick the processor-specific bits
+ *  into the kernel in an efficient manner.  The idea is to use branches
+ *  when we're only targetting one class of TLB, or indirect calls
+ *  when we're targetting multiple classes of TLBs.
+ */
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+
+#ifdef __STDC__
+#define ____glue(name,fn)	name##fn
+#else
+#define ____glue(name,fn)	name/**/fn
+#endif
+#define __glue(name,fn)		____glue(name,fn)
+
+
+
+/*
+ *	Data Abort Model
+ *	================
+ *
+ *	We have the following to choose from:
+ *	  arm6          - ARM6 style
+ *	  arm7		- ARM7 style
+ *	  v4_early	- ARMv4 without Thumb early abort handler
+ *	  v4t_late	- ARMv4 with Thumb late abort handler
+ *	  v4t_early	- ARMv4 with Thumb early abort handler
+ *	  v5tej_early	- ARMv5 with Thumb and Java early abort handler
+ *	  xscale	- ARMv5 with Thumb with Xscale extensions
+ *	  v6_early	- ARMv6 generic early abort handler
+ */
+#undef CPU_ABORT_HANDLER
+#undef MULTI_ABORT
+
+#if defined(CONFIG_CPU_ARM610)
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER cpu_arm6_data_abort
+# endif
+#endif
+
+#if defined(CONFIG_CPU_ARM710) || defined(CONFIG_CPU_S3C4510B)
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER cpu_arm7_data_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_LV4T
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v4t_late_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV4
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v4_early_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV4T
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v4t_early_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV5TJ
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v5tj_early_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV5T
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v5t_early_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV6
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v6_early_abort
+# endif
+#endif
+
+#ifndef CPU_ABORT_HANDLER
+#error Unknown data abort handler type
+#endif
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/hardirq.h linux-2.6.9-uc0/include/asm-armnommu/hardirq.h
--- linux-2.6.9/include/asm-armnommu/hardirq.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardirq.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardirq.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/amba.h linux-2.6.9-uc0/include/asm-armnommu/hardware/amba.h
--- linux-2.6.9/include/asm-armnommu/hardware/amba.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/amba.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/amba.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/amba_kmi.h linux-2.6.9-uc0/include/asm-armnommu/hardware/amba_kmi.h
--- linux-2.6.9/include/asm-armnommu/hardware/amba_kmi.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/amba_kmi.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/amba_kmi.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/clps7111.h linux-2.6.9-uc0/include/asm-armnommu/hardware/clps7111.h
--- linux-2.6.9/include/asm-armnommu/hardware/clps7111.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/clps7111.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/clps7111.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/cs89712.h linux-2.6.9-uc0/include/asm-armnommu/hardware/cs89712.h
--- linux-2.6.9/include/asm-armnommu/hardware/cs89712.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/cs89712.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/cs89712.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/dec21285.h linux-2.6.9-uc0/include/asm-armnommu/hardware/dec21285.h
--- linux-2.6.9/include/asm-armnommu/hardware/dec21285.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/dec21285.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/dec21285.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/ep7211.h linux-2.6.9-uc0/include/asm-armnommu/hardware/ep7211.h
--- linux-2.6.9/include/asm-armnommu/hardware/ep7211.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/ep7211.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/ep7211.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/ep7212.h linux-2.6.9-uc0/include/asm-armnommu/hardware/ep7212.h
--- linux-2.6.9/include/asm-armnommu/hardware/ep7212.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/ep7212.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/ep7212.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/icst525.h linux-2.6.9-uc0/include/asm-armnommu/hardware/icst525.h
--- linux-2.6.9/include/asm-armnommu/hardware/icst525.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/icst525.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/icst525.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/ioc.h linux-2.6.9-uc0/include/asm-armnommu/hardware/ioc.h
--- linux-2.6.9/include/asm-armnommu/hardware/ioc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/ioc.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/ioc.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/iomd.h linux-2.6.9-uc0/include/asm-armnommu/hardware/iomd.h
--- linux-2.6.9/include/asm-armnommu/hardware/iomd.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/iomd.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/iomd.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/linkup-l1110.h linux-2.6.9-uc0/include/asm-armnommu/hardware/linkup-l1110.h
--- linux-2.6.9/include/asm-armnommu/hardware/linkup-l1110.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/linkup-l1110.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/linkup-l1110.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/memc.h linux-2.6.9-uc0/include/asm-armnommu/hardware/memc.h
--- linux-2.6.9/include/asm-armnommu/hardware/memc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/memc.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/memc.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/pci_v3.h linux-2.6.9-uc0/include/asm-armnommu/hardware/pci_v3.h
--- linux-2.6.9/include/asm-armnommu/hardware/pci_v3.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/pci_v3.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/pci_v3.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/sa1111.h linux-2.6.9-uc0/include/asm-armnommu/hardware/sa1111.h
--- linux-2.6.9/include/asm-armnommu/hardware/sa1111.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/sa1111.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/sa1111.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/serial_amba.h linux-2.6.9-uc0/include/asm-armnommu/hardware/serial_amba.h
--- linux-2.6.9/include/asm-armnommu/hardware/serial_amba.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/serial_amba.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/serial_amba.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/ssp.h linux-2.6.9-uc0/include/asm-armnommu/hardware/ssp.h
--- linux-2.6.9/include/asm-armnommu/hardware/ssp.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/ssp.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hardware/ssp.h>
diff -Naur linux-2.6.9/include/asm-armnommu/hardware/t32.h linux-2.6.9-uc0/include/asm-armnommu/hardware/t32.h
--- linux-2.6.9/include/asm-armnommu/hardware/t32.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware/t32.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-armnommu/hardware/t32.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __T32_PUTS__
+#define __T32_PUTS__
+static void t32_puts(const char *p)
+{
+#ifndef CONFIG_JTAG_T32_OUTPUT_DISABLE
+	/*
+		r0 = string	; string address
+		r1 = 2		; state check bit (write)
+		r4 = *string	; character
+	*/
+		__asm__ __volatile__(
+			"	ldrb r4, [%0]			@ load a char\n"
+			"1:	mrc	p14, 0, r3, c0, c0 	@ read comms control reg\n"
+			"	and r3, r3, #2			@ the write buffer status\n"
+			"	cmp r3, #2			@ is it available?\n"
+			"	beq 1b				@ is not, wait till then\n"
+			"	mcr p14, 0, r4, c1, c0	@ write it\n"
+			"	cmp r4, #0x0a		@ is it LF?\n"
+			"	bne 2f				@ if it is not, continue\n"
+			"	mov r4, #0x0d		@ set the CR\n"
+			"	b   1b				@ loop for writing CR\n"			
+			"2:	ldrb r4, [%0, #1]!		@ load a char\n"
+			"	cmp r4, #0x0			@ test is null\n"
+			"	bne 1b				@ if it is not yet, loop"
+			: /* no output register */
+			: "r" (p)
+			: "r3", "r4");
+#endif
+}
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/hardware.h linux-2.6.9-uc0/include/asm-armnommu/hardware.h
--- linux-2.6.9/include/asm-armnommu/hardware.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hardware.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,42 @@
+/*
+ *  linux/include/asm-arm/hardware.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *  Copyright (C) 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Common hardware definitions
+ */
+
+#ifndef __ASM_HARDWARE_H
+#define __ASM_HARDWARE_H
+
+#include <asm/arch/hardware.h>
+
+#ifndef __ASSEMBLY__
+
+struct platform_device;
+
+extern int platform_add_devices(struct platform_device **, int);
+extern int platform_add_device(struct platform_device *);
+
+/* the machine dependent  bootmem reserve and free routines */
+#ifndef MACH_RESERVE_BOOTMEM
+	#define MACH_RESERVE_BOOTMEM()
+#endif
+
+#ifndef MACH_FREE_BOOTMEM
+	#define MACH_FREE_BOOTMEM()
+#endif
+
+/* by default, initmem is freed */
+#ifndef DO_FREE_INITMEM
+	#define DO_FREE_INITMEM() 	(1)
+#endif
+
+#endif /* !__ASSEMBLY__ */
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/hdreg.h linux-2.6.9-uc0/include/asm-armnommu/hdreg.h
--- linux-2.6.9/include/asm-armnommu/hdreg.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/hdreg.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/hdreg.h>
diff -Naur linux-2.6.9/include/asm-armnommu/ide.h linux-2.6.9-uc0/include/asm-armnommu/ide.h
--- linux-2.6.9/include/asm-armnommu/ide.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/ide.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/ide.h>
diff -Naur linux-2.6.9/include/asm-armnommu/ioctl.h linux-2.6.9-uc0/include/asm-armnommu/ioctl.h
--- linux-2.6.9/include/asm-armnommu/ioctl.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/ioctl.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/ioctl.h>
diff -Naur linux-2.6.9/include/asm-armnommu/ioctls.h linux-2.6.9-uc0/include/asm-armnommu/ioctls.h
--- linux-2.6.9/include/asm-armnommu/ioctls.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/ioctls.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/ioctls.h>
diff -Naur linux-2.6.9/include/asm-armnommu/io.h linux-2.6.9-uc0/include/asm-armnommu/io.h
--- linux-2.6.9/include/asm-armnommu/io.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/io.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/io.h>
diff -Naur linux-2.6.9/include/asm-armnommu/ipcbuf.h linux-2.6.9-uc0/include/asm-armnommu/ipcbuf.h
--- linux-2.6.9/include/asm-armnommu/ipcbuf.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/ipcbuf.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/ipcbuf.h>
diff -Naur linux-2.6.9/include/asm-armnommu/ipc.h linux-2.6.9-uc0/include/asm-armnommu/ipc.h
--- linux-2.6.9/include/asm-armnommu/ipc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/ipc.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/ipc.h>
diff -Naur linux-2.6.9/include/asm-armnommu/irq.h linux-2.6.9-uc0/include/asm-armnommu/irq.h
--- linux-2.6.9/include/asm-armnommu/irq.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/irq.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/irq.h>
diff -Naur linux-2.6.9/include/asm-armnommu/kmap_types.h linux-2.6.9-uc0/include/asm-armnommu/kmap_types.h
--- linux-2.6.9/include/asm-armnommu/kmap_types.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/kmap_types.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/kmap_types.h>
diff -Naur linux-2.6.9/include/asm-armnommu/leds.h linux-2.6.9-uc0/include/asm-armnommu/leds.h
--- linux-2.6.9/include/asm-armnommu/leds.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/leds.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/leds.h>
diff -Naur linux-2.6.9/include/asm-armnommu/limits.h linux-2.6.9-uc0/include/asm-armnommu/limits.h
--- linux-2.6.9/include/asm-armnommu/limits.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/limits.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/limits.h>
diff -Naur linux-2.6.9/include/asm-armnommu/linkage.h linux-2.6.9-uc0/include/asm-armnommu/linkage.h
--- linux-2.6.9/include/asm-armnommu/linkage.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/linkage.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/linkage.h>
diff -Naur linux-2.6.9/include/asm-armnommu/local.h linux-2.6.9-uc0/include/asm-armnommu/local.h
--- linux-2.6.9/include/asm-armnommu/local.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/local.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-generic/local.h>
diff -Naur linux-2.6.9/include/asm-armnommu/locks.h linux-2.6.9-uc0/include/asm-armnommu/locks.h
--- linux-2.6.9/include/asm-armnommu/locks.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/locks.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/locks.h>
diff -Naur linux-2.6.9/include/asm-armnommu/mach/arch.h linux-2.6.9-uc0/include/asm-armnommu/mach/arch.h
--- linux-2.6.9/include/asm-armnommu/mach/arch.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mach/arch.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,90 @@
+/*
+ *  linux/include/asm-armnommu/mach/arch.h
+ *
+ *  Copyright (C) 2000 Russell King
+ *  Modified by Hyok S. Choi for uClinux, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * The size of struct machine_desc
+ *   (for assembler code)
+ */
+#define SIZEOF_MACHINE_DESC	44
+
+#ifndef __ASSEMBLY__
+
+struct tag;
+struct meminfo;
+
+struct machine_desc {
+	/*
+	 * Note! The first three elements are used
+	 * by assembler code in head.S
+	 */
+	unsigned int		nr;		/* architecture number	*/
+	unsigned int		phys_ram;	/* start of physical ram */
+	unsigned int		phys_io;	/* start of physical io	*/
+
+	const char		*name;		/* architecture name	*/
+	unsigned int		param_offset;	/* parameter page	*/
+
+	unsigned int		video_start;	/* start of video RAM	*/
+	unsigned int		video_end;	/* end of video RAM	*/
+
+	unsigned int		reserve_lp0 :1;	/* never has lp0	*/
+	unsigned int		reserve_lp1 :1;	/* never has lp1	*/
+	unsigned int		reserve_lp2 :1;	/* never has lp2	*/
+	unsigned int		soft_reboot :1;	/* soft reboot		*/
+	void			(*fixup)(struct machine_desc *,
+					 struct tag *, char **,
+					 struct meminfo *);
+	void			(*init_irq)(void);
+	void			(*init_machine)(void);
+};
+
+/*
+ * Set of macros to define architecture features.  This is built into
+ * a table by the linker.
+ */
+#define MACHINE_START(_type,_name)		\
+const struct machine_desc __mach_desc_##_type	\
+ __attribute__((__section__(".arch.info"))) = {	\
+	.nr		= MACH_TYPE_##_type,	\
+	.name		= _name,
+
+#define MAINTAINER(n)
+
+#define BOOT_MEM(_pram,_pio,_vio)		\
+	.phys_ram	= _pram,		\
+	.phys_io	= _pio,
+
+#define BOOT_PARAMS(_params)			\
+	.param_offset	= _params,
+
+#define VIDEO(_start,_end)			\
+	.video_start	= _start,		\
+	.video_end	= _end,
+
+#define DISABLE_PARPORT(_n)			\
+	.reserve_lp##_n	= 1,
+
+#define SOFT_REBOOT				\
+	.soft_reboot	= 1,
+
+#define FIXUP(_func)				\
+	.fixup		= _func,
+
+#define INITIRQ(_func)				\
+	.init_irq	= _func,
+
+#define INIT_MACHINE(_func)			\
+	.init_machine	= _func,
+
+#define MACHINE_END				\
+};
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/mach/dma.h linux-2.6.9-uc0/include/asm-armnommu/mach/dma.h
--- linux-2.6.9/include/asm-armnommu/mach/dma.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mach/dma.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mach/dma.h>
diff -Naur linux-2.6.9/include/asm-armnommu/mach/flash.h linux-2.6.9-uc0/include/asm-armnommu/mach/flash.h
--- linux-2.6.9/include/asm-armnommu/mach/flash.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mach/flash.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mach/flash.h>
diff -Naur linux-2.6.9/include/asm-armnommu/mach/irq.h linux-2.6.9-uc0/include/asm-armnommu/mach/irq.h
--- linux-2.6.9/include/asm-armnommu/mach/irq.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mach/irq.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mach/irq.h>
diff -Naur linux-2.6.9/include/asm-armnommu/mach/map.h linux-2.6.9-uc0/include/asm-armnommu/mach/map.h
--- linux-2.6.9/include/asm-armnommu/mach/map.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mach/map.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mach/map.h>
diff -Naur linux-2.6.9/include/asm-armnommu/mach/pci.h linux-2.6.9-uc0/include/asm-armnommu/mach/pci.h
--- linux-2.6.9/include/asm-armnommu/mach/pci.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mach/pci.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mach/pci.h>
diff -Naur linux-2.6.9/include/asm-armnommu/mach/serial_sa1100.h linux-2.6.9-uc0/include/asm-armnommu/mach/serial_sa1100.h
--- linux-2.6.9/include/asm-armnommu/mach/serial_sa1100.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mach/serial_sa1100.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mach/serial_sa1100.h>
diff -Naur linux-2.6.9/include/asm-armnommu/mach-types.h linux-2.6.9-uc0/include/asm-armnommu/mach-types.h
--- linux-2.6.9/include/asm-armnommu/mach-types.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mach-types.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mach-types.h>
diff -Naur linux-2.6.9/include/asm-armnommu/mc146818rtc.h linux-2.6.9-uc0/include/asm-armnommu/mc146818rtc.h
--- linux-2.6.9/include/asm-armnommu/mc146818rtc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mc146818rtc.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mc146818rtc.h>
diff -Naur linux-2.6.9/include/asm-armnommu/memory.h linux-2.6.9-uc0/include/asm-armnommu/memory.h
--- linux-2.6.9/include/asm-armnommu/memory.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/memory.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,69 @@
+/*
+ *  linux/include/asm-armnommu/memory.h
+ *
+ *  Copyright (C) 2000-2002 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Note: this file should not be included by non-asm/.h files
+ */
+#ifndef __ASM_ARMNOMMU_MEMORY_H
+#define __ASM_ARMNOMMU_MEMORY_H
+
+#include <linux/config.h>
+#include <asm/arch/memory.h>
+
+
+
+#define virt_to_bus(x) ((unsigned long) (x))
+#define bus_to_virt(x) ((void *) (x))
+#define virt_to_phys(x) ((unsigned long) (x))
+#define phys_to_virt(x) ((void *) (x))
+
+#define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
+
+#define __virt_to_phys__is_a_macro
+#define __phys_to_virt__is_a_macro
+#define __virt_to_bus__is_a_macro
+#define __bus_to_virt__is_a_macro
+
+
+#define __pa(x)			__virt_to_phys((unsigned long)(x))
+#define __va(x)			((void *)__phys_to_virt((unsigned long)(x)))
+
+#ifndef CONFIG_DISCONTIGMEM
+/*
+ * PFNs are used to describe any physical page; this means
+ * PFN 0 == physical address 0.
+ *
+ * This is the PFN of the first RAM page in the kernel
+ * direct-mapped view.  We assume this is the first page
+ * of RAM in the mem_map as well.
+ */
+#define PHYS_PFN_OFFSET	(PHYS_OFFSET >> PAGE_SHIFT)
+
+#define page_to_pfn(page)	(((page) - mem_map) + PHYS_PFN_OFFSET)
+#define pfn_to_page(pfn)	((mem_map + (pfn)) - PHYS_PFN_OFFSET)
+
+#define virt_to_page(kaddr)	(pfn_to_page(__pa(kaddr) >> PAGE_SHIFT))
+#define virt_addr_valid(kaddr)	((unsigned long)(kaddr) >= PAGE_OFFSET && (unsigned long)(kaddr) < (unsigned long)high_memory)
+
+#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
+
+/* MAP_NR should not be used in 2.4 */
+#define MAP_NR(addr)      (((unsigned long) (addr) - PAGE_OFFSET) >> PAGE_SHIFT)
+
+#define PHYS_TO_NID(addr)	(0)
+
+#endif /* CONFIG_DISCONTIGMEM */
+
+/*
+ * We should really eliminate virt_to_bus() here - it's deprecated.
+ */
+#define page_to_bus(page)	(virt_to_bus(page_address(page)))
+
+
+#endif /* __ASM_ARMNOMMU_MEMORY_H */
diff -Naur linux-2.6.9/include/asm-armnommu/mman.h linux-2.6.9-uc0/include/asm-armnommu/mman.h
--- linux-2.6.9/include/asm-armnommu/mman.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mman.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mman.h>
diff -Naur linux-2.6.9/include/asm-armnommu/mmu_context.h linux-2.6.9-uc0/include/asm-armnommu/mmu_context.h
--- linux-2.6.9/include/asm-armnommu/mmu_context.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mmu_context.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,48 @@
+/*
+ *  linux/include/asm-armnommu/mmu_context.h
+ *
+ *  Copyright (C) 1996 Russell King.
+ *  Copyright (C) 2001 RidgRun Inc (www.ridgerun.com)
+ *  Copyright (C) 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   27-06-1996	RMK	Created
+ *   20-02-2001 GJM     Gutted for uClinux
+ *   05-03-2004 HSC     modified for 2.6
+ */
+#ifndef __ASM_ARMNOMMU_MMU_CONTEXT_H
+#define __ASM_ARMNOMMU_MMU_CONTEXT_H
+
+#include <linux/config.h>
+#include <asm/setup.h>
+#include <asm/page.h>
+#include <asm/pgalloc.h>
+
+static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
+{
+}
+
+extern inline int
+init_new_context(struct task_struct *tsk, struct mm_struct *mm)
+{
+	return(0);
+}
+
+#define destroy_context(mm)		do { } while(0)
+
+static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk)
+{
+}
+
+#define deactivate_mm(tsk,mm)	do { } while (0)
+
+extern inline void activate_mm(struct mm_struct *prev_mm,
+			       struct mm_struct *next_mm)
+{
+}
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/mmu.h linux-2.6.9-uc0/include/asm-armnommu/mmu.h
--- linux-2.6.9/include/asm-armnommu/mmu.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mmu.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,34 @@
+/*
+ *  linux/include/asm-armnommu/mmu.h
+ *
+ *  Copyright (C) 2002, David McCullough <davidm@snapgear.com>
+ *  fixed for 2.6 by Hyok S. Choi <hyok.choi@samsung.com>
+ */
+
+#ifndef __ARM_MMU_H
+#define __ARM_MMU_H
+
+
+struct mm_rblock_struct {
+	int	size;
+	int	refcount;
+	void	*kblock;
+};
+
+struct mm_tblock_struct {
+	struct mm_rblock_struct	*rblock;
+	struct mm_tblock_struct	*next;
+};
+
+typedef struct {
+	struct mm_tblock_struct	tblock;
+	unsigned long		end_brk;
+} mm_context_t;
+
+#if __LINUX_ARM_ARCH__ >= 6
+#define ASID(mm)	((mm)->context.id & 255)
+#else
+#define ASID(mm)	(0)
+#endif
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/mmzone.h linux-2.6.9-uc0/include/asm-armnommu/mmzone.h
--- linux-2.6.9/include/asm-armnommu/mmzone.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/mmzone.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/mmzone.h>
diff -Naur linux-2.6.9/include/asm-armnommu/module.h linux-2.6.9-uc0/include/asm-armnommu/module.h
--- linux-2.6.9/include/asm-armnommu/module.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/module.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/module.h>
diff -Naur linux-2.6.9/include/asm-armnommu/msgbuf.h linux-2.6.9-uc0/include/asm-armnommu/msgbuf.h
--- linux-2.6.9/include/asm-armnommu/msgbuf.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/msgbuf.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/msgbuf.h>
diff -Naur linux-2.6.9/include/asm-armnommu/namei.h linux-2.6.9-uc0/include/asm-armnommu/namei.h
--- linux-2.6.9/include/asm-armnommu/namei.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/namei.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/namei.h>
diff -Naur linux-2.6.9/include/asm-armnommu/numnodes.h linux-2.6.9-uc0/include/asm-armnommu/numnodes.h
--- linux-2.6.9/include/asm-armnommu/numnodes.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/numnodes.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/numnodes.h>
diff -Naur linux-2.6.9/include/asm-armnommu/nwflash.h linux-2.6.9-uc0/include/asm-armnommu/nwflash.h
--- linux-2.6.9/include/asm-armnommu/nwflash.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/nwflash.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/nwflash.h>
diff -Naur linux-2.6.9/include/asm-armnommu/page.h linux-2.6.9-uc0/include/asm-armnommu/page.h
--- linux-2.6.9/include/asm-armnommu/page.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/page.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,95 @@
+/*
+ *  linux/include/asm-armnommu/page.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PAGE_H
+#define _ASMARM_PAGE_H
+
+#include <linux/config.h>
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT		12
+#define PAGE_SIZE		(1UL << PAGE_SHIFT)
+#define PAGE_MASK		(~(PAGE_SIZE-1))
+
+#ifdef __KERNEL__
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+#ifndef __ASSEMBLY__
+
+#include <asm/glue.h>
+
+#undef _USER
+#undef MULTI_USER
+
+#if !defined(CONFIG_SMALL_TASKS) && PAGE_SHIFT < 13
+#define KTHREAD_SIZE (8192)
+#else
+#define KTHREAD_SIZE PAGE_SIZE
+#endif
+ 
+#define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
+#define free_user_page(page, addr)	free_page(addr)
+
+#define clear_page(page)	memset((page), 0, PAGE_SIZE)
+#define copy_page(to,from)	memcpy((to), (from), PAGE_SIZE)
+
+#define clear_user_page(page, vaddr, pg)	clear_page(page)
+#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct { unsigned long pte; } pte_t;
+typedef struct { unsigned long pmd[16]; } pmd_t;
+typedef struct { unsigned long pgd; } pgd_t;
+typedef struct { unsigned long pgprot; } pgprot_t;
+
+#define pte_val(x)	((x).pte)
+#define pmd_val(x)	((&x)->pmd[0])
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x)	((pte_t) { (x) } )
+#define __pmd(x)	((pmd_t) { (x) } )
+#define __pgd(x)	((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+/* Pure 2^n version of get_order */
+extern __inline__ int get_order(unsigned long size)
+{
+	int order;
+
+	size = (size-1) >> (PAGE_SHIFT-1);
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+	return order;
+}
+
+extern unsigned long memory_start;
+extern unsigned long memory_end;
+
+#include <asm/memory.h>
+
+
+#endif /* !__ASSEMBLY__ */
+
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/param.h linux-2.6.9-uc0/include/asm-armnommu/param.h
--- linux-2.6.9/include/asm-armnommu/param.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/param.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/param.h>
diff -Naur linux-2.6.9/include/asm-armnommu/parport.h linux-2.6.9-uc0/include/asm-armnommu/parport.h
--- linux-2.6.9/include/asm-armnommu/parport.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/parport.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/parport.h>
diff -Naur linux-2.6.9/include/asm-armnommu/pci.h linux-2.6.9-uc0/include/asm-armnommu/pci.h
--- linux-2.6.9/include/asm-armnommu/pci.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/pci.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/pci.h>
diff -Naur linux-2.6.9/include/asm-armnommu/percpu.h linux-2.6.9-uc0/include/asm-armnommu/percpu.h
--- linux-2.6.9/include/asm-armnommu/percpu.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/percpu.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef __ARM_PERCPU
+#define __ARM_PERCPU
+
+#include <asm-generic/percpu.h>
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/pgalloc.h linux-2.6.9-uc0/include/asm-armnommu/pgalloc.h
--- linux-2.6.9/include/asm-armnommu/pgalloc.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/pgalloc.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-armnommu/pgalloc.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PGALLOC_H
+#define _ASMARM_PGALLOC_H
+
+#include <asm/processor.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+
+#define check_pgt_cache()		do { } while (0)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/pgtable.h linux-2.6.9-uc0/include/asm-armnommu/pgtable.h
--- linux-2.6.9/include/asm-armnommu/pgtable.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/pgtable.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,100 @@
+/*
+ *  linux/include/asm-armnommu/pgtable.h
+ *
+ *  Copyright (C) 1995-2002 Russell King
+ *  Modified by Hyok S. Choi, 2004, Samsung Electronics Co.,Ltd.
+ *  (referenced from m68knommu)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PGTABLE_H
+#define _ASMARM_PGTABLE_H
+
+#ifndef __ASSEMBLY__
+
+
+#include <linux/config.h>
+#include <linux/slab.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/io.h>
+
+
+/*
+ * Trivial page table functions.
+ */
+#define pgd_present(pgd)	(1)
+#define pgd_none(pgd)		(0)
+#define pgd_bad(pgd)		(0)
+#define pgd_clear(pgdp)
+#define kern_addr_valid(addr)	(1)
+#define	pmd_offset(a, b)	((void *)0)
+
+/* FIXME */
+/*
+ * PMD_SHIFT determines the size of the area a second-level page table can map
+ * PGDIR_SHIFT determines what a third-level page table entry can map
+ */
+#define PGDIR_SHIFT		21
+
+#define PGDIR_SIZE		(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK		(~(PGDIR_SIZE-1))
+/* FIXME */
+
+#define PAGE_NONE	__pgprot(0)
+#define PAGE_SHARED	__pgprot(0)
+#define PAGE_COPY	__pgprot(0)
+#define PAGE_READONLY	__pgprot(0)
+#define PAGE_KERNEL	__pgprot(0)
+
+//extern void paging_init(struct meminfo *, struct machine_desc *);
+#define swapper_pg_dir ((pgd_t *) 0)
+
+#define __swp_type(x)		(0)
+#define __swp_offset(x)		(0)
+#define __swp_entry(typ,off)	((swp_entry_t) { ((typ) | ((off) << 7)) })
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+
+typedef pte_t *pte_addr_t;
+
+static inline int pte_file(pte_t pte) { return 0; }
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+#define ZERO_PAGE(vaddr)	(virt_to_page(0))
+
+/*
+ * Mark the prot value as uncacheable and unbufferable.
+ */
+#define pgprot_noncached(prot)	__pgprot(0)
+#define pgprot_writecombine(prot) __pgprot(0)
+
+
+/*
+ * These would be in other places but having them here reduces the diffs.
+ */
+extern unsigned int kobjsize(const void *objp);
+extern int is_in_rom(unsigned long);
+
+/*
+ * No page table caches to initialise.
+ */
+#define pgtable_cache_init()	do { } while (0)
+#define io_remap_page_range	remap_page_range
+
+/*
+ * All 32bit addresses are effectively valid for vmalloc...
+ * Sort of meaningless for non-VM targets.
+ */
+#define	VMALLOC_START	0
+#define	VMALLOC_END	0xffffffff
+
+#endif /*__ASSEMBLY__*/
+
+#endif /* _ASMARM_PGTABLE_H */
diff -Naur linux-2.6.9/include/asm-armnommu/poll.h linux-2.6.9-uc0/include/asm-armnommu/poll.h
--- linux-2.6.9/include/asm-armnommu/poll.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/poll.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/poll.h>
diff -Naur linux-2.6.9/include/asm-armnommu/posix_types.h linux-2.6.9-uc0/include/asm-armnommu/posix_types.h
--- linux-2.6.9/include/asm-armnommu/posix_types.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/posix_types.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/posix_types.h>
diff -Naur linux-2.6.9/include/asm-armnommu/processor.h linux-2.6.9-uc0/include/asm-armnommu/processor.h
--- linux-2.6.9/include/asm-armnommu/processor.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/processor.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,131 @@
+/*
+ *  linux/include/asm-armnommu/processor.h
+ *
+ *  Copyright (C) 1995-1999 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARM_PROCESSOR_H
+#define __ASM_ARM_PROCESSOR_H
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.  We won't be using it.
+ */
+#define TASK_UNMAPPED_BASE	0
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l;})
+
+#ifdef __KERNEL__
+
+#define MCA_bus 0
+#define MCA_bus__is_a_macro
+
+#include <asm/atomic.h>
+#include <asm/ptrace.h>
+#include <asm/procinfo.h>
+#include <asm/arch/memory.h>
+#include <asm/types.h>
+
+#define KERNEL_STACK_SIZE	PAGE_SIZE
+
+union debug_insn {
+	u32	arm;
+	u16	thumb;
+};
+
+struct debug_entry {
+	u32			address;
+	union debug_insn	insn;
+};
+
+struct debug_info {
+	int			nsaved;
+	struct debug_entry	bp[2];
+};
+
+struct thread_struct {
+							/* fault info	  */
+	unsigned long		address;
+	unsigned long		trap_no;
+	unsigned long		error_code;
+							/* debugging	  */
+	struct debug_info	debug;
+};
+
+#define INIT_THREAD  {	}
+
+#define start_thread(regs,pc,sp)					\
+({									\
+	unsigned long *stack = (unsigned long *)sp;			\
+	set_fs(USER_DS);						\
+	memzero(regs->uregs, sizeof(regs->uregs));			\
+	if (current->personality & ADDR_LIMIT_32BIT)			\
+		regs->ARM_cpsr = USR_MODE;				\
+	else								\
+		regs->ARM_cpsr = USR26_MODE;				\
+	if (elf_hwcap & HWCAP_THUMB && pc & 1)				\
+		regs->ARM_cpsr |= PSR_T_BIT;				\
+	regs->ARM_pc = pc & ~1;		/* pc */			\
+	regs->ARM_sp = sp;		/* sp */			\
+	regs->ARM_r2 = stack[2];	/* r2 (envp) */			\
+	regs->ARM_r1 = stack[1];	/* r1 (argv) */			\
+	regs->ARM_r0 = stack[0];	/* r0 (argc) */			\
+	regs->ARM_r10 = current->mm->start_data; /* data segment base */ \
+})
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+
+/* Free all resources held by a thread. */
+extern void release_thread(struct task_struct *);
+
+/* Prepare to copy thread state - unlazy all lazy status */
+#define prepare_to_copy(tsk)	do { } while (0)
+
+unsigned long get_wchan(struct task_struct *p);
+
+#define cpu_relax()			barrier()
+
+/*
+ * Create a new kernel thread
+ */
+extern int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
+
+#define KSTK_EIP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)->thread_info))[1019])
+#define KSTK_ESP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)->thread_info))[1017])
+
+/*
+ * Prefetching support - only ARMv5.
+ */
+#if __LINUX_ARM_ARCH__ >= 5
+
+#define ARCH_HAS_PREFETCH
+#define prefetch(ptr)				\
+	({					\
+		__asm__ __volatile__(		\
+		"pld\t%0"			\
+		:				\
+		: "o" (*(char *)(ptr))		\
+		: "cc");			\
+	})
+
+#define ARCH_HAS_PREFETCHW
+#define prefetchw(ptr)	prefetch(ptr)
+
+#define ARCH_HAS_SPINLOCK_PREFETCH
+#define spin_lock_prefetch(x) do { } while (0)
+
+#endif
+
+#endif
+
+#endif /* __ASM_ARM_PROCESSOR_H */
diff -Naur linux-2.6.9/include/asm-armnommu/proc-fns.h linux-2.6.9-uc0/include/asm-armnommu/proc-fns.h
--- linux-2.6.9/include/asm-armnommu/proc-fns.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/proc-fns.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,143 @@
+/*
+ *  linux/include/asm-armnommu/proc-fns.h
+ *
+ *  Copyright (C) 1997-1999 Russell King
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) 2003 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROCFNS_H
+#define __ASM_PROCFNS_H
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+
+/*
+ * Work out if we need multiple CPU support
+ */
+#undef MULTI_CPU
+#undef CPU_NAME
+
+/*
+ * CPU_NAME - the prefix for CPU related functions
+ */
+
+#ifdef CONFIG_CPU_32
+# ifdef CONFIG_CPU_ARM610
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm6
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM7V3
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm7
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM710
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm7
+#  endif
+# endif
+# ifdef CONFIG_CPU_S3C4510B
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm7
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM720T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm720
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM920T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm920
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM922T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm922
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM926T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm926
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM940T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm940
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM1020
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm1020
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM1020E
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm1020e
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM1022
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm1022
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM1026
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm1026
+#  endif
+# endif
+#endif
+
+#ifndef MULTI_CPU
+#include "asm/cpu-single.h"
+#else
+#include "asm/cpu-multi32.h"
+#endif
+
+#endif /* __KERNEL__ */
+#endif /* __ASM_PROCFNS_H */
diff -Naur linux-2.6.9/include/asm-armnommu/procinfo.h linux-2.6.9-uc0/include/asm-armnommu/procinfo.h
--- linux-2.6.9/include/asm-armnommu/procinfo.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/procinfo.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,56 @@
+/*
+ *  linux/include/asm-arm/procinfo.h
+ *
+ *  Copyright (C) 1996-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROCINFO_H
+#define __ASM_PROCINFO_H
+
+#ifndef __ASSEMBLY__
+
+struct cpu_cache_fns;
+struct processor;
+
+/*
+ * Note!  struct processor is always defined if we're
+ * using MULTI_CPU, otherwise this entry is unused,
+ * but still exists.
+ *
+ * NOTE! The following structure is defined by assembly
+ * language, NOT C code.  For more information, check:
+ *  arch/arm/mm/proc-*.S and arch/arm/kernel/head-armv.S
+ */
+struct proc_info_list {
+	unsigned int		cpu_val;
+	unsigned int		cpu_mask;
+	unsigned long		__cpu_mmu_flags;	/* used by head-armv.S */
+	unsigned long		__cpu_flush;		/* used by head-armv.S */
+	const char		*arch_name;
+	const char		*elf_name;
+	unsigned int		elf_hwcap;
+	const char		*cpu_name;
+	struct processor	*proc;
+	struct cpu_cache_fns	*cache;
+};
+
+extern unsigned int elf_hwcap;
+
+#endif	/* __ASSEMBLY__ */
+
+#define PROC_INFO_SZ	40
+
+#define HWCAP_SWP	1
+#define HWCAP_HALF	2
+#define HWCAP_THUMB	4
+#define HWCAP_26BIT	8	/* Play it safe */
+#define HWCAP_FAST_MULT	16
+#define HWCAP_FPA	32
+#define HWCAP_VFP	64
+#define HWCAP_EDSP	128
+#define HWCAP_JAVA	256
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/ptrace.h linux-2.6.9-uc0/include/asm-armnommu/ptrace.h
--- linux-2.6.9/include/asm-armnommu/ptrace.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/ptrace.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/ptrace.h>
diff -Naur linux-2.6.9/include/asm-armnommu/resource.h linux-2.6.9-uc0/include/asm-armnommu/resource.h
--- linux-2.6.9/include/asm-armnommu/resource.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/resource.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/resource.h>
diff -Naur linux-2.6.9/include/asm-armnommu/rmap.h linux-2.6.9-uc0/include/asm-armnommu/rmap.h
--- linux-2.6.9/include/asm-armnommu/rmap.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/rmap.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef _ARM_RMAP_H
+#define _ARM_RMAP_H
+
+/* Do not need anything here */
+
+#endif /* _ARM_RMAP_H */
diff -Naur linux-2.6.9/include/asm-armnommu/scatterlist.h linux-2.6.9-uc0/include/asm-armnommu/scatterlist.h
--- linux-2.6.9/include/asm-armnommu/scatterlist.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/scatterlist.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/scatterlist.h>
diff -Naur linux-2.6.9/include/asm-armnommu/sections.h linux-2.6.9-uc0/include/asm-armnommu/sections.h
--- linux-2.6.9/include/asm-armnommu/sections.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/sections.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-generic/sections.h>
diff -Naur linux-2.6.9/include/asm-armnommu/segment.h linux-2.6.9-uc0/include/asm-armnommu/segment.h
--- linux-2.6.9/include/asm-armnommu/segment.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/segment.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1,11 @@
+#ifndef __ASM_ARM_SEGMENT_H
+#define __ASM_ARM_SEGMENT_H
+
+#define __KERNEL_CS   0x0
+#define __KERNEL_DS   0x0
+
+#define __USER_CS     0x1
+#define __USER_DS     0x1
+
+#endif /* __ASM_ARM_SEGMENT_H */
+
diff -Naur linux-2.6.9/include/asm-armnommu/semaphore.h linux-2.6.9-uc0/include/asm-armnommu/semaphore.h
--- linux-2.6.9/include/asm-armnommu/semaphore.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/semaphore.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/semaphore.h>
diff -Naur linux-2.6.9/include/asm-armnommu/semaphore-helper.h linux-2.6.9-uc0/include/asm-armnommu/semaphore-helper.h
--- linux-2.6.9/include/asm-armnommu/semaphore-helper.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/semaphore-helper.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/semaphore-helper.h>
diff -Naur linux-2.6.9/include/asm-armnommu/sembuf.h linux-2.6.9-uc0/include/asm-armnommu/sembuf.h
--- linux-2.6.9/include/asm-armnommu/sembuf.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/sembuf.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/sembuf.h>
diff -Naur linux-2.6.9/include/asm-armnommu/serial.h linux-2.6.9-uc0/include/asm-armnommu/serial.h
--- linux-2.6.9/include/asm-armnommu/serial.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/serial.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/serial.h>
diff -Naur linux-2.6.9/include/asm-armnommu/setup.h linux-2.6.9-uc0/include/asm-armnommu/setup.h
--- linux-2.6.9/include/asm-armnommu/setup.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/setup.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/setup.h>
diff -Naur linux-2.6.9/include/asm-armnommu/shmbuf.h linux-2.6.9-uc0/include/asm-armnommu/shmbuf.h
--- linux-2.6.9/include/asm-armnommu/shmbuf.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/shmbuf.h	2004-10-28 11:14:24.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/shmbuf.h>
diff -Naur linux-2.6.9/include/asm-armnommu/shmparam.h linux-2.6.9-uc0/include/asm-armnommu/shmparam.h
--- linux-2.6.9/include/asm-armnommu/shmparam.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/shmparam.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/shmparam.h>
diff -Naur linux-2.6.9/include/asm-armnommu/sigcontext.h linux-2.6.9-uc0/include/asm-armnommu/sigcontext.h
--- linux-2.6.9/include/asm-armnommu/sigcontext.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/sigcontext.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/sigcontext.h>
diff -Naur linux-2.6.9/include/asm-armnommu/siginfo.h linux-2.6.9-uc0/include/asm-armnommu/siginfo.h
--- linux-2.6.9/include/asm-armnommu/siginfo.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/siginfo.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef _ASMARM_SIGINFO_H
+#define _ASMARM_SIGINFO_H
+
+#include <asm-generic/siginfo.h>
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/signal.h linux-2.6.9-uc0/include/asm-armnommu/signal.h
--- linux-2.6.9/include/asm-armnommu/signal.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/signal.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/signal.h>
diff -Naur linux-2.6.9/include/asm-armnommu/sizes.h linux-2.6.9-uc0/include/asm-armnommu/sizes.h
--- linux-2.6.9/include/asm-armnommu/sizes.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/sizes.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/sizes.h>
diff -Naur linux-2.6.9/include/asm-armnommu/smp.h linux-2.6.9-uc0/include/asm-armnommu/smp.h
--- linux-2.6.9/include/asm-armnommu/smp.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/smp.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,10 @@
+#ifndef __ASM_SMP_H
+#define __ASM_SMP_H
+
+#include <linux/config.h>
+
+#ifdef CONFIG_SMP
+#error SMP not supported
+#endif
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/socket.h linux-2.6.9-uc0/include/asm-armnommu/socket.h
--- linux-2.6.9/include/asm-armnommu/socket.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/socket.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/socket.h>
diff -Naur linux-2.6.9/include/asm-armnommu/sockios.h linux-2.6.9-uc0/include/asm-armnommu/sockios.h
--- linux-2.6.9/include/asm-armnommu/sockios.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/sockios.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/sockios.h>
diff -Naur linux-2.6.9/include/asm-armnommu/spinlock.h linux-2.6.9-uc0/include/asm-armnommu/spinlock.h
--- linux-2.6.9/include/asm-armnommu/spinlock.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/spinlock.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/spinlock.h>
diff -Naur linux-2.6.9/include/asm-armnommu/statfs.h linux-2.6.9-uc0/include/asm-armnommu/statfs.h
--- linux-2.6.9/include/asm-armnommu/statfs.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/statfs.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef _ASMARM_STATFS_H
+#define _ASMARM_STATFS_H
+
+#include <asm-generic/statfs.h>
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/stat.h linux-2.6.9-uc0/include/asm-armnommu/stat.h
--- linux-2.6.9/include/asm-armnommu/stat.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/stat.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/stat.h>
diff -Naur linux-2.6.9/include/asm-armnommu/string.h linux-2.6.9-uc0/include/asm-armnommu/string.h
--- linux-2.6.9/include/asm-armnommu/string.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/string.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/string.h>
diff -Naur linux-2.6.9/include/asm-armnommu/suspend.h linux-2.6.9-uc0/include/asm-armnommu/suspend.h
--- linux-2.6.9/include/asm-armnommu/suspend.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/suspend.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,4 @@
+#ifndef _ASMARMNOMMU_SUSPEND_H
+#define _ASMARMNOMMU_SUSPEND_H
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/system.h linux-2.6.9-uc0/include/asm-armnommu/system.h
--- linux-2.6.9/include/asm-armnommu/system.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/system.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,381 @@
+#ifndef __ASM_ARM_SYSTEM_H
+#define __ASM_ARM_SYSTEM_H
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+
+#define CPU_ARCH_UNKNOWN	0
+#define CPU_ARCH_ARMv3		1
+#define CPU_ARCH_ARMv4		2
+#define CPU_ARCH_ARMv4T		3
+#define CPU_ARCH_ARMv5		4
+#define CPU_ARCH_ARMv5T		5
+#define CPU_ARCH_ARMv5TE	6
+#define CPU_ARCH_ARMv5TEJ	7
+#define CPU_ARCH_ARMv6		8
+
+/*
+ * CR1 bits (CP#15 CR1)
+ */
+#define CR_M	(1 << 0)	/* MMU enable				*/
+#define CR_A	(1 << 1)	/* Alignment abort enable		*/
+#define CR_C	(1 << 2)	/* Dcache enable			*/
+#define CR_W	(1 << 3)	/* Write buffer enable			*/
+#define CR_P	(1 << 4)	/* 32-bit exception handler		*/
+#define CR_D	(1 << 5)	/* 32-bit data address range		*/
+#define CR_L	(1 << 6)	/* Implementation defined		*/
+#define CR_B	(1 << 7)	/* Big endian				*/
+#define CR_S	(1 << 8)	/* System MMU protection		*/
+#define CR_R	(1 << 9)	/* ROM MMU protection			*/
+#define CR_F	(1 << 10)	/* Implementation defined		*/
+#define CR_Z	(1 << 11)	/* Implementation defined		*/
+#define CR_I	(1 << 12)	/* Icache enable			*/
+#define CR_V	(1 << 13)	/* Vectors relocated to 0xffff0000	*/
+#define CR_RR	(1 << 14)	/* Round Robin cache replacement	*/
+#define CR_L4	(1 << 15)	/* LDR pc can set T bit			*/
+#define CR_DT	(1 << 16)
+#define CR_IT	(1 << 18)
+#define CR_ST	(1 << 19)
+#define CR_FI	(1 << 21)	/* Fast interrupt (lower latency mode)	*/
+#define CR_U	(1 << 22)	/* Unaligned access operation		*/
+#define CR_XP	(1 << 23)	/* Extended page tables			*/
+#define CR_VE	(1 << 24)	/* Vectored interrupts			*/
+
+/*
+ * This is used to ensure the compiler did actually allocate the register we
+ * asked it for some inline assembly sequences.  Apparently we can't trust
+ * the compiler from one version to another so a bit of paranoia won't hurt.
+ * This string is meant to be concatenated with the inline asm string and
+ * will cause compilation to stop on mismatch.
+ */
+#define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
+
+#ifndef __ASSEMBLY__
+
+#include <linux/kernel.h>
+
+struct thread_info;
+
+/* information about the system we're running on */
+extern unsigned int system_rev;
+extern unsigned int system_serial_low;
+extern unsigned int system_serial_high;
+extern unsigned int mem_fclk_21285;
+
+struct pt_regs;
+
+void die(const char *msg, struct pt_regs *regs, int err)
+		__attribute__((noreturn));
+
+void die_if_kernel(const char *str, struct pt_regs *regs, int err);
+
+void hook_fault_code(int nr, int (*fn)(unsigned long, unsigned int,
+				       struct pt_regs *),
+		     int sig, const char *name);
+
+#include <asm/proc-fns.h>
+
+#define xchg(ptr,x) \
+	((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+
+#define tas(ptr) (xchg((ptr),1))
+
+extern asmlinkage void __backtrace(void);
+
+extern int cpu_architecture(void);
+
+#define set_cr(x)					\
+	__asm__ __volatile__(				\
+	"mcr	p15, 0, %0, c1, c0, 0	@ set CR"	\
+	: : "r" (x) : "cc")
+
+#define get_cr()					\
+	({						\
+	unsigned int __val;				\
+	__asm__ __volatile__(				\
+	"mrc	p15, 0, %0, c1, c0, 0	@ get CR"	\
+	: "=r" (__val) : : "cc");			\
+	__val;						\
+	})
+
+extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
+extern unsigned long cr_alignment;	/* defined in entry-armv.S */
+
+#define UDBG_UNDEFINED	(1 << 0)
+#define UDBG_SYSCALL	(1 << 1)
+#define UDBG_BADABORT	(1 << 2)
+#define UDBG_SEGV	(1 << 3)
+#define UDBG_BUS	(1 << 4)
+
+extern unsigned int user_debug;
+
+
+#ifndef CONFIG_REMAP_VECTORS_TO_RAM
+  #if __LINUX_ARM_ARCH__ >= 4
+  #define vectors_base()	((cr_alignment & CR_V) ? 0xffff0000 : 0)
+  #else
+  #define vectors_base()	(0)
+  #endif
+#else /* remap_vectors_to_ram */
+  #define vectors_base()	(CONFIG_DRAM_BASE)
+#endif
+
+#define mb() __asm__ __volatile__ ("" : : : "memory")
+#define rmb() mb()
+#define wmb() mb()
+#define read_barrier_depends() do { } while(0)
+#define set_mb(var, value)  do { var = value; mb(); } while (0)
+#define set_wmb(var, value) do { var = value; wmb(); } while (0)
+#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");
+
+#ifdef CONFIG_SMP
+/*
+ * Define our own context switch locking.  This allows us to enable
+ * interrupts over the context switch, otherwise we end up with high
+ * interrupt latency.  The real problem area is switch_mm() which may
+ * do a full cache flush.
+ */
+#define prepare_arch_switch(rq,next)					\
+do {									\
+	spin_lock(&(next)->switch_lock);				\
+	spin_unlock_irq(&(rq)->lock);					\
+} while (0)
+
+#define finish_arch_switch(rq,prev)					\
+	spin_unlock(&(prev)->switch_lock)
+
+#define task_running(rq,p)						\
+	((rq)->curr == (p) || spin_is_locked(&(p)->switch_lock))
+#else
+/*
+ * Our UP-case is more simple, but we assume knowledge of how
+ * spin_unlock_irq() and friends are implemented.  This avoids
+ * us needlessly decrementing and incrementing the preempt count.
+ */
+#define prepare_arch_switch(rq,next)	local_irq_enable()
+#define finish_arch_switch(rq,prev)	spin_unlock(&(rq)->lock)
+#define task_running(rq,p)		((rq)->curr == (p))
+#endif
+
+/*
+ * switch_to(prev, next) should switch from task `prev' to `next'
+ * `prev' will never be the same as `next'.  schedule() itself
+ * contains the memory barrier to tell GCC not to cache `current'.
+ */
+struct thread_info;
+struct task_struct;
+extern struct task_struct *__switch_to(struct task_struct *, struct thread_info *, struct thread_info *);
+
+#define switch_to(prev,next,last)						\
+	do {									\
+		last = __switch_to(prev,prev->thread_info,next->thread_info);	\
+	} while (0)
+
+/*
+ * CPU interrupt mask handling.
+ */
+#if __LINUX_ARM_ARCH__ >= 6
+
+#define local_irq_save(x)					\
+	({							\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_save\n"	\
+	"cpsid	i"						\
+	: "=r" (x) : : "memory", "cc");				\
+	})
+
+#define local_irq_enable()  __asm__("cpsie i	@ __sti" : : : "memory", "cc")
+#define local_irq_disable() __asm__("cpsid i	@ __cli" : : : "memory", "cc")
+#define local_fiq_enable()  __asm__("cpsie f	@ __stf" : : : "memory", "cc")
+#define local_fiq_disable() __asm__("cpsid f	@ __clf" : : : "memory", "cc")
+
+#else
+
+/*
+ * Save the current interrupt enable state & disable IRQs
+ */
+#define local_irq_save(x)					\
+	({							\
+		unsigned long temp;				\
+		(void) (&temp == &x);				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_save\n"	\
+"	orr	%1, %0, #128\n"					\
+"	msr	cpsr_c, %1"					\
+	: "=r" (x), "=r" (temp)					\
+	:							\
+	: "memory", "cc");					\
+	})
+	
+/*
+ * Enable IRQs
+ */
+#define local_irq_enable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_enable\n"	\
+"	bic	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory", "cc");					\
+	})
+
+/*
+ * Disable IRQs
+ */
+#define local_irq_disable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_disable\n"	\
+"	orr	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory", "cc");					\
+	})
+
+/*
+ * Enable FIQs
+ */
+#define __stf()							\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ stf\n"		\
+"	bic	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory", "cc");					\
+	})
+
+/*
+ * Disable FIQs
+ */
+#define __clf()							\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ clf\n"		\
+"	orr	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory", "cc");					\
+	})
+
+#endif
+
+/*
+ * Save the current interrupt enable state.
+ */
+#define local_save_flags(x)					\
+	({							\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_save_flags"	\
+	: "=r" (x) : : "memory", "cc");				\
+	})
+
+/*
+ * restore saved IRQ & FIQ state
+ */
+#define local_irq_restore(x)					\
+	__asm__ __volatile__(					\
+	"msr	cpsr_c, %0		@ local_irq_restore\n"	\
+	:							\
+	: "r" (x)						\
+	: "memory", "cc")
+
+#ifdef CONFIG_SMP
+#error SMP not supported
+
+#define smp_mb()		mb()
+#define smp_rmb()		rmb()
+#define smp_wmb()		wmb()
+#define smp_read_barrier_depends()		read_barrier_depends()
+
+#else
+
+#define smp_mb()		barrier()
+#define smp_rmb()		barrier()
+#define smp_wmb()		barrier()
+#define smp_read_barrier_depends()		do { } while(0)
+
+#define clf()			__clf()
+#define stf()			__stf()
+
+#define irqs_disabled()			\
+({					\
+	unsigned long flags;		\
+	local_save_flags(flags);	\
+	flags & PSR_I_BIT;		\
+})
+
+#if defined(CONFIG_CPU_SA1100) || defined(CONFIG_CPU_SA110)
+/*
+ * On the StrongARM, "swp" is terminally broken since it bypasses the
+ * cache totally.  This means that the cache becomes inconsistent, and,
+ * since we use normal loads/stores as well, this is really bad.
+ * Typically, this causes oopsen in filp_close, but could have other,
+ * more disasterous effects.  There are two work-arounds:
+ *  1. Disable interrupts and emulate the atomic swap
+ *  2. Clean the cache, perform atomic swap, flush the cache
+ *
+ * We choose (1) since its the "easiest" to achieve here and is not
+ * dependent on the processor type.
+ */
+#define swp_is_buggy
+#endif
+
+static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
+{
+	extern void __bad_xchg(volatile void *, int);
+	unsigned long ret;
+#ifdef swp_is_buggy
+	unsigned long flags;
+#endif
+
+	switch (size) {
+#ifdef swp_is_buggy
+		case 1:
+			local_irq_save(flags);
+			ret = *(volatile unsigned char *)ptr;
+			*(volatile unsigned char *)ptr = x;
+			local_irq_restore(flags);
+			break;
+
+		case 4:
+			local_irq_save(flags);
+			ret = *(volatile unsigned long *)ptr;
+			*(volatile unsigned long *)ptr = x;
+			local_irq_restore(flags);
+			break;
+#else
+		case 1:	__asm__ __volatile__ ("swpb %0, %1, [%2]"
+					: "=&r" (ret)
+					: "r" (x), "r" (ptr)
+					: "memory", "cc");
+			break;
+		case 4:	__asm__ __volatile__ ("swp %0, %1, [%2]"
+					: "=&r" (ret)
+					: "r" (x), "r" (ptr)
+					: "memory", "cc");
+			break;
+#endif
+		default: __bad_xchg(ptr, size), ret = 0;
+	}
+
+	return ret;
+}
+
+#endif /* CONFIG_SMP */
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/termbits.h linux-2.6.9-uc0/include/asm-armnommu/termbits.h
--- linux-2.6.9/include/asm-armnommu/termbits.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/termbits.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/termbits.h>
diff -Naur linux-2.6.9/include/asm-armnommu/termios.h linux-2.6.9-uc0/include/asm-armnommu/termios.h
--- linux-2.6.9/include/asm-armnommu/termios.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/termios.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/termios.h>
diff -Naur linux-2.6.9/include/asm-armnommu/therm.h linux-2.6.9-uc0/include/asm-armnommu/therm.h
--- linux-2.6.9/include/asm-armnommu/therm.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/therm.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/therm.h>
diff -Naur linux-2.6.9/include/asm-armnommu/thread_info.h linux-2.6.9-uc0/include/asm-armnommu/thread_info.h
--- linux-2.6.9/include/asm-armnommu/thread_info.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/thread_info.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,148 @@
+/*
+ *  linux/include/asm-armnommu/thread_info.h
+ *
+ *  Copyright (C) 2002 Russell King.
+ *  modified by Hyok S. Choi, 2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_THREAD_INFO_H
+#define __ASM_ARM_THREAD_INFO_H
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+
+struct task_struct;
+struct exec_domain;
+
+#include <asm/fpstate.h>
+#include <asm/ptrace.h>
+#include <asm/types.h>
+#include <asm/domain.h>
+
+typedef unsigned long mm_segment_t;
+
+struct cpu_context_save {
+	__u32	r4;
+	__u32	r5;
+	__u32	r6;
+	__u32	r7;
+	__u32	r8;
+	__u32	r9;
+	__u32	sl;
+	__u32	fp;
+	__u32	sp;
+	__u32	pc;
+	__u32	extra[2];		/* Xscale 'acc' register, etc */
+};
+
+/*
+ * low level task data that entry.S needs immediate access to.
+ * We assume cpu_context follows immedately after cpu_domain.
+ */
+struct thread_info {
+	unsigned long		flags;		/* low level flags */
+	__s32			preempt_count;	/* 0 => preemptable, <0 => bug */
+	mm_segment_t		addr_limit;	/* address limit */
+	struct task_struct	*task;		/* main task structure */
+	struct exec_domain	*exec_domain;	/* execution domain */
+	__u32			cpu;		/* cpu */
+	__u32			cpu_domain;	/* cpu domain */
+	struct cpu_context_save	cpu_context;	/* cpu context */
+	__u8			used_cp[16];	/* thread used copro */
+	union fp_state		fpstate;
+	struct restart_block    restart_block;
+};
+
+#define INIT_THREAD_INFO(tsk)						\
+{									\
+	.task		= &tsk,						\
+	.exec_domain	= &default_exec_domain,				\
+	.flags		= 0,						\
+	.preempt_count	= 1,						\
+	.addr_limit	= KERNEL_DS,					\
+	.cpu_domain	= domain_val(DOMAIN_USER, DOMAIN_MANAGER) |	\
+			  domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) |	\
+			  domain_val(DOMAIN_IO, DOMAIN_CLIENT),		\
+	.restart_block	= {						\
+		.fn	= do_no_restart_syscall,			\
+	},								\
+}
+
+#define init_thread_info	(init_thread_union.thread_info)
+#define init_stack		(init_thread_union.stack)
+
+/*
+ * how to get the thread information struct from C
+ */
+static inline struct thread_info *current_thread_info(void) __attribute_const__;
+
+static inline struct thread_info *current_thread_info(void)
+{
+	register unsigned long sp asm ("sp");
+	return (struct thread_info *)(sp & ~0x1fff);
+}
+
+#define THREAD_SIZE		(8192)
+
+extern struct thread_info *alloc_thread_info(struct task_struct *task);
+extern void free_thread_info(struct thread_info *);
+
+#define get_thread_info(ti)	get_task_struct((ti)->task)
+#define put_thread_info(ti)	put_task_struct((ti)->task)
+
+#define thread_saved_pc(tsk)	\
+	((unsigned long)(pc_pointer((tsk)->thread_info->cpu_context.pc)))
+#define thread_saved_fp(tsk)	\
+	((unsigned long)((tsk)->thread_info->cpu_context.fp))
+
+#else /* !__ASSEMBLY__ */
+
+#define TI_FLAGS	0
+#define TI_PREEMPT	4
+#define TI_ADDR_LIMIT	8
+#define TI_TASK		12
+#define TI_EXEC_DOMAIN	16
+#define TI_CPU		20
+#define TI_CPU_DOMAIN	24
+#define TI_CPU_SAVE	28
+#define TI_USED_MATH	76
+#define TI_FPSTATE	(TI_USED_MATH+16)
+
+#endif
+
+#define PREEMPT_ACTIVE	0x04000000
+
+/*
+ * thread information flags:
+ *  TIF_SYSCALL_TRACE	- syscall trace active
+ *  TIF_NOTIFY_RESUME	- resumption notification requested
+ *  TIF_SIGPENDING	- signal pending
+ *  TIF_NEED_RESCHED	- rescheduling necessary
+ *  TIF_USEDFPU		- FPU was used by this task this quantum (SMP)
+ *  TIF_POLLING_NRFLAG	- true if poll_idle() is polling TIF_NEED_RESCHED
+ */
+#define TIF_NOTIFY_RESUME	0
+#define TIF_SIGPENDING		1
+#define TIF_NEED_RESCHED	2
+#define TIF_SYSCALL_TRACE	8
+#define TIF_USED_FPU		16
+#define TIF_POLLING_NRFLAG	17
+
+#define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
+#define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
+#define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
+#define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
+#define _TIF_USED_FPU		(1 << TIF_USED_FPU)
+#define _TIF_POLLING_NRFLAG	(1 << TIF_POLLING_NRFLAG)
+
+/*
+ * Change these and you break ASM code in entry-common.S
+ */
+#define _TIF_WORK_MASK		0x000000ff
+
+#endif /* __KERNEL__ */
+#endif /* __ASM_ARM_THREAD_INFO_H */
diff -Naur linux-2.6.9/include/asm-armnommu/timex.h linux-2.6.9-uc0/include/asm-armnommu/timex.h
--- linux-2.6.9/include/asm-armnommu/timex.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/timex.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/timex.h>
diff -Naur linux-2.6.9/include/asm-armnommu/tlbflush.h linux-2.6.9-uc0/include/asm-armnommu/tlbflush.h
--- linux-2.6.9/include/asm-armnommu/tlbflush.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/tlbflush.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,15 @@
+/*
+ *  linux/include/asm-arm/tlbflush.h
+ *
+ *  Modified for uClinux by Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_TLBFLUSH_H
+#define _ASMARM_TLBFLUSH_H
+
+#define tlb_flush(tlb)	((void)0)
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/tlb.h linux-2.6.9-uc0/include/asm-armnommu/tlb.h
--- linux-2.6.9/include/asm-armnommu/tlb.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/tlb.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-armnommu/tlb.h
+ *
+ *  Modified for uClinux by Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __ASMARM_TLB_H
+#define __ASMARM_TLB_H
+
+#include <asm/tlbflush.h>
+#include <linux/pagemap.h>
+#include <asm-generic/tlb.h>
+
+#endif
diff -Naur linux-2.6.9/include/asm-armnommu/topology.h linux-2.6.9-uc0/include/asm-armnommu/topology.h
--- linux-2.6.9/include/asm-armnommu/topology.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/topology.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,6 @@
+#ifndef _ASM_ARM_TOPOLOGY_H
+#define _ASM_ARM_TOPOLOGY_H
+
+#include <asm-generic/topology.h>
+
+#endif /* _ASM_ARM_TOPOLOGY_H */
diff -Naur linux-2.6.9/include/asm-armnommu/traps.h linux-2.6.9-uc0/include/asm-armnommu/traps.h
--- linux-2.6.9/include/asm-armnommu/traps.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/traps.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/traps.h>
diff -Naur linux-2.6.9/include/asm-armnommu/types.h linux-2.6.9-uc0/include/asm-armnommu/types.h
--- linux-2.6.9/include/asm-armnommu/types.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/types.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/types.h>
diff -Naur linux-2.6.9/include/asm-armnommu/uaccess.h linux-2.6.9-uc0/include/asm-armnommu/uaccess.h
--- linux-2.6.9/include/asm-armnommu/uaccess.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/uaccess.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,422 @@
+/*
+ *  linux/include/asm-armnommu/uaccess.h
+ *
+ *  Copyright (C) 1997-1999 Russell King
+ *  Copyright (C) 2003 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARMNOMMU_UACCESS_H
+#define _ASMARMNOMMU_UACCESS_H
+
+/*
+ * User space memory access functions
+ */
+#include <linux/sched.h>
+#include <asm/errno.h>
+#include <asm/arch/memory.h>
+#include <asm/domain.h>
+#include <asm/system.h>
+
+#define VERIFY_READ 0
+#define VERIFY_WRITE 1
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+
+struct exception_table_entry
+{
+	unsigned long insn, fixup;
+};
+
+extern int fixup_exception(struct pt_regs *regs);
+
+/*
+ * Note that this is actually 0x1,0000,0000
+ */
+#define KERNEL_DS	0x00000000
+/* uClinux has only one addr space. */
+#define USER_DS		PAGE_OFFSET
+
+#define get_ds()	(KERNEL_DS)
+#define get_fs()	(USER_DS)	/* uClinux has only one addr space. */
+
+static inline void set_fs (mm_segment_t fs)
+{ /* nothing to do here for uClinux */
+}
+
+#define segment_eq(a,b)	((a) == (b))
+
+/*
+ * assuming __range_ok & __addr_ok always succeed.
+ */
+#define __addr_ok(addr) 			1
+#define __range_ok(addr,size) 	0
+
+#define access_ok(type,addr,size)	(__range_ok(addr,size) == 0)
+
+static inline int verify_area(int type, const void * addr, unsigned long size)
+{
+	return access_ok(type, addr, size) ? 0 : -EFAULT;
+}
+
+/*
+ * Single-value transfer routines.  They automatically use the right
+ * size if we just have the right pointer type.  Note that the functions
+ * which read from user space (*get_*) need to take care not to leak
+ * kernel data even if the calling code is buggy and fails to check
+ * the return value.  This means zeroing out the destination variable
+ * or buffer on error.  Normally this is done out of line by the
+ * fixup code, but there are a few places where it intrudes on the
+ * main code path.  When we only write to user space, there is no
+ * problem.
+ *
+ * The "__xxx" versions of the user access functions do not verify the
+ * address space - it must have been done previously with a separate
+ * "access_ok()" call.
+ *
+ * The "xxx_error" versions set the third argument to EFAULT if an
+ * error occurs, and leave it unchanged on success.  Note that these
+ * versions are void (ie, don't return a value as such).
+ */
+
+extern int __get_user_1(void *);
+extern int __get_user_2(void *);
+extern int __get_user_4(void *);
+extern int __get_user_8(void *);
+extern int __get_user_bad(void);
+
+#define __get_user_x(__r1,__p,__e,__s,__i...)				\
+	   __asm__ __volatile__ (					\
+		__asmeq("%0", "r0") __asmeq("%1", "r1")			\
+		"bl	__get_user_" #__s				\
+		: "=&r" (__e), "=r" (__r1)				\
+		: "0" (__p)						\
+		: __i, "cc")
+
+#define get_user(x,p)							\
+	({								\
+		const register typeof(*(p)) *__p asm("r0") = (p);	\
+		register typeof(*(p)) __r1 asm("r1");			\
+		register int __e asm("r0");				\
+		switch (sizeof(*(__p))) {				\
+		case 1:							\
+			__get_user_x(__r1, __p, __e, 1, "lr");		\
+	       		break;						\
+		case 2:							\
+			__get_user_x(__r1, __p, __e, 2, "r2", "lr");	\
+			break;						\
+		case 4:							\
+	       		__get_user_x(__r1, __p, __e, 4, "lr");		\
+			break;						\
+		case 8:							\
+			__get_user_x(__r1, __p, __e, 8, "lr");		\
+	       		break;						\
+		default: __e = __get_user_bad(); break;			\
+		}							\
+		x = __r1;						\
+		__e;							\
+	})
+
+#define __get_user(x,ptr)						\
+({									\
+	long __gu_err = 0;						\
+	__get_user_err((x),(ptr),__gu_err);				\
+	__gu_err;							\
+})
+
+#define __get_user_error(x,ptr,err)					\
+({									\
+	__get_user_err((x),(ptr),err);					\
+	(void) 0;							\
+})
+
+#define __get_user_err(x,ptr,err)					\
+do {									\
+	unsigned long __gu_addr = (unsigned long)(ptr);			\
+	unsigned long __gu_val;						\
+	switch (sizeof(*(ptr))) {					\
+	case 1:	__get_user_asm_byte(__gu_val,__gu_addr,err);	break;	\
+	case 2:	__get_user_asm_half(__gu_val,__gu_addr,err);	break;	\
+	case 4:	__get_user_asm_word(__gu_val,__gu_addr,err);	break;	\
+	default: (__gu_val) = __get_user_bad();				\
+	}								\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
+} while (0)
+
+#define __get_user_asm_byte(x,addr,err)				\
+	__asm__ __volatile__(					\
+	"1:	ldrbt	%1,[%2],#0\n"				\
+	"2:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"3:	mov	%0, %3\n"				\
+	"	mov	%1, #0\n"				\
+	"	b	2b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 3b\n"				\
+	"	.previous"					\
+	: "+r" (err), "=&r" (x)					\
+	: "r" (addr), "i" (-EFAULT)				\
+	: "cc")
+
+#ifndef __ARMEB__
+#define __get_user_asm_half(x,__gu_addr,err)			\
+({								\
+	unsigned long __b1, __b2;				\
+	__get_user_asm_byte(__b1, __gu_addr, err);		\
+	__get_user_asm_byte(__b2, __gu_addr + 1, err);		\
+	(x) = __b1 | (__b2 << 8);				\
+})
+#else
+#define __get_user_asm_half(x,__gu_addr,err)			\
+({								\
+	unsigned long __b1, __b2;				\
+	__get_user_asm_byte(__b1, __gu_addr, err);		\
+	__get_user_asm_byte(__b2, __gu_addr + 1, err);		\
+	(x) = (__b1 << 8) | __b2;				\
+})
+#endif
+
+#define __get_user_asm_word(x,addr,err)				\
+	__asm__ __volatile__(					\
+	"1:	ldrt	%1,[%2],#0\n"				\
+	"2:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"3:	mov	%0, %3\n"				\
+	"	mov	%1, #0\n"				\
+	"	b	2b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 3b\n"				\
+	"	.previous"					\
+	: "+r" (err), "=&r" (x)					\
+	: "r" (addr), "i" (-EFAULT)				\
+	: "cc")
+
+extern int __put_user_1(void *, unsigned int);
+extern int __put_user_2(void *, unsigned int);
+extern int __put_user_4(void *, unsigned int);
+extern int __put_user_8(void *, unsigned long long);
+extern int __put_user_bad(void);
+
+#define __put_user_x(__r1,__p,__e,__s)					\
+	   __asm__ __volatile__ (					\
+		__asmeq("%0", "r0") __asmeq("%2", "r1")			\
+		"bl	__put_user_" #__s				\
+		: "=&r" (__e)						\
+		: "0" (__p), "r" (__r1)					\
+		: "ip", "lr", "cc")
+
+#define put_user(x,p)							\
+	({								\
+		const register typeof(*(p)) __r1 asm("r1") = (x);	\
+		const register typeof(*(p)) *__p asm("r0") = (p);	\
+		register int __e asm("r0");				\
+		switch (sizeof(*(__p))) {				\
+		case 1:							\
+			__put_user_x(__r1, __p, __e, 1);		\
+			break;						\
+		case 2:							\
+			__put_user_x(__r1, __p, __e, 2);		\
+			break;						\
+		case 4:							\
+			__put_user_x(__r1, __p, __e, 4);		\
+			break;						\
+		case 8:							\
+			__put_user_x(__r1, __p, __e, 8);		\
+			break;						\
+		default: __e = __put_user_bad(); break;			\
+		}							\
+		__e;							\
+	})
+
+#define __put_user(x,ptr)						\
+({									\
+	long __pu_err = 0;						\
+	__put_user_err((x),(ptr),__pu_err);				\
+	__pu_err;							\
+})
+
+#define __put_user_error(x,ptr,err)					\
+({									\
+	__put_user_err((x),(ptr),err);					\
+	(void) 0;							\
+})
+
+#define __put_user_err(x,ptr,err)					\
+do {									\
+	unsigned long __pu_addr = (unsigned long)(ptr);			\
+	__typeof__(*(ptr)) __pu_val = (x);				\
+	switch (sizeof(*(ptr))) {					\
+	case 1: __put_user_asm_byte(__pu_val,__pu_addr,err);	break;	\
+	case 2: __put_user_asm_half(__pu_val,__pu_addr,err);	break;	\
+	case 4: __put_user_asm_word(__pu_val,__pu_addr,err);	break;	\
+	case 8:	__put_user_asm_dword(__pu_val,__pu_addr,err);	break;	\
+	default: __put_user_bad();					\
+	}								\
+} while (0)
+
+#define __put_user_asm_byte(x,__pu_addr,err)			\
+	__asm__ __volatile__(					\
+	"1:	strbt	%1,[%2],#0\n"				\
+	"2:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"3:	mov	%0, %3\n"				\
+	"	b	2b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 3b\n"				\
+	"	.previous"					\
+	: "+r" (err)						\
+	: "r" (x), "r" (__pu_addr), "i" (-EFAULT)		\
+	: "cc")
+
+#ifndef __ARMEB__
+#define __put_user_asm_half(x,__pu_addr,err)			\
+({								\
+	unsigned long __temp = (unsigned long)(x);		\
+	__put_user_asm_byte(__temp, __pu_addr, err);		\
+	__put_user_asm_byte(__temp >> 8, __pu_addr + 1, err);	\
+})
+#else
+#define __put_user_asm_half(x,__pu_addr,err)			\
+({								\
+	unsigned long __temp = (unsigned long)(x);		\
+	__put_user_asm_byte(__temp >> 8, __pu_addr, err);	\
+	__put_user_asm_byte(__temp, __pu_addr + 1, err);	\
+})
+#endif
+
+#define __put_user_asm_word(x,__pu_addr,err)			\
+	__asm__ __volatile__(					\
+	"1:	strt	%1,[%2],#0\n"				\
+	"2:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"3:	mov	%0, %3\n"				\
+	"	b	2b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 3b\n"				\
+	"	.previous"					\
+	: "+r" (err)						\
+	: "r" (x), "r" (__pu_addr), "i" (-EFAULT)		\
+	: "cc")
+
+#ifndef __ARMEB__
+#define	__reg_oper0	"%R2"
+#define	__reg_oper1	"%Q2"
+#else
+#define	__reg_oper0	"%Q2"
+#define	__reg_oper1	"%R2"
+#endif
+
+#define __put_user_asm_dword(x,__pu_addr,err)			\
+	__asm__ __volatile__(					\
+	"1:	strt	" __reg_oper1 ", [%1], #4\n"		\
+	"2:	strt	" __reg_oper0 ", [%1], #0\n"		\
+	"3:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"4:	mov	%0, %3\n"				\
+	"	b	3b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 4b\n"				\
+	"	.long	2b, 4b\n"				\
+	"	.previous"					\
+	: "+r" (err), "+r" (__pu_addr)				\
+	: "r" (x), "i" (-EFAULT)				\
+	: "cc")
+
+extern unsigned long __arch_copy_from_user(void *to, const void __user *from, unsigned long n);
+extern unsigned long __arch_copy_to_user(void __user *to, const void *from, unsigned long n);
+extern unsigned long __arch_clear_user(void __user *addr, unsigned long n);
+extern unsigned long __arch_strncpy_from_user(char *to, const char __user *from, unsigned long count);
+extern unsigned long __arch_strnlen_user(const char __user *s, long n);
+
+static inline unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	if (access_ok(VERIFY_READ, from, n))
+		n = __arch_copy_from_user(to, from, n);
+	else /* security hole - plug it */
+		memzero(to, n);
+	return n;
+}
+
+static inline unsigned long __copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	return __arch_copy_from_user(to, from, n);
+}
+
+static inline unsigned long copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __arch_copy_to_user(to, from, n);
+	return n;
+}
+
+static inline unsigned long __copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	return __arch_copy_to_user(to, from, n);
+}
+
+static inline unsigned long clear_user (void __user *to, unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __arch_clear_user(to, n);
+	return n;
+}
+
+static inline unsigned long __clear_user (void __user *to, unsigned long n)
+{
+	return __arch_clear_user(to, n);
+}
+
+static inline long strncpy_from_user (char *dst, const char __user *src, long count)
+{
+	long res = -EFAULT;
+	if (access_ok(VERIFY_READ, src, 1))
+		res = __arch_strncpy_from_user(dst, src, count);
+	return res;
+}
+
+static inline long __strncpy_from_user (char *dst, const char __user *src, long count)
+{
+	return __arch_strncpy_from_user(dst, src, count);
+}
+
+#define strlen_user(s)	strnlen_user(s, ~0UL >> 1)
+
+static inline long strnlen_user(const char __user *s, long n)
+{
+	unsigned long res = 0;
+
+	if (__addr_ok(s))
+		res = __arch_strnlen_user(s, n);
+
+	return res;
+}
+
+#endif /* _ASMARMNOMMU_UACCESS_H */
diff -Naur linux-2.6.9/include/asm-armnommu/ucontext.h linux-2.6.9-uc0/include/asm-armnommu/ucontext.h
--- linux-2.6.9/include/asm-armnommu/ucontext.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/ucontext.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/ucontext.h>
diff -Naur linux-2.6.9/include/asm-armnommu/unaligned.h linux-2.6.9-uc0/include/asm-armnommu/unaligned.h
--- linux-2.6.9/include/asm-armnommu/unaligned.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/unaligned.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/unaligned.h>
diff -Naur linux-2.6.9/include/asm-armnommu/unistd.h linux-2.6.9-uc0/include/asm-armnommu/unistd.h
--- linux-2.6.9/include/asm-armnommu/unistd.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/unistd.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1,550 @@
+/*
+ *  linux/include/asm-armnommu/unistd.h
+ *
+ *  Copyright (C) 2001-2003 Russell King
+ *  Modified by Hyok S. Choi, 2004, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This is to be revisited for compatible issues with uClibc and etc.
+ */
+#ifndef __ASM_ARM_UNISTD_H
+#define __ASM_ARM_UNISTD_H
+
+#include <linux/linkage.h>
+
+#if defined(__thumb__)
+#define __NR_SYSCALL_BASE	0
+#else
+#define __NR_SYSCALL_BASE	0x900000
+#endif
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_restart_syscall		(__NR_SYSCALL_BASE+  0)
+#define __NR_exit			(__NR_SYSCALL_BASE+  1)
+#define __NR_fork			(__NR_SYSCALL_BASE+  2)
+#define __NR_read			(__NR_SYSCALL_BASE+  3)
+#define __NR_write			(__NR_SYSCALL_BASE+  4)
+#define __NR_open			(__NR_SYSCALL_BASE+  5)
+#define __NR_close			(__NR_SYSCALL_BASE+  6)
+					/* 7 was sys_waitpid */
+#define __NR_creat			(__NR_SYSCALL_BASE+  8)
+#define __NR_link			(__NR_SYSCALL_BASE+  9)
+#define __NR_unlink			(__NR_SYSCALL_BASE+ 10)
+#define __NR_execve			(__NR_SYSCALL_BASE+ 11)
+#define __NR_chdir			(__NR_SYSCALL_BASE+ 12)
+#define __NR_time			(__NR_SYSCALL_BASE+ 13)
+#define __NR_mknod			(__NR_SYSCALL_BASE+ 14)
+#define __NR_chmod			(__NR_SYSCALL_BASE+ 15)
+#define __NR_lchown			(__NR_SYSCALL_BASE+ 16)
+					/* 17 was sys_break */
+					/* 18 was sys_stat */
+#define __NR_lseek			(__NR_SYSCALL_BASE+ 19)
+#define __NR_getpid			(__NR_SYSCALL_BASE+ 20)
+#define __NR_mount			(__NR_SYSCALL_BASE+ 21)
+#define __NR_umount			(__NR_SYSCALL_BASE+ 22)
+#define __NR_setuid			(__NR_SYSCALL_BASE+ 23)
+#define __NR_getuid			(__NR_SYSCALL_BASE+ 24)
+#define __NR_stime			(__NR_SYSCALL_BASE+ 25)
+#define __NR_ptrace			(__NR_SYSCALL_BASE+ 26)
+#define __NR_alarm			(__NR_SYSCALL_BASE+ 27)
+					/* 28 was sys_fstat */
+#define __NR_pause			(__NR_SYSCALL_BASE+ 29)
+#define __NR_utime			(__NR_SYSCALL_BASE+ 30)
+					/* 31 was sys_stty */
+					/* 32 was sys_gtty */
+#define __NR_access			(__NR_SYSCALL_BASE+ 33)
+#define __NR_nice			(__NR_SYSCALL_BASE+ 34)
+					/* 35 was sys_ftime */
+#define __NR_sync			(__NR_SYSCALL_BASE+ 36)
+#define __NR_kill			(__NR_SYSCALL_BASE+ 37)
+#define __NR_rename			(__NR_SYSCALL_BASE+ 38)
+#define __NR_mkdir			(__NR_SYSCALL_BASE+ 39)
+#define __NR_rmdir			(__NR_SYSCALL_BASE+ 40)
+#define __NR_dup			(__NR_SYSCALL_BASE+ 41)
+#define __NR_pipe			(__NR_SYSCALL_BASE+ 42)
+#define __NR_times			(__NR_SYSCALL_BASE+ 43)
+					/* 44 was sys_prof */
+#define __NR_brk			(__NR_SYSCALL_BASE+ 45)
+#define __NR_setgid			(__NR_SYSCALL_BASE+ 46)
+#define __NR_getgid			(__NR_SYSCALL_BASE+ 47)
+					/* 48 was sys_signal */
+#define __NR_geteuid			(__NR_SYSCALL_BASE+ 49)
+#define __NR_getegid			(__NR_SYSCALL_BASE+ 50)
+#define __NR_acct			(__NR_SYSCALL_BASE+ 51)
+#define __NR_umount2			(__NR_SYSCALL_BASE+ 52)
+					/* 53 was sys_lock */
+#define __NR_ioctl			(__NR_SYSCALL_BASE+ 54)
+#define __NR_fcntl			(__NR_SYSCALL_BASE+ 55)
+					/* 56 was sys_mpx */
+#define __NR_setpgid			(__NR_SYSCALL_BASE+ 57)
+					/* 58 was sys_ulimit */
+					/* 59 was sys_olduname */
+#define __NR_umask			(__NR_SYSCALL_BASE+ 60)
+#define __NR_chroot			(__NR_SYSCALL_BASE+ 61)
+#define __NR_ustat			(__NR_SYSCALL_BASE+ 62)
+#define __NR_dup2			(__NR_SYSCALL_BASE+ 63)
+#define __NR_getppid			(__NR_SYSCALL_BASE+ 64)
+#define __NR_getpgrp			(__NR_SYSCALL_BASE+ 65)
+#define __NR_setsid			(__NR_SYSCALL_BASE+ 66)
+#define __NR_sigaction			(__NR_SYSCALL_BASE+ 67)
+					/* 68 was sys_sgetmask */
+					/* 69 was sys_ssetmask */
+#define __NR_setreuid			(__NR_SYSCALL_BASE+ 70)
+#define __NR_setregid			(__NR_SYSCALL_BASE+ 71)
+#define __NR_sigsuspend			(__NR_SYSCALL_BASE+ 72)
+#define __NR_sigpending			(__NR_SYSCALL_BASE+ 73)
+#define __NR_sethostname		(__NR_SYSCALL_BASE+ 74)
+#define __NR_setrlimit			(__NR_SYSCALL_BASE+ 75)
+#define __NR_getrlimit			(__NR_SYSCALL_BASE+ 76)	/* Back compat 2GB limited rlimit */
+#define __NR_getrusage			(__NR_SYSCALL_BASE+ 77)
+#define __NR_gettimeofday		(__NR_SYSCALL_BASE+ 78)
+#define __NR_settimeofday		(__NR_SYSCALL_BASE+ 79)
+#define __NR_getgroups			(__NR_SYSCALL_BASE+ 80)
+#define __NR_setgroups			(__NR_SYSCALL_BASE+ 81)
+#define __NR_select			(__NR_SYSCALL_BASE+ 82)
+#define __NR_symlink			(__NR_SYSCALL_BASE+ 83)
+					/* 84 was sys_lstat */
+#define __NR_readlink			(__NR_SYSCALL_BASE+ 85)
+#define __NR_uselib			(__NR_SYSCALL_BASE+ 86)
+#define __NR_swapon			(__NR_SYSCALL_BASE+ 87)
+#define __NR_reboot			(__NR_SYSCALL_BASE+ 88)
+#define __NR_readdir			(__NR_SYSCALL_BASE+ 89)
+#define __NR_mmap			(__NR_SYSCALL_BASE+ 90)
+#define __NR_munmap			(__NR_SYSCALL_BASE+ 91)
+#define __NR_truncate			(__NR_SYSCALL_BASE+ 92)
+#define __NR_ftruncate			(__NR_SYSCALL_BASE+ 93)
+#define __NR_fchmod			(__NR_SYSCALL_BASE+ 94)
+#define __NR_fchown			(__NR_SYSCALL_BASE+ 95)
+#define __NR_getpriority		(__NR_SYSCALL_BASE+ 96)
+#define __NR_setpriority		(__NR_SYSCALL_BASE+ 97)
+					/* 98 was sys_profil */
+#define __NR_statfs			(__NR_SYSCALL_BASE+ 99)
+#define __NR_fstatfs			(__NR_SYSCALL_BASE+100)
+					/* 101 was sys_ioperm */
+#define __NR_socketcall			(__NR_SYSCALL_BASE+102)
+#define __NR_syslog			(__NR_SYSCALL_BASE+103)
+#define __NR_setitimer			(__NR_SYSCALL_BASE+104)
+#define __NR_getitimer			(__NR_SYSCALL_BASE+105)
+#define __NR_stat			(__NR_SYSCALL_BASE+106)
+#define __NR_lstat			(__NR_SYSCALL_BASE+107)
+#define __NR_fstat			(__NR_SYSCALL_BASE+108)
+					/* 109 was sys_uname */
+					/* 110 was sys_iopl */
+#define __NR_vhangup			(__NR_SYSCALL_BASE+111)
+					/* 112 was sys_idle */
+#define __NR_syscall			(__NR_SYSCALL_BASE+113) /* syscall to call a syscall! */
+#define __NR_wait4			(__NR_SYSCALL_BASE+114)
+#define __NR_swapoff			(__NR_SYSCALL_BASE+115)
+#define __NR_sysinfo			(__NR_SYSCALL_BASE+116)
+#define __NR_ipc			(__NR_SYSCALL_BASE+117)
+#define __NR_fsync			(__NR_SYSCALL_BASE+118)
+#define __NR_sigreturn			(__NR_SYSCALL_BASE+119)
+#define __NR_clone			(__NR_SYSCALL_BASE+120)
+#define __NR_setdomainname		(__NR_SYSCALL_BASE+121)
+#define __NR_uname			(__NR_SYSCALL_BASE+122)
+					/* 123 was sys_modify_ldt */
+#define __NR_adjtimex			(__NR_SYSCALL_BASE+124)
+#define __NR_mprotect			(__NR_SYSCALL_BASE+125)
+#define __NR_sigprocmask		(__NR_SYSCALL_BASE+126)
+#define __NR_create_module		(__NR_SYSCALL_BASE+127)
+#define __NR_init_module		(__NR_SYSCALL_BASE+128)
+#define __NR_delete_module		(__NR_SYSCALL_BASE+129)
+#define __NR_get_kernel_syms		(__NR_SYSCALL_BASE+130)
+#define __NR_quotactl			(__NR_SYSCALL_BASE+131)
+#define __NR_getpgid			(__NR_SYSCALL_BASE+132)
+#define __NR_fchdir			(__NR_SYSCALL_BASE+133)
+#define __NR_bdflush			(__NR_SYSCALL_BASE+134)
+#define __NR_sysfs			(__NR_SYSCALL_BASE+135)
+#define __NR_personality		(__NR_SYSCALL_BASE+136)
+					/* 137 was sys_afs_syscall */
+#define __NR_setfsuid			(__NR_SYSCALL_BASE+138)
+#define __NR_setfsgid			(__NR_SYSCALL_BASE+139)
+#define __NR__llseek			(__NR_SYSCALL_BASE+140)
+#define __NR_getdents			(__NR_SYSCALL_BASE+141)
+#define __NR__newselect			(__NR_SYSCALL_BASE+142)
+#define __NR_flock			(__NR_SYSCALL_BASE+143)
+#define __NR_msync			(__NR_SYSCALL_BASE+144)
+#define __NR_readv			(__NR_SYSCALL_BASE+145)
+#define __NR_writev			(__NR_SYSCALL_BASE+146)
+#define __NR_getsid			(__NR_SYSCALL_BASE+147)
+#define __NR_fdatasync			(__NR_SYSCALL_BASE+148)
+#define __NR__sysctl			(__NR_SYSCALL_BASE+149)
+#define __NR_mlock			(__NR_SYSCALL_BASE+150)
+#define __NR_munlock			(__NR_SYSCALL_BASE+151)
+#define __NR_mlockall			(__NR_SYSCALL_BASE+152)
+#define __NR_munlockall			(__NR_SYSCALL_BASE+153)
+#define __NR_sched_setparam		(__NR_SYSCALL_BASE+154)
+#define __NR_sched_getparam		(__NR_SYSCALL_BASE+155)
+#define __NR_sched_setscheduler		(__NR_SYSCALL_BASE+156)
+#define __NR_sched_getscheduler		(__NR_SYSCALL_BASE+157)
+#define __NR_sched_yield		(__NR_SYSCALL_BASE+158)
+#define __NR_sched_get_priority_max	(__NR_SYSCALL_BASE+159)
+#define __NR_sched_get_priority_min	(__NR_SYSCALL_BASE+160)
+#define __NR_sched_rr_get_interval	(__NR_SYSCALL_BASE+161)
+#define __NR_nanosleep			(__NR_SYSCALL_BASE+162)
+#define __NR_mremap			(__NR_SYSCALL_BASE+163)
+#define __NR_setresuid			(__NR_SYSCALL_BASE+164)
+#define __NR_getresuid			(__NR_SYSCALL_BASE+165)
+					/* 166 was sys_vm86 */
+					/* 167 was sys_query_module */
+#define __NR_poll			(__NR_SYSCALL_BASE+168)
+#define __NR_nfsservctl			(__NR_SYSCALL_BASE+169)
+#define __NR_setresgid			(__NR_SYSCALL_BASE+170)
+#define __NR_getresgid			(__NR_SYSCALL_BASE+171)
+#define __NR_prctl			(__NR_SYSCALL_BASE+172)
+#define __NR_rt_sigreturn		(__NR_SYSCALL_BASE+173)
+#define __NR_rt_sigaction		(__NR_SYSCALL_BASE+174)
+#define __NR_rt_sigprocmask		(__NR_SYSCALL_BASE+175)
+#define __NR_rt_sigpending		(__NR_SYSCALL_BASE+176)
+#define __NR_rt_sigtimedwait		(__NR_SYSCALL_BASE+177)
+#define __NR_rt_sigqueueinfo		(__NR_SYSCALL_BASE+178)
+#define __NR_rt_sigsuspend		(__NR_SYSCALL_BASE+179)
+#define __NR_pread64			(__NR_SYSCALL_BASE+180)
+#define __NR_pwrite64			(__NR_SYSCALL_BASE+181)
+#define __NR_chown			(__NR_SYSCALL_BASE+182)
+#define __NR_getcwd			(__NR_SYSCALL_BASE+183)
+#define __NR_capget			(__NR_SYSCALL_BASE+184)
+#define __NR_capset			(__NR_SYSCALL_BASE+185)
+#define __NR_sigaltstack		(__NR_SYSCALL_BASE+186)
+#define __NR_sendfile			(__NR_SYSCALL_BASE+187)
+					/* 188 reserved */
+					/* 189 reserved */
+#define __NR_vfork			(__NR_SYSCALL_BASE+190)
+#define __NR_ugetrlimit			(__NR_SYSCALL_BASE+191)	/* SuS compliant getrlimit */
+#define __NR_mmap2			(__NR_SYSCALL_BASE+192)
+#define __NR_truncate64			(__NR_SYSCALL_BASE+193)
+#define __NR_ftruncate64		(__NR_SYSCALL_BASE+194)
+#define __NR_stat64			(__NR_SYSCALL_BASE+195)
+#define __NR_lstat64			(__NR_SYSCALL_BASE+196)
+#define __NR_fstat64			(__NR_SYSCALL_BASE+197)
+#define __NR_lchown32			(__NR_SYSCALL_BASE+198)
+#define __NR_getuid32			(__NR_SYSCALL_BASE+199)
+#define __NR_getgid32			(__NR_SYSCALL_BASE+200)
+#define __NR_geteuid32			(__NR_SYSCALL_BASE+201)
+#define __NR_getegid32			(__NR_SYSCALL_BASE+202)
+#define __NR_setreuid32			(__NR_SYSCALL_BASE+203)
+#define __NR_setregid32			(__NR_SYSCALL_BASE+204)
+#define __NR_getgroups32		(__NR_SYSCALL_BASE+205)
+#define __NR_setgroups32		(__NR_SYSCALL_BASE+206)
+#define __NR_fchown32			(__NR_SYSCALL_BASE+207)
+#define __NR_setresuid32		(__NR_SYSCALL_BASE+208)
+#define __NR_getresuid32		(__NR_SYSCALL_BASE+209)
+#define __NR_setresgid32		(__NR_SYSCALL_BASE+210)
+#define __NR_getresgid32		(__NR_SYSCALL_BASE+211)
+#define __NR_chown32			(__NR_SYSCALL_BASE+212)
+#define __NR_setuid32			(__NR_SYSCALL_BASE+213)
+#define __NR_setgid32			(__NR_SYSCALL_BASE+214)
+#define __NR_setfsuid32			(__NR_SYSCALL_BASE+215)
+#define __NR_setfsgid32			(__NR_SYSCALL_BASE+216)
+#define __NR_getdents64			(__NR_SYSCALL_BASE+217)
+#define __NR_pivot_root			(__NR_SYSCALL_BASE+218)
+#define __NR_mincore			(__NR_SYSCALL_BASE+219)
+#define __NR_madvise			(__NR_SYSCALL_BASE+220)
+#define __NR_fcntl64			(__NR_SYSCALL_BASE+221)
+					/* 222 for tux */
+					/* 223 is unused */
+#define __NR_gettid			(__NR_SYSCALL_BASE+224)
+#define __NR_readahead			(__NR_SYSCALL_BASE+225)
+#define __NR_setxattr			(__NR_SYSCALL_BASE+226)
+#define __NR_lsetxattr			(__NR_SYSCALL_BASE+227)
+#define __NR_fsetxattr			(__NR_SYSCALL_BASE+228)
+#define __NR_getxattr			(__NR_SYSCALL_BASE+229)
+#define __NR_lgetxattr			(__NR_SYSCALL_BASE+230)
+#define __NR_fgetxattr			(__NR_SYSCALL_BASE+231)
+#define __NR_listxattr			(__NR_SYSCALL_BASE+232)
+#define __NR_llistxattr			(__NR_SYSCALL_BASE+233)
+#define __NR_flistxattr			(__NR_SYSCALL_BASE+234)
+#define __NR_removexattr		(__NR_SYSCALL_BASE+235)
+#define __NR_lremovexattr		(__NR_SYSCALL_BASE+236)
+#define __NR_fremovexattr		(__NR_SYSCALL_BASE+237)
+#define __NR_tkill			(__NR_SYSCALL_BASE+238)
+#define __NR_sendfile64			(__NR_SYSCALL_BASE+239)
+#define __NR_futex			(__NR_SYSCALL_BASE+240)
+#define __NR_sched_setaffinity		(__NR_SYSCALL_BASE+241)
+#define __NR_sched_getaffinity		(__NR_SYSCALL_BASE+242)
+#define __NR_io_setup			(__NR_SYSCALL_BASE+243)
+#define __NR_io_destroy			(__NR_SYSCALL_BASE+244)
+#define __NR_io_getevents		(__NR_SYSCALL_BASE+245)
+#define __NR_io_submit			(__NR_SYSCALL_BASE+246)
+#define __NR_io_cancel			(__NR_SYSCALL_BASE+247)
+#define __NR_exit_group			(__NR_SYSCALL_BASE+248)
+#define __NR_lookup_dcookie		(__NR_SYSCALL_BASE+249)
+#define __NR_epoll_create		(__NR_SYSCALL_BASE+250)
+#define __NR_epoll_ctl			(__NR_SYSCALL_BASE+251)
+#define __NR_epoll_wait			(__NR_SYSCALL_BASE+252)
+#define __NR_remap_file_pages		(__NR_SYSCALL_BASE+253)
+					/* 254 for set_thread_area */
+					/* 255 for get_thread_area */
+					/* 256 for set_tid_address */
+#define __NR_timer_create		(__NR_SYSCALL_BASE+257)
+#define __NR_timer_settime		(__NR_SYSCALL_BASE+258)
+#define __NR_timer_gettime		(__NR_SYSCALL_BASE+259)
+#define __NR_timer_getoverrun		(__NR_SYSCALL_BASE+260)
+#define __NR_timer_delete		(__NR_SYSCALL_BASE+261)
+#define __NR_clock_settime		(__NR_SYSCALL_BASE+262)
+#define __NR_clock_gettime		(__NR_SYSCALL_BASE+263)
+#define __NR_clock_getres		(__NR_SYSCALL_BASE+264)
+#define __NR_clock_nanosleep		(__NR_SYSCALL_BASE+265)
+#define __NR_statfs64			(__NR_SYSCALL_BASE+266)
+#define __NR_fstatfs64			(__NR_SYSCALL_BASE+267)
+#define __NR_tgkill			(__NR_SYSCALL_BASE+268)
+#define __NR_utimes			(__NR_SYSCALL_BASE+269)
+#define __NR_fadvise64_64		(__NR_SYSCALL_BASE+270)
+#define __NR_pciconfig_iobase		(__NR_SYSCALL_BASE+271)
+#define __NR_pciconfig_read		(__NR_SYSCALL_BASE+272)
+#define __NR_pciconfig_write		(__NR_SYSCALL_BASE+273)
+
+/*
+ * The following SWIs are ARM private.
+ */
+#define __ARM_NR_BASE			(__NR_SYSCALL_BASE+0x0f0000)
+#define __ARM_NR_breakpoint		(__ARM_NR_BASE+1)
+#define __ARM_NR_cacheflush		(__ARM_NR_BASE+2)
+#define __ARM_NR_usr26			(__ARM_NR_BASE+3)
+#define __ARM_NR_usr32			(__ARM_NR_BASE+4)
+
+#define __sys2(x) #x
+#define __sys1(x) __sys2(x)
+
+#ifndef __syscall
+#if defined(__thumb__)
+#define __syscall(name)					\
+	"push	{r7}\n\t"				\
+	"mov	r7, #" __sys1(__NR_##name) "\n\t"	\
+	"swi	0\n\t"					\
+	"pop	{r7}"
+#else
+#define __syscall(name) "swi\t" __sys1(__NR_##name) ""
+#endif
+#endif
+
+#define __syscall_return(type, res)					\
+do {									\
+	if ((unsigned long)(res) >= (unsigned long)(-125)) {		\
+		errno = -(res);						\
+		res = -1;						\
+	}								\
+	return (type) (res);						\
+} while (0)
+
+#define _syscall0(type,name)						\
+type name(void) {							\
+  register long __res_r0 __asm__("r0");					\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  __syscall(name)							\
+	: "=r" (__res_r0)						\
+	:								\
+	: "lr");							\
+  __res = __res_r0;							\
+  __syscall_return(type,__res);						\
+}
+
+#define _syscall1(type,name,type1,arg1) 				\
+type name(type1 arg1) { 						\
+  register long __r0 __asm__("r0") = (long)arg1;			\
+  register long __res_r0 __asm__("r0");					\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  __syscall(name)							\
+	: "=r" (__res_r0)						\
+	: "r" (__r0)							\
+	: "lr");							\
+  __res = __res_r0;							\
+  __syscall_return(type,__res);						\
+}
+
+#define _syscall2(type,name,type1,arg1,type2,arg2)			\
+type name(type1 arg1,type2 arg2) {					\
+  register long __r0 __asm__("r0") = (long)arg1;			\
+  register long __r1 __asm__("r1") = (long)arg2;			\
+  register long __res_r0 __asm__("r0");					\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  __syscall(name)							\
+	: "=r" (__res_r0)						\
+	: "r" (__r0),"r" (__r1) 					\
+	: "lr");							\
+  __res = __res_r0;							\
+  __syscall_return(type,__res);						\
+}
+
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\
+type name(type1 arg1,type2 arg2,type3 arg3) {				\
+  register long __r0 __asm__("r0") = (long)arg1;			\
+  register long __r1 __asm__("r1") = (long)arg2;			\
+  register long __r2 __asm__("r2") = (long)arg3;			\
+  register long __res_r0 __asm__("r0");					\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  __syscall(name)							\
+	: "=r" (__res_r0)						\
+	: "r" (__r0),"r" (__r1),"r" (__r2)				\
+	: "lr");							\
+  __res = __res_r0;							\
+  __syscall_return(type,__res);						\
+}
+
+
+#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)\
+type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {		\
+  register long __r0 __asm__("r0") = (long)arg1;			\
+  register long __r1 __asm__("r1") = (long)arg2;			\
+  register long __r2 __asm__("r2") = (long)arg3;			\
+  register long __r3 __asm__("r3") = (long)arg4;			\
+  register long __res_r0 __asm__("r0");					\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  __syscall(name)							\
+	: "=r" (__res_r0)						\
+	: "r" (__r0),"r" (__r1),"r" (__r2),"r" (__r3)			\
+	: "lr");							\
+  __res = __res_r0;							\
+  __syscall_return(type,__res);						\
+}
+  
+
+#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,type5,arg5)	\
+type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5) {	\
+  register long __r0 __asm__("r0") = (long)arg1;			\
+  register long __r1 __asm__("r1") = (long)arg2;			\
+  register long __r2 __asm__("r2") = (long)arg3;			\
+  register long __r3 __asm__("r3") = (long)arg4;			\
+  register long __r4 __asm__("r4") = (long)arg5;			\
+  register long __res_r0 __asm__("r0");					\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  __syscall(name)							\
+	: "=r" (__res_r0)						\
+	: "r" (__r0),"r" (__r1),"r" (__r2),"r" (__r3),"r" (__r4)	\
+	: "lr");							\
+  __res = __res_r0;							\
+  __syscall_return(type,__res);						\
+}
+
+#define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,type5,arg5,type6,arg6)	\
+type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5, type6 arg6) {	\
+  register long __r0 __asm__("r0") = (long)arg1;			\
+  register long __r1 __asm__("r1") = (long)arg2;			\
+  register long __r2 __asm__("r2") = (long)arg3;			\
+  register long __r3 __asm__("r3") = (long)arg4;			\
+  register long __r4 __asm__("r4") = (long)arg5;			\
+  register long __r5 __asm__("r5") = (long)arg6;			\
+  register long __res_r0 __asm__("r0");					\
+  long __res;								\
+  __asm__ __volatile__ (						\
+  __syscall(name)							\
+	: "=r" (__res_r0)						\
+	: "r" (__r0),"r" (__r1),"r" (__r2),"r" (__r3), "r" (__r4),"r" (__r5)		\
+	: "lr");							\
+  __res = __res_r0;							\
+  __syscall_return(type,__res);						\
+}
+
+#ifdef __KERNEL__
+#define __ARCH_WANT_IPC_PARSE_VERSION
+#define __ARCH_WANT_OLD_READDIR
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_SYS_UTIME
+#define __ARCH_WANT_SYS_SOCKETCALL
+#define __ARCH_WANT_SYS_FADVISE64
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_NICE
+#define __ARCH_WANT_SYS_OLD_GETRLIMIT
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __ARCH_WANT_SYS_SIGPENDING
+#define __ARCH_WANT_SYS_SIGPROCMASK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+#endif
+
+#ifdef __KERNEL_SYSCALLS__
+
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <linux/syscalls.h>
+
+static inline pid_t setsid(void)
+{
+	return sys_setsid();
+}
+
+static inline long write(int fd, const char *buf, off_t count)
+{
+	return sys_write(fd, buf, count);
+}
+
+static inline long read(int fd, char *buf, off_t count)
+{
+	return sys_read(fd, buf, count);
+}
+
+static inline off_t lseek(int fd, off_t offset, int count)
+{
+	return sys_lseek(fd, offset, count);
+}
+
+static inline long dup(int fd)
+{
+	return sys_dup(fd);
+}
+
+static inline long open(const char *file, int flag, int mode)
+{
+	return sys_open(file, flag, mode);
+}
+
+static inline long close(int fd)
+{
+	return sys_close(fd);
+}
+
+static inline long _exit(int exitcode)
+{
+	return sys_exit(exitcode);
+}
+
+static inline pid_t waitpid(pid_t pid, int *wait_stat, int options)
+{
+	return sys_wait4((int)pid, wait_stat, options, NULL);
+}
+
+extern long execve(const char *file, char **argv, char **envp);
+
+struct pt_regs;
+asmlinkage int sys_execve(char *filenamei, char **argv, char **envp,
+			struct pt_regs *regs);
+asmlinkage int sys_clone(unsigned long clone_flags, unsigned long newsp,
+			struct pt_regs *regs);
+asmlinkage int sys_fork(struct pt_regs *regs);
+asmlinkage int sys_vfork(struct pt_regs *regs);
+asmlinkage int sys_pipe(unsigned long *fildes);
+asmlinkage int sys_ptrace(long request, long pid, long addr, long data);
+struct sigaction;
+asmlinkage long sys_rt_sigaction(int sig,
+				const struct sigaction __user *act,
+				struct sigaction __user *oact,
+				size_t sigsetsize);
+
+#endif
+
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+#define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall");
+
+#endif /* __ASM_ARM_UNISTD_H */
diff -Naur linux-2.6.9/include/asm-armnommu/user.h linux-2.6.9-uc0/include/asm-armnommu/user.h
--- linux-2.6.9/include/asm-armnommu/user.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/user.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/user.h>
diff -Naur linux-2.6.9/include/asm-armnommu/vga.h linux-2.6.9-uc0/include/asm-armnommu/vga.h
--- linux-2.6.9/include/asm-armnommu/vga.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/vga.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/vga.h>
diff -Naur linux-2.6.9/include/asm-armnommu/xor.h linux-2.6.9-uc0/include/asm-armnommu/xor.h
--- linux-2.6.9/include/asm-armnommu/xor.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-armnommu/xor.h	2004-10-28 11:14:25.000000000 +1000
@@ -0,0 +1 @@
+#include <asm-arm/xor.h>
diff -Naur linux-2.6.9/include/asm-m68knommu/bitops.h linux-2.6.9-uc0/include/asm-m68knommu/bitops.h
--- linux-2.6.9/include/asm-m68knommu/bitops.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/bitops.h	2004-10-28 11:14:32.000000000 +1000
@@ -294,6 +294,8 @@
 
 #define find_first_zero_bit(addr, size) \
         find_next_zero_bit((addr), (size), 0)
+#define find_first_bit(addr, size) \
+        find_next_bit((addr), (size), 0)
 
 static __inline__ int find_next_zero_bit (void * addr, int size, int offset)
 {
diff -Naur linux-2.6.9/include/asm-m68knommu/checksum.h linux-2.6.9-uc0/include/asm-m68knommu/checksum.h
--- linux-2.6.9/include/asm-m68knommu/checksum.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/checksum.h	2004-10-28 11:14:32.000000000 +1000
@@ -1,6 +1,8 @@
 #ifndef _M68K_CHECKSUM_H
 #define _M68K_CHECKSUM_H
 
+#include <linux/in6.h>
+
 /*
  * computes the checksum of a memory block at buff, length len,
  * and adds in "sum" (32-bit)
diff -Naur linux-2.6.9/include/asm-m68knommu/coldfire.h linux-2.6.9-uc0/include/asm-m68knommu/coldfire.h
--- linux-2.6.9/include/asm-m68knommu/coldfire.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/coldfire.h	2004-10-28 11:14:32.000000000 +1000
@@ -22,7 +22,7 @@
 #define	MCF_MBAR2	0x80000000
 #define	MCF_IPSBAR	0x40000000
 
-#ifdef CONFIG_M5282
+#if defined(CONFIG_M527x) || defined(CONFIG_M528x)
 #undef MCF_MBAR
 #define	MCF_MBAR	MCF_IPSBAR
 #endif
@@ -60,8 +60,14 @@
 #define	MCF_CLK		66000000
 #elif defined(CONFIG_CLOCK_70MHz)
 #define	MCF_CLK		70000000
+#elif defined(CONFIG_CLOCK_100MHz)
+#define	MCF_CLK		100000000
 #elif defined(CONFIG_CLOCK_140MHz)
 #define	MCF_CLK		140000000
+#elif defined(CONFIG_CLOCK_150MHz)
+#define	MCF_CLK		150000000
+#elif defined(CONFIG_CLOCK_166MHz)
+#define	MCF_CLK		166000000
 #else
 #error "Don't know what your ColdFire CPU clock frequency is??"
 #endif
@@ -70,7 +76,7 @@
  *	One some ColdFire family members the bus clock (used by internal
  *	peripherals) is not the same as the CPU clock.
  */
-#ifdef CONFIG_M5249
+#if defined(CONFIG_M5249) || defined(CONFIG_M527x)
 #define	MCF_BUSCLK	(MCF_CLK / 2)
 #else
 #define	MCF_BUSCLK	MCF_CLK
diff -Naur linux-2.6.9/include/asm-m68knommu/cs89x0_fct.h linux-2.6.9-uc0/include/asm-m68knommu/cs89x0_fct.h
--- linux-2.6.9/include/asm-m68knommu/cs89x0_fct.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/cs89x0_fct.h	2004-10-28 11:14:32.000000000 +1000
@@ -0,0 +1,347 @@
+
+/* include/asm-m68knommu/cs89x0_fct.h: arch/platformm specific code for CS89x0
+ *
+ * Copyright (C) 2004  Georges Menie
+ *
+ */
+
+#ifndef _CS89X0_FCT_H_
+#define _CS89X0_FCT_H_
+
+#if defined(CONFIG_UCSIMM)
+
+static inline int cs89x_hw_init_hook(struct net_device *dev, int unit)
+{
+	extern unsigned char *cs8900a_hwaddr;
+
+	if (unit != 0)
+		return 1; /* only one device */
+
+	/* set up the chip select */
+	*(volatile unsigned  char *)0xfffff42b |= 0x01; /* output /sleep */
+	*(volatile unsigned short *)0xfffff428 |= 0x0101; /* not sleeping */
+	*(volatile unsigned  char *)0xfffff42b &= ~0x02; /* input irq5 */
+	*(volatile unsigned short *)0xfffff428 &= ~0x0202; /* irq5 fcn on */
+	*(volatile unsigned short *)0xfffff102 = 0x8000; /* 0x04000000 */
+	*(volatile unsigned short *)0xfffff112 = 0x01e1; /* 128k, 2ws, FLASH, en */
+
+	dev->base_addr = 0x10000301;
+	dev->irq = IRQ5_IRQ_NUM;
+	memcpy(dev->dev_addr, cs8900a_hwaddr, 6);
+
+	return 0;
+}
+
+static inline int cs89x_set_irq(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	writereg(dev, PP_BusCTL, 0);    /* Disable Interrupts. */
+	write_irq(dev, lp->chip_type, dev->irq);
+	*(volatile unsigned short *)0xfffff302 |= 0x0080; /* +ve pol irq */
+	if (request_irq(dev->irq, &net_interrupt, IRQ_FLG_STD, dev->name, dev)) {
+		if (net_debug)
+			printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+		return 1;
+	}
+	writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+
+	return 0;
+}
+
+#elif defined(CONFIG_UCDIMM)
+
+static inline int cs89x_hw_init_hook(struct net_device *dev, int unit)
+{
+	extern unsigned char *cs8900a_hwaddr;
+
+	if (unit != 0)
+		return 1; /* only one device */
+
+	/* set up the chip select */
+	*(volatile unsigned  char *)0xfffff430 |= 0x08;
+	*(volatile unsigned  char *)0xfffff433 |= 0x08;
+	*(volatile unsigned  char *)0xfffff431 |= (0x08); /* sleep */
+	*(volatile unsigned  char *)0xfffff42b &= ~0x02; /* input irq5 */
+	*(volatile unsigned short *)0xfffff428 &= ~0x0202; /* irq5 fcn on */
+	*(volatile unsigned short *)0xfffff102 = 0x8000; /* 0x04000000 */
+	*(volatile unsigned short *)0xfffff112 = 0x01e1; /* 128k, 2ws, FLASH, en */
+
+	dev->base_addr = 0x10000301;
+	dev->irq = IRQ5_IRQ_NUM;
+	memcpy(dev->dev_addr, cs8900a_hwaddr, 6);
+
+	return 0;
+}
+
+static inline int cs89x_set_irq(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	writereg(dev, PP_BusCTL, 0);    /* Disable Interrupts. */
+	write_irq(dev, lp->chip_type, dev->irq);
+	*(volatile unsigned short *)0xfffff302 |= 0x0080; /* +ve pol irq */
+	if (request_irq(dev->irq, &net_interrupt, IRQ_FLG_STD, dev->name, dev)) {
+		if (net_debug)
+			printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+		return 1;
+	}
+	writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+
+	return 0;
+}
+
+#elif defined(CONFIG_DRAGEN2)
+
+static inline int cs89x_hw_init_hook(struct net_device *dev, int unit)
+{
+	if (net_debug)
+		printk("cs89x0:cs89x0_hw_init_hook(%d)\n", unit);
+
+	if (unit != 0)
+		return 1; /* only one device */
+
+	dev->base_addr = 0x08000041;
+	dev->irq = INT1_IRQ_NUM;
+	memcpy(dev->dev_addr, (void *) 0x400fffa, 6);
+
+	return 0;
+}
+
+static inline int cs89x_set_irq(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	writereg(dev, PP_BusCTL, 0);    /* Disable Interrupts. */
+	write_irq(dev, lp->chip_type, dev->irq);
+	if (request_irq(dev->irq, &net_interrupt, IRQ_FLG_STD, dev->name, dev)) {
+		if (net_debug)
+			printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+		return 1;
+	}
+	writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+
+	return 0;
+}
+
+#elif defined(CONFIG_EZ328LCD) || defined(CONFIG_VZ328LCD)
+
+static inline int cs89x_hw_init_hook(struct net_device *dev, int unit)
+{
+	if (unit != 0)
+		return 1; /* only one device */
+
+	dev->base_addr = 0x2000301;
+	dev->irq = IRQ5_IRQ_NUM;
+	dev->dev_addr[0] = 0x00;
+	dev->dev_addr[1] = 0x10;
+	dev->dev_addr[2] = 0x8b;
+	dev->dev_addr[3] = 0xf1;
+	dev->dev_addr[4] = 0xda;
+	dev->dev_addr[5] = 0x01;
+
+	return 0;
+}
+
+static inline int cs89x_set_irq(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	writereg(dev, PP_BusCTL, 0);    /* Disable Interrupts. */
+	write_irq(dev, lp->chip_type, dev->irq);
+	*(volatile unsigned short *)0xfffff302 |= 0x0080; /* +ve pol irq */
+	if (request_irq(dev->irq, &net_interrupt, IRQ_FLG_STD, dev->name, dev)) {
+		if (net_debug)
+			printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+		return 1;
+	}
+	writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+
+	return 0;
+}
+
+#elif defined(CONFIG_ARCH_TA7S)
+
+static inline int cs89x_hw_init_hook(struct net_device *dev, int unit)
+{
+	if (unit != 0)
+		return 1; /* only one device */
+
+	dev->base_addr = 0x10000001;
+	dev->irq = IRQ_CSL_USER_0;
+
+	return 0;
+}
+
+static inline int cs89x_set_irq(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	writereg(dev, PP_BusCTL, 0);    /* Disable Interrupts. */
+	write_irq(dev, lp->chip_type, dev->irq);
+	if (request_irq(dev->irq, &net_interrupt, SA_INTERRUPT, dev->name, dev)) {
+		if (net_debug)
+			printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+		return 1;
+	}
+	writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+
+	return 0;
+}
+
+#elif defined(CONFIG_DRAGONIXVZ)
+
+static inline int cs89x_hw_init_hook(struct net_device *dev, int unit)
+{
+	extern unsigned char cs8900a_hwaddr1[6];
+
+	if (unit != 0)
+		return 1; /* only one device */
+
+	/* set up the chip select */
+	*(volatile unsigned  char *)0xfffff41b &= ~0x80; /* input irq6 */
+	*(volatile unsigned  char *)0x04000105= 0x01; /* nSleep=1 */
+
+	dev->base_addr = 0x4000001;
+	dev->irq = IRQ6_IRQ_NUM;
+	memcpy(dev->dev_addr, cs8900a_hwaddr1, 6);
+
+	return 0;
+}
+
+static inline int cs89x_set_irq(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	
+	writereg(dev, PP_BusCTL, 0);    /* Disable Interrupts. */
+	write_irq(dev, lp->chip_type, dev->irq);
+	*(volatile unsigned short *)0xfffff302 &= ~0x1100; /* -ve pol, level sensitive irq */
+	if (request_irq(dev->irq, &net_interrupt, IRQ_FLG_STD, dev->name, dev)) {
+		if (net_debug)
+			printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+		return 1;
+	}
+	writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+
+	return 0;
+}
+
+#elif defined(CONFIG_CWVZ328)
+
+static inline int cs89x_hw_init_hook(struct net_device *dev, int unit)
+{
+	if (unit != 0)
+		return 1; /* only one device */
+
+	*(volatile unsigned  char *)0xfffff42b |= 0x01; /* output /sleep */
+	*(volatile unsigned short *)0xfffff428 |= 0x0101; /* not sleeping */
+	*(volatile unsigned  char *)0xfffff42b &= ~0x02; /* input irq5 */
+	*(volatile unsigned short *)0xfffff428 &= ~0x0202; /* irq5 fcn on */
+	*(volatile unsigned short *)0xfffff102 = 0x2000; /* 0x4000000 */
+	*(volatile unsigned short *)0xfffff112 = 0x01e1; /* 128k, 2ws, FLASH, en */
+
+	dev->base_addr = 0x4000001;
+	dev->irq = IRQ5_IRQ_NUM;
+	dev->dev_addr[0] = 0x00;
+	dev->dev_addr[1] = 0x10;
+	dev->dev_addr[2] = 0x8b;
+	dev->dev_addr[3] = 0xf1;
+	dev->dev_addr[4] = 0xda;
+	dev->dev_addr[5] = 0x01;
+
+	return 0;
+}
+
+static inline int cs89x_set_irq(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	writereg(dev, PP_BusCTL, 0);    /* Disable Interrupts. */
+	write_irq(dev, lp->chip_type, dev->irq);
+	*(volatile unsigned short *)0xfffff302 |= 0x0080; /* +ve pol irq */
+	if (request_irq(dev->irq, &net_interrupt, IRQ_FLG_STD, dev->name, dev)) {
+		if (net_debug)
+			printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+		return 1;
+	}
+	writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+
+	return 0;
+}
+
+#elif defined(CONFIG_EXCALIBUR)
+
+static inline int cs89x_hw_init_hook(struct net_device *dev, int unit)
+{
+	extern unsigned char *cs8900a_hwaddr;
+
+	if (unit != 0)
+		return 1; /* only one device */
+
+	*(char *)na_enet = 0;			/* Reset the chip to a usable state. */
+#if 0 /* this is done in cs89x0_probe1 if (ioaddr & 1) flag is set */
+	dev->base_addr = ioaddr;
+	if (readreg(dev, PP_ChipID) != CHIP_EISA_ID_SIG) {
+		return -ENODEV;
+	}
+#endif
+#ifdef na_enet_reset_n
+	*(volatile unsigned char*)na_enet_reset_n=3;
+#endif
+
+	dev->base_addr = na_enet+1;
+	dev->irq = na_enet_irq;
+	memcpy(dev->dev_addr, cs8900a_hwaddr, 6);
+
+	return 0;
+}
+
+static inline int cs89x_set_irq(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	writereg(dev, PP_BusCTL, 0);    /* Disable Interrupts. */
+	write_irq(dev, lp->chip_type, dev->irq);
+	if (request_irq(dev->irq, &net_interrupt, SA_INTERRUPT, dev->name, dev)) {
+		if (net_debug)
+			printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+		return 1;
+	}
+	writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+
+	return 0;
+}
+
+#elif defined(CONFIG_HYPERSTONE_CS89X0)
+
+static inline int cs89x_hw_init_hook(struct net_device *dev, int unit)
+{
+	if (unit != 0)
+		return 1; /* only one device */
+
+	dev->base_addr = 0x01000301;
+	dev->irq = CONFIG_HYPERSTONE_CS89X0_IRQ-1;
+	memcpy(dev->dev_addr, "\x48\x79\x4c\x6e\x78\x30", 6); /* FIXME */
+
+	return 0;
+}
+
+static inline int cs89x_set_irq(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	writereg(dev, PP_BusCTL, 0);    /* Disable Interrupts. */
+	write_irq(dev, lp->chip_type, dev->irq);
+	if (request_irq(dev->irq, &net_interrupt, SA_INTERRUPT, dev->name, dev)) {
+		if (net_debug)
+			printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+		return 1;
+	}
+	writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+
+	return 0;
+}
+
+#endif
+
+#endif
diff -Naur linux-2.6.9/include/asm-m68knommu/delay.h linux-2.6.9-uc0/include/asm-m68knommu/delay.h
--- linux-2.6.9/include/asm-m68knommu/delay.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/delay.h	2004-10-28 11:14:32.000000000 +1000
@@ -1,14 +1,13 @@
 #ifndef _M68KNOMMU_DELAY_H
 #define _M68KNOMMU_DELAY_H
 
-#include <asm/param.h>
-
 /*
  * Copyright (C) 1994 Hamish Macdonald
- *
- * Delay routines, using a pre-computed "loops_per_second" value.
+ * Copyright (C) 2004 Greg Ungerer <gerg@snapgear.com>
  */
 
+#include <asm/param.h>
+
 extern __inline__ void __delay(unsigned long loops)
 {
 #if defined(CONFIG_COLDFIRE)
@@ -34,35 +33,27 @@
 }
 
 /*
- * Use only for very small delays ( < 1 msec).  Should probably use a
- * lookup table, really, as the multiplications take much too long with
- * short delays.  This is a "reasonable" implementation, though (and the
- * first constant multiplications gets optimized away if the delay is
- * a constant)  
+ *	Ideally we use a 32*32->64 multiply to calculate the number of
+ *	loop iterations, but the older standard 68k and ColdFire do not
+ *	have this instruction. So for them we have a clsoe approximation
+ *	loop using 32*32->32 multiplies only. This calculation based on
+ *	the ARM version of delay.
+ *
+ *	We want to implement:
+ *
+ *	loops = (usecs * 0x10c6 * HZ * loops_per_jiffy) / 2^32
  */
 
+#define	HZSCALE		(268435456 / (1000000/HZ))
+
 extern unsigned long loops_per_jiffy;
 
-extern __inline__ void udelay(unsigned long usecs)
+extern __inline__ void _udelay(unsigned long usecs)
 {
-#ifdef CONFIG_M68332
-        usecs *= 0x000010c6;       
-       __asm__ __volatile__ ("mulul %1,%0:%2"
-                    : "=d" (usecs)
-                  : "d" (usecs),
-                   "d" (loops_per_jiffy*HZ));
-	__delay(usecs);
-
-#elif defined(CONFIG_M68328) || defined(CONFIG_M68EZ328) || \
-		defined(CONFIG_COLDFIRE) || defined(CONFIG_M68360) || \
-		defined(CONFIG_M68VZ328)
-	register unsigned long full_loops, part_loops;
-
-	full_loops = ((usecs * HZ) / 1000000) * loops_per_jiffy;
-	usecs %= (1000000 / HZ);
-	part_loops = (usecs * HZ * loops_per_jiffy) / 1000000;
-
-	__delay(full_loops + part_loops);
+#if defined(CONFIG_M68328) || defined(CONFIG_M68EZ328) || \
+    defined(CONFIG_M68VZ328) || defined(CONFIG_M68360) || \
+    defined(CONFIG_COLDFIRE)
+	__delay((((usecs * HZSCALE) >> 11) * (loops_per_jiffy >> 11)) >> 6);
 #else
 	unsigned long tmp;
 
@@ -74,4 +65,12 @@
 #endif
 }
 
+/*
+ *	Moved the udelay() function into library code, no longer inlined.
+ *	I had to change the algorithm because we are overflowing now on
+ *	the faster ColdFire parts. The code is a little biger, so it makes
+ *	sense to library it.
+ */
+extern void udelay(unsigned long usecs);
+
 #endif /* defined(_M68KNOMMU_DELAY_H) */
diff -Naur linux-2.6.9/include/asm-m68knommu/m527xsim.h linux-2.6.9-uc0/include/asm-m68knommu/m527xsim.h
--- linux-2.6.9/include/asm-m68knommu/m527xsim.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/m527xsim.h	2004-10-28 11:14:34.000000000 +1000
@@ -0,0 +1,38 @@
+/****************************************************************************/
+
+/*
+ *	m527xsim.h -- ColdFire 5270/5271 System Integration Module support.
+ *
+ *	(C) Copyright 2004, Greg Ungerer (gerg@snapgear.com)
+ */
+
+/****************************************************************************/
+#ifndef	m527xsim_h
+#define	m527xsim_h
+/****************************************************************************/
+
+#include <linux/config.h>
+
+/*
+ *	Define the 5270/5271 SIM register set addresses.
+ */
+#define	MCFICM_INTC0		0x0c00		/* Base for Interrupt Ctrl 0 */
+#define	MCFICM_INTC1		0x0d00		/* Base for Interrupt Ctrl 1 */
+#define	MCFINTC_IPRH		0x00		/* Interrupt pending 32-63 */
+#define	MCFINTC_IPRL		0x04		/* Interrupt pending 1-31 */
+#define	MCFINTC_IMRH		0x08		/* Interrupt mask 32-63 */
+#define	MCFINTC_IMRL		0x0c		/* Interrupt mask 1-31 */
+#define	MCFINTC_INTFRCH		0x10		/* Interrupt force 32-63 */
+#define	MCFINTC_INTFRCL		0x14		/* Interrupt force 1-31 */
+#define	MCFINTC_IRLR		0x18		/* */
+#define	MCFINTC_IACKL		0x19		/* */
+#define	MCFINTC_ICR0		0x40		/* Base ICR register */
+
+#define	MCFINT_VECBASE		64		/* Vector base number */
+#define	MCFINT_UART0		13		/* Interrupt number for UART0 */
+#define	MCFINT_UART1		14		/* Interrupt number for UART1 */
+#define	MCFINT_UART2		15		/* Interrupt number for UART2 */
+#define	MCFINT_PIT1		36		/* Interrupt number for PIT1 */
+
+/****************************************************************************/
+#endif	/* m527xsim_h */
diff -Naur linux-2.6.9/include/asm-m68knommu/m5282sim.h linux-2.6.9-uc0/include/asm-m68knommu/m5282sim.h
--- linux-2.6.9/include/asm-m68knommu/m5282sim.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/m5282sim.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,35 +0,0 @@
-/****************************************************************************/
-
-/*
- *	m5282sim.h -- ColdFire 5282 System Integration Module support.
- *
- *	(C) Copyright 2003, Greg Ungerer (gerg@snapgear.com)
- */
-
-/****************************************************************************/
-#ifndef	m5282sim_h
-#define	m5282sim_h
-/****************************************************************************/
-
-#include <linux/config.h>
-
-/*
- *	Define the 5282 SIM register set addresses.
- */
-#define	MCFICM_INTC0		0x0c00		/* Base for Interrupt Ctrl 0 */
-#define	MCFICM_INTC1		0x0d00		/* Base for Interrupt Ctrl 0 */
-#define	MCFINTC_IPRH		0x00		/* Interrupt pending 32-63 */
-#define	MCFINTC_IPRL		0x04		/* Interrupt pending 1-31 */
-#define	MCFINTC_IMRH		0x08		/* Interrupt mask 32-63 */
-#define	MCFINTC_IMRL		0x0c		/* Interrupt mask 1-31 */
-#define	MCFINTC_INTFRCH		0x10		/* Interrupt force 32-63 */
-#define	MCFINTC_INTFRCL		0x14		/* Interrupt force 1-31 */
-#define	MCFINTC_IRLR		0x18		/* */
-#define	MCFINTC_IACKL		0x19		/* */
-#define	MCFINTC_ICR0		0x40		/* Base ICR register */
-
-#define	MCFINT_UART0		13		/* Interrupt number for UART0 */
-#define	MCFINT_PIT1		55		/* Interrupt number for PIT1 */
-
-/****************************************************************************/
-#endif	/* m5282sim_h */
diff -Naur linux-2.6.9/include/asm-m68knommu/m528xsim.h linux-2.6.9-uc0/include/asm-m68knommu/m528xsim.h
--- linux-2.6.9/include/asm-m68knommu/m528xsim.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/m528xsim.h	2004-10-28 11:14:34.000000000 +1000
@@ -0,0 +1,36 @@
+/****************************************************************************/
+
+/*
+ *	m528xsim.h -- ColdFire 5280/5282 System Integration Module support.
+ *
+ *	(C) Copyright 2003, Greg Ungerer (gerg@snapgear.com)
+ */
+
+/****************************************************************************/
+#ifndef	m528xsim_h
+#define	m528xsim_h
+/****************************************************************************/
+
+#include <linux/config.h>
+
+/*
+ *	Define the 5280/5282 SIM register set addresses.
+ */
+#define	MCFICM_INTC0		0x0c00		/* Base for Interrupt Ctrl 0 */
+#define	MCFICM_INTC1		0x0d00		/* Base for Interrupt Ctrl 0 */
+#define	MCFINTC_IPRH		0x00		/* Interrupt pending 32-63 */
+#define	MCFINTC_IPRL		0x04		/* Interrupt pending 1-31 */
+#define	MCFINTC_IMRH		0x08		/* Interrupt mask 32-63 */
+#define	MCFINTC_IMRL		0x0c		/* Interrupt mask 1-31 */
+#define	MCFINTC_INTFRCH		0x10		/* Interrupt force 32-63 */
+#define	MCFINTC_INTFRCL		0x14		/* Interrupt force 1-31 */
+#define	MCFINTC_IRLR		0x18		/* */
+#define	MCFINTC_IACKL		0x19		/* */
+#define	MCFINTC_ICR0		0x40		/* Base ICR register */
+
+#define	MCFINT_VECBASE		64		/* Vector base number */
+#define	MCFINT_UART0		13		/* Interrupt number for UART0 */
+#define	MCFINT_PIT1		55		/* Interrupt number for PIT1 */
+
+/****************************************************************************/
+#endif	/* m528xsim_h */
diff -Naur linux-2.6.9/include/asm-m68knommu/m68360_enet.h linux-2.6.9-uc0/include/asm-m68knommu/m68360_enet.h
--- linux-2.6.9/include/asm-m68knommu/m68360_enet.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/m68360_enet.h	2004-10-28 11:14:34.000000000 +1000
@@ -1,7 +1,4 @@
-/***********************************
- * $Id: m68360_enet.h,v 1.1 2002/03/02 15:01:07 gerg Exp $
- ***********************************
- *
+/*
  ***************************************
  * Definitions for the ETHERNET controllers
  ***************************************
diff -Naur linux-2.6.9/include/asm-m68knommu/mcfdma.h linux-2.6.9-uc0/include/asm-m68knommu/mcfdma.h
--- linux-2.6.9/include/asm-m68knommu/mcfdma.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/mcfdma.h	2004-10-28 11:14:34.000000000 +1000
@@ -21,7 +21,7 @@
 #define	MCFDMA_BASE1		0x240		/* Base address of DMA 1 */
 #elif defined(CONFIG_M5272)
 #define	MCFDMA_BASE0		0x0e0		/* Base address of DMA 0 */
-#elif defined(CONFIG_M5282)
+#elif defined(CONFIG_M527x) || defined(CONFIG_M528x)
 /* These are relative to the IPSBAR, not MBAR */
 #define	MCFDMA_BASE0		0x100		/* Base address of DMA 0 */
 #define	MCFDMA_BASE1		0x140		/* Base address of DMA 1 */
diff -Naur linux-2.6.9/include/asm-m68knommu/mcfpit.h linux-2.6.9-uc0/include/asm-m68knommu/mcfpit.h
--- linux-2.6.9/include/asm-m68knommu/mcfpit.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/mcfpit.h	2004-10-28 11:14:34.000000000 +1000
@@ -14,7 +14,7 @@
 #include <linux/config.h>
 
 /*
- *	Get address specific defines for the 5282.
+ *	Get address specific defines for the 5270/5271 and 5280/5282.
  */
 #define	MCFPIT_BASE1		0x00150000	/* Base address of TIMER1 */
 #define	MCFPIT_BASE2		0x00160000	/* Base address of TIMER2 */
diff -Naur linux-2.6.9/include/asm-m68knommu/mcfsim.h linux-2.6.9-uc0/include/asm-m68knommu/mcfsim.h
--- linux-2.6.9/include/asm-m68knommu/mcfsim.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/mcfsim.h	2004-10-28 11:14:34.000000000 +1000
@@ -15,7 +15,8 @@
 #include <linux/config.h>
 
 /*
- *	Include 5204, 5206, 5249, 5272, 5282, 5307 or 5407 specific addresses.
+ *	Include 5204, 5206/e, 5249, 5270/5271, 5272, 5280/5282, 5307 or
+ *	5407 specific addresses.
  */
 #if defined(CONFIG_M5204)
 #include <asm/m5204sim.h>
@@ -23,10 +24,12 @@
 #include <asm/m5206sim.h>
 #elif defined(CONFIG_M5249)
 #include <asm/m5249sim.h>
+#elif defined(CONFIG_M527x)
+#include <asm/m527xsim.h>
 #elif defined(CONFIG_M5272)
 #include <asm/m5272sim.h>
-#elif defined(CONFIG_M5282)
-#include <asm/m5282sim.h>
+#elif defined(CONFIG_M528x)
+#include <asm/m528xsim.h>
 #elif defined(CONFIG_M5307)
 #include <asm/m5307sim.h>
 #elif defined(CONFIG_M5407)
diff -Naur linux-2.6.9/include/asm-m68knommu/mcfuart.h linux-2.6.9-uc0/include/asm-m68knommu/mcfuart.h
--- linux-2.6.9/include/asm-m68knommu/mcfuart.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/mcfuart.h	2004-10-28 11:14:34.000000000 +1000
@@ -29,7 +29,7 @@
 #define	MCFUART_BASE1		0x140		/* Base address of UART1 */
 #define	MCFUART_BASE2		0x180		/* Base address of UART2 */
 #endif
-#elif defined(CONFIG_M5282)
+#elif defined(CONFIG_M527x) || defined(CONFIG_M528x)
 #define MCFUART_BASE1		0x200           /* Base address of UART1 */
 #define MCFUART_BASE2		0x240           /* Base address of UART2 */
 #define MCFUART_BASE3		0x280           /* Base address of UART3 */
diff -Naur linux-2.6.9/include/asm-m68knommu/page_offset.h linux-2.6.9-uc0/include/asm-m68knommu/page_offset.h
--- linux-2.6.9/include/asm-m68knommu/page_offset.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/page_offset.h	2004-10-28 11:14:34.000000000 +1000
@@ -1,6 +1,5 @@
 
 #include <linux/config.h>
-#include <asm/shglcore.h>
 
 /* This handles the memory map.. */
 
@@ -45,7 +44,4 @@
 #ifdef CONFIG_M68EN302
 #define PAGE_OFFSET_RAW		0x00000000
 #endif
-#ifdef CONFIG_SHGLCORE
-#define PAGE_OFFSET_RAW		SHGLCORE_RAM_BANK_0_ADDR 
-#endif
 
diff -Naur linux-2.6.9/include/asm-m68knommu/param.h linux-2.6.9-uc0/include/asm-m68knommu/param.h
--- linux-2.6.9/include/asm-m68knommu/param.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/param.h	2004-10-28 11:14:34.000000000 +1000
@@ -3,38 +3,11 @@
 
 #include <linux/config.h>
 
-#ifndef HZ
-#ifdef CONFIG_COLDFIRE
 #if defined(CONFIG_CLEOPATRA)
-#define HZ 1000
-#else
-#define HZ 100
-#endif
-#endif
-#ifdef CONFIG_M68EN302
-#define HZ 100
-#endif
-#ifdef CONFIG_M68328
-#define HZ 100
+#define	HZ 1000
 #endif
-#ifdef CONFIG_M68EZ328
-#define HZ 100
-#endif
-#ifdef CONFIG_UCSIMM
-#define HZ 100
-#endif
-
-#ifdef CONFIG_M68VZ328
-#define HZ 100
-#endif
-
-#ifdef CONFIG_SHGLCORE
-#define HZ 50
-#endif
-#ifdef CONFIG_M68360
-#define HZ 100
-#endif
-
+#ifndef HZ
+#define	HZ 100
 #endif
 
 #ifdef __KERNEL__
diff -Naur linux-2.6.9/include/asm-m68knommu/shglcore.h linux-2.6.9-uc0/include/asm-m68knommu/shglcore.h
--- linux-2.6.9/include/asm-m68knommu/shglcore.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/shglcore.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,65 +0,0 @@
-
-/* Copyright (C) 1998  Kenneth Albanowski <kjahds@kjahds.com>,
- */
-
-#ifndef _M68K_SHGLCORE_H
-#define _M68K_SHGLCORE_H
-
-#include <linux/config.h>
-
-#ifdef CONFIG_SHGLCORE
-
-#include <asm/MC68332.h>
-
-#ifdef CONFIG_SHGLCORE_2MEG
-
-#define SHGLCORE_ROM_BANK_0_ADDR	0x000000
-#define SHGLCORE_ROM_BANK_1_ADDR	0x100000
-#define SHGLCORE_RAM_BANK_0_ADDR	0x200000
-#define SHGLCORE_RAM_BANK_1_ADDR	0x300000
-#define SHGLCORE_FLASH_BANK_0_ADDR	0x400000
-
-#define SHGLCORE_ROM_BANK_0_LENGTH	0x100000
-#define SHGLCORE_ROM_BANK_1_LENGTH	0x100000
-#define SHGLCORE_RAM_BANK_0_LENGTH	0x100000
-#define SHGLCORE_RAM_BANK_1_LENGTH	0x100000
-#define SHGLCORE_FLASH_BANK_0_LENGTH	0x80000
-
-#define SHGLCORE_ACC_ADDR		0x600000
-#define SHGLCORE_LANCE_ADDR		0x700000
-
-#else
-
-#define SHGLCORE_ROM_BANK_0_ADDR	0x000000
-#define SHGLCORE_RAM_BANK_0_ADDR	0x100000
-#define SHGLCORE_FLASH_BANK_0_ADDR	0x300000
-
-#define SHGLCORE_ROM_BANK_0_LENGTH	0x100000
-#define SHGLCORE_RAM_BANK_0_LENGTH	0x100000
-#define SHGLCORE_FLASH_BANK_0_LENGTH	0x80000
-
-#define SHGLCORE_ACC_ADDR		0x400000
-#define SHGLCORE_LANCE_ADDR		0x500000
-
-#endif
-
-#define MAX_DMA_ADDRESS			SHGLCORE_RAM_BANK_0_ADDR + SHGLCORE_RAM_BANK_0_LENGTH
-
-#define SHGLCORE_LATCH_ADDR	(SHGLCORE_ACC_ADDR+0x100)
-#define SHGLCORE_1865_0_ADDR	(SHGLCORE_ACC_ADDR+0x600)
-#define SHGLCORE_1865_1_ADDR	(SHGLCORE_ACC_ADDR+0x700)
-
-#define SHGLCORE_LATCH_BIT(x)	BYTE_REF(SHGLCORE_LATCH_ADDR+x)
-
-#define SHGLCORE_LATCH_STATUS_LED	0
-#define SHGLCORE_LATCH_ERROR_LED	1
-#define SHGLCORE_LATCH_ALARM_LED	2
-
-#define SHGLCORE_LATCH_1865		4
-
-#define SHGLCORE_LATCH_RELAY_1		6
-#define SHGLCORE_LATCH_RELAY_2		7
-
-#endif /* SHGLCORE */
-
-#endif /* _M68K_SHGLCORE_H */
diff -Naur linux-2.6.9/include/asm-m68knommu/shglports.h linux-2.6.9-uc0/include/asm-m68knommu/shglports.h
--- linux-2.6.9/include/asm-m68knommu/shglports.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/shglports.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,76 +0,0 @@
-
-/* Copyright (C) 1998  Kenneth Albanowski <kjahds@kjahds.com>,
- *         1997, 1998  D. Jeff Dionne <jeff@lineo.ca>,
- */
-
-#ifndef _M68K_SHGLPORTS_H
-#define _M68K_SHGLPORTS_H
-
-#include <linux/config.h>
-#include <linux/sched.h>
-
-#ifdef CONFIG_SHGLCORE
-
-extern struct semaphore porte_interlock;
-
-struct SHGLCORE_PORT_QS { 
-  unsigned char
-  nullqs:1, /* COM1TX */ 
-  sbin:1,   /* PQS6 (PCS3) */
-  sbclk:1,  /* PQS5 (PCS2) */
-  sbout:1,  /* PQS4 (PCS1) */
-  null4:4;  /* MISO, MOSI, SCLK, /SS=PCS0 */
-};
-
-#define PORT_QS ((volatile struct SHGLCORE_PORT_QS*)PORTQS_ADDR)
-
-struct SHGLCORE_PORT_E {
-  unsigned char
-  dead:1,       /* LED */
-  sbirigb:1,    /* PE6 */
-  ds:1,         /* /DS */
-  nulle1:1,     /* na */ 
-  sbpll:1,      /* PE3 */
-  avec:1,       /* /AVEC */
-  sbsrom:1,     /* PE1 */
-  sbpanel:1;    /* PE0 */
-};
-
-#define PORT_E ((volatile struct SHGLCORE_PORT_E*)PORTE_ADDR)
-
-struct SHGLCORE_PORT_F {
-  unsigned char
-  nullf1:4,
-  nullf2:4;
-};
-
-#define PORT_F ((volatile struct SHGLCORE_PORT_F*)PORTF_ADDR)
-
-extern int comm_status_led, comm_error_led, alarm_led;
-
-static inline void SET_COMM_STATUS_LED(int value) {
-	BYTE_REF(SHGLCORE_ACC_ADDR+0x100+0) = comm_status_led = value;
-}
-static inline int GET_COMM_STATUS_LED(void) {
-	return comm_status_led;
-}
-
-
-static inline void SET_COMM_ERROR_LED(int value) {
-	BYTE_REF(SHGLCORE_ACC_ADDR+0x100+1) = comm_error_led = value;
-}
-static inline int GET_COMM_ERROR_LED(void) {
-	return comm_error_led;
-}
-
-
-static inline void SET_ALARM_LED(int value) {
-	BYTE_REF(SHGLCORE_ACC_ADDR+0x100+2) = alarm_led = value;
-}
-static inline int GET_ALARM_LED(void) {
-	return alarm_led;
-}
-
-#endif
-
-#endif /* _M68K_SHGLPORTS_H */
diff -Naur linux-2.6.9/include/asm-m68knommu/system.h linux-2.6.9-uc0/include/asm-m68knommu/system.h
--- linux-2.6.9/include/asm-m68knommu/system.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/system.h	2004-10-28 11:14:35.000000000 +1000
@@ -257,6 +257,19 @@
         jmp (%a0);			\
         ");				\
 })
+#elif defined(CONFIG_M528x)
+/*
+ * The MCF528x has a bit (SOFTRST) in memory (Reset Control Register RCR),
+ * that when set, resets the MCF528x.
+ */
+#define HARD_RESET_NOW() \
+({						\
+	unsigned char volatile *reset;		\
+	asm("move.w	#0x2700, %sr");		\
+	reset = ((volatile unsigned short *)(MCF_IPSBAR + 0x110000));	\
+	while(1)				\
+	*reset |= (0x01 << 7);\
+})
 #else
 #define HARD_RESET_NOW() ({		\
         asm("				\
diff -Naur linux-2.6.9/include/asm-m68knommu/thread_info.h linux-2.6.9-uc0/include/asm-m68knommu/thread_info.h
--- linux-2.6.9/include/asm-m68knommu/thread_info.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/thread_info.h	2004-10-28 11:14:35.000000000 +1000
@@ -12,6 +12,12 @@
 
 #ifdef __KERNEL__
 
+/*
+ * Size of kernel stack for each process. This must be a power of 2...
+ */
+#define THREAD_SIZE		8192	/* 2 pages */
+
+
 #ifndef __ASSEMBLY__
 
 /*
@@ -45,12 +51,6 @@
 #define init_stack		(init_thread_union.stack)
 
 
-/*
- * Size of kernel stack for each process. This must be a power of 2...
- */
-#define THREAD_SIZE		8192	/* 2 pages */
-
-
 /* how to get the thread information struct from C */
 static inline struct thread_info *current_thread_info(void)
 {
diff -Naur linux-2.6.9/include/asm-m68knommu/unistd.h linux-2.6.9-uc0/include/asm-m68knommu/unistd.h
--- linux-2.6.9/include/asm-m68knommu/unistd.h	2004-10-28 11:09:40.000000000 +1000
+++ linux-2.6.9-uc0/include/asm-m68knommu/unistd.h	2004-10-28 11:14:35.000000000 +1000
@@ -5,6 +5,7 @@
  * This file contains the system call numbers.
  */
 
+#define __NR_restart_syscall      0
 #define __NR_exit		  1
 #define __NR_fork		  2
 #define __NR_read		  3
@@ -80,7 +81,7 @@
 #define __NR_sigpending		 73
 #define __NR_sethostname	 74
 #define __NR_setrlimit		 75
-#define __NR_old_getrlimit	 76
+#define __NR_getrlimit		 76
 #define __NR_getrusage		 77
 #define __NR_gettimeofday	 78
 #define __NR_settimeofday	 79
@@ -170,6 +171,7 @@
 #define __NR_mremap		163
 #define __NR_setresuid		164
 #define __NR_getresuid		165
+#define __NR_getpagesize	166
 #define __NR_query_module	167
 #define __NR_poll		168
 #define __NR_nfsservctl		169
@@ -194,7 +196,7 @@
 #define __NR_getpmsg		188	/* some people actually want streams */
 #define __NR_putpmsg		189	/* some people actually want streams */
 #define __NR_vfork		190
-#define __NR_getrlimit		191
+#define __NR_ugetrlimit		191
 #define __NR_mmap2		192
 #define __NR_truncate64		193
 #define __NR_ftruncate64	194
@@ -220,8 +222,71 @@
 #define __NR_setgid32		214
 #define __NR_setfsuid32		215
 #define __NR_setfsgid32		216
-
-#define	NR_syscalls		256
+#define __NR_pivot_root		217
+#define __NR_getdents64		220
+#define __NR_gettid		221
+#define __NR_tkill		222
+#define __NR_setxattr		223
+#define __NR_lsetxattr		224
+#define __NR_fsetxattr		225
+#define __NR_getxattr		226
+#define __NR_lgetxattr		227
+#define __NR_fgetxattr		228
+#define __NR_listxattr		229
+#define __NR_llistxattr		230
+#define __NR_flistxattr		231
+#define __NR_removexattr	232
+#define __NR_lremovexattr	233
+#define __NR_fremovexattr	234
+#define __NR_futex		235
+#define __NR_sendfile64		236
+#define __NR_mincore		237
+#define __NR_madvise		238
+#define __NR_fcntl64		239
+#define __NR_readahead		240
+#define __NR_io_setup		241
+#define __NR_io_destroy		242
+#define __NR_io_getevents	243
+#define __NR_io_submit		244
+#define __NR_io_cancel		245
+#define __NR_fadvise64		246
+#define __NR_exit_group		247
+#define __NR_lookup_dcookie	248
+#define __NR_epoll_create	249
+#define __NR_epoll_ctl		250
+#define __NR_epoll_wait		251
+#define __NR_remap_file_pages	252
+#define __NR_set_tid_address	253
+#define __NR_timer_create	254
+#define __NR_timer_settime	255
+#define __NR_timer_gettime	256
+#define __NR_timer_getoverrun	257
+#define __NR_timer_delete	258
+#define __NR_clock_settime	259
+#define __NR_clock_gettime	260
+#define __NR_clock_getres	261
+#define __NR_clock_nanosleep	262
+#define __NR_statfs64		263
+#define __NR_fstatfs64		264
+#define __NR_tgkill		265
+#define __NR_utimes		266
+#define __NR_fadvise64_64	267
+#define __NR_mbind		268
+#define __NR_get_mempolicy	269
+#define __NR_set_mempolicy	270
+#define __NR_mq_open		271
+#define __NR_mq_unlink		272
+#define __NR_mq_timedsend	273
+#define __NR_mq_timedreceive	274
+#define __NR_mq_notify		275
+#define __NR_mq_getsetattr	276
+#define __NR_waitid		277
+#define __NR_sys_setaltroot	278
+#define __NR_add_key		279
+#define __NR_request_key	280
+#define __NR_keyctl		281
+ 
+#define NR_syscalls		282
 
 /* user-visible error numbers are in the range -1 - -122: see
    <asm-m68k/errno.h> */
diff -Naur linux-2.6.9/include/linux/serial_core.h linux-2.6.9-uc0/include/linux/serial_core.h
--- linux-2.6.9/include/linux/serial_core.h	2004-10-28 11:09:38.000000000 +1000
+++ linux-2.6.9-uc0/include/linux/serial_core.h	2004-10-28 11:14:52.000000000 +1000
@@ -65,6 +65,9 @@
 /* Parisc type numbers. */
 #define PORT_MUX	48
 
+/* Motorola ColdFire */
+#define	PORT_MCF	49
+
 /* Macintosh Zilog type numbers */
 #define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */
 #define PORT_PMAC_ZILOG	51
@@ -89,6 +92,12 @@
 /* MPC52xx type numbers */
 #define PORT_MPC52xx	59
 
+/* JTAG emulation port types */
+#define PORT_T32_JTAG1	60
+
+/* Samsung S3C4510B */
+#define PORT_S3C4510B   61
+
 #ifdef __KERNEL__
 
 #include <linux/config.h>
diff -Naur linux-2.6.9/init/Kconfig linux-2.6.9-uc0/init/Kconfig
--- linux-2.6.9/init/Kconfig	2004-10-28 11:10:59.000000000 +1000
+++ linux-2.6.9-uc0/init/Kconfig	2004-10-28 11:14:57.000000000 +1000
@@ -294,8 +294,9 @@
 	  If unsure, say N.
 
 config SHMEM
+	depends on MMU
 	default y
-	bool "Use full shmem filesystem" if EMBEDDED && MMU
+	bool "Use full shmem filesystem" if EMBEDDED
 	help
 	  The shmem is an internal filesystem used to manage shared memory.
 	  It is backed by swap and manages resource limits. It is also exported
@@ -306,6 +307,7 @@
 endmenu		# General setup
 
 config TINY_SHMEM
+	depends on MMU
 	default !SHMEM
 	bool
 
diff -Naur linux-2.6.9/MAINTAINERS linux-2.6.9-uc0/MAINTAINERS
--- linux-2.6.9/MAINTAINERS	2004-10-28 11:10:59.000000000 +1000
+++ linux-2.6.9-uc0/MAINTAINERS	2004-10-28 11:11:00.000000000 +1000
@@ -2436,6 +2436,12 @@
 L:	uclinux-dev@uclinux.org
 S:	Maintained
 
+UCLINUX FOR ARM
+P:	Hyok S. Choi
+M:	hyok.choi@samsung.com
+W:	http://opensrc.sec.samsung.com/
+S:	Maintained
+
 UCLINUX FOR NEC V850
 P:	Miles Bader
 M:	uclinux-v850@lsi.nec.co.jp
diff -Naur linux-2.6.9/Makefile linux-2.6.9-uc0/Makefile
--- linux-2.6.9/Makefile	2004-10-28 11:10:59.000000000 +1000
+++ linux-2.6.9-uc0/Makefile	2004-10-28 11:11:10.000000000 +1000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 9
-EXTRAVERSION =
+EXTRAVERSION = -uc0
 NAME=Zonked Quokka
 
 # *DOCUMENTATION*
diff -Naur linux-2.6.9/mm/nommu.c linux-2.6.9-uc0/mm/nommu.c
--- linux-2.6.9/mm/nommu.c	2004-10-28 11:10:59.000000000 +1000
+++ linux-2.6.9-uc0/mm/nommu.c	2004-10-28 11:15:15.000000000 +1000
@@ -32,9 +32,10 @@
 atomic_t vm_committed_space = ATOMIC_INIT(0);
 int sysctl_overcommit_memory = OVERCOMMIT_GUESS; /* heuristic overcommit */
 int sysctl_overcommit_ratio = 50; /* default is 50% */
-
 int sysctl_max_map_count = DEFAULT_MAX_MAP_COUNT;
+
 EXPORT_SYMBOL(sysctl_max_map_count);
+EXPORT_SYMBOL(mem_map);
 
 /*
  * Handle all mappings that got truncated by a "truncate()"
@@ -74,6 +75,8 @@
 	return -EFBIG;
 }
 
+EXPORT_SYMBOL(vmtruncate);
+
 /*
  * Return the total memory allocated for this pointer, not
  * just what the caller asked for.
@@ -430,6 +433,7 @@
 
 	tblock->next = current->mm->context.tblock.next;
 	current->mm->context.tblock.next = tblock;
+	current->mm->total_vm += len >> PAGE_SHIFT;
 
 #ifdef DEBUG
 	printk("do_mmap:\n");
@@ -483,6 +487,7 @@
 	realalloc -= kobjsize(tblock);
 	askedalloc -= sizeof(struct mm_tblock_struct);
 	kfree(tblock);
+	mm->total_vm -= len >> PAGE_SHIFT;
 
 #ifdef DEBUG
 	show_process_blocks();
@@ -495,6 +500,7 @@
 void exit_mmap(struct mm_struct * mm)
 {
 	struct mm_tblock_struct *tmp;
+	mm->total_vm = 0;
 
 	if (!mm)
 		return;
@@ -574,3 +580,14 @@
 void swap_unplug_io_fn(struct backing_dev_info *bdi, struct page *page)
 {
 }
+
+unsigned long arch_get_unmapped_area(struct file *file, unsigned long addr,
+	unsigned long len, unsigned long pgoff, unsigned long flags)
+{
+	return -ENOMEM;
+}
+
+void arch_unmap_area(struct vm_area_struct *area)
+{
+}
+
diff -Naur linux-2.6.9/mm/page_alloc.c linux-2.6.9-uc0/mm/page_alloc.c
--- linux-2.6.9/mm/page_alloc.c	2004-10-28 11:10:59.000000000 +1000
+++ linux-2.6.9-uc0/mm/page_alloc.c	2004-10-28 11:15:15.000000000 +1000
@@ -219,7 +219,9 @@
 {
 	if (	page_mapped(page) ||
 		page->mapping != NULL ||
+#ifdef CONFIG_MMU
 		page_count(page) != 0 ||
+#endif
 		(page->flags & (
 			1 << PG_lru	|
 			1 << PG_private |
