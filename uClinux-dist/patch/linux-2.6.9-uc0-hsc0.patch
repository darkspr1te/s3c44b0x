diff -Naur linux-2.6.9-uc0/arch/arm/kernel/vmlinux.lds.S linux-2.6.9-hsc0/arch/arm/kernel/vmlinux.lds.S
--- linux-2.6.9-uc0/arch/arm/kernel/vmlinux.lds.S	2004-10-19 06:53:50.000000000 +0900
+++ linux-2.6.9-hsc0/arch/arm/kernel/vmlinux.lds.S	2004-11-19 16:46:04.000000000 +0900
@@ -4,7 +4,7 @@
  */
 
 #include <asm-generic/vmlinux.lds.h>
-	
+
 OUTPUT_ARCH(arm)
 ENTRY(stext)
 #ifndef __ARMEB__
diff -Naur linux-2.6.9-uc0/arch/armnommu/boot/Makefile linux-2.6.9-hsc0/arch/armnommu/boot/Makefile
--- linux-2.6.9-uc0/arch/armnommu/boot/Makefile	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/boot/Makefile	2004-11-23 12:14:56.000000000 +0900
@@ -22,6 +22,8 @@
 initrd_phys-$(CONFIG_ARCH_ATMEL)	:= 0x01300000
    zreladdr-$(CONFIG_ARCH_S3C44B0)	:= 0x0c008000
   ztextaddr-$(CONFIG_ARCH_S3C44B0)	:= 0x0c300000
+   zreladdr-$(CONFIG_ARCH_S3C24A0)	:= 0x10008000
+initrd_phys-$(CONFIG_ARCH_S3C24A0)      := 0x10800000
 
 ZRELADDR    := $(zreladdr-y)
 ZTEXTADDR   := $(ztextaddr-y)
diff -Naur linux-2.6.9-uc0/arch/armnommu/configs/atmel_defconfig linux-2.6.9-hsc0/arch/armnommu/configs/atmel_defconfig
--- linux-2.6.9-uc0/arch/armnommu/configs/atmel_defconfig	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/configs/atmel_defconfig	2004-11-23 09:31:01.000000000 +0900
@@ -1,5 +1,7 @@
 #
 # Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-uc0
+# Tue Nov 23 09:26:36 2004
 #
 CONFIG_ARM=y
 CONFIG_UCLINUX=y
@@ -12,14 +14,13 @@
 #
 CONFIG_EXPERIMENTAL=y
 # CONFIG_CLEAN_COMPILE is not set
-# CONFIG_STANDALONE is not set
 CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
 # General setup
 #
-# CONFIG_SYSVIPC is not set
+CONFIG_LOCALVERSION=""
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
 # CONFIG_AUDIT is not set
@@ -46,6 +47,8 @@
 #
 CONFIG_ARCH_ATMEL=y
 # CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
 # CONFIG_ARCH_S5C7375 is not set
 CONFIG_SET_MEM_PARAM=y
 CONFIG_DRAM_BASE=0x01000000
@@ -72,6 +75,7 @@
 #
 CONFIG_CPU_32=y
 CONFIG_CPU_ARM710=y
+# CONFIG_CPU_S3C4510B is not set
 CONFIG_CPU_32v3=y
 CONFIG_CPU_CACHE_V3=y
 
@@ -103,11 +107,13 @@
 #
 # Generic Driver Options
 #
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_PM is not set
 CONFIG_PREEMPT=y
 CONFIG_CMDLINE="root=/dev/ram initrd=0x01300000,768K keepinitrd"
-# CONFIG_ALIGNMENT_TRAP is not set
+CONFIG_ALIGNMENT_TRAP=y
 
 #
 # Parallel port support
@@ -115,6 +121,11 @@
 # CONFIG_PARPORT is not set
 
 #
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
 # Plug and Play support
 #
 
@@ -125,7 +136,7 @@
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_SIZE=2048
 CONFIG_BLK_DEV_INITRD=y
 
 #
@@ -182,7 +193,6 @@
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
 
 #
 # Input Device Drivers
@@ -207,7 +217,6 @@
 CONFIG_SERIAL_ATMEL_CONSOLE=y
 # CONFIG_UNIX98_PTYS is not set
 # CONFIG_LEGACY_PTYS is not set
-# CONFIG_QIC02_TAPE is not set
 
 #
 # IPMI
@@ -220,16 +229,12 @@
 # CONFIG_WATCHDOG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_FTAPE is not set
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -272,7 +277,8 @@
 #
 # DOS/FAT/NT Filesystems
 #
-# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
 # CONFIG_NTFS_FS is not set
 
 #
@@ -339,8 +345,8 @@
 CONFIG_DEBUG_INFO=y
 CONFIG_DEBUG_KERNEL=y
 CONFIG_DEBUG_SLAB=y
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_SPINLOCK=y
 CONFIG_DEBUG_WAITQ=y
 CONFIG_DEBUG_BUGVERBOSE=y
 CONFIG_DEBUG_ERRORS=y
@@ -359,5 +365,6 @@
 #
 # Library routines
 #
+# CONFIG_CRC_CCITT is not set
 # CONFIG_CRC32 is not set
 # CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9-uc0/arch/armnommu/configs/espd_4510b_defconfig linux-2.6.9-hsc0/arch/armnommu/configs/espd_4510b_defconfig
--- linux-2.6.9-uc0/arch/armnommu/configs/espd_4510b_defconfig	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/configs/espd_4510b_defconfig	2004-11-23 11:24:25.000000000 +0900
@@ -1,5 +1,7 @@
 #
 # Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-hsc0
+# Tue Nov 23 11:15:38 2004
 #
 CONFIG_ARM=y
 CONFIG_UCLINUX=y
@@ -12,14 +14,13 @@
 #
 CONFIG_EXPERIMENTAL=y
 # CONFIG_CLEAN_COMPILE is not set
-# CONFIG_STANDALONE is not set
 CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
 # General setup
 #
-# CONFIG_SYSVIPC is not set
+CONFIG_LOCALVERSION=""
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
@@ -48,6 +49,7 @@
 # CONFIG_ARCH_ATMEL is not set
 # CONFIG_ARCH_S3C3410 is not set
 CONFIG_ARCH_ESPD_4510B=y
+# CONFIG_ARCH_S3C44B0 is not set
 # CONFIG_ARCH_S5C7375 is not set
 CONFIG_SET_MEM_PARAM=y
 CONFIG_DRAM_BASE=0x00000000
@@ -98,6 +100,8 @@
 #
 # Generic Driver Options
 #
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_PM is not set
 # CONFIG_PREEMPT is not set
@@ -153,6 +157,7 @@
 # CONFIG_INET_AH is not set
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
 # CONFIG_IPV6 is not set
 # CONFIG_NETFILTER is not set
 
@@ -172,13 +177,16 @@
 # CONFIG_NET_DIVERT is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_FASTROUTE is not set
 # CONFIG_NET_HW_FLOWCONTROL is not set
 
 #
 # QoS and/or fair queueing
 #
 # CONFIG_NET_SCHED is not set
+# CONFIG_NET_SCH_CLK_JIFFIES is not set
+# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
+# CONFIG_NET_SCH_CLK_CPU is not set
+# CONFIG_NET_CLS_ROUTE is not set
 
 #
 # Network testing
@@ -202,6 +210,7 @@
 # CONFIG_MII is not set
 CONFIG_ETH_S3C4510B=y
 # CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_SMC91X is not set
 # CONFIG_NE2000 is not set
 
 #
@@ -278,7 +287,6 @@
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
 
 #
 # Input Device Drivers
@@ -310,7 +318,6 @@
 CONFIG_SERIAL_CORE_CONSOLE=y
 # CONFIG_UNIX98_PTYS is not set
 # CONFIG_LEGACY_PTYS is not set
-# CONFIG_QIC02_TAPE is not set
 
 #
 # IPMI
@@ -323,16 +330,12 @@
 # CONFIG_WATCHDOG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_FTAPE is not set
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -376,7 +379,8 @@
 #
 # DOS/FAT/NT Filesystems
 #
-# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
 # CONFIG_NTFS_FS is not set
 
 #
@@ -419,6 +423,7 @@
 # CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
@@ -481,5 +486,6 @@
 #
 # Library routines
 #
+# CONFIG_CRC_CCITT is not set
 # CONFIG_CRC32 is not set
 # CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9-uc0/arch/armnommu/configs/GDB_ARMulator_defconfig linux-2.6.9-hsc0/arch/armnommu/configs/GDB_ARMulator_defconfig
--- linux-2.6.9-uc0/arch/armnommu/configs/GDB_ARMulator_defconfig	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/configs/GDB_ARMulator_defconfig	2004-11-23 09:31:05.000000000 +0900
@@ -1,5 +1,7 @@
 #
 # Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-uc0
+# Tue Nov 23 09:26:36 2004
 #
 CONFIG_ARM=y
 CONFIG_UCLINUX=y
@@ -12,14 +14,13 @@
 #
 CONFIG_EXPERIMENTAL=y
 # CONFIG_CLEAN_COMPILE is not set
-# CONFIG_STANDALONE is not set
 CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
 # General setup
 #
-# CONFIG_SYSVIPC is not set
+CONFIG_LOCALVERSION=""
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
 # CONFIG_AUDIT is not set
@@ -46,6 +47,8 @@
 #
 CONFIG_ARCH_ATMEL=y
 # CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
 # CONFIG_ARCH_S5C7375 is not set
 CONFIG_SET_MEM_PARAM=y
 CONFIG_DRAM_BASE=0x01000000
@@ -72,6 +75,7 @@
 #
 CONFIG_CPU_32=y
 CONFIG_CPU_ARM710=y
+# CONFIG_CPU_S3C4510B is not set
 CONFIG_CPU_32v3=y
 CONFIG_CPU_CACHE_V3=y
 
@@ -103,11 +107,13 @@
 #
 # Generic Driver Options
 #
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_PM is not set
 CONFIG_PREEMPT=y
 CONFIG_CMDLINE="root=/dev/ram initrd=0x01300000,768K keepinitrd"
-# CONFIG_ALIGNMENT_TRAP is not set
+CONFIG_ALIGNMENT_TRAP=y
 
 #
 # Parallel port support
@@ -115,6 +121,11 @@
 # CONFIG_PARPORT is not set
 
 #
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
 # Plug and Play support
 #
 
@@ -125,7 +136,7 @@
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_SIZE=2048
 CONFIG_BLK_DEV_INITRD=y
 
 #
@@ -182,7 +193,6 @@
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
 
 #
 # Input Device Drivers
@@ -207,7 +217,6 @@
 CONFIG_SERIAL_ATMEL_CONSOLE=y
 # CONFIG_UNIX98_PTYS is not set
 # CONFIG_LEGACY_PTYS is not set
-# CONFIG_QIC02_TAPE is not set
 
 #
 # IPMI
@@ -220,16 +229,12 @@
 # CONFIG_WATCHDOG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_FTAPE is not set
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -272,7 +277,8 @@
 #
 # DOS/FAT/NT Filesystems
 #
-# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
 # CONFIG_NTFS_FS is not set
 
 #
@@ -339,8 +345,8 @@
 CONFIG_DEBUG_INFO=y
 CONFIG_DEBUG_KERNEL=y
 CONFIG_DEBUG_SLAB=y
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_SPINLOCK=y
 CONFIG_DEBUG_WAITQ=y
 CONFIG_DEBUG_BUGVERBOSE=y
 CONFIG_DEBUG_ERRORS=y
@@ -359,5 +365,6 @@
 #
 # Library routines
 #
+# CONFIG_CRC_CCITT is not set
 # CONFIG_CRC32 is not set
 # CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9-uc0/arch/armnommu/configs/s3c24a0_defconfig linux-2.6.9-hsc0/arch/armnommu/configs/s3c24a0_defconfig
--- linux-2.6.9-uc0/arch/armnommu/configs/s3c24a0_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/configs/s3c24a0_defconfig	2004-11-23 13:46:33.000000000 +0900
@@ -0,0 +1,403 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-hsc0
+# Tue Nov 23 13:45:43 2004
+#
+CONFIG_ARM=y
+CONFIG_UCLINUX=y
+# CONFIG_MMU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
+# CONFIG_ARCH_S5C7375 is not set
+CONFIG_ARCH_S3C24A0=y
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x10000000
+CONFIG_DRAM_SIZE=0x03000000
+CONFIG_FLASH_MEM_BASE=0x00400000
+CONFIG_FLASH_SIZE=0x00400000
+
+#
+# S3C24A0 Implementations
+#
+CONFIG_ARCH_SMDK24A0=y
+CONFIG_ARCH_SPJ=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+CONFIG_CPU_MXU_ENABLE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+# CONFIG_ISA_DMA is not set
+# CONFIG_FIQ is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# At least one math emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+CONFIG_PREEMPT=y
+CONFIG_CMDLINE="root=/dev/ram0 rootfstype=romfs initrd=0x10800000,4M keepinitrd console=ttyJ0 init=/bin/sh"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_T32 is not set
+CONFIG_SERIAL_S3C24A0=y
+CONFIG_SERIAL_S3C24A0_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.9-uc0/arch/armnommu/configs/s3c3410_defconfig linux-2.6.9-hsc0/arch/armnommu/configs/s3c3410_defconfig
--- linux-2.6.9-uc0/arch/armnommu/configs/s3c3410_defconfig	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/configs/s3c3410_defconfig	2004-11-23 10:29:09.000000000 +0900
@@ -1,5 +1,7 @@
 #
 # Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-hsc0
+# Tue Nov 23 10:18:45 2004
 #
 CONFIG_ARM=y
 CONFIG_UCLINUX=y
@@ -12,16 +14,17 @@
 #
 # CONFIG_EXPERIMENTAL is not set
 CONFIG_CLEAN_COMPILE=y
-CONFIG_STANDALONE=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
 # General setup
 #
-# CONFIG_SYSVIPC is not set
+CONFIG_LOCALVERSION=""
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
 CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 # CONFIG_KALLSYMS is not set
@@ -30,6 +33,7 @@
 CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 
 #
@@ -40,20 +44,23 @@
 #
 # System Type
 #
+# CONFIG_ARCH_ATMEL is not set
 CONFIG_ARCH_S3C3410=y
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
 # CONFIG_ARCH_S5C7375 is not set
 CONFIG_SET_MEM_PARAM=y
 CONFIG_DRAM_BASE=0x01000000
 CONFIG_DRAM_SIZE=0x01000000
 CONFIG_FLASH_MEM_BASE=0x00000000
 CONFIG_FLASH_SIZE=0x00200000
+CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
+CONFIG_ARM_CLK=40000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
 
 #
 # S3C3410 Options
 #
-CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
-CONFIG_ARM_CLK=40000000
-CONFIG_SKIP_DUMP_CPU_INFO=y
 CONFIG_REMAP_VECTORS_TO_RAM=y
 
 #
@@ -61,10 +68,9 @@
 #
 CONFIG_CPU_32=y
 CONFIG_CPU_ARM710=y
+# CONFIG_CPU_S3C4510B is not set
 CONFIG_CPU_32v3=y
 CONFIG_CPU_CACHE_V3=y
-CONFIG_CPU_COPY_V3=y
-CONFIG_CPU_TLB_V3=y
 
 #
 # Processor Features
@@ -81,7 +87,6 @@
 # CONFIG_ZBOOT_ROM is not set
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
-# CONFIG_HOTPLUG is not set
 
 #
 # At least one math emulation must be selected
@@ -96,9 +101,11 @@
 #
 # Generic Driver Options
 #
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_DEBUG_DRIVER is not set
 # CONFIG_PM is not set
-# CONFIG_ARTHUR is not set
-CONFIG_CMDLINE="ramdisk=8192 initrd=0x01300000,1M keepinitrd root=/dev/ram"
+CONFIG_CMDLINE="ramdisk=8192 initrd=0x01300000,1M keepinitrd root=/dev/ram0"
 # CONFIG_ALIGNMENT_TRAP is not set
 
 #
@@ -129,11 +136,8 @@
 # Networking support
 #
 # CONFIG_NET is not set
-
-#
-# Amateur Radio support
-#
-# CONFIG_HAMRADIO is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -146,6 +150,14 @@
 # CONFIG_SCSI is not set
 
 #
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
 # I2O device support
 #
 
@@ -173,7 +185,6 @@
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
 
 #
 # Input Device Drivers
@@ -189,8 +200,6 @@
 #
 # CONFIG_VT is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_LEDMAN is not set
-# CONFIG_RESETSWITCH is not set
 
 #
 # Serial drivers
@@ -205,12 +214,7 @@
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 # CONFIG_UNIX98_PTYS is not set
-
-#
-# Mice
-#
-# CONFIG_BUSMOUSE is not set
-# CONFIG_QIC02_TAPE is not set
+# CONFIG_LEGACY_PTYS is not set
 
 #
 # IPMI
@@ -223,20 +227,21 @@
 # CONFIG_WATCHDOG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_FTAPE is not set
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -269,13 +274,15 @@
 #
 # DOS/FAT/NT Filesystems
 #
-# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
 # CONFIG_NTFS_FS is not set
 
 #
 # Pseudo filesystems
 #
 # CONFIG_PROC_FS is not set
+# CONFIG_SYSFS is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
@@ -283,6 +290,7 @@
 #
 # Miscellaneous filesystems
 #
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_CRAMFS is not set
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -346,4 +354,6 @@
 #
 # Library routines
 #
+# CONFIG_CRC_CCITT is not set
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9-uc0/arch/armnommu/configs/s3c44b0x_defconfig linux-2.6.9-hsc0/arch/armnommu/configs/s3c44b0x_defconfig
--- linux-2.6.9-uc0/arch/armnommu/configs/s3c44b0x_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/configs/s3c44b0x_defconfig	2004-11-23 12:11:49.000000000 +0900
@@ -0,0 +1,495 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-hsc0
+# Tue Nov 23 11:37:48 2004
+#
+CONFIG_ARM=y
+CONFIG_UCLINUX=y
+# CONFIG_MMU is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+CONFIG_ARCH_S3C44B0=y
+# CONFIG_ARCH_S5C7375 is not set
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x00000000
+CONFIG_DRAM_SIZE=0x00800000
+CONFIG_FLASH_MEM_BASE=0x01000000
+CONFIG_FLASH_SIZE=0x00200000
+CONFIG_ARM_CLK=50000000
+CONFIG_SKIP_DUMP_CPU_INFO=y
+CONFIG_REMAP_VECTORS_TO_RAM=y
+
+#
+# S3C44B0X Board Options
+#
+# CONFIG_DEBUG_NICKMIT is not set
+CONFIG_ARM_CLK_ADJUST=y
+CONFIG_ARM_CLK_FIN=8000000
+
+#
+# S3C44B0X Board Driver Options
+#
+CONFIG_SERIAL_S3C44B0X=y
+CONFIG_SERIAL_S3C44B0X_CONSOLE=y
+CONFIG_ETH_RTL8019AS=y
+CONFIG_S3C44B0X_GPIO_LED=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM710=y
+# CONFIG_CPU_S3C4510B is not set
+CONFIG_CPU_32v3=y
+CONFIG_CPU_CACHE_V3=y
+
+#
+# Processor Features
+#
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+# CONFIG_ISA_DMA is not set
+# CONFIG_FIQ is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# At least one math emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+CONFIG_CMDLINE=""
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_SMC91X is not set
+# CONFIG_NE2000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_T32 is not set
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SLAB=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9-uc0/arch/armnommu/configs/s5c7375_defconfig linux-2.6.9-hsc0/arch/armnommu/configs/s5c7375_defconfig
--- linux-2.6.9-uc0/arch/armnommu/configs/s5c7375_defconfig	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/configs/s5c7375_defconfig	2004-11-23 09:23:43.000000000 +0900
@@ -1,5 +1,7 @@
 #
 # Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-uc0
+# Tue Nov 23 08:19:47 2004
 #
 CONFIG_ARM=y
 CONFIG_UCLINUX=y
@@ -12,14 +14,13 @@
 #
 CONFIG_EXPERIMENTAL=y
 # CONFIG_CLEAN_COMPILE is not set
-# CONFIG_STANDALONE is not set
 CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
 # General setup
 #
-# CONFIG_SYSVIPC is not set
+CONFIG_LOCALVERSION=""
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
 # CONFIG_AUDIT is not set
@@ -47,6 +48,7 @@
 # CONFIG_ARCH_ATMEL is not set
 # CONFIG_ARCH_S3C3410 is not set
 # CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
 CONFIG_ARCH_S5C7375=y
 CONFIG_SET_MEM_PARAM=y
 CONFIG_DRAM_BASE=0x00000000
@@ -105,6 +107,8 @@
 #
 # Generic Driver Options
 #
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_PM is not set
 CONFIG_PREEMPT=y
@@ -193,7 +197,6 @@
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
 
 #
 # Input Device Drivers
@@ -226,7 +229,6 @@
 CONFIG_SERIAL_CORE_CONSOLE=y
 # CONFIG_UNIX98_PTYS is not set
 # CONFIG_LEGACY_PTYS is not set
-# CONFIG_QIC02_TAPE is not set
 
 #
 # IPMI
@@ -239,16 +241,12 @@
 # CONFIG_WATCHDOG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_FTAPE is not set
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -291,7 +289,8 @@
 #
 # DOS/FAT/NT Filesystems
 #
-# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
 # CONFIG_NTFS_FS is not set
 
 #
@@ -378,5 +377,6 @@
 #
 # Library routines
 #
+# CONFIG_CRC_CCITT is not set
 # CONFIG_CRC32 is not set
 # CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9-uc0/arch/armnommu/defconfig linux-2.6.9-hsc0/arch/armnommu/defconfig
--- linux-2.6.9-uc0/arch/armnommu/defconfig	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/defconfig	2004-11-23 09:30:54.000000000 +0900
@@ -1,5 +1,7 @@
 #
 # Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-uc0
+# Tue Nov 23 09:26:36 2004
 #
 CONFIG_ARM=y
 CONFIG_UCLINUX=y
@@ -12,14 +14,13 @@
 #
 CONFIG_EXPERIMENTAL=y
 # CONFIG_CLEAN_COMPILE is not set
-# CONFIG_STANDALONE is not set
 CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
 # General setup
 #
-# CONFIG_SYSVIPC is not set
+CONFIG_LOCALVERSION=""
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
 # CONFIG_AUDIT is not set
@@ -46,6 +47,8 @@
 #
 CONFIG_ARCH_ATMEL=y
 # CONFIG_ARCH_S3C3410 is not set
+# CONFIG_ARCH_ESPD_4510B is not set
+# CONFIG_ARCH_S3C44B0 is not set
 # CONFIG_ARCH_S5C7375 is not set
 CONFIG_SET_MEM_PARAM=y
 CONFIG_DRAM_BASE=0x01000000
@@ -72,6 +75,7 @@
 #
 CONFIG_CPU_32=y
 CONFIG_CPU_ARM710=y
+# CONFIG_CPU_S3C4510B is not set
 CONFIG_CPU_32v3=y
 CONFIG_CPU_CACHE_V3=y
 
@@ -103,11 +107,13 @@
 #
 # Generic Driver Options
 #
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_PM is not set
 CONFIG_PREEMPT=y
 CONFIG_CMDLINE="root=/dev/ram initrd=0x01300000,768K keepinitrd"
-# CONFIG_ALIGNMENT_TRAP is not set
+CONFIG_ALIGNMENT_TRAP=y
 
 #
 # Parallel port support
@@ -115,6 +121,11 @@
 # CONFIG_PARPORT is not set
 
 #
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
 # Plug and Play support
 #
 
@@ -125,7 +136,7 @@
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_SIZE=2048
 CONFIG_BLK_DEV_INITRD=y
 
 #
@@ -182,7 +193,6 @@
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
 
 #
 # Input Device Drivers
@@ -207,7 +217,6 @@
 CONFIG_SERIAL_ATMEL_CONSOLE=y
 # CONFIG_UNIX98_PTYS is not set
 # CONFIG_LEGACY_PTYS is not set
-# CONFIG_QIC02_TAPE is not set
 
 #
 # IPMI
@@ -220,16 +229,12 @@
 # CONFIG_WATCHDOG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_FTAPE is not set
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -272,7 +277,8 @@
 #
 # DOS/FAT/NT Filesystems
 #
-# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
 # CONFIG_NTFS_FS is not set
 
 #
@@ -339,8 +345,8 @@
 CONFIG_DEBUG_INFO=y
 CONFIG_DEBUG_KERNEL=y
 CONFIG_DEBUG_SLAB=y
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_SPINLOCK=y
 CONFIG_DEBUG_WAITQ=y
 CONFIG_DEBUG_BUGVERBOSE=y
 CONFIG_DEBUG_ERRORS=y
@@ -359,5 +365,6 @@
 #
 # Library routines
 #
+# CONFIG_CRC_CCITT is not set
 # CONFIG_CRC32 is not set
 # CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.9-uc0/arch/armnommu/Kconfig linux-2.6.9-hsc0/arch/armnommu/Kconfig
--- linux-2.6.9-uc0/arch/armnommu/Kconfig	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/Kconfig	2004-11-23 12:20:52.000000000 +0900
@@ -140,6 +140,11 @@
 	help
 	  Samsung's S5C7375 16/32-bit SOC(ARM920T) for internal use.
 
+config ARCH_S3C24A0 
+	bool "Samsung S3C24A0" 
+	help 
+	  Samsung's S3C24A0 media processor based on ARM926EJ core. 
+
 endchoice
 
 config SET_MEM_PARAM
@@ -155,6 +160,7 @@
 	default 0x0C000000 if ARCH_S3C44B0
 	default 0x00000000 if ARCH_S5C7375
 	default 0x00000000 if ARCH_ESPD_4510B
+	default 0x10000000 if ARCH_S3C24A0 
 	default 0x00800000
 
 config DRAM_SIZE
@@ -164,6 +170,7 @@
 	default 0x01000000 if ARCH_S3C44B0
 	default 0x00400000 if ARCH_S5C7375
 	default 0x00800000 if ARCH_ESPD_4510B
+	default 0x04000000 if ARCH_S3C24A0 
 	default 0x00800000
 
 config FLASH_MEM_BASE
@@ -189,7 +196,7 @@
 source "arch/armnommu/mach-s3c44b0x/Kconfig"
 source "arch/armnommu/mach-s5c7375/Kconfig"
 source "arch/armnommu/mach-espd_4510b/Kconfig"
-
+source "arch/armnommu/mach-s3c24a0/Kconfig" 
 source arch/armnommu/mm/Kconfig
 
 endmenu
diff -Naur linux-2.6.9-uc0/arch/armnommu/kernel/entry-common.S linux-2.6.9-hsc0/arch/armnommu/kernel/entry-common.S
--- linux-2.6.9-uc0/arch/armnommu/kernel/entry-common.S	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/kernel/entry-common.S	2004-11-22 15:30:18.000000000 +0900
@@ -121,11 +121,6 @@
 	get_scno
 	arm710_bug_check scno, ip
 
-#ifdef CONFIG_ALIGNMENT_TRAP
-	ldr	ip, __cr_alignment
-	ldr	ip, [ip]
-	mcr	p15, 0, ip, c1, c0		@ update control register
-#endif
 	enable_irq ip
 
 	str	r4, [sp, #-S_OFF]!		@ push fifth arg
@@ -172,13 +167,6 @@
 	bl	syscall_trace
 	b	ret_slow_syscall
 
-	.align	5
-#ifdef CONFIG_ALIGNMENT_TRAP
-	.type	__cr_alignment, #object
-__cr_alignment:
-	.word	cr_alignment
-#endif
-
 	.type	sys_call_table, #object
 ENTRY(sys_call_table)
 #include "calls.S"
diff -Naur linux-2.6.9-uc0/arch/armnommu/kernel/entry.S linux-2.6.9-hsc0/arch/armnommu/kernel/entry.S
--- linux-2.6.9-uc0/arch/armnommu/kernel/entry.S	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/kernel/entry.S	2004-11-22 15:30:52.000000000 +0900
@@ -226,7 +226,6 @@
 		ldmia	r7, {r2 - r4}			@ Get USR pc, cpsr
 		stmia	r5, {r2 - r4}			@ Save USR pc, cpsr, old_r0
 		stmdb	r5, {sp, lr}^
-		alignment_trap r7, r7, __temp_abt
 		zero_fp
 #ifdef MULTI_ABORT
 		ldr	r4, .LCprocfns			@ pass r2, r3 to
@@ -248,7 +247,6 @@
 		ldmia	r4, {r5 - r7}			@ get saved PC, SPSR
 		stmia	r8, {r5 - r7}			@ save pc, psr, old_r0
 		stmdb	r8, {sp, lr}^
-		alignment_trap r4, r7, __temp_irq
 		zero_fp
 #ifdef CONFIG_PREEMPT
 		get_thread_info r8
@@ -285,7 +283,6 @@
 		ldmia	r4, {r5 - r7}
 		stmia	r8, {r5 - r7}			@ Save USR pc, cpsr, old_r0
 		stmdb	r8, {sp, lr}^			@ Save user sp, lr
-		alignment_trap r4, r7, __temp_und
 		zero_fp
 		tst	r6, #PSR_T_BIT			@ Thumb mode?
 		bne	fpundefinstr			@ ignore FP
@@ -382,7 +379,6 @@
 		ldmia	r4, {r5 - r7}			@ Get USR pc, cpsr
 		stmia	r8, {r5 - r7}			@ Save USR pc, cpsr, old_r0
 		stmdb	r8, {sp, lr}^			@ Save sp_usr lr_usr
-		alignment_trap r4, r7, __temp_abt
 		zero_fp
 		enable_irq r0				@ Enable interrupts
 		mov	r0, r5				@ address (pc)
@@ -399,7 +395,7 @@
 
 /*
  * Register switch for ARMv3 and ARMv4 processors
- * r0 = previous thread_info, r1 = next thread_info
+ * r0 = previous task_struct, r1 = previous thread_info, r2 = next thread_info
  * previous and next are guaranteed not to be the same.
  */
 ENTRY(__switch_to)
diff -Naur linux-2.6.9-uc0/arch/armnommu/kernel/init_task.c linux-2.6.9-hsc0/arch/armnommu/kernel/init_task.c
--- linux-2.6.9-uc0/arch/armnommu/kernel/init_task.c	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/kernel/init_task.c	2004-11-19 15:01:17.000000000 +0900
@@ -7,6 +7,7 @@
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/init_task.h>
+#include <linux/mqueue.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
diff -Naur linux-2.6.9-uc0/arch/armnommu/kernel/Makefile linux-2.6.9-hsc0/arch/armnommu/kernel/Makefile
--- linux-2.6.9-uc0/arch/armnommu/kernel/Makefile	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/kernel/Makefile	2004-11-22 15:17:17.000000000 +0900
@@ -23,7 +23,7 @@
 head-y			:= $(HEADMACH)
 endif
 
-extra-y := $(head-y) init_task.o vmlinux.lds.s
+extra-y := $(head-y) init_task.o vmlinux.lds
 
 # Spell out some dependencies that aren't automatically figured out
 $(obj)/entry.o: 	arch/arm/kernel/entry-header.S include/asm-armnommu/constants.h \
diff -Naur linux-2.6.9-uc0/arch/armnommu/kernel/setup.c linux-2.6.9-hsc0/arch/armnommu/kernel/setup.c
--- linux-2.6.9-uc0/arch/armnommu/kernel/setup.c	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/kernel/setup.c	2004-11-19 15:01:17.000000000 +0900
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/root_dev.h>
 #include <linux/cpu.h>
+#include <linux/interrupt.h>
 
 #include <asm/elf.h>
 #include <asm/hardware.h>
@@ -35,6 +36,7 @@
 
 #include <asm/mach/arch.h>
 #include <asm/mach/irq.h>
+#include <asm/mach/time.h>
 
 #ifndef MEM_SIZE
 #define MEM_SIZE	(16*1024*1024)
@@ -90,7 +92,6 @@
 char elf_platform[ELF_PLATFORM_SIZE];
 EXPORT_SYMBOL(elf_platform);
 
-char saved_command_line[COMMAND_LINE_SIZE];
 unsigned long phys_initrd_start __initdata = 0;
 unsigned long phys_initrd_size __initdata = 0;
 
@@ -724,6 +725,7 @@
 	 * Set up various architecture-specific pointers
 	 */
 	init_arch_irq = mdesc->init_irq;
+	init_arch_time = mdesc->init_time;
 	init_machine = mdesc->init_machine;
 
 #ifdef CONFIG_VT
diff -Naur linux-2.6.9-uc0/arch/armnommu/kernel/sys_arm.c linux-2.6.9-hsc0/arch/armnommu/kernel/sys_arm.c
--- linux-2.6.9-uc0/arch/armnommu/kernel/sys_arm.c	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/kernel/sys_arm.c	2004-11-19 15:08:42.000000000 +0900
@@ -165,14 +165,14 @@
 		union semun fourth;
 		if (!ptr)
 			return -EINVAL;
-		if (get_user(fourth.__pad, (void __user **) ptr))
+		if (get_user(fourth.__pad, (void __user * __user *) ptr))
 			return -EFAULT;
 		return sys_semctl (first, second, third, fourth);
 	}
 
 	case MSGSND:
 		return sys_msgsnd(first, (struct msgbuf __user *) ptr, 
-				   second, third);
+				  second, third);
 	case MSGRCV:
 		switch (version) {
 		case 0: {
@@ -204,11 +204,8 @@
 				return ret;
 			return put_user(raddr, (ulong __user *)third);
 		}
-		case 1:	/* iBCS2 emulator entry point */
-			if (!segment_eq(get_fs(), get_ds()))
-				return -EINVAL;
-			return do_shmat(first, (char __user *) ptr,
-					second, (ulong __user *) third);
+		case 1: /* Of course, we don't support iBCS2! */
+			return -EINVAL;
 		}
 	case SHMDT: 
 		return sys_shmdt ((char __user *)ptr);
@@ -244,7 +241,7 @@
 	if (!newsp)
 		newsp = regs->ARM_sp;
 
-	return do_fork(clone_flags & ~CLONE_IDLETASK, newsp, regs, 0, NULL, NULL);
+	return do_fork(clone_flags, newsp, regs, 0, NULL, NULL);
 }
 
 asmlinkage int sys_vfork(struct pt_regs *regs)
@@ -306,7 +303,7 @@
 		  "Ir" (sizeof(regs))
 		: "r0", "r1", "r2", "r3", "ip", "memory");
 
-out:
+ out:
 	return ret;
 }
 EXPORT_SYMBOL(execve);
diff -Naur linux-2.6.9-uc0/arch/armnommu/kernel/vmlinux.lds.S linux-2.6.9-hsc0/arch/armnommu/kernel/vmlinux.lds.S
--- linux-2.6.9-uc0/arch/armnommu/kernel/vmlinux.lds.S	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/kernel/vmlinux.lds.S	2004-11-23 09:18:56.000000000 +0900
@@ -38,9 +38,6 @@
 		__early_begin = .;
 			*(__early_param)
 		__early_end = .;
-		__start___param = .;
-			*(__param)
-		__stop___param = .;
 		__initcall_start = .;
 			*(.initcall1.init)
 			*(.initcall2.init)
@@ -74,6 +71,7 @@
 		_text = .;		/* Text and read-only data	*/
 			*(.text)
 			SCHED_TEXT
+			LOCK_TEXT
 			*(.fixup)
 			*(.gnu.warning)
 			*(.rodata)
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-atmel/arch.c linux-2.6.9-hsc0/arch/armnommu/mach-atmel/arch.c
--- linux-2.6.9-uc0/arch/armnommu/mach-atmel/arch.c	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-atmel/arch.c	2004-11-19 15:01:17.000000000 +0900
@@ -41,9 +41,13 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/map.h>
 
+extern void atmel_time_init(void);
+
 extern void __init atmel_init_irq(void);
 
+
 MACHINE_START(ATMEL, "ATMEL EB01")
 	MAINTAINER("Hyok S. Choi <hyok.choi@samsung.com>")
 	INITIRQ(atmel_init_irq)
+	INITTIME(atmel_time_init)
 MACHINE_END
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-atmel/Makefile linux-2.6.9-hsc0/arch/armnommu/mach-atmel/Makefile
--- linux-2.6.9-uc0/arch/armnommu/mach-atmel/Makefile	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-atmel/Makefile	2004-11-19 15:01:17.000000000 +0900
@@ -4,4 +4,4 @@
 
 # Object file lists.
 
-obj-y		+= arch.o irq.o
+obj-y		+= arch.o irq.o time.o
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-atmel/time.c linux-2.6.9-hsc0/arch/armnommu/mach-atmel/time.c
--- linux-2.6.9-uc0/arch/armnommu/mach-atmel/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-atmel/time.c	2004-11-19 15:01:17.000000000 +0900
@@ -0,0 +1,97 @@
+/*
+ *  linux/arch/armnommu/mach-atmel/time.c
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *                      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+                                                                                                                                           
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+#include <asm/arch/time.h>
+
+unsigned long atmel_gettimeoffset (void)
+{
+	volatile struct at91_timers* tt = (struct at91_timers*) (AT91_TC_BASE);
+	volatile struct at91_timer_channel* tc = &tt->chans[KERNEL_TIMER].ch;
+	return tc->cv * (1000*1000)/(ARM_CLK/128);
+}
+
+static irqreturn_t
+atmel_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	timer_tick(regs);
+
+    return IRQ_HANDLED;
+}
+
+static struct irqaction atmel_timer_irq = {
+        .name           = "ATMEL Timer Tick",
+        .flags          = SA_INTERRUPT,
+        .handler        = atmel_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+
+void __init  atmel_time_init (void)
+{
+        register volatile struct at91_timers* tt = (struct at91_timers*) (AT91_TC_BASE);
+        register volatile struct at91_timer_channel* tc = &tt->chans[KERNEL_TIMER].ch;
+        unsigned long v;
+
+	/* enable Kernel timer */
+	HW_AT91_TIMER_INIT(KERNEL_TIMER)
+
+        /* No SYNC */
+        tt->bcr = 0;
+        /* program NO signal on XC1 */
+        v = tt->bmr;
+	v &= ~TCNXCNS(KERNEL_TIMER,3);
+	v |= TCNXCNS(KERNEL_TIMER,1);
+        tt->bmr = v;
+
+        tc->ccr = 2;  /* disable the channel */
+
+        /* select ACLK/128 as inupt frequency for TC1 and enable CPCTRG */
+        tc->cmr = 3 | (1 << 14);
+
+        tc->idr = ~0ul;  /* disable all interrupt */
+        tc->rc = ((ARM_CLK/128)/HZ - 1);   /* load the count limit into the CR register */
+        tc->ier = TC_CPCS;  /* enable CPCS interrupt */
+
+	/*
+	 * @todo do those really need to be function pointers ?
+	 */
+        gettimeoffset = atmel_gettimeoffset;
+        atmel_timer_irq.handler = atmel_timer_interrupt;
+
+	/* set up the interrupt */
+        setup_irq(KERNEL_TIMER_IRQ_NUM, &atmel_timer_irq);
+
+        /* enable the channel */
+        tc->ccr = TC_SWTRG|TC_CLKEN;
+}
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/arch.c linux-2.6.9-hsc0/arch/armnommu/mach-espd_4510b/arch.c
--- linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/arch.c	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-espd_4510b/arch.c	2004-11-23 11:18:01.000000000 +0900
@@ -28,6 +28,7 @@
 #include <asm/mach/arch.h>
 
 extern void __init s3c4510b_init_irq(void);
+extern void s3c4510b_time_init(void);
 
 void __init s3c4510b_init_machine(void) {
 	/* enable LED 0 */
@@ -39,4 +40,5 @@
 	INITIRQ( s3c4510b_init_irq)
 	INIT_MACHINE( s3c4510b_init_machine)
 	BOOT_PARAMS(0x00000800)
+	INITTIME( s3c4510b_time_init)
 MACHINE_END
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/Makefile linux-2.6.9-hsc0/arch/armnommu/mach-espd_4510b/Makefile
--- linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/Makefile	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-espd_4510b/Makefile	2004-11-23 10:37:02.000000000 +0900
@@ -4,4 +4,4 @@
 
 # Object file lists.
 
-obj-y		+= arch.o irq.o mm.o dma.o
+obj-y		+= arch.o irq.o mm.o dma.o time.o
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/time.c linux-2.6.9-hsc0/arch/armnommu/mach-espd_4510b/time.c
--- linux-2.6.9-uc0/arch/armnommu/mach-espd_4510b/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-espd_4510b/time.c	2004-11-23 10:36:46.000000000 +0900
@@ -0,0 +1,115 @@
+/*
+ *  linux/arch/armnommu/mach-espd_4510b/time.c
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *                      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+                                                                                                                                           
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/arch/timex.h>
+#include <asm/mach/irq.h>
+                                                                                                                                           
+#define CLOCKS_PER_USEC (CONFIG_ARM_CLK/1000000)
+                                                                                                                                           
+static volatile unsigned long timer_cnt;
+                                                                                                                                           
+unsigned long s3c4510b_gettimeoffset (void)
+{
+        unsigned long usec;
+                                                                                                                                           
+        /* returns microseconds -- timer 1 is free running in countdown mode */
+        usec = 0xFFFFFFFF - inl( REG_TCNT1);
+        usec /= CLOCKS_PER_USEC;
+                                                                                                                                           
+        return usec;
+}
+                                                                                                                                           
+static irqreturn_t
+s3c4510b_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+                                                                                                                                           
+        timer_cnt++;
+                                                                                                                                           
+#ifdef CONFIG_ARCH_ESPD_4510B
+        if ( ! (timer_cnt % (HZ/4))) {
+                LED_TOGGLE(0);
+        }
+#endif
+        timer_tick(regs);
+                                                                                                                                           
+        return IRQ_HANDLED;
+}
+
+static struct irqaction s3c4510b_timer_irq = {
+        .name           = "S3C4510b Timer Tick",
+        .flags          = SA_INTERRUPT,
+        .handler        = s3c4510b_timer_interrupt
+};
+
+                                                                                                                                           
+/*
+ * Set up timer interrupt
+ */
+                                                                                                                                           
+void __init  s3c4510b_time_init (void)
+{
+        u_int32_t period;
+                                                                                                                                           
+        /*
+         * disable and clear timers 0 and 1.  set both timers to
+         * interval mode.
+         */
+        outl( 0x0, REG_TMOD);
+        /* clear any pending interrupts */
+        outl( 0x1FFFFF, REG_INTPEND);
+                                                                                                                                           
+        timer_cnt = 0;
+                                                                                                                                           
+        /* initialize the timer period */
+        period = (CLOCK_TICK_RATE / HZ);
+        outl( period, REG_TDATA0);
+                                                                                                                                           
+        /* set timer1 to continually count down from FFFFFFFF */
+        outl( 0xFFFFFFFF, REG_TDATA1);
+                                                                                                                                           
+//      printk(KERN_INFO "time_init():  TICK_RATE: %u, HZ: %u, period: %u\n", CLOCK_TICK_RATE, HZ, period);
+                                                                                                                                           
+        gettimeoffset     = s3c4510b_gettimeoffset;
+        s3c4510b_timer_irq.handler = s3c4510b_timer_interrupt;
+                                                                                                                                           
+        /* set up the interrupt vevtor for timer 0 match */
+        setup_irq( INT_TIMER0, &s3c4510b_timer_irq);
+                                                                                                                                           
+        /* enable the timer IRQ */
+        INT_ENABLE( INT_TIMER0);
+                                                                                                                                           
+        /* let timer 0 run... */
+        outl( TM0_RUN | TM1_RUN, REG_TMOD);
+}
+                                                                                                                                           
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/clocks.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/clocks.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/clocks.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/clocks.c	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,118 @@
+/*
+ *  arch/arm/mach-s3c24a0/clocks.c
+ *
+ *  $Id: clocks.c,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <asm/errno.h>
+#include <asm/arch/clocks.h>
+
+
+
+static unsigned long get_usb_clk_freq(int who)
+{
+        unsigned long val = UPLLCON;
+
+        if (CLKSRC & (1<<7)) return 0;  /* UPLL OFF */
+        val = ((GET_MDIV(val) + 8) * FIN)/((GET_PDIV(val) + 2) * (1 << GET_SDIV(val)));
+        return val;
+}
+
+/* 
+ * CLKDIVN  differs from S3C24A0X to S3C24A0A 
+ * --SW.LEE
+ */
+
+static inline unsigned long
+cal_bus_clk(unsigned long cpu_clk, unsigned long ratio, int who)
+{
+	unsigned long hclk = 0;
+	unsigned long pclk = 0;
+
+	if (who == GET_UPLL)
+		return get_usb_clk_freq(GET_UPLL); 
+
+	switch (ratio & 0x6) {
+		case 0:
+			hclk = cpu_clk;
+			break;
+		case 2:
+			hclk = cpu_clk/2;
+			break; 
+		case 4:
+			hclk = cpu_clk/4;
+			break; 
+		default:
+			panic("Wrong Value in CLKDIVN");
+	}
+	switch (ratio & 0x1) {
+		case 0:
+			pclk = hclk;
+			break;
+		case 1:
+			pclk = hclk/2;
+			break;
+	}
+
+	if (who == GET_HCLK) 
+			return hclk;
+	else {
+		if (who == GET_PCLK) 
+			return pclk;
+		else 
+			panic("Wrong Clock requested ");
+	}
+}
+
+
+/*
+ * cpu clock = (((mdiv + 8) * FIN) / ((pdiv + 2) * (1 << sdiv)))
+ *  FIN = Input Frequency (to CPU)
+ */
+unsigned long
+elfin_get_cpu_clk(void)
+{
+	unsigned long val = MPLLCON;
+	
+	return (((GET_MDIV(val) + 8) * FIN) / ((GET_PDIV(val) + 2) * (1 << GET_SDIV(val))));
+}
+EXPORT_SYMBOL(elfin_get_cpu_clk);
+
+unsigned long
+elfin_get_bus_clk(int who)
+{
+	unsigned long cpu_clk = elfin_get_cpu_clk();
+	unsigned long ratio = CLKDIVN_BUS;
+
+	return (cal_bus_clk(cpu_clk, ratio, who));
+}
+EXPORT_SYMBOL(elfin_get_bus_clk);
+
+#define MEGA	(1000 * 1000)
+static int __init elfin_cpu_init(void)
+{
+	unsigned long freq, hclk, pclk;
+
+	freq = elfin_get_cpu_clk();
+	hclk = elfin_get_bus_clk(GET_HCLK);
+	pclk = elfin_get_bus_clk(GET_PCLK);
+
+	printk(KERN_INFO "CPU clock = %ld.%03ld Mhz,", freq / MEGA, freq % MEGA);
+	
+	printk(" HCLK = %ld.%03ld Mhz, PCLK = %ld.%03ld Mhz\n",
+		 hclk / MEGA, hclk % MEGA, pclk / MEGA, pclk % MEGA);
+
+	return 0;
+}
+
+__initcall(elfin_cpu_init);
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/entry-macro.S linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/entry-macro.S
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/entry-macro.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/entry-macro.S	2004-11-23 13:35:39.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ *  arch/armnommu/mach-s3c24a0/entry-macro.S
+ * 
+ *  Heechul Yun <heechul.yun@samsung.com>
+ */
+
+#if defined(CONFIG_ARCH_S3C24A0)
+#include <asm/hardware.h>        
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+                mov     \irqstat,   #io_p2v(0x40000000) @ Virtual Address
+                add     \irqstat, \irqstat,#0x00200000  @ INT Ctrl base
+                                                                                                                                                      
+                ldr     \irqnr,   [\irqstat,#0x14]      @ INTOFFSET
+                cmp     \irqnr,#0
+                bne     1002f
+                ldr     \irqstat,[\irqstat,#-0x4]       @ INTPND
+                tst     \irqstat,#0x1                   @ EINT0_2 happens ?
+1002:
+        
+                .endm 
+		.macro	disable_fiq
+		.endm
+
+		/* we don't have an irq priority table */
+		.macro irq_prio_table
+		.endm
+#endif
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/generic.h linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/generic.h
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/generic.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/generic.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,14 @@
+/*
+ *  /arch/arm/mach-s3c24a0/generic.h
+ *
+ * 	$Id: generic.h,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ * 	
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+extern void __init elfin_map_io(void);
+extern void __init elfin_init_irq(void);
+
+/* drivers/serial/serial_s3c24a0.c */
+extern void __init elfin_register_uart(int idx, int port);
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/head.S linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/head.S
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/head.S	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,166 @@
+/*
+ *  linux/arch/armnommu/mach-s3c24a0/head.S
+ *
+ *  Taken from mach-s5c7375/head.S
+ *         
+ *  modified by heechul.yun@samsung.com 
+ */
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/assembler.h>
+#include <asm/mach-types.h>
+#include <asm/procinfo.h>
+#include <asm/ptrace.h>
+#include <asm/mach/arch.h>
+
+/*
+ * Kernel startup entry point.
+ */
+	__INIT
+	.type	stext, #function
+ENTRY(stext)
+	mov	r12, r0
+	mov	r0, #PSR_F_BIT | PSR_I_BIT | MODE_SVC	@ make sure svc mode
+	msr	cpsr_c, r0			@ and all irqs disabled
+
+/*
+ * ARM920T need MMU enable for D-cache.
+ * we just make the identical table before the MMU enabling.
+ */
+#ifdef CONFIG_CPU_MXU_ENABLE
+	/* Write domain id (cp15_r3) */
+	mvn	r0, #0			/* Domains 0, 1 = client */
+	mcr	p15, 0, r0, c3, c0, 0	/* load domain access register */
+	/* Set control register v4 */
+
+	mov	r0, #0
+	mcr	p15, 0, r0, c13, c0, 0	/* zero PID */
+	mcr	p15, 0, r0, c7, c7, 0	/* invalidate I,D caches */
+	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
+	mcr	p15, 0, r0, c8, c7, 0	/* invalidate I,D TLBs */
+	mrc	p15, 0, r0, c1, c0, 0	/* get control register */
+	bic	r0, r0, #0x0001		/* disable MMU */
+	mcr	p15, 0, r0, c1, c0, 0	/* write control register */
+
+                
+init_ttb:
+        /*
+         * We must reserve DRAM_BASE ~ DRAM_BASE+0x8000. 
+         * And Kernel TEXTADDR must be after DRAM_BASE + 0x8000
+         */ 
+#if !defined(CONFIG_DRAM_BASE) || !defined(CONFIG_DRAM_SIZE) 
+        #define CONFIG_DRAM_BASE 0x10000000
+        #define CONFIG_DRAM_SIZE 0x04000000 
+#endif 
+        ldr     r0,=(CONFIG_DRAM_BASE + 0x4000) /* set TTB (Must be on 16KB boundary) */ 
+        mcr     p15, 0, r0, c2, c0, 0   /* write to TTB(CP15,c2) */
+        
+	/* 
+	 *
+	 * Create translation table for flat mapping
+	 * Top 12 bits of VA is pointer into table
+	 * Create 4096 entries from 000xxxxx to fffxxxxx
+         * 
+	 * Set Section descriptor. 4K entry totla and 
+         * each entry describe 1MB. 
+	 */
+	mov	r1, #0x1000                 @ 4K counter 
+	subs 	r1,r1,#1
+        mov     r2,#0b110000000000          @ set access permissions (AP) for full access SVC/USR (11:10)
+        orr     r2,r2,#0b000111100000       @ set for domain 15 (8:5)
+        orr     r2,r2,#0b000000010000       @ must be 1 (4)
+        orr     r2,r2,#0b000000000000       @ set non cachable non bufferable (CB) (3:2)
+        orr     r2,r2,#0b000000000010       @ set for 1Mb section (1:0)
+init_ttb_1: /* create 4K entry */ 
+        orr     r3,r2,r1,lsl#20             @ use loop counter to create individual table entries
+        str     r3,[r0,r1,lsl#2]            @ str r3 at TTB base + loopcount*4
+        subs    r1,r1,#1                    @ decrement loop counter
+        bpl     init_ttb_1
+
+	/* resetting the SDRAM area to cacheable*/
+        /* DRAM_BASE ~ DRAM_BASE+DRAM_SIZE */
+        /* 64MB -> 64 entry -> 0x40 */ 
+	mov	r1, #(CONFIG_DRAM_SIZE >> 20 ) @ 64 entry =ase addr
+        subs    r1, r1, #1
+        
+	mov     r2,#0b110000000000          @ set access permissions (AP) for full access SVC/USR (11:10)
+	orr     r2,r2,#0b000111100000       @ set for domain 15 (8:5)
+	orr     r2,r2,#0b000000010000       @ must be 1 (4)
+	orr     r2,r2,#0b000000001100       @ set cachable but unbufferable (CB) (3:2)
+	orr     r2,r2,#0b000000000010       @ set for 1Mb section (1:0)
+
+init_ttb_2: /* create 64 entry (for 64MB SDRAM) */
+        add     r4, r1, #(CONFIG_DRAM_BASE >> 20 )  @ drambase >> 20 bit .
+        orr     r3,r2,r4,lsl#20             @ use loop counter to create individual table entries
+	str     r3,[r0,r4,lsl#2]            @ str r3 at TTB base + loopcount*4
+	subs    r1,r1,#1                    @ decrement loop counter
+	bpl     init_ttb_2
+	@init_domains : we define all domains are manager. so no access permission check is occured.
+	mvn     r0, #0				@ trick. 0 -1 == 0xFFFFFFFF
+	mcr     p15, 0, r0, c3, c0, 0       @ write to CP15 register 5
+/*
+ * set global core configurations
+ */
+        mrc     p15, 0, r0, c1, c0, 0       @ read CP15 register 1 into r0
+       
+#ifndef CONFIG_CPU_ICACHE_DISABLE         
+        orr     r0, r0, #(0x1 <<12)         @ enable I Cache
+#endif         
+#ifndef CONFIG_CPU_DCACHE_DISABLE        
+        orr     r0, r0, #(0x1 <<2)          @ enable D Cache
+#endif
+#ifdef  CONFIG_ALIGNMENT_TRAP
+        orr     r0, r0, #2                  @ ...........A. 
+#endif                 
+        orr     r0, r0, #(0b11 <<30)        @ enable asynchronous clocking mode
+        orr     r0, r0, #0x1                @ enable MMU
+
+        mcr     p15, 0, r0, c1, c0, 0       @ write cp15 register 1
+
+#endif
+
+/*
+ * stuffs for cache are done.
+ * Now we setup the stack and machine id, and start the kernel!
+ */
+
+        adr	r5, LC0
+        ldmia	r5, {r5, r6, r7, r8, r9, sp}			@ Setup stack
+
+        /*  Copy data sections to their new home.  */
+
+
+        /*  Clear BSS */
+        mov	r4, #0
+1:      cmp	r5, r8					
+        strcc	r4, [r5],#4
+        bcc	1b
+
+        /*  Pretend we know what our processor code is (for arm_id)   */
+
+	ldr	r2, S3C24A0_PROCESSOR_TYPE
+
+	str     r2, [r6]
+	ldr     r2, S3C24A0_MACH_TYPE
+	str     r2, [r9]
+
+        str     r0, [r7]        /* save c1 to cr_alignment */ 
+
+        mov fp, #0
+        b	start_kernel
+        
+LC0:	.long	__bss_start                     @ r5
+        .long	processor_id                    @ r6
+        .long   cr_alignment                    @ r7 
+        .long	_end                            @ r8 
+	.long   __machine_arch_type             @ r9 
+        .long	init_thread_union+8192          @ sp 
+	
+S3C24A0_PROCESSOR_TYPE:
+	.long	0x41069264
+S3C24A0_MACH_TYPE:
+	.long	MACH_TYPE_S3C24A0 
+
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/irq.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/irq.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/irq.c	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,314 @@
+/*$)C
+ *  arch/arm/mach-s3c24a0/irq.c
+ *
+ *  Generic S3C24A0 IRQ handling.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <linux/sysdev.h>
+
+/* Pendng registers
+ *
+ * INTPND               0x40200010
+ * SUBINTPND    0x40200018
+ * EINTPND              0x44800038
+ */
+static const unsigned long p_regs[3] = { 0x40200010, 0x40200018, 0x44800038 };
+
+/* Mask registers
+ *
+ * INTMSK               0x40200008
+ * SUBINTMSK    0x4020001c
+ * EINTMSK              0x44800034
+ */
+
+static const unsigned long m_regs[3] = { 0x40200008, 0x4020001c, 0x44800034 };
+
+/*
+ * Interrupt table
+ */
+static const int r_irqs[NR_IRQS] = {
+        96, 96, 96, 96, 96,  5,  6,  7,  8,  9, 10, 11, 12, 96, 96, 15,
+        96, 96, 18, 19, 96, 21, 22, 96, 96, 25, 26, 27, 96, 29, 30, 96,
+        17, 17, 17, 23, 23, 23, 28, 28, 96, 96, 96, 13, 13, 16, 16, 14,
+        14, 31, 31, 31, 14, 24, 24, 29, 29, 20, 20, 20, 20, 96, 96, 96,
+         0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  4,
+         4,  4,  4, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96
+};
+
+static inline void clear_pending(int irq)
+{
+        int i = r_irqs[irq];
+        if (i == NR_IRQS)
+                return;
+
+        *(volatile unsigned long *)(io_p2v(p_regs[irq >> 5])) = (1 << (irq % 32));
+        SRCPND = (1 << i);
+        INTPND = INTPND;
+        INTPND;
+}
+
+static inline int read_pending(int irq)
+{
+        return ((*(volatile unsigned long *)(io_p2v(p_regs[irq >> 5]))) & (1 << (irq % 32)));
+}
+
+static inline void mask_irq(int irq)
+{
+        *(volatile unsigned long *)(io_p2v(m_regs[irq >> 5])) |= (1 << (irq % 32));
+}
+
+static inline void unmask_irq(int irq)
+{
+        *(volatile unsigned long *)(io_p2v(m_regs[irq >> 5])) &= ~(1 << (irq % 32));
+}
+
+//#define DEBUG // hcyun
+#undef DEBUG
+
+static inline int find_irq(int irq)
+{
+        int i;
+
+#ifdef DEBUG
+        if ( irq == 4 || irq == 3 ) printk("find_irq: irq=%d\n", irq);
+#endif
+
+        for (i = IRQ_GRP1_START; i < NR_IRQS; i++) {
+                if (r_irqs[i] == irq) {
+#ifdef DEBUG
+                        if ( i >= 64 ) printk("Externel IRQ %d\n", i);
+                        else if ( i >= 32 ) printk("Sub IRQ %d\n", i);
+#endif
+
+                        if (read_pending(i)) {
+#ifdef DEBUG
+                                if ( i >= 64 ) printk("OK there's external pending IRQ %d\n", i);
+                                else if ( i >= 32 ) printk("OK there's sub pending IRQ %d\n", i);
+#endif
+                                return i;
+                        }
+                }
+        }
+        return NR_IRQS;
+}
+
+int fixup_irq(int irq)
+{
+        int retval = NR_IRQS;
+
+        if (irq >= IRQ_GRP1_START)
+                return retval;
+
+        if ((r_irqs[irq]) == NR_IRQS) {
+                retval = find_irq(irq);
+        } else {
+                retval = irq;
+        }
+
+        return retval;
+}
+
+static void elfin_mask_ack_irq(unsigned int irq)
+{
+        mask_irq(irq);
+        clear_pending(irq);
+}
+
+static void elfin_ack_irq(unsigned int irq)
+{
+        clear_pending(irq);
+}
+
+static void elfin_mask_irq(unsigned int irq)
+{
+        mask_irq(irq);
+}
+
+static void elfin_unmask_irq(unsigned int irq)
+{
+        unmask_irq(irq);
+}
+
+static struct irqchip s3c24a0_irq_chip = {
+        .ack    = elfin_ack_irq,  // irq_ack
+        .mask   = elfin_mask_irq,  // irq_mask
+        .unmask = elfin_unmask_irq   // irq_unmak
+};
+
+
+
+#ifdef CONFIG_PM
+static unsigned long ic_irq_enable;
+
+static int irq_suspend(struct sys_device *dev, u32 state)
+{
+        return 0;
+}
+
+static int irq_resume(struct sys_device *dev)
+{
+        /* disable all irq sources */
+        return 0;
+}
+#else
+#define irq_suspend NULL
+#define irq_resume NULL
+#endif
+
+static struct sysdev_class irq_class = {
+        set_kset_name("irq"),
+        .suspend        = irq_suspend,
+        .resume         = irq_resume,
+};
+
+static struct sys_device irq_device = {
+        .id     = 0,
+        .cls    = &irq_class,
+};
+
+static int __init irq_init_sysfs(void)
+{
+        int ret = sysdev_class_register(&irq_class);
+        if (ret == 0)
+                ret = sysdev_register(&irq_device);
+        return ret;
+}
+
+device_initcall(irq_init_sysfs);
+
+void __init elfin_init_irq(void)
+{
+        int irq;
+
+        unsigned int flags;
+
+        /* disable all interrupts */
+        INTSUBMSK = 0xffffffff;
+        EINTMASK = 0xffffffff;
+        INTMSK = 0xffffffff;
+
+        /* clear status registers */
+        EINTPEND = EINTPEND;
+        SUBSRCPND = SUBSRCPND;
+        SRCPND = SRCPND;
+        INTPND = INTPND;
+
+        /* all interrupts set as IRQ */
+        INTMOD = 0x00000000;
+
+        /* we have three groups */
+        for (irq = 0; irq < NR_IRQS; irq++) {
+                flags = IRQF_PROBE;
+
+                /* external IRQ */
+                if ((r_irqs[irq]) == NR_IRQS) {
+                        if (irq < IRQ_GRP1_START)
+                                INTMSK &= ~(1 << irq);
+                }
+                /* main IRQ */
+                else if ( irq < IRQ_GRP2_START )
+                        flags |= IRQF_VALID;
+
+                set_irq_chip(irq, &s3c24a0_irq_chip);
+                set_irq_handler(irq, do_edge_IRQ);
+                set_irq_flags(irq, flags);
+        }
+}
+
+/*
+ * S3C24A0 , External Interrupt setting interface
+ *
+ *  1) GPIO-A8: external irq$)C
+ *  2) Edge setting
+ *                         |<--ECTRL-->|<--GPIO--->|
+ *                           bit   reg   bit   reg
+ *                           ofs   ofs   ofs   ofs
+ * +-----+-----+-----+-----+-----+-----+-----+-----+
+ * |4-bit|4-bit|4-bit|4-bit|4-bit|4-bit|4-bit|4-bit|
+ * +-----+-----+-----+-----+-----+-----+-----+-----+
+ */
+
+static const unsigned long garbage[] = {
+        0xffff0000,     /* EINT 0 */
+        0xffff1010,     /* EINT 1 */
+        0xffff2020,     /* EINT 2 */
+        0xffff0130,     /* EINT 3 */
+        0xffff1140,     /* EINT 4 */
+        0xffff2150,     /* EINT 5 */
+        0xffff3160,     /* EINT 6 */
+        0xffff4170,     /* EINT 7 */
+        0xffff5180,     /* EINT 8 */
+        0xffff6190,     /* EINT 9 */
+        0xffff71a0,     /* EINT 10 */
+        0xffff0201,     /* EINT 11 */
+        0xffff1211,     /* EINT 12 */
+        0xffff2221,     /* EINT 13 */
+        0xffff3231,     /* EINT 14 */
+        0xffff4241,     /* EINT 15 */
+        0xffff5251,     /* EINT 16 */
+        0xffff6261,     /* EINT 17 */
+        0xffff7271,     /* EINT 18 */
+};
+
+int set_external_irq(int irq, int edge, int pullup)
+{
+        int phy_irq = EINTIRQ_DEC(irq); /* physical irq number */
+        unsigned long g;
+        struct irqdesc *desc;
+
+
+        if (phy_irq > 18)
+                return -EINVAL;
+
+        g = garbage[phy_irq];
+
+        /* GPIO setting */
+        *(volatile unsigned long *)(io_p2v(0x44800008 - (0x4 * (g & 0x0000000f)))) &= ~(0x3 << (((g & 0x000000f0) >> 0x4) * 0x2));
+        *(volatile unsigned long *)(io_p2v(0x44800008 - (0x4 * (g & 0x0000000f)))) |= (0x2 << (((g & 0x000000f0) >> 0x4) * 0x2));
+
+#if 0
+        printk("GPIO(0x%x) = 0x%x\n", io_p2v(0x44800008), *(volatile unsigned long *)io_p2v(0x44800008));
+        printk("GPIO(0x%x) = 0x%x\n", io_p2v(0x44800004), *(volatile unsigned long *)io_p2v(0x44800004));
+#endif
+
+        /* edge setting */
+        *(volatile unsigned long *)(io_p2v(0x44800018 + (0x4 * ((g & 0x00000f00) >> 0x8)))) &= ~(0x7 << (((g & 0x0000f000) >> 0xc) * 0x4));
+        *(volatile unsigned long *)(io_p2v(0x44800018 + (0x4 * ((g & 0x00000f00) >> 0x8)))) |= (edge << (((g & 0x0000f000) >> 0xc) * 0x4));
+
+        /* Set pullup */
+        GPUP &= ~(1 << phy_irq);
+        GPUP |= pullup;
+
+        desc = irq_desc + irq;
+        desc->valid = 1;
+
+        switch ( edge ) {
+        case EINT_FALLING_EDGE:
+        case EINT_RISING_EDGE:
+        case EINT_BOTH_EDGES:
+                set_irq_handler(irq, do_edge_IRQ);
+                break;
+        case EINT_LOW_LEVEL:
+        case EINT_HIGH_LEVEL:
+                set_irq_handler(irq, do_level_IRQ);
+                break;
+        }
+        clear_pending(irq);
+        return 0;
+}
+
+EXPORT_SYMBOL(set_external_irq);
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/Kconfig linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/Kconfig
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/Kconfig	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,13 @@
+if ARCH_S3C24A0
+
+menu "S3C24A0 Implementations" 
+
+config ARCH_SMDK24A0 
+        bool "Meritek SMDK24A0" 
+     
+config ARCH_SPJ
+        depends on ARCH_SMDK24A0 
+        bool "Bluetek SPJ Daughter Board for SMDK24A0" 
+endmenu 
+
+endif 
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/leds.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/leds.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/leds.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/leds.c	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,30 @@
+/*
+ *  /arch/arm/mach-s3c24a0/leds.c
+ *
+ * 	$Id: leds.c,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ * 	
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include "leds.h"
+
+static int __init
+s3c24a0_leds_init(void)
+{
+#ifdef CONFIG_BOARD_SMDK24A0
+	if (machine_is_s3c24a0())
+		leds_event = smdk_leds_event;
+#endif
+
+	leds_event(led_start);
+	return 0;
+}
+
+__initcall(s3c24a0_leds_init);
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/leds.h linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/leds.h
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/leds.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/leds.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,7 @@
+/*
+ * arch/arm/mach-s3c24a0/leds.h
+ *
+ * $Id: leds.h,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ *
+ */
+extern void smdk_leds_event(led_event_t evt);
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/leds-smdk.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/leds-smdk.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/leds-smdk.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/leds-smdk.c	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,122 @@
+/*
+ *  arch/arm/mach-s3c24a0/leds-smdk.c
+ *
+ *  $Id: leds-smdk.c,v 1.1 2004/06/03 01:35:02 hcyun Exp $
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/leds.h>
+#include <asm/system.h>
+#include <asm/arch/smdk.h>
+
+#include "leds.h"
+
+#define LED_STATE_ENABLED	1
+#define LED_STATE_CLAIMED	2
+
+#define LED0		(1 << 0)
+#define LED1		(1 << 1)
+#define LED2		(1 << 2)
+#define LED3		(1 << 3)	
+
+static unsigned int led_state;
+static unsigned int hw_led_state;
+
+static inline void
+led_update(unsigned int state)
+{
+	write_gpio_bit(SMDK_LED4, (state & LED0));
+	write_gpio_bit(SMDK_LED5, ((state & LED1) >> 1));
+	write_gpio_bit(SMDK_LED6, ((state & LED2) >> 2));
+	write_gpio_bit(SMDK_LED7, ((state & LED3) >> 3));
+}
+
+void
+smdk_leds_event(led_event_t evt)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch (evt) {
+	case led_start:
+		hw_led_state = (LED1 | LED2 | LED3);
+		led_state = LED_STATE_ENABLED;
+		break;
+
+	case led_stop:
+		led_state &= ~LED_STATE_ENABLED;
+		hw_led_state = (LED0 | LED1 | LED2 | LED3);
+		led_update(hw_led_state);
+		break;
+
+	case led_claim:
+		led_state |= LED_STATE_CLAIMED;
+		hw_led_state = (LED0 | LED1 | LED2 | LED3);
+		break;
+
+	case led_release:
+		led_state &= ~LED_STATE_CLAIMED;
+		hw_led_state = (LED1 | LED2 | LED3);
+		break;
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:
+		if (!(led_state & LED_STATE_CLAIMED))
+			hw_led_state ^= LED3;
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_CPU
+	case led_idle_start:
+		if (!(led_state & LED_STATE_CLAIMED))
+			hw_led_state |= LED2;
+		break;
+
+	case led_idle_end:
+		if (!(led_state & LED_STATE_CLAIMED))
+			hw_led_state &= ~LED2;
+		break;
+#endif
+
+	case led_halted:
+		break;
+
+	case led_green_on:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state &= ~LED2;
+		break;
+
+	case led_green_off:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state |= LED2;
+		break;
+
+	case led_amber_on:
+		break;
+
+	case led_amber_off:
+		break;
+
+	case led_red_on:
+		break;
+
+	case led_red_off:
+		break;
+
+	default:
+		break;
+	}
+
+	if (led_state & LED_STATE_ENABLED)
+		led_update(hw_led_state);
+
+	local_irq_restore(flags);
+}
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/Makefile linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/Makefile
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/Makefile	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,28 @@
+$(Error:FIXME)
+
+#
+# Makefile for the linux kernel.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+USE_STANDARD_AS_RULE := true
+
+
+obj-y :=
+obj-m := registers.o
+obj-n :=
+obj-  :=
+
+# Common support (must be linked before board specific support)
+obj-y += irq.o clocks.o 
+
+# Specific board support
+obj-$(CONFIG_ARCH_SMDK24A0) += smdk.o
+
+# LEDs support
+leds-y := leds.o
+leds-$(CONFIG_ARCH_SMDK24A0) += leds-smdk.o
+obj-$(CONFIG_LEDS) += $(leds-y)
+ 
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/registers.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/registers.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/registers.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/registers.c	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,260 @@
+/*
+ * arch/arm/mach-s3c24a0/register.c
+ *
+ * S3C24A0 register monitor & controller
+ *
+ * $Id: registers.c,v 1.1 2004/06/03 01:35:10 hcyun Exp $
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+ 	
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>               /* because we are a module */
+#include <linux/init.h>                 /* for the __init macros */
+#include <linux/proc_fs.h>              /* all the /proc functions */
+#include <linux/ioport.h>
+#include <asm/uaccess.h>                /* to copy to/from userspace */
+#include <asm/arch/hardware.h>
+
+#define MODULE_NAME "regmon"
+#define CPU_DIRNAME "cpu"
+#define REG_DIRNAME "registers"
+
+static ssize_t proc_read_reg(struct file * file, char * buf,
+		size_t nbytes, loff_t *ppos);
+static ssize_t proc_write_reg(struct file * file, const char * buffer,
+		size_t count, loff_t *ppos);
+
+static struct file_operations proc_reg_operations = {
+	read:	proc_read_reg,
+	write:	proc_write_reg
+};
+
+typedef struct elfin_reg_entry {
+	u32 phyaddr;
+	char* name;
+	unsigned short low_ino;
+} elfin_reg_entry_t;
+
+static elfin_reg_entry_t elfin_regs[] =
+{
+/*	{ phyaddr,    name } */
+
+	/* PLL clock */	
+	{0x40000000, "LOCKTIME"},
+	{0x40000004, "OSCWEST"},
+	{0x40000010, "MPLLCON"},
+	{0x40000014, "UPLLCON"},
+	{0x40000020, "CLKCON"},
+	{0x40000024, "CLKSRC"},
+	{0x40000028, "CLKDIV"},
+	{0x40000030, "PWRMAN"},
+	{0x40000038, "SOFTRESET"},
+
+	/* INT */
+	{0x40200000, "SRCPND"},
+	{0x40200004, "INTMOD"},
+	{0x40200008, "INTMSK"},
+	{0x4020000c, "PRIORITY"},
+	{0x40200010, "INTPND"},
+	{0x40200014, "INTOFFSET"},
+	{0x40200018, "SUBSRCPND"},
+	{0x4020001c, "INTSUBMSK"},
+	{0x40200020, "VECINTMOD"},
+	{0x40200024, "VECADDR"},
+	{0x40200028, "NVECADDR"},
+	{0x4020002c, "VAR"},
+
+	/* SROM */
+	{0x40c20000, "SROM_BW"},
+	{0x40c20004, "SROM_BC0"},
+	{0x40c20008, "SROM_BC1"},
+	{0x40c2000c, "SROM_BC2"},
+
+	/* PWM timer */
+	{0x44000000, "TCFG0"},
+	{0x44000004, "TCFG1"},
+	{0x44000008, "TCON"},
+	{0x4400000c, "TCNTB0"},
+	{0x44000010, "TCMPB0"},
+	{0x44000014, "TCNTO0"},
+	{0x44000018, "TCNTB1"},
+	{0x4400001c, "TCMPB1"},
+	{0x44000020, "TCNTO1"},
+	{0x44000024, "TCNTB2"},
+	{0x44000028, "TCMPB2"},
+	{0x4400002c, "TCNTO2"},
+	{0x44000030, "TCNTB3"},
+	{0x44000034, "TCMPB3"},
+	{0x44000038, "TCNTO3"},
+	{0x4400003c, "TCNTB4"},
+	{0x44000040, "TCNTO4"},
+
+	/* CamIF */
+	{0x48000004, "CAM_STAY1"},
+	{0x48000008, "CAM_STAY2"},
+	{0x4800000c, "CAM_STAY3"},
+	{0x48000010, "CAM_STAY4"},
+	{0x48000000, "CAM_RDSTAT"},
+
+	/* Post Processor */
+	{0x4a100000, "VP_MODE"},
+	{0x4a100004, "VP_RATIO_Y"},
+	{0x4a100008, "VP_RATIO_CB"},
+	{0x4a10000c, "VP_RATIO_CR"},
+	{0x4a100010, "VP_SRC_WIDTH"},
+	{0x4a100014, "VP_SRC_HEIGHT"},
+	{0x4a100018, "VP_DST_WIDTH"},
+	{0x4a10001c, "VP_DST_HEIGHT"},
+	{0x4a100020, "VP_START_Y1"},
+	{0x4a100024, "VP_START_Y2"},
+	{0x4a100028, "VP_START_Y3"},
+	{0x4a10002c, "VP_START_Y4"},
+	{0x4a100030, "VP_START_CB1"},
+	{0x4a100034, "VP_START_CB2"},
+	{0x4a100038, "VP_START_CB3"},
+	{0x4a10003c, "VP_START_CB4"},
+	{0x4a100040, "VP_START_CR1"},
+	{0x4a100044, "VP_START_CR2"},
+	{0x4a100048, "VP_START_CR3"},
+	{0x4a10004c, "VP_START_CR4"},
+	{0x4a100050, "VP_START_RGB1"},
+	{0x4a100054, "VP_START_RGB2"},
+	{0x4a100058, "VP_START_RGB3"},
+	{0x4a10005c, "VP_START_RGB4"},
+	{0x4a100060, "VP_END_Y1"},
+	{0x4a100064, "VP_END_Y2"},
+	{0x4a100068, "VP_END_Y3"},
+	{0x4a10006c, "VP_END_Y4"},
+	{0x4a100070, "VP_END_CB1"},
+	{0x4a100074, "VP_END_CB2"},
+	{0x4a100078, "VP_END_CB3"},
+	{0x4a10007c, "VP_END_CB4"},
+	{0x4a100080, "VP_END_CR1"},
+	{0x4a100084, "VP_END_CR2"},
+	{0x4a100088, "VP_END_CR3"},
+	{0x4a10008c, "VP_END_CR4"},
+	{0x4a100090, "VP_END_RGB1"},
+	{0x4a100094, "VP_END_RGB2"},
+	{0x4a100098, "VP_END_RGB3"},
+	{0x4a10009c, "VP_END_RGB4"},
+	{0x4a1000f0, "VP_BYPASS"},
+	{0x4a1000f4, "VP_OFS_Y"},
+	{0x4a1000f8, "VP_OFS_CB"},
+	{0x4a1000fc, "VP_OFS_CR"},
+	{0x4a100100, "VP_OFS_RGB"},
+
+	/* BUS matrix */
+	{0x40ce0000, "BUS_PRIORITY0"},
+	{0x40ce0004, "BUS_PRIORITY1"},
+};
+
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
+
+static int proc_read_reg(struct file * file, char * buf,
+		size_t nbytes, loff_t *ppos)
+{
+	int i_ino = (file->f_dentry->d_inode)->i_ino;
+	char outputbuf[15];
+	int count;
+	int i;
+	elfin_reg_entry_t* current_reg=NULL;
+	if (*ppos>0) /* Assume reading completed in previous read*/
+		return 0;
+	for (i=0;i<ARRAY_SIZE(elfin_regs);i++) {
+		if (elfin_regs[i].low_ino==i_ino) {
+			current_reg = &elfin_regs[i];
+			break;
+		}
+	}
+	if (current_reg==NULL)
+		return -EINVAL;
+
+	count = sprintf(outputbuf, "0x%08lx\n",
+			*((volatile unsigned long *) io_p2v(current_reg->phyaddr)));
+	*ppos+=count;
+	if (count>nbytes)  /* Assume output can be read at one time */
+		return -EINVAL;
+	if (copy_to_user(buf, outputbuf, count))
+		return -EFAULT;
+	return count;
+}
+
+static ssize_t proc_write_reg(struct file * file, const char * buffer,
+		size_t count, loff_t *ppos)
+{
+	int i_ino = (file->f_dentry->d_inode)->i_ino;
+	elfin_reg_entry_t* current_reg=NULL;
+	int i;
+	unsigned long newRegValue;
+	char *endp;
+
+	for (i=0;i<ARRAY_SIZE(elfin_regs);i++) {
+		if (elfin_regs[i].low_ino==i_ino) {
+			current_reg = &elfin_regs[i];
+			break;
+		}
+	}
+	if (current_reg==NULL)
+		return -EINVAL;
+
+	newRegValue = simple_strtoul(buffer,&endp,0);
+	*((volatile unsigned long *) io_p2v(current_reg->phyaddr))=newRegValue;
+	return (count+endp-buffer);
+}
+
+static struct proc_dir_entry *regdir;
+static struct proc_dir_entry *cpudir;
+
+static int __init init_reg_monitor(void)
+{
+	struct proc_dir_entry *entry;
+	int i;
+
+	cpudir = proc_mkdir(CPU_DIRNAME, &proc_root);
+	if (cpudir == NULL) {
+		printk(KERN_ERR MODULE_NAME": can't create /proc/" CPU_DIRNAME "\n");
+		return(-ENOMEM);
+	}
+
+	regdir = proc_mkdir(REG_DIRNAME, cpudir);
+	if (regdir == NULL) {
+		printk(KERN_ERR MODULE_NAME": can't create /proc/" CPU_DIRNAME "/" REG_DIRNAME "\n");
+		return(-ENOMEM);
+	}
+
+	for(i=0;i<ARRAY_SIZE(elfin_regs);i++) {
+		entry = create_proc_entry(elfin_regs[i].name,
+				S_IWUSR |S_IRUSR | S_IRGRP | S_IROTH,
+				regdir);
+		if(entry) {
+			elfin_regs[i].low_ino = entry->low_ino;
+			entry->proc_fops = &proc_reg_operations;
+		} else {
+			printk( KERN_ERR MODULE_NAME
+				": can't create /proc/" REG_DIRNAME
+				"/%s\n", elfin_regs[i].name);
+			return(-ENOMEM);
+		}
+	}
+	return (0);
+}
+
+static void __exit cleanup_reg_monitor(void)
+{
+	int i;
+	for(i=0;i<ARRAY_SIZE(elfin_regs);i++)
+		remove_proc_entry(elfin_regs[i].name,regdir);
+	remove_proc_entry(REG_DIRNAME, cpudir);
+	remove_proc_entry(CPU_DIRNAME, &proc_root);
+}
+
+module_init(init_reg_monitor);
+module_exit(cleanup_reg_monitor);
+
+MODULE_LICENSE("GPL");
+
+EXPORT_NO_SYMBOLS;
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/smdk.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/smdk.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c24a0/smdk.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c24a0/smdk.c	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,163 @@
+/*
+ *  /arch/arm/mach-s3c24a0/smdk.c
+ *
+ *  This file contains all SMDK24A0 specific tweaks.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  Changes
+ *
+ *  2004/06/10 <heechul.yun@samsung.com>   Initial CPLD IDE support for SPJ
+ *  2004/06/13 <heechul.yun@samsung.com>   CPLD IDE and USB csupport for SPJ
+ *  2004/06/23 <heechul.yun@samsung.com>   Added bank1 access functions and now
+ *     IDE works with cs8900.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/serial_core.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include "generic.h"
+
+// #define DEBUG;
+#ifdef DEBUG
+#  define PDEBUG(fmt, args...) \
+printk(KERN_DEBUG "[%s:%d] " fmt, __PRETTY_FUNCTION__, __LINE__ , ## args)
+#else
+#  define PDEBUG(fmt, args...) do {} while(0)
+#endif
+
+/* global lock to protect bank1 register settings */
+spinlock_t bank1_lock = SPIN_LOCK_UNLOCKED;
+
+bank_param_t bank1_params[] =
+{
+        { 0x08, 0x3740 }, /* B1_IDE_PIO0 */
+        { 0x08, 0x2340 }, /* B1_IDE_PIO4 */
+        { 0x38, 0x3740 }, /* B1_CS89x0 */
+        { 0x00, 0x2200 }, /* B1_USB2 */
+};
+
+/* bank1 state of interrupt context */
+static int b1_int_state = B1_STATE_NONE;
+
+/**
+ * real_bank1_set_param: blah blah
+ */
+static __inline__ void real_bank1_set_param(int bw_val, int bc1_val)
+{
+        SROM_BW &= ~0x38;
+        SROM_BW |= bw_val;
+        SROM_BC1 = bc1_val;
+}
+
+/**
+ * bank1_set_state - set bank1 timing
+ * @state - state
+ *
+ * long description
+ */
+void bank1_set_state(int state)
+{
+#if 0
+        unsigned long flags;
+
+        if ( state == B1_STATE_NONE)
+                return;
+
+        if ( state > B1_STATE_LIMIT || state < B1_STATE_NONE )
+                panic("bank1: Inavlid state");
+
+
+        spin_lock_irqsave( &bank1_lock, flags);
+
+        if ( !in_interrupt())
+             current->bank1_state = state;
+
+        real_bank1_set_param( bank1_params[state].bw, bank1_params[state].bc);
+
+        spin_unlock_irqrestore( &bank1_lock, flags);
+#endif
+
+}
+
+
+void bank1_set_int_state(int state)
+{
+#if 0
+        unsigned long flags;
+
+        if ( !in_interrupt() )
+                panic("bank1_set_int_state is called fron interrupt context\n");
+
+        spin_lock_irqsave( &bank1_lock, flags);
+
+        b1_int_state = state; /* set */
+
+        if ( state == B1_STATE_NONE) /* 1st level interrupt */
+                state = current->bank1_state;
+
+        if ( state != B1_STATE_NONE )
+                real_bank1_set_param( bank1_params[state].bw, bank1_params[state].bc);
+
+        spin_unlock_irqrestore( &bank1_lock, flags);
+#endif
+}
+
+/*
+ * bank1_get_int_state - bank1 state of interrupt context
+ */
+int bank1_get_int_state(void)
+{
+        return b1_int_state;
+}
+
+EXPORT_SYMBOL(bank1_set_state);
+EXPORT_SYMBOL(bank1_set_int_state);
+EXPORT_SYMBOL(bank1_get_int_state);
+
+static int __init smdk_init(void)
+{
+        printk("%s: initialize smdk24a0 board\n", __func__);
+
+        set_gpio_ctrl(SMDK_LED4 | GPIO_PULLUP_DIS | GPIO_MODE_OUT);
+        set_gpio_ctrl(SMDK_LED5 | GPIO_PULLUP_DIS | GPIO_MODE_OUT);
+        set_gpio_ctrl(SMDK_LED6 | GPIO_PULLUP_DIS | GPIO_MODE_OUT);
+        set_gpio_ctrl(SMDK_LED7 | GPIO_PULLUP_DIS | GPIO_MODE_OUT);
+
+        // real_bank1_set_param(0x38, 0x3740);
+        real_bank1_set_param(0x38, 0x2340);
+        printk("Set BANK1 register (0x%x, 0x%x)\n", SROM_BW, SROM_BC1);
+
+        return 0;
+}
+
+__initcall(smdk_init);
+
+
+
+MACHINE_START(S3C24A0, "Samsung-SMDK24A0")
+        MAINTAINER("Heechul Yun")
+        BOOT_MEM(0x10000000, 0x40000000, 0xe0000000)
+        BOOT_PARAMS(0x10000100)
+        INITIRQ(elfin_init_irq)
+MACHINE_END
+
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/arch.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c3410/arch.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/arch.c	2004-11-19 15:00:52.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c3410/arch.c	2004-11-23 10:21:51.000000000 +0900
@@ -39,7 +39,8 @@
 
 
 extern void __init s3c3410_init_irq(void);
-
+extern void s3c3410_time_init(void);
+                                                                                                                                           
 static void __init
 fixup_s3c3410(struct machine_desc *desc, struct param_struct *params,
         char **cmdline, struct meminfo *mi)
@@ -50,4 +51,5 @@
 	MAINTAINER("Hyok S. Choi <hyok.choi@samsung.com>")
 	FIXUP(fixup_s3c3410)
 	INITIRQ(s3c3410_init_irq)
+	INITTIME(s3c3410_time_init)
 MACHINE_END
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/Makefile linux-2.6.9-hsc0/arch/armnommu/mach-s3c3410/Makefile
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/Makefile	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c3410/Makefile	2004-11-23 10:11:42.000000000 +0900
@@ -4,4 +4,4 @@
 
 # Object file lists.
 
-obj-y		+= arch.o irq.o mm.o dma.o
+obj-y		+= arch.o irq.o mm.o dma.o time.o
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/time.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c3410/time.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c3410/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c3410/time.c	2004-11-23 10:25:18.000000000 +0900
@@ -0,0 +1,96 @@
+/*
+ *  linux/arch/armnommu/mach-s3c3410/time.c
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *                      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+                                                                                                                                           
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/mach/time.h>
+#include <asm/arch/time.h>
+
+
+extern void s3c3410_unmask_irq(unsigned int irq);
+                                                                                                                                           
+unsigned long s3c3410_gettimeoffset (void)
+{
+        return (inw(S3C3410X_TCNT0) / CLOCKS_PER_USEC);
+}
+                                                                                                                                           
+static irqreturn_t
+s3c3410_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+    timer_tick(regs);
+                                                                                                                                           
+    return IRQ_HANDLED;
+}
+
+static struct irqaction s3c3410_timer_irq = {
+        .name           = "S3C3410 Timer Tick",
+        .flags          = SA_INTERRUPT,
+        .handler        = s3c3410_timer_interrupt
+};
+                                                                                                                                           
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+                                                                                                                                           
+void __init  s3c3410_time_init (void)
+{
+        u_int8_t tmod;
+        u_int16_t period;
+                                                                                                                                           
+        /*
+         * disable and clear timer 0, set to
+         * internal clock and interval mode
+         */
+        tmod = S3C3410X_T16_OMS_INTRV | S3C3410X_T16_CL;
+        outb(tmod, S3C3410X_TCON0);
+                                                                                                                                           
+        /* initialize the timer period and prescaler */
+        period = (CONFIG_ARM_CLK/S3C3410X_TIMER0_PRESCALER)/HZ;
+        outw(period, S3C3410X_TDAT0);
+        outb(S3C3410X_TIMER0_PRESCALER-1, S3C3410X_TPRE0);
+                                                                                                                                           
+        /*
+         * @todo do those really need to be function pointers ?
+         */
+        gettimeoffset     = s3c3410_gettimeoffset;
+        s3c3410_timer_irq.handler = s3c3410_timer_interrupt;
+                                                                                                                                           
+        /* set up the interrupt vevtor for timer 0 match */
+        setup_irq(S3C3410X_INTERRUPT_TMC0, &s3c3410_timer_irq);
+                                                                                                                                           
+        /* enable the timer IRQ */
+        s3c3410_unmask_irq(S3C3410X_INTERRUPT_TMC0);
+                                                                                                                                           
+        /* let timer 0 run... */
+        tmod |= S3C3410X_T16_TEN;
+        tmod &= ~S3C3410X_T16_CL;
+        outb(tmod, S3C3410X_TCON0);
+}
+                                                                                                                                           
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/arch.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c44b0x/arch.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/arch.c	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c44b0x/arch.c	2004-11-23 12:08:37.000000000 +0900
@@ -34,13 +34,14 @@
 #include <linux/initrd.h>
 
 // used by sysctl
-#define DEFAULT_MAX_MAP_COUNT	65536
-int sysctl_max_map_count = DEFAULT_MAX_MAP_COUNT;
+//#define DEFAULT_MAX_MAP_COUNT	65536
+//int sysctl_max_map_count = DEFAULT_MAX_MAP_COUNT;
 
 int s3c44b0x_fMHZ 	= CONFIG_ARM_CLK / 1000000;
 int s3c44b0x_finMHZ	= CONFIG_ARM_CLK_FIN / 1000000;
 
 extern void __init s3c44b0x_init_irq(void);
+extern void s3c44b0x_time_init(void);
 
 void __init s3c44b0x_init_machine(void)
 {
@@ -102,4 +103,5 @@
 	FIXUP(s3c44b0x_fixup)
 	INITIRQ(s3c44b0x_init_irq)
 	INIT_MACHINE(s3c44b0x_init_machine)
+	INITTIME(s3c44b0x_time_init)
 MACHINE_END
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/time.c linux-2.6.9-hsc0/arch/armnommu/mach-s3c44b0x/time.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s3c44b0x/time.c	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s3c44b0x/time.c	2004-11-23 11:51:54.000000000 +0900
@@ -1,5 +1,7 @@
 /*
- * linux/arch/arm/mach-s3c44b0x/time.c
+ * for 2.6.8.1 port by 
+ *    Hyok S. Choi <hyok.choi@samsung.com>
+ * linux/arch/armnommu/mach-s3c44b0x/time.c
  */
 
 #include <linux/init.h>
@@ -7,8 +9,13 @@
 #include <linux/timex.h>
 #include <linux/types.h>
 #include <linux/sched.h>
+#include <linux/interrupt.h>
 #include <asm/io.h>
 #include <asm/arch/hardware.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/mach/time.h>
+#include <asm/arch/timex.h>
 
 #define S3C44B0X_SYSTIMER_DIVIDER	2
 extern int s3c44b0x_fMHZ;
@@ -39,4 +46,59 @@
 	SYSREG_OR_SET	(S3C44B0X_TCON, 0x05<<24);
 }
 
+/*
+ * Set up timer interrupt.
+ */
+#if     CONFIG_ARM_CLK_ADJUST
+void s3c44b0x_led_off(int);
+void s3c44b0x_led_on(int);
+#endif
+                                                                                                                                           
+unsigned long s3c44b0x_gettimeoffset (void)
+{
+        return SYSREG_GETW(S3C44B0X_TCNTB5);
+}
+                                                                                                                                           
+static irqreturn_t s3c44b0x_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+#if     CONFIG_DEBUG_NICKMIT
+        static int cnt = 0;
+        ++cnt;
+        if (cnt == HZ) {
+                static int stat = 0;
+                cnt = 0;
+                if (stat)
+                        s3c44b0x_led_on(0);
+                else
+                        s3c44b0x_led_off(0);
+                stat = 1 - stat;
+        }
+#endif
+        timer_tick(regs);
+
+        return IRQ_HANDLED;
+}
+
+static struct irqaction s3c44b0x_timer_irq = {
+        .name           = "S3C44B0X Timer Tick",
+        .flags          = SA_INTERRUPT,
+        .handler        = s3c44b0x_timer_interrupt
+};
+
+                                                                                                                                           
+void __init s3c44b0x_time_init(void)
+{
+        s3c44b0x_systimer_setup();
+        /*
+         * @todo do those really need to be function pointers ?
+         */
+        gettimeoffset     = s3c44b0x_gettimeoffset;
+        s3c44b0x_timer_irq.handler = s3c44b0x_timer_interrupt;
+                                                                                                                                           
+        setup_irq(S3C44B0X_INTERRUPT_TIMER5, &s3c44b0x_timer_irq);
+        s3c44b0x_clear_pb(S3C44B0X_INTERRUPT_TIMER5);
+        s3c44b0x_unmask_irq(S3C44B0X_INTERRUPT_TIMER5);
+                                                                                                                                           
+        s3c44b0x_systimer_start();
+}
 
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/arch.c linux-2.6.9-hsc0/arch/armnommu/mach-s5c7375/arch.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/arch.c	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s5c7375/arch.c	2004-11-19 15:01:17.000000000 +0900
@@ -42,9 +42,12 @@
 #include <asm/mach/map.h>
 
 
+extern void s5c7375_time_init(void);
+
 extern void __init s5c7375_init_irq(void);
 
 MACHINE_START(S5C7375, "S5C7375, SAMSUNG ELECTRONICS Co., Ltd.")
 	MAINTAINER("Hyok S. Choi <hyok.choi@samsung.com>")
 	INITIRQ(s5c7375_init_irq)
+	INITTIME(s5c7375_time_init)
 MACHINE_END
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/Makefile linux-2.6.9-hsc0/arch/armnommu/mach-s5c7375/Makefile
--- linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/Makefile	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s5c7375/Makefile	2004-11-19 15:01:17.000000000 +0900
@@ -4,4 +4,4 @@
 
 # Object file lists.
 
-obj-y		+= arch.o irq.o dma.o
+obj-y		+= arch.o irq.o dma.o time.o
diff -Naur linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/time.c linux-2.6.9-hsc0/arch/armnommu/mach-s5c7375/time.c
--- linux-2.6.9-uc0/arch/armnommu/mach-s5c7375/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mach-s5c7375/time.c	2004-11-19 15:01:17.000000000 +0900
@@ -0,0 +1,99 @@
+/*
+ *  linux/arch/armnommu/mach-s5c7375/time.c
+ *
+ *  Copyright (C) SAMSUNG ELECTRONICS 
+ *                      Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+                                                                                                                                           
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/arch/s5c7375.h>
+#include <asm/mach/time.h>
+#include <asm/arch/time.h>
+
+unsigned long s5c7375_gettimeoffset (void)
+{
+	return (((RESCHED_PERIOD  * CLOCKS_PER_USEC) /1000) - rT3LDR)  / CLOCKS_PER_USEC;
+}
+
+static irqreturn_t
+s5c7375_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+    /* clear interrupt pending bit */
+    rT3ISR = 0;
+    timer_tick(regs);
+
+    return IRQ_HANDLED;
+}
+
+static struct irqaction s5c7375_timer_irq = {
+        .name           = "S5C7375 Timer Tick",
+        .flags          = SA_INTERRUPT,
+        .handler        = s5c7375_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+
+void __init  s5c7375_time_init (void)
+{
+	//- APB bus speed setting
+	/*
+	 * Number of AHB clock cycles allocated in the ENABLE or
+	 * SETUP state of the 2-nd APB peripheral minus one.
+	 */
+	rAPBCON2=(unsigned long)0x00010000; 
+
+	gettimeoffset = s5c7375_gettimeoffset;
+	s5c7375_timer_irq.handler = s5c7375_timer_interrupt;
+
+	/*
+	 * Timer 3 is used for OS_timer by external clock.
+	 */
+	rT3CTR = TMR_TE_DISABLE | TMR_IE_PULSE | TMR_OE_ENABLE | TMR_UD_DOWN \
+			| TMR_UDS_TxCTR | TMR_OM_PULSE | TMR_ES_POS | TMR_M_PERIODIC_TIMER;
+
+	/*
+	 * prescaler to 0x6B 'cause : 
+	 * 	27M / (0x6B +1) = 4usec
+	 */
+	rT3PSR = SYS_TIMER03_PRESCALER; // 0x6B
+	/* rT3LDR  =  X second * (frequency/second ) */
+	rT3LDR = RESCHED_PERIOD  * CLOCKS_PER_USEC /1000;
+			/* is equal to 
+			 *	RESCHED_PERIOD * 1000    // for msec to usec
+			 * 	   * (ECLK/ (SYS_TIMER03_PRESCALER +1)) /1000000;
+			 *	= 2500
+			 */
+   	/* clear interrupt pending bit */
+	rT3ISR = 0;
+
+	setup_irq(INT_N_TIMER3, &s5c7375_timer_irq);
+
+	/* timer 3 enable it! */
+	rT3CTR |= TMR_TE_ENABLE;
+
+}
diff -Naur linux-2.6.9-uc0/arch/armnommu/Makefile linux-2.6.9-hsc0/arch/armnommu/Makefile
--- linux-2.6.9-uc0/arch/armnommu/Makefile	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/Makefile	2004-11-23 12:22:05.000000000 +0900
@@ -8,9 +8,8 @@
 # Copyright (C) 2004 by Hyok S. Choi (for uClinux/ARM 2.6)
 # Copyright (C) 1995-2001 by Russell King
 
-LDFLAGS_vmlinux	:=-p -X
-LDFLAGS_BLOB	:=--format binary
-AFLAGS_vmlinux.lds.o = -DTEXTADDR=$(TEXTADDR) -DDATAADDR=$(DATAADDR)
+LDFLAGS_vmlinux	:=-p --no-undefined -X
+CPPFLAGS_vmlinux.lds = -DTEXTADDR=$(TEXTADDR) -DDATAADDR=$(DATAADDR)
 OBJCOPYFLAGS	:=-O binary -R .note -R .comment -S
 GZFLAGS		:=-9
 CFLAGS		+=-fno-builtin -D__linux__
@@ -39,8 +38,8 @@
 # Note that GCC does not numerically define an architecture version
 # macro, but instead defines a whole series of macros which makes
 # testing for a specific architecture or later rather impossible.
-arch-$(CONFIG_CPU_32v6)		:=-D__LINUX_ARM_ARCH__=6 -march=armv5t -Wa,-march=armv6
-arch-$(CONFIG_CPU_32v5)		:=-D__LINUX_ARM_ARCH__=5 $(call check_gcc,-march=armv5te,-march=armv4)
+arch-$(CONFIG_CPU_32v6)		:=-D__LINUX_ARM_ARCH__=6 $(call cc-option,-march=armv6,-march=armv5t -Wa$(comma)-march=armv6)
+arch-$(CONFIG_CPU_32v5)		:=-D__LINUX_ARM_ARCH__=5 $(call cc-option,-march=armv5te,-march=armv4)
 arch-$(CONFIG_CPU_32v4)		:=-D__LINUX_ARM_ARCH__=4 -march=armv4
 arch-$(CONFIG_CPU_32v3)		:=-D__LINUX_ARM_ARCH__=3 -march=armv3
 
@@ -53,20 +52,18 @@
 tune-$(CONFIG_CPU_ARM740T)	:=-mtune=arm7tdmi
 tune-$(CONFIG_CPU_ARM920T)	:=-mtune=arm9tdmi
 tune-$(CONFIG_CPU_ARM922T)	:=-mtune=arm9tdmi
+tune-$(CONFIG_CPU_ARM925T)	:=-mtune=arm9tdmi
 tune-$(CONFIG_CPU_ARM926T)	:=-mtune=arm9tdmi
 tune-$(CONFIG_CPU_ARM940T)	:=-mtune=arm9tdmi
 
 # Need -Uarm for gcc < 3.x
-CFLAGS_BOOT	:=-mapcs-32 $(arch-y) $(tune-y) -mshort-load-bytes -msoft-float -Wa,-mno-fpu -Uarm
-CFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -mshort-load-bytes -msoft-float -Wa,-mno-fpu -Uarm
-AFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -msoft-float -Wa,-mno-fpu
+CFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) $(call cc-option,-malignment-traps,-mshort-load-bytes) -msoft-float -Uarm
+AFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -msoft-float
 
-# settings for endian
-ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
-  LDFLAGS_BLOB  += --oformat elf32-bigarm
-else
-  LDFLAGS_BLOB  += --oformat elf32-littlearm
-endif
+CHECKFLAGS	+= -D__arm__
+
+#Default value
+DATAADDR	:= .
 
 # These are the default values for independt
 DATAADDR	:= .
@@ -86,6 +83,8 @@
 	textaddr-$(CONFIG_ARCH_S3C44B0)		:= 0x0c008000
 machine-$(CONFIG_ARCH_S5C7375) 		:= s5c7375
 	textaddr-$(CONFIG_ARCH_S5C7375) 	:= 0x00008000
+machine-$(CONFIG_ARCH_S3C24A0)		:= s3c24a0
+	textaddr-$(CONFIG_ARCH_S3C24A0) 	:= 0x10008000
 
 # set the environment variables and export
 MACHINE  := $(machine-y)
@@ -93,7 +92,7 @@
 ifeq ($(incdir-y),)
 incdir-y := $(MACHINE)
 endif
-INCDIR   := $(incdir-y)
+INCDIR   := arch-$(incdir-y)
   
 export	MACHINE PROCESSOR TEXTADDR GZFLAGS CFLAGS_BOOT
 
@@ -123,6 +122,9 @@
 endif
 core-$(CONFIG_FPE_NWFPE)	+= arch/arm/nwfpe/
 core-$(CONFIG_FPE_FASTFPE)	+= $(FASTFPE_OBJ)
+core-$(CONFIG_VFP)		+= arch/arm/vfp/
+
+drivers-$(CONFIG_OPROFILE)      += arch/arm/oprofile/
 
 libs-y				+= arch/arm/lib/
 
@@ -132,25 +134,27 @@
 boot := arch/armnommu/boot
 
 #	Update machine arch and proc symlinks if something which affects
-#	them changed.  We use .arch and .proc to indicate when they were
-#	updated last, otherwise make uses the target directory mtime.
+#	them changed.  We use .arch to indicate when they were updated
+#	last, otherwise make uses the target directory mtime.
 
-include/asm-armnommu/.arch: $(wildcard include/config/arch/*.h)
-	@echo '  Making asm-armnommu/arch -> asm-armnommu/arch-$(INCDIR) symlink'
-	@rm -f include/asm-armnommu/arch
-	@ln -sf arch-$(INCDIR) include/asm-armnommu/arch
+include/asm-armnommu/.arch: $(wildcard include/config/arch/*.h) include/config/MARKER
+	@echo '  SYMLINK include/asm-armnommu/arch -> include/asm-armnommu/$(INCDIR)'
+ifneq ($(KBUILD_SRC),)
+	$(Q)mkdir -p include/asm-armnommu
+	$(Q)ln -fsn $(srctree)/include/asm-armnommu/$(INCDIR) include/asm-armnommu/arch
+else
+	$(Q)ln -fsn $(INCDIR) include/asm-armnommu/arch
+endif
 	@touch $@
 
-prepare: maketools
+prepare: maketools include/asm-armnommu/.arch
 
 .PHONY: maketools FORCE
-maketools: include/asm-armnommu/.arch \
-	   include/asm-armnommu/constants.h include/linux/version.h FORCE
+maketools: include/asm-armnommu/constants.h include/linux/version.h FORCE
 	$(Q)$(MAKE) $(build)=arch/arm/tools include/asm-arm/mach-types.h
 
 # Convert bzImage to zImage
-bzImage: vmlinux
-	$(Q)$(MAKE) $(build)=$(boot) $(boot)/zImage
+bzImage: zImage
 
 zImage Image bootpImage uImage: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
@@ -164,24 +168,20 @@
 zinstall install: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) $@
 
-CLEAN_FILES += include/asm-armnommu/constants.h* include/asm-arm/mach-types.h
-CLEAN_FILES += linux.bin linux arch/armnommu/kernel/entry-macro.S
-CLEAN_FILES += include/asm-armnommu/arch include/asm-armnommu/.arch
+CLEAN_FILES += include/asm-armnommu/constants.h* include/asm-arm/mach-types.h \
+			include/asm-armnommu/arch include/asm-armnommu/.arch \
+			linux.bin linux arch/armnommu/kernel/entry-macro.S
 
 # We use MRPROPER_FILES and CLEAN_FILES now
 archclean:
 	$(Q)$(MAKE) $(clean)=$(boot)
 
-# My testing targets (that short circuit a few dependencies)
-zImg:;	$(Q)$(MAKE) $(build)=$(boot) $(boot)/zImage
-Img:;	$(Q)$(MAKE) $(build)=$(boot) $(boot)/Image
+# My testing targets (bypasses dependencies)
 bp:;	$(Q)$(MAKE) $(build)=$(boot) $(boot)/bootpImage
-i:;	$(Q)$(MAKE) $(build)=$(boot) install
-zi:;	$(Q)$(MAKE) $(build)=$(boot) zinstall
+i zi:;	$(Q)$(MAKE) $(build)=$(boot) $@
 
 arch/$(ARCH)/kernel/asm-offsets.s: include/asm include/linux/version.h \
-				   include/asm-armnommu/.arch \
-				   include/config/MARKER
+				   include/asm-armnommu/.arch
 
 include/asm-$(ARCH)/constants.h: arch/$(ARCH)/kernel/asm-offsets.s
 	$(call filechk,gen-asm-offsets)
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/consistent.c linux-2.6.9-hsc0/arch/armnommu/mm/consistent.c
--- linux-2.6.9-uc0/arch/armnommu/mm/consistent.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/consistent.c	2004-11-23 10:09:03.000000000 +0900
@@ -0,0 +1,79 @@
+/*
+ *  linux/arch/armnommu/mm/consistent.c
+ *
+ *  Copyright (C) 2004 Hyok S. Choi <hyok.choi@samsung.com>
+ *
+ *  Dynamic DMA mapping support.
+ *
+ *  We never have any address translations to worry about, so this
+ *  is just alloc/free.
+ */
+                                                                                                                                           
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+                                                                                                                                           
+void *dma_alloc_coherent(struct device *dev, size_t size,
+                           dma_addr_t *dma_handle, int gfp)
+{
+        void *ret;
+        /* ignore region specifiers */
+        gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
+                                                                                                                                           
+        if (dev == NULL || (*dev->dma_mask < 0xffffffff))
+                gfp |= GFP_DMA;
+        ret = (void *)__get_free_pages(gfp, get_order(size));
+                                                                                                                                           
+        if (ret != NULL) {
+                memset(ret, 0, size);
+                *dma_handle = virt_to_phys(ret);
+        }
+        return ret;
+}
+EXPORT_SYMBOL(dma_alloc_coherent);
+                                                                                                                                           
+void dma_free_coherent(struct device *dev, size_t size,
+                         void *vaddr, dma_addr_t dma_handle)
+{
+        free_pages((unsigned long)vaddr, get_order(size));
+}
+
+EXPORT_SYMBOL(dma_free_coherent);
+
+/*
+ * Initialise the consistent memory allocation.
+ */
+static int __init consistent_init(void)
+{
+	return 0;
+}
+
+core_initcall(consistent_init);
+
+/*
+ * Make an area consistent for devices.
+ */
+void consistent_sync(void *vaddr, size_t size, int direction)
+{
+	unsigned long start = (unsigned long)vaddr;
+	unsigned long end   = start + size;
+
+	switch (direction) {
+	case DMA_FROM_DEVICE:		/* invalidate only */
+		dmac_inv_range(start, end);
+		break;
+	case DMA_TO_DEVICE:		/* writeback only */
+		dmac_clean_range(start, end);
+		break;
+	case DMA_BIDIRECTIONAL:		/* writeback and invalidate */
+		dmac_flush_range(start, end);
+		break;
+	default:
+		BUG();
+	}
+}
+EXPORT_SYMBOL(consistent_sync);
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/Kconfig linux-2.6.9-hsc0/arch/armnommu/mm/Kconfig
--- linux-2.6.9-uc0/arch/armnommu/mm/Kconfig	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/Kconfig	2004-11-23 12:19:30.000000000 +0900
@@ -23,7 +23,8 @@
 
 # ARM710
 config CPU_ARM710
-	bool "Support ARM710 processor" if !ARCH_S3C3410 && !ARCH_ATMEL && !ARCH_ESPD_4510B  && !ARCH_S3C44B0
+	bool "Support ARM710 processor"
+        depends on ARCH_S3C3410 || ARCH_ATMEL || ARCH_S3C44B0
 	default y if ARCH_S3C3410 || ARCH_ATMEL || ARCH_S3C44B0
 	select CPU_32v3
 	select CPU_CACHE_V3
@@ -38,7 +39,8 @@
 
 # S3C4510B
 config CPU_S3C4510B
-	bool "Support S3C4510B/ARM7TDMI processor" if !ARCH_ESPD_4510B
+	bool "Support S3C4510B/ARM7TDMI processor"
+        depends on ARCH_ESPD_4510B
 	default y if ARCH_ESPD_4510B
 	select CPU_32v4
 
@@ -125,7 +127,8 @@
 # ARM926T
 config CPU_ARM926T
 	bool "Support ARM926T processor"
-	depends on ARCH_INTEGRATOR || ARCH_OMAP1610
+	depends on ARCH_INTEGRATOR || ARCH_OMAP1610 || ARCH_S3C24A0 
+	default y if ARCH_S3C24A0
 	select CPU_32v5
 	select CPU_ABRT_EV5TJ
 	help
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/Makefile linux-2.6.9-hsc0/arch/armnommu/mm/Makefile
--- linux-2.6.9-uc0/arch/armnommu/mm/Makefile	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/Makefile	2004-11-23 10:09:38.000000000 +0900
@@ -2,7 +2,7 @@
 # Makefile for the linux armnommu-specific parts of the memory manager.
 #
 
-obj-y				:= extable.o fault.o \
+obj-y				:= extable.o fault.o consistent.o \
 				   fault-common.o init.o ioremap.o mm.o
 
 obj-$(CONFIG_MODULES)		+= proc-syms.o
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1020e.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm1020e.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1020e.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm1020e.S	2004-11-23 11:48:26.000000000 +0900
@@ -194,6 +194,18 @@
  *	- end	- virtual end address
  */
 ENTRY(arm1020e_coherent_kern_range)
+	/* FALLTHROUGH */                                                                                                                                           
+/*
+ *      coherent_user_range(start, end)
+ *
+ *      Ensure coherency between the Icache and the Dcache in the
+ *      region described by start, end.  If you have non-snooping
+ *      Harvard caches, you need to implement this function.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ */
+ENTRY(arm1020e_coherent_user_range)
 	mov	ip, #0
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 1:
@@ -305,6 +317,7 @@
 	.long	arm1020e_flush_user_cache_all
 	.long	arm1020e_flush_user_cache_range
 	.long	arm1020e_coherent_kern_range
+	.long	arm1020e_coherent_user_range
 	.long	arm1020e_flush_kern_dcache_page
 	.long	arm1020e_dma_inv_range
 	.long	arm1020e_dma_clean_range
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1020.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm1020.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1020.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm1020.S	2004-11-23 11:48:26.000000000 +0900
@@ -197,6 +197,19 @@
  *	- end	- virtual end address
  */
 ENTRY(arm1020_coherent_kern_range)
+	/* FALLTHROUGH */                                                                                                                                           
+/*
+ *      coherent_user_range(start, end)
+ *
+ *      Ensure coherency between the Icache and the Dcache in the
+ *      region described by start, end.  If you have non-snooping
+ *      Harvard caches, you need to implement this function.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ */
+ENTRY(arm1020_coherent_user_range)
+
 	mov	ip, #0
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 	mcr	p15, 0, ip, c7, c10, 4
@@ -318,6 +331,7 @@
 	.long	arm1020_flush_user_cache_all
 	.long	arm1020_flush_user_cache_range
 	.long	arm1020_coherent_kern_range
+	.long	arm1020_coherent_user_range
 	.long	arm1020_flush_kern_dcache_page
 	.long	arm1020_dma_inv_range
 	.long	arm1020_dma_clean_range
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1022.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm1022.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1022.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm1022.S	2004-11-23 11:48:26.000000000 +0900
@@ -181,6 +181,18 @@
  *	- end	- virtual end address
  */
 ENTRY(arm1022_coherent_kern_range)
+        /* FALLTHROUGH */                                                                                                                                            
+/*
+ *      coherent_user_range(start, end)
+ *
+ *      Ensure coherency between the Icache and the Dcache in the
+ *      region described by start, end.  If you have non-snooping
+ *      Harvard caches, you need to implement this function.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ */
+ENTRY(arm1022_coherent_user_range)
 	mov	ip, #0
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 1:
@@ -292,6 +304,7 @@
 	.long	arm1022_flush_user_cache_all
 	.long	arm1022_flush_user_cache_range
 	.long	arm1022_coherent_kern_range
+	.long	arm1022_coherent_user_range
 	.long	arm1022_flush_kern_dcache_page
 	.long	arm1022_dma_inv_range
 	.long	arm1022_dma_clean_range
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1026.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm1026.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm1026.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm1026.S	2004-11-23 11:48:26.000000000 +0900
@@ -176,6 +176,18 @@
  *	- end	- virtual end address
  */
 ENTRY(arm1026_coherent_kern_range)
+        /* FALLTHROUGH */                                                                                                                                            
+/*
+ *      coherent_user_range(start, end)
+ *
+ *      Ensure coherency between the Icache and the Dcache in the
+ *      region described by start, end.  If you have non-snooping
+ *      Harvard caches, you need to implement this function.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ */
+ENTRY(arm1026_coherent_user_range)
 	mov	ip, #0
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 1:
@@ -287,6 +299,7 @@
 	.long	arm1026_flush_user_cache_all
 	.long	arm1026_flush_user_cache_range
 	.long	arm1026_coherent_kern_range
+	.long	arm1026_coherent_user_range
 	.long	arm1026_flush_kern_dcache_page
 	.long	arm1026_dma_inv_range
 	.long	arm1026_dma_clean_range
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm6_7.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm6_7.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm6_7.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm6_7.S	2004-11-23 11:48:26.000000000 +0900
@@ -190,7 +190,6 @@
 
 ENTRY(cpu_arm6_do_idle)
 ENTRY(cpu_arm7_do_idle)
-		mov	r0, #-EINVAL
 		mov	pc, lr
 
 /*
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm740.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm740.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm740.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm740.S	2004-11-23 11:48:26.000000000 +0900
@@ -1,11 +1,11 @@
 /*
- *  linux/arch/armnommu/mm/arm740.S: MPU functions for ARM740
- * 
- *  Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
- *                     Rob Scott (rscott@mtrob.fdns.net)
- *  Copyright (C) 2000 ARM Limited, Deep Blue Solutions Ltd.
- *  Copyright 2004, Hyok S. Choi, for 2.6.
- */
+ *  linux/arch/armnommu/mm/arm740.S: MPU functions for ARM740
+ * 
+ *  Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *                     Rob Scott (rscott@mtrob.fdns.net)
+ *  Copyright (C) 2000 ARM Limited, Deep Blue Solutions Ltd.
+ *  Copyright 2004, Hyok S. Choi, for 2.6.
+ */
 	
 #include <linux/linkage.h>
 #include <linux/config.h>
@@ -18,9 +18,9 @@
 #include <asm/ptrace.h>
 #include "proc-macros.S"
 
-
+
 /*
- * cpu_arm740_data_abort()
+ * cpu_arm740_data_abort()
  *
  * obtain information about current aborted instruction
  *
@@ -32,251 +32,251 @@
  *  r3 = FSR
  */
 	.align	5
-Ldata_ldmstm:
-	tst	r4, #1 << 21			@ check writeback bit
-	beq	Ldata_simple
-	mov	r7, #0x11
-	orr	r7, r7, r7, lsl #8
-	and	r0, r4, r7
-	and	r2, r4, r7, lsl #1
-	add	r0, r0, r2, lsr #1
-	and	r2, r4, r7, lsl #2
-	add	r0, r0, r2, lsr #2
-	and	r2, r4, r7, lsl #3
-	add	r0, r0, r2, lsr #3
-	add	r0, r0, r0, lsr #8
-	add	r0, r0, r0, lsr #4
-	and	r7, r0, #15			@ r7 = no. of registers to transfer.
-	and	r5, r4, #15 << 16		@ Get Rn
-	ldr	r0, [sp, r5, lsr #14]		@ Get register
-	tst	r4, #1 << 23			@ U bit
-	subne	r7, r0, r7, lsl #2
-	addeq	r7, r0, r7, lsl #2		@ Do correction (signed)
-Ldata_saver7:
-	str	r7, [sp, r5, lsr #14]		@ Put register
-Ldata_simple:
-	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
-	mrc	p15, 0, r3, c5, c0, 0		@ get FSR
-	and	r3, r3, #255
-	mov	pc, lr
-
-ENTRY(cpu_arm740_data_abort)
-	ldr	r4, [r0]			@ read instruction causing problem
-	tst	r4, r4, lsr #21			@ C = bit 20
-	sbc	r1, r1, r1			@ r1 = C - 1
-	and	r2, r4, #15 << 24
-	add	pc, pc, r2, lsr #22		@ Now branch to the relevent processing routine
-	movs	pc, lr
-
-	b	Ldata_lateldrhpost		@ ldrh	rd, [rn], #m/rm
-	b	Ldata_lateldrhpre		@ ldrh	rd, [rn, #m/rm]
-	b	Ldata_unknown
-	b	Ldata_unknown
-	b	Ldata_lateldrpostconst		@ ldr	rd, [rn], #m
-	b	Ldata_lateldrpreconst		@ ldr	rd, [rn, #m] 
-	b	Ldata_lateldrpostreg		@ ldr	rd, [rn], rm
-	b	Ldata_lateldrprereg		@ ldr	rd, [rn, rm]
-	b	Ldata_ldmstm			@ ldm*a	rn, <rlist>
-	b	Ldata_ldmstm			@ ldm*b	rn, <rlist>
-	b	Ldata_unknown
-	b	Ldata_unknown
-	b	Ldata_simple			@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
-	b	Ldata_simple			@ ldc	rd, [rn, #m]
-	b	Ldata_unknown
-
-Ldata_unknown:	@ Part of jumptable
-	mov	r0, r2
-	mov	r1, r4
-	mov	r2, r3
-	bl	baddataabort
-	b	ret_from_exception
-
-Ldata_lateldrhpre:
-	tst	r4, #1 << 21			@ check writeback bit
-	beq	Ldata_simple
-Ldata_lateldrhpost:
-	and	r5, r4, #0x00f			@ get Rm / low nibble of immediate value
-	tst	r4, #1 << 22			@ if (immediate offset)
-	andne	r2, r4, #0xf00			@ { immediate high nibble
-	orrne	r2, r5, r2, lsr #4		@   combine nibbles } else
-	ldreq	r2, [sp, r5, lsl #2]		@ { load Rm value }
-	and	r5, r4, #15 << 16		@ get Rn
-	ldr	r0, [sp, r5, lsr #14]		@ load Rn value
-	tst	r4, #1 << 23			@ U bit
-	subne	r7, r0, r2
-	addeq	r7, r0, r2
-	b	Ldata_saver7
-
-Ldata_lateldrpreconst:
-	tst	r4, #1 << 21			@ check writeback bit
-	beq	Ldata_simple
-Ldata_lateldrpostconst:
-	movs	r2, r4, lsl #20			@ Get offset
-	beq	Ldata_simple
-	and	r5, r4, #15 << 16		@ Get Rn
-	ldr	r0, [sp, r5, lsr #14]
-	tst	r4, #1 << 23			@ U bit
-	subne	r7, r0, r2, lsr #20
-	addeq	r7, r0, r2, lsr #20
-	b	Ldata_saver7
-
-Ldata_lateldrprereg:
-	tst	r4, #1 << 21			@ check writeback bit
-	beq	Ldata_simple
-Ldata_lateldrpostreg:
-	and	r5, r4, #15
-	ldr	r2, [sp, r5, lsl #2]		@ Get Rm
-	mov	r3, r4, lsr #7
-	ands	r3, r3, #31
-	and	r6, r4, #0x70
-	orreq	r6, r6, #8
-	add	pc, pc, r6
-	mov	r0, r0
-
-	mov	r2, r2, lsl r3			@ 0: LSL #!0
-	b	1f
-	b	1f				@ 1: LSL #0
-	mov	r0, r0
-	b	1f				@ 2: MUL?
-	mov	r0, r0
-	b	1f				@ 3: MUL?
-	mov	r0, r0
-	mov	r2, r2, lsr r3			@ 4: LSR #!0
-	b	1f
-	mov	r2, r2, lsr #32			@ 5: LSR #32
-	b	1f
-	b	1f				@ 6: MUL?
-	mov	r0, r0
-	b	1f				@ 7: MUL?
-	mov	r0, r0
-	mov	r2, r2, asr r3			@ 8: ASR #!0
-	b	1f
-	mov	r2, r2, asr #32			@ 9: ASR #32
-	b	1f
-	b	1f				@ A: MUL?
-	mov	r0, r0
-	b	1f				@ B: MUL?
-	mov	r0, r0
-	mov	r2, r2, ror r3			@ C: ROR #!0
-	b	1f
-	mov	r2, r2, rrx			@ D: RRX
-	b	1f
-	mov	r0, r0				@ E: MUL?
-	mov	r0, r0
-	mov	r0, r0				@ F: MUL?
-
-
-1:	and	r5, r4, #15 << 16		@ Get Rn
-	ldr	r0, [sp, r5, lsr #14]
-	tst	r4, #1 << 23			@ U bit
-	subne	r7, r0, r2
-	addeq	r7, r0, r2
-	b	Ldata_saver7
-
-
+Ldata_ldmstm:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+	mov	r7, #0x11
+	orr	r7, r7, r7, lsl #8
+	and	r0, r4, r7
+	and	r2, r4, r7, lsl #1
+	add	r0, r0, r2, lsr #1
+	and	r2, r4, r7, lsl #2
+	add	r0, r0, r2, lsr #2
+	and	r2, r4, r7, lsl #3
+	add	r0, r0, r2, lsr #3
+	add	r0, r0, r0, lsr #8
+	add	r0, r0, r0, lsr #4
+	and	r7, r0, #15			@ r7 = no. of registers to transfer.
+	and	r5, r4, #15 << 16		@ Get Rn
+	ldr	r0, [sp, r5, lsr #14]		@ Get register
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r7, lsl #2
+	addeq	r7, r0, r7, lsl #2		@ Do correction (signed)
+Ldata_saver7:
+	str	r7, [sp, r5, lsr #14]		@ Put register
+Ldata_simple:
+	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
+	mrc	p15, 0, r3, c5, c0, 0		@ get FSR
+	and	r3, r3, #255
+	mov	pc, lr
+
+ENTRY(cpu_arm740_data_abort)
+	ldr	r4, [r0]			@ read instruction causing problem
+	tst	r4, r4, lsr #21			@ C = bit 20
+	sbc	r1, r1, r1			@ r1 = C - 1
+	and	r2, r4, #15 << 24
+	add	pc, pc, r2, lsr #22		@ Now branch to the relevent processing routine
+	movs	pc, lr
+
+	b	Ldata_lateldrhpost		@ ldrh	rd, [rn], #m/rm
+	b	Ldata_lateldrhpre		@ ldrh	rd, [rn, #m/rm]
+	b	Ldata_unknown
+	b	Ldata_unknown
+	b	Ldata_lateldrpostconst		@ ldr	rd, [rn], #m
+	b	Ldata_lateldrpreconst		@ ldr	rd, [rn, #m] 
+	b	Ldata_lateldrpostreg		@ ldr	rd, [rn], rm
+	b	Ldata_lateldrprereg		@ ldr	rd, [rn, rm]
+	b	Ldata_ldmstm			@ ldm*a	rn, <rlist>
+	b	Ldata_ldmstm			@ ldm*b	rn, <rlist>
+	b	Ldata_unknown
+	b	Ldata_unknown
+	b	Ldata_simple			@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
+	b	Ldata_simple			@ ldc	rd, [rn, #m]
+	b	Ldata_unknown
+
+Ldata_unknown:	@ Part of jumptable
+	mov	r0, r2
+	mov	r1, r4
+	mov	r2, r3
+	bl	baddataabort
+	b	ret_from_exception
+
+Ldata_lateldrhpre:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+Ldata_lateldrhpost:
+	and	r5, r4, #0x00f			@ get Rm / low nibble of immediate value
+	tst	r4, #1 << 22			@ if (immediate offset)
+	andne	r2, r4, #0xf00			@ { immediate high nibble
+	orrne	r2, r5, r2, lsr #4		@   combine nibbles } else
+	ldreq	r2, [sp, r5, lsl #2]		@ { load Rm value }
+	and	r5, r4, #15 << 16		@ get Rn
+	ldr	r0, [sp, r5, lsr #14]		@ load Rn value
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r2
+	addeq	r7, r0, r2
+	b	Ldata_saver7
+
+Ldata_lateldrpreconst:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+Ldata_lateldrpostconst:
+	movs	r2, r4, lsl #20			@ Get offset
+	beq	Ldata_simple
+	and	r5, r4, #15 << 16		@ Get Rn
+	ldr	r0, [sp, r5, lsr #14]
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r2, lsr #20
+	addeq	r7, r0, r2, lsr #20
+	b	Ldata_saver7
+
+Ldata_lateldrprereg:
+	tst	r4, #1 << 21			@ check writeback bit
+	beq	Ldata_simple
+Ldata_lateldrpostreg:
+	and	r5, r4, #15
+	ldr	r2, [sp, r5, lsl #2]		@ Get Rm
+	mov	r3, r4, lsr #7
+	ands	r3, r3, #31
+	and	r6, r4, #0x70
+	orreq	r6, r6, #8
+	add	pc, pc, r6
+	mov	r0, r0
+
+	mov	r2, r2, lsl r3			@ 0: LSL #!0
+	b	1f
+	b	1f				@ 1: LSL #0
+	mov	r0, r0
+	b	1f				@ 2: MUL?
+	mov	r0, r0
+	b	1f				@ 3: MUL?
+	mov	r0, r0
+	mov	r2, r2, lsr r3			@ 4: LSR #!0
+	b	1f
+	mov	r2, r2, lsr #32			@ 5: LSR #32
+	b	1f
+	b	1f				@ 6: MUL?
+	mov	r0, r0
+	b	1f				@ 7: MUL?
+	mov	r0, r0
+	mov	r2, r2, asr r3			@ 8: ASR #!0
+	b	1f
+	mov	r2, r2, asr #32			@ 9: ASR #32
+	b	1f
+	b	1f				@ A: MUL?
+	mov	r0, r0
+	b	1f				@ B: MUL?
+	mov	r0, r0
+	mov	r2, r2, ror r3			@ C: ROR #!0
+	b	1f
+	mov	r2, r2, rrx			@ D: RRX
+	b	1f
+	mov	r0, r0				@ E: MUL?
+	mov	r0, r0
+	mov	r0, r0				@ F: MUL?
+
+
+1:	and	r5, r4, #15 << 16		@ Get Rn
+	ldr	r0, [sp, r5, lsr #14]
+	tst	r4, #1 << 23			@ U bit
+	subne	r7, r0, r2
+	addeq	r7, r0, r2
+	b	Ldata_saver7
+
+
 /*
- * cpu_arm740_check_bugs()
+ * cpu_arm740_check_bugs()
  */
-ENTRY(cpu_arm740_check_bugs)
+ENTRY(cpu_arm740_check_bugs)
 	mrs	ip, cpsr
 	bic	ip, ip, #PSR_F_BIT
 	msr	cpsr, ip
 	mov	pc, lr
 
 /*
- * cpu_arm740_proc_init()
- */
-ENTRY(cpu_arm740_proc_init)
+ * cpu_arm740_proc_init()
+ */
+ENTRY(cpu_arm740_proc_init)
 	mov	pc, lr
 
 /*
- * cpu_arm740_proc_fin()
+ * cpu_arm740_proc_fin()
  */
-ENTRY(cpu_arm740_proc_fin)
+ENTRY(cpu_arm740_proc_fin)
 	stmfd	sp!, {lr}
 	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
 	msr	cpsr_c, ip
-	mrc	p15, 0, r0, c1, c0, 0
-	bic	r0, r0, #0x1000			@ ...i............
-	bic	r0, r0, #0x000e			@ ............wca.
-	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
-	mcr	p15, 0, r1, c7, c7, 0		@ invalidate cache
-	ldmfd	sp!, {pc}
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x000e			@ ............wca.
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	mcr	p15, 0, r1, c7, c7, 0		@ invalidate cache
+	ldmfd	sp!, {pc}
 
 /*
- * cpu_arm740_reset(loc)
- * Params  : r0 = address to jump to
- * Notes   : This sets up everything for a reset
+ * cpu_arm740_reset(loc)
+ * Params  : r0 = address to jump to
+ * Notes   : This sets up everything for a reset
  */
-ENTRY(cpu_arm740_reset)
-	mov	ip, #0
-	mcr	p15, 0, ip, c7, c7, 0		@ invalidate cache
-	mrc	p15, 0, ip, c1, c0, 0		@ get ctrl register
-	bic	ip, ip, #0x000e				@ ............wcam
-	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
-	mov	pc, r0
+ENTRY(cpu_arm740_reset)
+	mov	ip, #0
+	mcr	p15, 0, ip, c7, c7, 0		@ invalidate cache
+	mrc	p15, 0, ip, c1, c0, 0		@ get ctrl register
+	bic	ip, ip, #0x000e				@ ............wcam
+	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
+	mov	pc, r0
 
 /*
  * idle mode processing 
  */
-ENTRY(cpu_arm740_do_idle)  
-	mov	pc, lr
+ENTRY(cpu_arm740_do_idle)  
+	mov	pc, lr
 
 /* 
  * *FIXME* 
  */ 	
-ENTRY(cpu_arm740_dcache_clean_area)
-	mov	r0, #0
-	mcr	p15, 0, r0, c7, c7, 0		@ flush cache
-	mov	pc, lr
-	
+ENTRY(cpu_arm740_dcache_clean_area)
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7, 0		@ flush cache
+	mov	pc, lr
+	
 /*
- * Function: arm740_switch_mm(unsigned long pgd_phys)
+ * Function: arm740_switch_mm(unsigned long pgd_phys)
  * Params  : pgd_phys	Physical address of page table
  * Purpose : Perform a task switch, 
  */	
-ENTRY(cpu_arm740_switch_mm)
+ENTRY(cpu_arm740_switch_mm)
 	mov	pc, lr	
 
 	
 	/* .section ".text.init", #alloc, #execinstr */ 
 	__INIT
 	
-__arm740_setup:
-	mov	r0, #0
-	mcr	p15, 0, r0, c7, c7, 0		@ invalidate caches
-
-	mov r0, #0x0					@disable region 3-7
-	mcr p15, 0, r0, c6, c3
-	mcr p15, 0, r0, c6, c4
-	mcr p15, 0, r0, c6, c5
-	mcr p15, 0, r0, c6, c6
-	mcr p15, 0, r0, c6, c7
-
-	mov r0, #0x0000003F			@ (base = 0, size = 4GB, non cacheable, no write buffer)
-	mcr p15, 0, r0, c6,	c0		@ enable region 0, default
-	mov r0, #0x00000037			@ (base = 0, size = 256MB, cacheable, write buffered)
-	mcr p15, 0, r0, c6,	c1		@enable region 1, RAM
-	mov r0, #0x20000000
-	add r0, r0, #0x37			@ (base = 512MB, size = 256MB, cacheable, write buffered)
-	mcr p15, 0, r0, c6,	c2		@enable region 2, ROM/Flash
-
-	mov r0, #0x06				
-	mcr p15, 0, r0, c2, c0		@ Region 1&2 cacheable
-	mov r0, #0x02			
-	mcr p15, 0, r0, c3, c0		@ Region 1 write buferred
-
-	mov r0, #0xff00
-	add r0, r0, #0x00ff
-	mcr p15, 0, r0, c5, c0		@ all read/write access
-
-	mrc	p15, 0, r0, c1, c0		@ get control register
-	orr r0, r0, #0x00030000		@ Split cache mode
-	orr	r0, r0, #0x0000000d		@ MPU, Cache, Write Buffer on
-	
-	mov	pc, lr				@ __ret (head-armv.S)
-		
-	.size	__arm740_setup, . - __arm740_setup	
+__arm740_setup:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7, 0		@ invalidate caches
+
+	mov r0, #0x0					@disable region 3-7
+	mcr p15, 0, r0, c6, c3
+	mcr p15, 0, r0, c6, c4
+	mcr p15, 0, r0, c6, c5
+	mcr p15, 0, r0, c6, c6
+	mcr p15, 0, r0, c6, c7
+
+	mov r0, #0x0000003F			@ (base = 0, size = 4GB, non cacheable, no write buffer)
+	mcr p15, 0, r0, c6,	c0		@ enable region 0, default
+	mov r0, #0x00000037			@ (base = 0, size = 256MB, cacheable, write buffered)
+	mcr p15, 0, r0, c6,	c1		@enable region 1, RAM
+	mov r0, #0x20000000
+	add r0, r0, #0x37			@ (base = 512MB, size = 256MB, cacheable, write buffered)
+	mcr p15, 0, r0, c6,	c2		@enable region 2, ROM/Flash
+
+	mov r0, #0x06				
+	mcr p15, 0, r0, c2, c0		@ Region 1&2 cacheable
+	mov r0, #0x02			
+	mcr p15, 0, r0, c3, c0		@ Region 1 write buferred
+
+	mov r0, #0xff00
+	add r0, r0, #0x00ff
+	mcr p15, 0, r0, c5, c0		@ all read/write access
+
+	mrc	p15, 0, r0, c1, c0		@ get control register
+	orr r0, r0, #0x00030000		@ Split cache mode
+	orr	r0, r0, #0x0000000d		@ MPU, Cache, Write Buffer on
+	
+	mov	pc, lr				@ __ret (head-armv.S)
+		
+	.size	__arm740_setup, . - __arm740_setup	
 
 	__INITDATA
 
@@ -284,22 +284,22 @@
  * Purpose : Function pointers used to access above functions - all calls
  *	     come through these
  */
-	.type	arm740_processor_functions, #object
-ENTRY(arm740_processor_functions)
-	.word	cpu_arm740_data_abort
-	.word	cpu_arm740_proc_init
-	.word	cpu_arm740_proc_fin
-	.word	cpu_arm740_reset
-	.word   cpu_arm740_do_idle
-
-	.word	cpu_arm740_dcache_clean_area
-	.word	cpu_arm740_switch_mm
-	.size	arm740_processor_functions, . - arm740_processor_functions
+	.type	arm740_processor_functions, #object
+ENTRY(arm740_processor_functions)
+	.word	cpu_arm740_data_abort
+	.word	cpu_arm740_proc_init
+	.word	cpu_arm740_proc_fin
+	.word	cpu_arm740_reset
+	.word   cpu_arm740_do_idle
+
+	.word	cpu_arm740_dcache_clean_area
+	.word	cpu_arm740_switch_mm
+	.size	arm740_processor_functions, . - arm740_processor_functions
 
 	.section ".rodata"	
 	.type	cpu_arch_name, #object
 cpu_arch_name:
-	.asciz	"armv4"
+	.asciz	"armv4"
 	.size	cpu_arch_name, . - cpu_arch_name
 
 	.type	cpu_elf_name, #object
@@ -307,27 +307,27 @@
 	.asciz	"v4"
 	.size	cpu_elf_name, . - cpu_elf_name
 
-	.type	cpu_arm740_name, #object
-cpu_arm740_name:
-	.ascii	"ARM740T"
-	.size	cpu_arm740_name, . - cpu_arm740_name
+	.type	cpu_arm740_name, #object
+cpu_arm740_name:
+	.ascii	"ARM740T"
+	.size	cpu_arm740_name, . - cpu_arm740_name
 
 	.align
 
 
 	.section ".proc.info", #alloc, #execinstr
-	.type	__arm740_proc_info,#object
-__arm740_proc_info:
-	.long	0x41807400
-	.long	0xfffffff0
+	.type	__arm740_proc_info,#object
+__arm740_proc_info:
+	.long	0x41807400
+	.long	0xfffffff0
 	.long	0x00000c1e			@ mmuflags
-	b	__arm740_setup
+	b	__arm740_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT
-	.long	cpu_arm740_name  
-	.long	arm740_processor_functions 
-	.long	v4_cache_fns			@ cache model
-	.size	__arm740_proc_info, . - __arm740_proc_info
+	.long	cpu_arm740_name  
+	.long	arm740_processor_functions 
+	.long	v4_cache_fns			@ cache model
+	.size	__arm740_proc_info, . - __arm740_proc_info
+
 
-
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm920.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm920.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm920.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm920.S	2004-11-23 11:48:26.000000000 +0900
@@ -183,6 +183,19 @@
  *	- end	- virtual end address
  */
 ENTRY(arm920_coherent_kern_range)
+	/* FALLTHROUGH */
+
+/*
+ *	coherent_user_range(start, end)
+ *
+ *	Ensure coherency between the Icache and the Dcache in the
+ *	region described by start, end.  If you have non-snooping
+ *	Harvard caches, you need to implement this function.
+ *
+ *	- start	- virtual start address
+ *	- end	- virtual end address
+ */
+ENTRY(arm920_coherent_user_range)
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
@@ -278,6 +291,7 @@
 	.long	arm920_flush_user_cache_all
 	.long	arm920_flush_user_cache_range
 	.long	arm920_coherent_kern_range
+	.long	arm920_coherent_user_range
 	.long	arm920_flush_kern_dcache_page
 	.long	arm920_dma_inv_range
 	.long	arm920_dma_clean_range
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm922.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm922.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm922.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm922.S	2004-11-23 11:48:26.000000000 +0900
@@ -185,6 +185,18 @@
  *	- end	- virtual end address
  */
 ENTRY(arm922_coherent_kern_range)
+        /* FALLTHROUGH */                                                                                                                                            
+/*
+ *      coherent_user_range(start, end)
+ *
+ *      Ensure coherency between the Icache and the Dcache in the
+ *      region described by start, end.  If you have non-snooping
+ *      Harvard caches, you need to implement this function.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ */
+ENTRY(arm922_coherent_user_range)
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
@@ -280,6 +292,7 @@
 	.long	arm922_flush_user_cache_all
 	.long	arm922_flush_user_cache_range
 	.long	arm922_coherent_kern_range
+	.long	arm922_coherent_user_range
 	.long	arm922_flush_kern_dcache_page
 	.long	arm922_dma_inv_range
 	.long	arm922_dma_clean_range
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm925.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm925.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm925.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm925.S	2004-11-23 11:48:26.000000000 +0900
@@ -226,6 +226,18 @@
  *	- end	- virtual end address
  */
 ENTRY(arm925_coherent_kern_range)
+        /* FALLTHROUGH */                                                                                                                                            
+/*
+ *      coherent_user_range(start, end)
+ *
+ *      Ensure coherency between the Icache and the Dcache in the
+ *      region described by start, end.  If you have non-snooping
+ *      Harvard caches, you need to implement this function.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ */
+ENTRY(arm925_coherent_user_range)
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
@@ -330,6 +342,7 @@
 	.long	arm925_flush_user_cache_all
 	.long	arm925_flush_user_cache_range
 	.long	arm925_coherent_kern_range
+	.long	arm925_coherent_user_range
 	.long	arm925_flush_kern_dcache_page
 	.long	arm925_dma_inv_range
 	.long	arm925_dma_clean_range
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm926.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm926.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm926.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm926.S	2004-11-23 11:48:26.000000000 +0900
@@ -186,6 +186,18 @@
  *	- end	- virtual end address
  */
 ENTRY(arm926_coherent_kern_range)
+        /* FALLTHROUGH */                                                                                                                                            
+/*
+ *      coherent_user_range(start, end)
+ *
+ *      Ensure coherency between the Icache and the Dcache in the
+ *      region described by start, end.  If you have non-snooping
+ *      Harvard caches, you need to implement this function.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ */
+ENTRY(arm926_coherent_user_range)
 	bic	r0, r0, #CACHE_DLINESIZE - 1
 1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
@@ -290,6 +302,7 @@
 	.long	arm926_flush_user_cache_all
 	.long	arm926_flush_user_cache_range
 	.long	arm926_coherent_kern_range
+	.long	arm926_coherent_user_range
 	.long	arm926_flush_kern_dcache_page
 	.long	arm926_dma_inv_range
 	.long	arm926_dma_clean_range
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-arm946.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm946.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-arm946.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-arm946.S	2004-11-23 11:48:26.000000000 +0900
@@ -1,10 +1,10 @@
 /*
- *  linux/arch/armnommu/mm/arm946.S: MPU functions for ARM946E-S
- * 
- *  Copyright 2003, STMicroelectronics
- *  Copyright 2004, Hyok S. Choi, for 2.6.
- *
- */
+ *  linux/arch/armnommu/mm/arm946.S: MPU functions for ARM946E-S
+ * 
+ *  Copyright 2003, STMicroelectronics
+ *  Copyright 2004, Hyok S. Choi, for 2.6.
+ *
+ */
 	
 #include <linux/linkage.h>
 #include <linux/config.h>
@@ -20,11 +20,11 @@
 
 	/* FIXME - this is also defined in cache-v4wb.S */ 
 #define CACHE_DSIZE	4096	/* 4K */
-#define CACHE_DLINESIZE	32	/* 8word */
+#define CACHE_DLINESIZE	32	/* 8word */
 #define CACHE_DLIMIT	(CACHE_DSIZE * 4)
-
+
 /*
- * cpu_arm946_data_abort()
+ * cpu_arm946_data_abort()
  *
  * obtain information about current aborted instruction
  *
@@ -36,7 +36,7 @@
  *  r3 = FSR
  */
 	.align	5
-ENTRY(cpu_arm946_data_abort)
+ENTRY(cpu_arm946_data_abort)
 	ldr	r1, [r0]			@ read aborted instruction
 	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
 	tst	r1, r1, lsr #21			@ C = bit 20
@@ -46,24 +46,24 @@
 	mov	pc, lr
 
 /*
- * cpu_arm946_check_bugs()
+ * cpu_arm946_check_bugs()
  */
-ENTRY(cpu_arm946_check_bugs)
+ENTRY(cpu_arm946_check_bugs)
 	mrs	ip, cpsr
 	bic	ip, ip, #PSR_F_BIT
 	msr	cpsr, ip
 	mov	pc, lr
 
 /*
- * cpu_arm946_proc_init()
- */
-ENTRY(cpu_arm946_proc_init)
+ * cpu_arm946_proc_init()
+ */
+ENTRY(cpu_arm946_proc_init)
 	mov	pc, lr
 
 /*
- * cpu_arm946_proc_fin()
+ * cpu_arm946_proc_fin()
  */
-ENTRY(cpu_arm946_proc_fin)
+ENTRY(cpu_arm946_proc_fin)
 	stmfd	sp!, {lr}
 	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
 	msr	cpsr_c, ip
@@ -79,7 +79,7 @@
 	ldmfd	sp!, {pc}
 
 /*
- * cpu_arm946_reset(loc)
+ * cpu_arm946_reset(loc)
  *
  * Perform a soft reset of the system.  Put the CPU into the
  * same state as it would be if it had been reset, and branch
@@ -87,7 +87,7 @@
  *
  * loc: location to jump to for soft reset
  */
-ENTRY(cpu_arm946_reset)
+ENTRY(cpu_arm946_reset)
 	mov	ip, #0
 	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches
 	mrc	p15, 0, ip, c1, c0, 0		@ ctrl register
@@ -99,8 +99,8 @@
 /*
  * idle mode processing 
  */
-ENTRY(cpu_arm946_do_idle)  
-#if defined(CONFIG_CPU_ARM946_CPU_IDLE)
+ENTRY(cpu_arm946_do_idle)  
+#if defined(CONFIG_CPU_ARM946_CPU_IDLE)
 	mcr	p15, 0, r0, c7, c0, 4		@ Wait for interrupt
 #endif
 	mov	pc, lr
@@ -108,27 +108,27 @@
 /* 
  * *FIXME* 
  */ 	
-ENTRY(cpu_arm946_dcache_clean_area)
+ENTRY(cpu_arm946_dcache_clean_area)
 1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	add	r0, r0, #CACHE_DLINESIZE
 	subs	r1, r1, #CACHE_DLINESIZE
 	bhi	1b
 	mov	pc, lr
 /*
- * Function: arm946_switch_mm(unsigned long pgd_phys)
+ * Function: arm946_switch_mm(unsigned long pgd_phys)
  * Params  : pgd_phys	Physical address of page table
  * Purpose : Perform a task switch, 
  */	
-ENTRY(cpu_arm946_switch_mm)
-/* FIXME: customized cache initialize here */
-/*	bl	custom_init_cache */ 
-	mov	pc, lr	
+ENTRY(cpu_arm946_switch_mm)
+/* FIXME: customized cache initialize here */
+/*	bl	custom_init_cache */ 
+	mov	pc, lr	
 
 	
 	/* .section ".text.init", #alloc, #execinstr */ 
 	__INIT
 	
-__arm946_setup:
+__arm946_setup:
 	MRC     p15, 0, R0, c1, c0, 0		@ get control register
 		
 /*
@@ -154,7 +154,7 @@
 	orr	r0, r0, #0x1000                 @ I Cache on
 #endif
 	mov	pc, lr
-	.size	__arm946_setup, . - __arm946_setup	
+	.size	__arm946_setup, . - __arm946_setup	
 
 	__INITDATA
 
@@ -162,54 +162,54 @@
  * Purpose : Function pointers used to access above functions - all calls
  *	     come through these
  */
-	.type	arm946_processor_functions, #object
-ENTRY(arm946_processor_functions)
-	.word	cpu_arm946_data_abort
-	.word	cpu_arm946_proc_init
-	.word	cpu_arm946_proc_fin
-	.word	cpu_arm946_reset
-	.word   cpu_arm946_do_idle
-
-	.word	cpu_arm946_dcache_clean_area
-	.word	cpu_arm946_switch_mm
-	.size	arm946_processor_functions, . - arm946_processor_functions
+	.type	arm946_processor_functions, #object
+ENTRY(arm946_processor_functions)
+	.word	cpu_arm946_data_abort
+	.word	cpu_arm946_proc_init
+	.word	cpu_arm946_proc_fin
+	.word	cpu_arm946_reset
+	.word   cpu_arm946_do_idle
+
+	.word	cpu_arm946_dcache_clean_area
+	.word	cpu_arm946_switch_mm
+	.size	arm946_processor_functions, . - arm946_processor_functions
 
 	.section ".rodata"	
 	.type	cpu_arch_name, #object
 cpu_arch_name:
-	.asciz	"armv5"
+	.asciz	"armv5"
 	.size	cpu_arch_name, . - cpu_arch_name
 
 	.type	cpu_elf_name, #object
 cpu_elf_name:
-	.asciz	"v5"
+	.asciz	"v5"
 	.size	cpu_elf_name, . - cpu_elf_name
 
-	.type	cpu_arm946_name, #object
-cpu_arm946_name:
-	.ascii	"ARM946E"
-	.size	cpu_arm946_name, . - cpu_arm946_name
+	.type	cpu_arm946_name, #object
+cpu_arm946_name:
+	.ascii	"ARM946E"
+	.size	cpu_arm946_name, . - cpu_arm946_name
 
 	.align
 
 
 	.section ".proc.info", #alloc, #execinstr
-	.type	__arm946_proc_info,#object
-__arm946_proc_info:
-	.long	0x41009460
+	.type	__arm946_proc_info,#object
+__arm946_proc_info:
+	.long	0x41009460
 	.long	0xff00fff0
 	.long	0x00000c1e			@ mmuflags
-	b	__arm946_setup
+	b	__arm946_setup
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP | HWCAP_HALF | HWCAP_26BIT
-	.long	cpu_arm946_name  
-	.long	arm946_processor_functions 
+	.long	cpu_arm946_name  
+	.long	arm946_processor_functions 
 #if defined(CONFIG_CPU_CACHE_V4WT)
-	.long	v4wt_cache_fns			@ cache model
+	.long	v4wt_cache_fns			@ cache model
 #elif defined(CONFIG_CPU_CACHE_V4WB)
 	.long	v4wb_cache_fns			@ cache model
 #endif /* CONFIG_CPU_CACHE_V4WT */
-	.size	__arm946_proc_info, . - __arm946_proc_info
+	.size	__arm946_proc_info, . - __arm946_proc_info
+
 
-
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-s3c4510b.S linux-2.6.9-hsc0/arch/armnommu/mm/proc-s3c4510b.S
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-s3c4510b.S	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-s3c4510b.S	2004-11-23 11:48:26.000000000 +0900
@@ -98,6 +98,19 @@
 ENTRY(s3c4510b_coherent_kern_range)
 	/* FALLTHROUGH */
 
+                                                                                                                                           
+/*
+ *      coherent_user_range(start, end)
+ *
+ *      Ensure coherency between the Icache and the Dcache in the
+ *      region described by start, end.  If you have non-snooping
+ *      Harvard caches, you need to implement this function.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ */
+ENTRY(s3c4510b_coherent_user_range)
+
 /*
  *	flush_kern_dcache_page(void *page)
  *
@@ -351,6 +364,7 @@
 		.long	s3c4510b_flush_user_cache_all
 		.long	s3c4510b_flush_user_cache_range
 		.long	s3c4510b_coherent_kern_range
+	        .long   s3c4510b_coherent_user_range
 		.long	s3c4510b_flush_kern_dcache_page
 		.long	s3c4510b_dma_inv_range
 		.long	s3c4510b_dma_clean_range
diff -Naur linux-2.6.9-uc0/arch/armnommu/mm/proc-syms.c linux-2.6.9-hsc0/arch/armnommu/mm/proc-syms.c
--- linux-2.6.9-uc0/arch/armnommu/mm/proc-syms.c	2004-11-19 15:00:53.000000000 +0900
+++ linux-2.6.9-hsc0/arch/armnommu/mm/proc-syms.c	2004-11-23 11:42:39.000000000 +0900
@@ -26,6 +26,7 @@
 EXPORT_SYMBOL_NOVERS(__cpuc_flush_user_all);
 EXPORT_SYMBOL_NOVERS(__cpuc_flush_user_range);
 EXPORT_SYMBOL_NOVERS(__cpuc_coherent_kern_range);
+EXPORT_SYMBOL_NOVERS(__cpuc_coherent_user_range);
 EXPORT_SYMBOL_NOVERS(__cpuc_flush_dcache_page);
 #else
 EXPORT_SYMBOL(cpu_cache);
diff -Naur linux-2.6.9-uc0/drivers/serial/Kconfig linux-2.6.9-hsc0/drivers/serial/Kconfig
--- linux-2.6.9-uc0/drivers/serial/Kconfig	2004-11-19 15:00:54.000000000 +0900
+++ linux-2.6.9-hsc0/drivers/serial/Kconfig	2004-11-23 13:44:54.000000000 +0900
@@ -313,6 +313,29 @@
 	  you can alter that using a kernel command line option such as
 	  "console=ttySx". 
 
+config SERIAL_S3C24A0 
+	tristate "Samsung S3C24A0 Serial port support"
+	depends on ARM && ARCH_S3C24A0
+	select SERIAL_CORE
+	help
+	  Support for the on-chip UARTs on the Samsung S3C24A0 CPU,
+	  providing /dev/ttyS0 and 1.
+
+
+config SERIAL_S3C24A0_CONSOLE 
+	bool "Support for console on S3C24A0 serial port"
+	depends on SERIAL_S3C24A0=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Allow selection of the S3C24A0 on-board serial ports for use as
+	  an virtual console.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttySx". 
+
+
 config SERIAL_DZ
 	bool "DECstation DZ serial driver"
 	depends on MACH_DECSTATION && MIPS32
diff -Naur linux-2.6.9-uc0/drivers/serial/serial_atmel.c linux-2.6.9-hsc0/drivers/serial/serial_atmel.c
--- linux-2.6.9-uc0/drivers/serial/serial_atmel.c	2004-11-19 15:00:54.000000000 +0900
+++ linux-2.6.9-hsc0/drivers/serial/serial_atmel.c	2004-11-22 14:59:10.000000000 +0900
@@ -370,7 +370,7 @@
 	if (tty->flip.count >= TTY_FLIPBUF_SIZE)
 		schedule_work(&tty->flip.work);
 
-	if ((count tty->flip.count) >= TTY_FLIPBUF_SIZE) {
+	if ((count + tty->flip.count) >= TTY_FLIPBUF_SIZE) {
 #ifdef US_RTS
 		atmel_cts_off(info);
 #endif
@@ -412,17 +412,17 @@
 		goto clear_and_return;
 	}
 
-	if (info->xmit_tail info->xmit_cnt < SERIAL_XMIT_SIZE) {
-		xmit_string(info, info->xmit_buf info->xmit_tail,
+	if (info->xmit_tail + info->xmit_cnt < SERIAL_XMIT_SIZE) {
+		xmit_string(info, info->xmit_buf + info->xmit_tail,
 					info->xmit_cnt);
 		info->xmit_tail =
-			(info->xmit_tail info->xmit_cnt) & (SERIAL_XMIT_SIZE - 1);
+			(info->xmit_tail + info->xmit_cnt) & (SERIAL_XMIT_SIZE - 1);
 		info->xmit_cnt = 0;
 	} else {
 		coucou1();
-		xmit_string(info, info->xmit_buf info->xmit_tail,
+		xmit_string(info, info->xmit_buf + info->xmit_tail,
 					SERIAL_XMIT_SIZE - info->xmit_tail);
-		//xmit_string(info, info->xmit_buf, info->xmit_tail info->xmit_cnt - SERIAL_XMIT_SIZE);
+		//xmit_string(info, info->xmit_buf, info->xmit_tail + info->xmit_cnt - SERIAL_XMIT_SIZE);
 		info->xmit_cnt =
 			info->xmit_cnt - (SERIAL_XMIT_SIZE - info->xmit_tail);
 		info->xmit_tail = 0;
@@ -958,12 +958,12 @@
 		if (from_user) {
 			down(&tmp_buf_sem);
 			copy_from_user(tmp_buf, buf, c);
-			memcpy(info->xmit_buf info->xmit_head, tmp_buf, c);
+			memcpy(info->xmit_buf + info->xmit_head, tmp_buf, c);
 			up(&tmp_buf_sem);
 		} else {
-			memcpy(info->xmit_buf info->xmit_head, buf, c);
+			memcpy(info->xmit_buf + info->xmit_head, buf, c);
 		}
-		info->xmit_head = (info->xmit_head c) & (SERIAL_XMIT_SIZE - 1);
+		info->xmit_head = (info->xmit_head + c) & (SERIAL_XMIT_SIZE - 1);
 		info->xmit_cnt += c;
 		restore_flags(flags);
 		buf += c;
@@ -990,8 +990,8 @@
 			if (info->xmit_cnt) {
 				/* Send char */
 				wait_EOT(info->usart);
-				if (info->xmit_tail info->xmit_cnt < SERIAL_XMIT_SIZE) {
-					xmit_string(info, info->xmit_buf info->xmit_tail,
+				if (info->xmit_tail + info->xmit_cnt < SERIAL_XMIT_SIZE) {
+					xmit_string(info, info->xmit_buf + info->xmit_tail,
 								info->xmit_cnt);
 					info->xmit_tail =
 						(info->xmit_tail +
@@ -999,9 +999,9 @@
 					info->xmit_cnt = 0;
 				} else {
 					coucou2();
-					xmit_string(info, info->xmit_buf info->xmit_tail,
+					xmit_string(info, info->xmit_buf + info->xmit_tail,
 								SERIAL_XMIT_SIZE - info->xmit_tail);
-					//xmit_string(info, info->xmit_buf, info->xmit_tail info->xmit_cnt - SERIAL_XMIT_SIZE);
+					//xmit_string(info, info->xmit_buf, info->xmit_tail + info->xmit_cnt - SERIAL_XMIT_SIZE);
 					info->xmit_cnt =
 						info->xmit_cnt - (SERIAL_XMIT_SIZE - info->xmit_tail);
 					info->xmit_tail = 0;
@@ -1415,6 +1415,8 @@
 	tty->closing = 0;
 	info->event = 0;
 	info->tty = 0;
+#warning "This is not and has never been valid so fix it"	
+#if 0
 	if (tty->ldisc.num != ldiscs[N_TTY].num) {
 		if (tty->ldisc.close)
 			(tty->ldisc.close) (tty);
@@ -1423,6 +1425,7 @@
 		if (tty->ldisc.open)
 			(tty->ldisc.open) (tty);
 	}
+#endif
 	if (info->blocked_open) {
 		if (info->close_delay) {
 			current->state = TASK_INTERRUPTIBLE;
@@ -1767,10 +1770,10 @@
 
 	tmp[0] = ch;
 
-	outl_t((unsigned long) tmp, (USART0_BASE US_TPR) );
-	outl_t(1, (USART0_BASE US_TCR) );
+	outl_t((unsigned long) tmp, (USART0_BASE + US_TPR) );
+	outl_t(1, (USART0_BASE + US_TCR) );
 
-	while (inl_t((USART0_BASE US_TCR) )) {
+	while (inl_t((USART0_BASE + US_TCR) )) {
 	}
 }
 
@@ -1808,12 +1811,12 @@
 
 	for (q = 0; q < s; q++) {
 		if (q % 16 == 0) {
-			dbg_printk("%08X: ", q a);
+			dbg_printk("%08X: ", q + a);
 		}
 		if (q % 16 == 7) {
-			dbg_printk("%02X-", *(unsigned char *) (q a));
+			dbg_printk("%02X-", *(unsigned char *) (q + a));
 		} else {
-			dbg_printk("%02X ", *(unsigned char *) (q a));
+			dbg_printk("%02X ", *(unsigned char *) (q + a));
 		}
 		if (q % 16 == 15) {
 			dbg_printk(" :\n");
@@ -1864,7 +1867,7 @@
     	while (count--) {
         	if (*str == '\n')
            		rs_put_char(info,'\r');
-        	rs_put_char(info, *str+);
+        	rs_put_char(info, *str++ );
     	}
 }
 
diff -Naur linux-2.6.9-uc0/drivers/serial/serial_s3c24a0.c linux-2.6.9-hsc0/drivers/serial/serial_s3c24a0.c
--- linux-2.6.9-uc0/drivers/serial/serial_s3c24a0.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/drivers/serial/serial_s3c24a0.c	2004-11-23 13:42:58.000000000 +0900
@@ -0,0 +1,596 @@
+/*
+ * drivser/serial/serial_s3c24a0.c
+ *
+ * device for S3C24A0
+ *
+ * $Id: serial_s3c24a0.c,v 1.1 2004/06/03 01:35:26 hcyun Exp $
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/serial_core.h>
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/arch/clocks.h>
+
+#define CONFIG_USE_ERR_IRQ        0
+
+#define __DRIVER_NAME    "Samsung S3C24A0 Internal UART"
+
+
+#ifdef CONFIG_BOARD_S3C24A0_SMDK
+#define UART_NR                   1
+#else
+#define UART_NR                   2
+#endif
+
+#define UART_ULCON(port)          __REG((port)->iobase + oULCON)
+#define UART_UCON(port)           __REG((port)->iobase + oUCON)
+#define UART_UFCON(port)          __REG((port)->iobase + oUFCON)
+#define UART_UTRSTAT(port)        __REG((port)->iobase + oUTRSTAT)
+#define UART_UERSTAT(port)        __REG((port)->iobase + oUERSTAT)
+#define UART_UTXH(port)           __REG((port)->iobase + oUTXH)
+#define UART_URXH(port)           __REG((port)->iobase + oURXH)
+#define UART_UBRDIV(port)         __REG((port)->iobase + oUBRDIV)
+
+#define ERR_IRQ(port)             ((port)->irq + 2)
+#define TX_IRQ(port)              ((port)->irq + 1)
+#define RX_IRQ(port)              ((port)->irq)
+
+#define INT_DISABLE(port)         disable_irq(port);
+#define INT_ENABLE(port)          enable_irq(port);
+/*
+ * Internal helper function
+ */
+static void __xmit_char(struct uart_port *port, const char ch)
+{
+        while (!(UART_UTRSTAT(port) & UTRSTAT_TX_EMP));
+        UART_UTXH(port) = ch;
+        if (ch == '\n') {
+                while (!(UART_UTRSTAT(port) & UTRSTAT_TX_EMP));
+                UART_UTXH(port) = '\r';
+        }
+}
+
+static void __xmit_string(struct uart_port *port, const char *p, int len)
+{
+        while( len-- > 0) {
+                __xmit_char( port, *p++);
+        }
+}
+
+
+
+static void elfinuart_stop_tx(struct uart_port *port, u_int from_tty)
+{
+}
+
+static void elfinuart_start_tx(struct uart_port *port, u_int from_tty)
+{
+        struct uart_info *info = port->info;
+        struct circ_buf *xmit = &port->info->xmit;
+
+        int count;
+
+        if (port->x_char) {
+                __xmit_char(port, port->x_char);
+                port->icount.tx++;
+                port->x_char = 0;
+                return;
+        }
+
+        if (uart_circ_empty( xmit) || uart_tx_stopped( port)) {
+                elfinuart_stop_tx(port, 0);
+                return;
+        }
+
+        count = port->fifosize >> 1;
+        do {
+                __xmit_char( port, xmit->buf[xmit->tail]);
+                info->xmit.tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+                port->icount.tx++;
+                if (uart_circ_empty(xmit))
+                        break;
+        } while (--count > 0);
+
+        if (uart_circ_chars_pending( xmit) < WAKEUP_CHARS)
+                uart_write_wakeup( port);
+
+        if (uart_circ_empty(xmit))
+                elfinuart_stop_tx( port, 0);
+}
+
+static void elfinuart_stop_rx(struct uart_port *port)
+{
+}
+
+static void elfinuart_enable_ms(struct uart_port *port)
+{
+}
+
+static void elfinuart_rx_char(struct uart_port *port)
+{
+        unsigned int status, ch, max_count = 256;
+        struct tty_struct *tty = port->info->tty;
+
+        status = UART_UTRSTAT(port);
+        while ((status & UTRSTAT_RX_RDY) && max_count--) {
+                if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+                        tty->flip.work.func((void *) tty);
+                        if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+                                printk(KERN_WARNING "TTY_DONT_FLIP set\n");
+                                return;
+                        }
+                }
+
+                ch = UART_URXH(port);
+
+                *tty->flip.char_buf_ptr = ch;
+                *tty->flip.flag_buf_ptr = TTY_NORMAL;
+                port->icount.rx++;
+                tty->flip.flag_buf_ptr++;
+                tty->flip.char_buf_ptr++;
+                tty->flip.count++;
+                /* No error handling just yet.
+                 * On the MX1 these are seperate
+                 * IRQs, so we need to deal with
+                 * the sanity of 5 IRQs for one
+                 * serial port before we deal
+                 * with the error path properly.
+                 */
+                status = UART_UTRSTAT(port);
+        }
+        tty_flip_buffer_push(tty);
+}
+
+static u_int elfinuart_tx_empty(struct uart_port *port)
+{
+        return (UART_UTRSTAT(port) & UTRSTAT_TR_EMP ? 0 : TIOCSER_TEMT);
+}
+
+static u_int elfinuart_get_mctrl(struct uart_port *port)
+{
+        return (TIOCM_CTS | TIOCM_DSR | TIOCM_CAR);
+}
+
+static void elfinuart_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+}
+
+static void elfinuart_break_ctl(struct uart_port *port, int break_state)
+{
+        u_int ucon;
+
+        ucon = UART_UCON(port);
+
+        if (break_state == -1)
+                ucon |= UCON_BRK_SIG;
+        else
+                ucon &= ~UCON_BRK_SIG;
+
+        UART_UCON(port) = ucon;
+}
+
+static irqreturn_t elfinuart_rx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+        struct uart_port *port = dev_id;
+        elfinuart_rx_char(port);
+
+        return IRQ_HANDLED;
+}
+
+static irqreturn_t elfinuart_tx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+        struct uart_port *port = dev_id;
+        elfinuart_start_tx(port, 0);
+        return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_USE_ERR_IRQ
+static irqreturn_t elfinuart_err_int(int irq, void *dev_id,
+                                      struct pt_regs *reg)
+{
+        struct uart_port *port = dev_id;
+        struct uart_info *info = port->info;
+        struct tty_struct *tty = info->tty;
+        unsigned char err = UART_UERSTAT(port) & UERSTAT_ERR_MASK;
+        unsigned int ch, flg =  TTY_NORMAL;
+
+        ch = UART_URXH(port);
+        if (!err)
+                return IRQ_HANDLED;
+
+        if (err & UERSTAT_OVERRUN)
+                port->icount.overrun++;
+
+        err &= port->read_status_mask;
+
+        if (err & UERSTAT_OVERRUN) {
+                *tty->flip.char_buf_ptr = ch;
+                *tty->flip.flag_buf_ptr = flg;
+                tty->flip.flag_buf_ptr++;
+                tty->flip.char_buf_ptr++;
+                tty->flip.count++;
+                if (tty->flip.count < TTY_FLIPBUF_SIZE) {
+                        ch = 0;
+                        flg = TTY_OVERRUN;
+                }
+        }
+
+        *tty->flip.flag_buf_ptr++ = flg;
+        *tty->flip.char_buf_ptr++ = ch;
+        tty->flip.count++;
+        return IRQ_HANDLED;
+}
+#endif
+
+static struct irqaction __rx_irqaction[UART_NR] = {
+        {
+                name:     "serial0_rx",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_rx_int,
+        },
+        {
+                name:     "serial1_rx",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_rx_int,
+        },
+};
+
+static struct irqaction __tx_irqaction[UART_NR] = {
+        {
+                name:     "serial0_tx",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_tx_int,
+        },
+        {
+                name:     "serial1_tx",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_tx_int,
+        },
+};
+
+static struct irqaction __err_irqaction[UART_NR] = {
+        {
+                name:     "serial0_err",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_err_int,
+        },
+        {
+                name:     "serial1_err",
+                flags:    SA_INTERRUPT,
+                handler:  elfinuart_err_int,
+        },
+};
+
+static int elfinuart_startup(struct uart_port *port)
+{
+        int ret;
+        u_int ucon;
+
+        /*
+         * Allocate the IRQs for TX and RX
+         */
+        __tx_irqaction[port->line].dev_id = (void *)port;
+        __rx_irqaction[port->line].dev_id = (void *)port;
+        __err_irqaction[port->line].dev_id = (void *)port;
+
+        ret = setup_irq( RX_IRQ(port), &__rx_irqaction[port->line]);
+        if (ret) goto rx_failed;
+
+#if 0
+        ret = setup_irq( TX_IRQ(port), &__tx_irqaction[port->line]);
+        if (ret) goto tx_failed;
+#endif
+
+#ifdef CONFIG_USE_ERR_IRQ
+        ret = setup_irq( ERR_IRQ(port), &__err_irqaction[port->line]);
+        if (ret) goto err_failed;
+#endif
+
+        ucon = (UCON_TX_INT_LVL | UCON_RX_INT_LVL |
+                        UCON_TX_INT | UCON_RX_INT | UCON_RX_TIMEOUT);
+
+
+        spin_lock_irq( &port->lock);
+
+        UART_UCON(port) = ucon;
+
+        spin_unlock_irq( &port->lock);
+
+        return 0;
+
+#ifdef CONFIG_USE_ERR_IRQ
+err_failed:
+        printk(KERN_ERR "%s: err failed\n", __FUNCTION__);
+        INT_DISABLE( ERR_IRQ(port));
+#endif
+tx_failed:
+        printk(KERN_ERR "%s: tx  failed\n", __FUNCTION__);
+        INT_DISABLE( TX_IRQ(port));
+rx_failed:
+        printk(KERN_ERR "%s: rx  failed\n", __FUNCTION__);
+        INT_DISABLE( RX_IRQ(port));
+        return ret;
+}
+
+static void elfinuart_shutdown(struct uart_port *port)
+{
+#ifdef CONFIG_USE_ERR_IRQ
+        INT_DISABLE( ERR_IRQ(port));
+#endif
+        INT_DISABLE( TX_IRQ(port));
+        INT_DISABLE( RX_IRQ(port));
+
+        UART_UCON(port) = 0x0;
+}
+
+#if 0
+static void elfinuart_change_speed(struct uart_port *port, u_int cflag, u_int iflag, u_int quot)
+{
+        u_int ulcon, ufcon;
+        int flags;
+
+        ufcon = UART_UFCON(port);
+
+        switch (cflag & CSIZE) {
+                case CS5:
+                        ulcon = ULCON_WL5;
+                break;
+                case CS6:
+                        ulcon = ULCON_WL6;
+                break;
+                case CS7:
+                        ulcon = ULCON_WL7;
+                break;
+                default:
+                        ulcon = ULCON_WL8;
+                break;
+        }
+
+        if (cflag & CSTOPB)
+                ulcon |= ULCON_STOP;
+        if (cflag & PARENB) {
+                if (!(cflag & PARODD))
+            ulcon |= ULCON_PAR_EVEN;
+        }
+
+        if (port->fifosize > 1)
+                ufcon |= UFCON_FIFO_EN;
+
+        port->read_status_mask =  UERSTAT_OVERRUN;
+
+        port->ignore_status_mask = 0;
+        if (iflag & IGNBRK) {
+                if (iflag & IGNPAR)
+                    port->ignore_status_mask |= UERSTAT_OVERRUN;
+        }
+
+        quot -= 1;
+
+        spin_lock_irqsave( &port->lock, flags );
+
+        UART_UFCON(port) = ufcon;
+        UART_ULCON(port) = ulcon;
+        UART_UBRDIV(port) = quot;
+
+        spin_unlock_irqrestore(&port->lock, flags);
+}
+
+#endif
+
+static void elfinuart_set_termios(struct uart_port *port, struct termios *termios, struct termios *old)
+{
+        int quot;
+
+        uart_update_timeout(port, termios->c_cflag, 115200);
+#if 0
+        quot = uart_get_divisor(port, 115200);
+        elfinuart_change_speed(port, termios->c_cflag, 0, quot);
+#endif
+
+}
+static void elfinuart_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+}
+
+static int elfinuart_set_wake(struct uart_port *port, unsigned int state)
+{
+        return 0;
+}
+
+
+
+
+static const char *elfinuart_type(struct uart_port *port)
+{
+        return __DRIVER_NAME;
+}
+
+static void elfinuart_config_port(struct uart_port *port, int flags)
+{
+        if (flags & UART_CONFIG_TYPE)
+                port->type = PORT_S3C24A0;
+}
+
+static void elfinuart_release_port(struct uart_port *port)
+{
+}
+
+static int elfinuart_request_port(struct uart_port *port)
+{
+        return 0;
+}
+
+static int elfinuart_verify_port(struct uart_port *port, struct serial_struct *serial)
+{
+        return 0;
+}
+
+static struct uart_ops elfin_pops = {
+        tx_empty     : elfinuart_tx_empty,
+        set_mctrl    : elfinuart_set_mctrl,
+        get_mctrl    : elfinuart_get_mctrl,
+        stop_tx      : elfinuart_stop_tx,
+        start_tx     : elfinuart_start_tx,
+        stop_rx      : elfinuart_stop_rx,
+        enable_ms    : elfinuart_enable_ms,
+        break_ctl    : elfinuart_break_ctl,
+        startup      : elfinuart_startup,
+        shutdown     : elfinuart_shutdown,
+        set_termios:    elfinuart_set_termios,
+        pm:             elfinuart_pm,
+        set_wake:       elfinuart_set_wake,
+        type         : elfinuart_type,
+        config_port  : elfinuart_config_port,
+        release_port : elfinuart_release_port,
+        request_port : elfinuart_request_port,
+        verify_port:    elfinuart_verify_port,
+};
+
+static struct uart_port elfin_ports[UART_NR] = {
+        {
+                iobase   : (unsigned long)(UART0_CTL_BASE),
+                irq      : IRQ_RXD0,
+                uartclk  : 130252800,
+                fifosize : 64,
+                ops      : &elfin_pops,
+                type     : PORT_S3C24A0,
+                flags    : ASYNC_BOOT_AUTOCONF,
+        },
+#ifndef CONFIG_BOARD_S3C24A0_SMDK
+        {
+                iobase   : (unsigned long)(UART1_CTL_BASE),
+                irq      : IRQ_RXD1,
+                uartclk  : 130252800,
+                fifosize : 64,
+                ops      : &elfin_pops,
+                type     : PORT_S3C24A0,
+                flags    : ASYNC_BOOT_AUTOCONF,
+        }
+#endif /* !CONFIG_BOARD_S3C24A0_SMDK */
+};
+
+void __init elfin_register_uart(int idx, int port)
+{
+        if (idx >= UART_NR) {
+                printk(KERN_ERR "%s: bad index number %d\n"
+                        , __FUNCTION__, idx);
+                return;
+        }
+        elfin_ports[idx].uartclk = elfin_get_bus_clk(GET_PCLK);
+
+        switch (port) {
+                case 0:
+                        elfin_ports[idx].iobase = (unsigned long)(UART0_CTL_BASE);
+                        elfin_ports[idx].irq  = IRQ_RXD0;
+                break;
+                case 1:
+                        elfin_ports[idx].iobase = (unsigned long)(UART1_CTL_BASE);
+                        elfin_ports[idx].irq  = IRQ_RXD1;
+                break;
+                default:
+                        printk(KERN_ERR "%s : bad port number %d\n", __FUNCTION__, port);
+        }
+}
+
+
+
+#ifdef CONFIG_SERIAL_S3C24A0_CONSOLE
+
+static void elfin_console_write(struct console *co, const char *s, u_int count)
+{
+        struct uart_port *port = elfin_ports + co->index;
+        __xmit_string( port, s, count);
+}
+
+static int __init elfin_console_setup(struct console *co, char *options)
+{
+        struct uart_port *port;
+        int baud = 115200;
+        int bits = 8;
+        int parity = 'n';
+        int flow = 0;
+
+        port = uart_get_console(elfin_ports, UART_NR, co);
+
+        if (options)
+                uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+        return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver elfin_reg;
+static struct console elfin_cons = {
+        name     : "ttyS",
+        write    : elfin_console_write,
+        device   : uart_console_device,
+        setup    : elfin_console_setup,
+        flags    : CON_PRINTBUFFER,
+        index    : -1,
+        data     : &elfin_reg,
+};
+
+static int __init elfin_console_init(void)
+{
+        register_console(&elfin_cons);
+        return 0;
+}
+
+console_initcall(elfin_console_init);
+
+#define S3C24A0_CONSOLE         &elfin_cons
+#else   /* CONFIG_SERIAL_S3C24A0_CONSOLE */
+#define S3C24A0_CONSOLE         NULL
+#endif  /* CONFIG_SERIAL_S3C24A0_CONSOLE */
+
+
+static struct uart_driver elfin_reg = {
+        owner          : THIS_MODULE,
+        driver_name    : "ttyS",
+        dev_name       : "ttyS",
+        major   : TTY_MAJOR,
+        minor   : 64,
+        nr      : UART_NR,
+        cons           : S3C24A0_CONSOLE,
+};
+
+static int __init elfinuart_init(void)
+{
+        int ret;
+
+        printk("Initializing %s\n", __DRIVER_NAME);
+        ret = uart_register_driver(&elfin_reg);
+        if (ret == 0) {
+                int i;
+
+                for (i = 0; i < UART_NR; i++)
+                        uart_add_one_port(&elfin_reg, &elfin_ports[i]);
+        }
+        return ret;
+
+}
+
+static void __exit elfinuart_exit(void)
+{
+        uart_unregister_driver(&elfin_reg);
+}
+
+module_init(elfinuart_init);
+module_exit(elfinuart_exit);
+
+
+MODULE_AUTHOR("Samsung");
+MODULE_DESCRIPTION("S3C24A0 generic serial port driver");
+MODULE_SUPPORTED_DEVICE("ttyS");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/time.h linux-2.6.9-hsc0/include/asm-armnommu/arch-atmel/time.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-atmel/time.h	2004-11-19 15:00:54.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-atmel/time.h	2004-11-19 15:01:39.000000000 +0900
@@ -25,64 +25,5 @@
 #error Wierd -- KERNEL_TIMER is not defined or something....
 #endif
 
-unsigned long atmel_gettimeoffset (void)
-{
-	volatile struct at91_timers* tt = (struct at91_timers*) (AT91_TC_BASE);
-	volatile struct at91_timer_channel* tc = &tt->chans[KERNEL_TIMER].ch;
-	return tc->cv * (1000*1000)/(ARM_CLK/128);
-}
-
-static irqreturn_t
-atmel_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-        do_timer(regs);
-        do_profile(regs);
-
-    return IRQ_HANDLED;
-}
-
-/*
- * Set up timer interrupt, and return the current time in seconds.
- */
-
-void __init  time_init (void)
-{
-        register volatile struct at91_timers* tt = (struct at91_timers*) (AT91_TC_BASE);
-        register volatile struct at91_timer_channel* tc = &tt->chans[KERNEL_TIMER].ch;
-        unsigned long v;
-
-	/* enable Kernel timer */
-	HW_AT91_TIMER_INIT(KERNEL_TIMER)
-
-        /* No SYNC */
-        tt->bcr = 0;
-        /* program NO signal on XC1 */
-        v = tt->bmr;
-	v &= ~TCNXCNS(KERNEL_TIMER,3);
-	v |= TCNXCNS(KERNEL_TIMER,1);
-        tt->bmr = v;
-
-        tc->ccr = 2;  /* disable the channel */
-
-        /* select ACLK/128 as inupt frequency for TC1 and enable CPCTRG */
-        tc->cmr = 3 | (1 << 14);
-
-        tc->idr = ~0ul;  /* disable all interrupt */
-        tc->rc = ((ARM_CLK/128)/HZ - 1);   /* load the count limit into the CR register */
-        tc->ier = TC_CPCS;  /* enable CPCS interrupt */
-
-	/*
-	 * @todo do those really need to be function pointers ?
-	 */
-        gettimeoffset = atmel_gettimeoffset;
-        timer_irq.handler = atmel_timer_interrupt;
-
-	/* set up the interrupt */
-        setup_irq(KERNEL_TIMER_IRQ_NUM, &timer_irq);
-
-        /* enable the channel */
-        tc->ccr = TC_SWTRG|TC_CLKEN;
-}
-
 #endif
 
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/time.h linux-2.6.9-hsc0/include/asm-armnommu/arch-espd_4510b/time.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-espd_4510b/time.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-espd_4510b/time.h	2004-11-23 10:33:34.000000000 +0900
@@ -28,82 +28,4 @@
 #ifndef __ASM_ARCH_TIME_H__
 #define __ASM_ARCH_TIME_H__
 
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/hardware.h>
-#include <asm/arch/timex.h>
-#include <asm/mach/irq.h>
-
-#define CLOCKS_PER_USEC	(CONFIG_ARM_CLK/1000000)
-
-static volatile unsigned long timer_cnt;
-
-unsigned long s3c4510b_gettimeoffset (void)
-{
-	unsigned long usec;
-
-	/* returns microseconds -- timer 1 is free running in countdown mode */
-	usec = 0xFFFFFFFF - inl( REG_TCNT1);
-	usec /= CLOCKS_PER_USEC;
-	
-	return usec;
-}
-
-static irqreturn_t
-s3c4510b_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-
-	timer_cnt++;
-
-#ifdef CONFIG_ARCH_ESPD_4510B
-	if ( ! (timer_cnt % (HZ/4))) {
-		LED_TOGGLE(0);
-	}
-#endif
-	do_timer(regs);
-	do_profile(regs);
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Set up timer interrupt
- */
-
-void __init  time_init (void)
-{
-	u_int32_t period;
-	
-	/*
-	 * disable and clear timers 0 and 1.  set both timers to
-	 * interval mode.
-	 */
-	outl( 0x0, REG_TMOD);
-	/* clear any pending interrupts */
-	outl( 0x1FFFFF, REG_INTPEND);
-
-	timer_cnt = 0;
-
-	/* initialize the timer period */
-	period = (CLOCK_TICK_RATE / HZ);
-	outl( period, REG_TDATA0);
-
-	/* set timer1 to continually count down from FFFFFFFF */
-	outl( 0xFFFFFFFF, REG_TDATA1);
-
-//	printk(KERN_INFO "time_init():  TICK_RATE: %u, HZ: %u, period: %u\n", CLOCK_TICK_RATE, HZ, period);
-
-	gettimeoffset     = s3c4510b_gettimeoffset;
-	timer_irq.handler = s3c4510b_timer_interrupt;
-
-	/* set up the interrupt vevtor for timer 0 match */
-	setup_irq( INT_TIMER0, &timer_irq);
-	
-	/* enable the timer IRQ */
-	INT_ENABLE( INT_TIMER0);
-
-	/* let timer 0 run... */
-	outl( TM0_RUN | TM1_RUN, REG_TMOD);
-}
-
 #endif
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/bitfield.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/bitfield.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/bitfield.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/bitfield.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,116 @@
+/*
+ *	FILE    	bitfield.h
+ *
+ *	Version 	1.1
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	April 1998 (April 1997)
+ *	System  	Advanced RISC Machine (ARM)
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of macros to operate on bit fields.
+ */
+
+
+
+#ifndef __BITFIELD_H
+#define __BITFIELD_H
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+#else
+#define UData(Data)	(Data)
+#endif
+
+
+/*
+ * MACRO: Fld
+ *
+ * Purpose
+ *    The macro "Fld" encodes a bit field, given its size and its shift value
+ *    with respect to bit 0.
+ *
+ * Note
+ *    A more intuitive way to encode bit fields would have been to use their
+ *    mask. However, extracting size and shift value information from a bit
+ *    field's mask is cumbersome and might break the assembler (255-character
+ *    line-size limit).
+ *
+ * Input
+ *    Size      	Size of the bit field, in number of bits.
+ *    Shft      	Shift value of the bit field with respect to bit 0.
+ *
+ * Output
+ *    Fld       	Encoded bit field.
+ */
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+
+/*
+ * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
+ *
+ * Purpose
+ *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
+ *    the size, shift value, mask, aligned mask, and first bit of a
+ *    bit field.
+ *
+ * Input
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FSize     	Size of the bit field, in number of bits.
+ *    FShft     	Shift value of the bit field with respect to bit 0.
+ *    FMsk      	Mask for the bit field.
+ *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
+ *    F1stBit   	First bit of the bit field.
+ */
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
+#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
+#define F1stBit(Field)	(UData (1) << FShft (Field))
+
+#define FClrBit(Data, Bit)	(Data = (Data & ~(Bit)))
+#define FClrFld(Data, Field)	(Data = (Data & ~FMsk(Field)))
+
+
+/*
+ * MACRO: FInsrt
+ *
+ * Purpose
+ *    The macro "FInsrt" inserts a value into a bit field by shifting the
+ *    former appropriately.
+ *
+ * Input
+ *    Value     	Bit-field value.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FInsrt    	Bit-field value positioned appropriately.
+ */
+
+#define FInsrt(Value, Field) \
+                	(UData (Value) << FShft (Field))
+
+
+/*
+ * MACRO: FExtr
+ *
+ * Purpose
+ *    The macro "FExtr" extracts the value of a bit field by masking and
+ *    shifting it appropriately.
+ *
+ * Input
+ *    Data      	Data containing the bit-field to be extracted.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FExtr     	Bit-field value.
+ */
+
+#define FExtr(Data, Field) \
+                	((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
+
+
+#endif /* __BITFIELD_H */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/clocks.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/clocks.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/clocks.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/clocks.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-s3c24a0/clocks.h
+ *
+ * $Id: clocks.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _S3C24A0_CLOCK_H_
+#define _S3C24A0_CLOCK_H_
+
+#include <asm/hardware.h>
+
+#define GET_PCLK	0
+#define GET_HCLK	1
+#define GET_UPLL        2
+
+#define GET_MDIV(x)	FExtr(x, fPLL_MDIV)
+#define GET_PDIV(x)	FExtr(x, fPLL_PDIV)
+#define GET_SDIV(x)	FExtr(x, fPLL_SDIV)
+
+#define get_cpu_clk()  elfin_get_cpu_clk()
+#define get_bus_clk(x) elfin_get_bus_clk((x))
+
+unsigned long elfin_get_cpu_clk(void);
+unsigned long elfin_get_bus_clk(int);
+#endif /* _S3C24A0_CLOCK_H_ */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/dma.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/dma.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/dma.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,55 @@
+/*
+ *  include/asm-arm/arch-s3c24a0/dma.h
+ *  
+ *  $Id: dma.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on linux/include/asm-arm/arch-s3c2410/dma.h
+ *
+ */
+
+#ifndef __ASM_ARCH_DMA_H__
+#define __ASM_ARCH_DMA_H__
+
+#include "hardware.h"
+
+#define MAX_DMA_ADDRESS	0xffffffff
+
+/*
+ * NB: By nandy
+ * If MAX_DMA_CHANNELS is zero, It means that this architecuture not use 
+ * the regular generic DMA interface provided by kernel.
+ * Why? I don't know. I will investigate S3C24A0 DMA model and generic
+ * DMA interface. But not yet.
+ */
+#define MAX_DMA_CHANNELS	0
+
+/* The S3C24A0 has four internal DMA channels. */
+#define S3C24A0_DMA_CHANNELS	4
+
+#define MAX_S3C24A0_DMA_CHANNELS	S3C24A0_DMA_CHANNELS
+
+#define DMA_CH0			0
+#define DMA_CH1			1
+#define DMA_CH2			2
+#define DMA_CH3			3
+
+#define DMA_BUF_WR		1
+#define DMA_BUF_RD		0
+
+typedef void (*dma_callback_t)(void *buf_id, int size);
+
+/* S3C24A0 DMA API */
+extern int elfin_request_dma(const char *device_id, dmach_t channel,
+				dma_callback_t write_cb, dma_callback_t read_cb); 
+extern int elfin_dma_queue_buffer(dmach_t channel, void *buf_id, 
+					dma_addr_t data, int size, int write);
+extern int elfin_dma_flush_all(dmach_t channel);
+extern void elfin_free_dma(dmach_t channel);
+extern int elfin_dma_get_current(dmach_t channel, void **buf_id, dma_addr_t *addr);
+extern int elfin_dma_stop(dmach_t channel);
+    
+#endif /* __ASM_ARCH_DMA_H__ */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/hardware.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/hardware.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/hardware.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/hardware.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,139 @@
+/*
+ * include/asm-arm/arch-s3c24a0/hardware.h
+ *
+ * $Id: hardware.h,v 1.2 2004/07/13 07:07:01 noyman Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * based on S3C2410.h modified by hcyun <heechul.yun@sa
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <linux/config.h>
+
+/* called on reserve_node_zero() for reserving mmu section table */
+#ifndef CONFIG_DRAM_BASE
+  #define CONFIG_DRAM_BASE 0x10000000
+#endif
+
+#define MACH_RESERVE_BOOTMEM()  do { \
+    reserve_bootmem_node(pgdat, (CONFIG_DRAM_BASE + 0x4000), 0x4000); \
+  } while(0)
+
+#define MACH_FREE_BOOTMEM()
+
+
+#define PCIO_BASE               0
+
+#if defined(CONFIG_DRAM_BASE) && defined(CONFIG_DRAM_SIZE)
+  #define PA_SDRAM_BASE          (CONFIG_DRAM_BASE)
+  #define MEM_SIZE               (CONFIG_DRAM_SIZE)
+#else
+  #define PA_SDRAM_BASE          0x10000000
+  #define MEM_SIZE               0x04000000
+#endif
+
+/*
+ * S3C24A0 internal I/O mappings
+ *
+ * We have the following mapping:
+ *              phys            virt
+ *              40000000        e0000000
+ */
+
+#ifndef CONFIG_UCLINUX
+
+
+#define VIO_BASE                0xe0000000      /* virtual start of IO space */
+#define PIO_START               0x40000000      /* physical start of IO space */
+
+#define io_p2v(x) ((x) | 0xa0000000)
+#define io_v2p(x) ((x) & ~0xa0000000)
+
+#define io_p2v_isp(x) ((x) + 0xec000000)
+#define io_v2p_isp(x) ((x) - 0xec000000)
+
+
+#else /* UCLINUX */
+
+#define PIO_START               0x40000000
+#define VIO_BASE                PIO_START
+
+#define io_p2v(x) (x)
+#define io_v2p(x) (x)
+
+#define io_p2v_isp(x) (x)
+#define io_v2p_isp(x) (x)
+
+
+#endif  /* CONFIG_UCLINUX */
+
+
+#ifndef __ASSEMBLY__
+#include <asm/types.h>
+
+/*
+ * This __REG() version gives the same results as the one above, except
+ * that we are fooling gcc some how so it generates far better and smaller
+ * assembly code for access to contigous registers. It's a shame that gcc
+ * doesn't guess this by itself
+ */
+typedef struct { volatile u32 offset[4096]; } __regbase;
+#define __REGP(x)       ((__regbase *)((x)&~4095))->offset[((x)&4095)>>2]
+#define __REG(x)        __REGP(io_p2v(x))
+
+/* Let's kick gcc's ass again... */
+# define __REG2(x,y)    \
+        ( __builtin_constant_p(y) ? (__REG((x) + (y))) \
+                                  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+
+#define __PREG(x)       (io_v2p((u32)&(x)))
+
+/*SEO add  to allocate vertual memory address for ISP1583 */
+#define __REG_ISP(x)    io_p2v_isp(x)
+#define __PREG_ISP(x)   io_v2p_isp(x)
+
+
+#else   /* __ASSEMBLY__ */
+
+# define __REG(x)       io_p2v(x)
+# define __PREG(x)      io_v2p(x)
+
+#endif  /* __ASSEMBLY__ */
+
+#include "S3C24A0.h"
+
+#ifndef __ASSEMBLY__
+
+#define EINT_PULLUP_EN          (0)
+#define EINT_PULLUP_DIS         (1)
+
+#define EINT_LOW_LEVEL          (0x0)
+#define EINT_HIGH_LEVEL         (0x1)
+#define EINT_FALLING_EDGE       (0x2)
+#define EINT_RISING_EDGE        (0x4)
+#define EINT_BOTH_EDGES         (0x6)
+
+extern int set_external_irq(int irq, int edge, int pullup);
+
+#endif
+
+#include "smdk.h"
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/ide.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/ide.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/ide.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/ide.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,148 @@
+/*
+ * include/asm-arm/arch-s3c24a0/ide.h
+ *
+ *
+ * Originally based upon linux/include/asm-arm/arch-sa1100/ide.h
+ *
+ * Changes
+ *
+ * 2004/06/10 <heechul.yun@samsung.com>  SPJ CPLD IDE support
+ * 2004/06/13 <heechul.yun@samsung.com>  CPLD IDE and USB csupport for SPJ
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+
+#ifndef MAX_HWIFS
+        #define MAX_HWIFS       1
+#else
+        #undef MAX_HWIFS
+        #define MAX_HWIFS 1
+#endif
+
+#define CPLD_IDE_DEBUG  // hcyun
+
+/*
+ * Set up a hw structure for a specified data port, control port and IRQ.
+ * This should follow whatever the default interface uses.
+ */
+static __inline__ void
+ide_init_hwif_ports(hw_regs_t *hw, int data_port, int ctrl_port, int *irq)
+{
+        ide_ioreg_t reg;
+
+        memset(hw, 0, sizeof(*hw));
+
+        reg = (ide_ioreg_t)data_port;
+
+        /* increasing 8 */
+        hw->io_ports[IDE_DATA_OFFSET] =  reg + 0;
+        hw->io_ports[IDE_ERROR_OFFSET] = reg + (1 << 3);
+        hw->io_ports[IDE_NSECTOR_OFFSET] = reg + (2 << 3);
+        hw->io_ports[IDE_SECTOR_OFFSET] = reg + (3 << 3);
+        hw->io_ports[IDE_LCYL_OFFSET] = reg + (4 << 3);
+        hw->io_ports[IDE_HCYL_OFFSET] = reg + (5 << 3);
+        hw->io_ports[IDE_SELECT_OFFSET] = reg + (6 << 3);
+        hw->io_ports[IDE_STATUS_OFFSET] = reg + (7 << 3);
+
+        hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
+
+        if (irq)
+                *irq = 0;
+}
+
+
+/*
+ * CPLD IDE reset. to reset first assert 0 and then assert 1
+ */
+
+static __inline__ void ide_set_reset(int on)
+{
+        volatile unsigned char *usb_reset = (unsigned char *)(SMDK_CPLD_USB_VIO+0x00800000);
+        volatile unsigned char *ide_reset = (unsigned char *)(SMDK_CPLD_IDE_VIO+0x00800000);
+
+        if ( on ) {
+                /* turn CPLD to IDE mode */
+                *ide_reset = 0x02;
+
+                /* turn on IDE */
+                *ide_reset = 0x03;
+
+        } else {
+                /* turn off IDE */
+                *ide_reset = 0x02;
+
+                *ide_reset = 0x02;
+        }
+
+/*
+        *ide_reset = 0x1;
+        *usb_reset = 0x0;
+        *usb_reset = 0x1;
+*/
+
+}
+
+
+/*
+ * Register the standard ports for this architecture with the IDE driver.
+ */
+static __inline__ void
+ide_init_default_hwifs(void)
+{
+        /*
+                A7      A6      A5      A4      A3      <-- CPLD address line used
+
+                CE2     CE1     A2      A1      A0       IORD   IOWR
+                ---------------------------------
+                1       0       0       0       0        data port
+                ..
+                ..
+
+                0       1       1       1       0        control port
+
+                data port = SMDK_CPLD_IDE_VIO + 0x80
+                control port = SMDK_CPLD_IDE_VIO + 0x70
+
+         */
+
+        /* Nothing to declare... */
+
+        int ret;
+
+        hw_regs_t hw;
+
+        ide_init_hwif_ports(&hw, SMDK_CPLD_IDE_VIO + 0x80, SMDK_CPLD_IDE_VIO + 0x70, NULL);
+
+        hw.irq = SMDK_CPLD_IDE_IRQ;
+
+        ide_register_hw(&hw, NULL);
+
+
+#ifdef CPLD_IDE_DEBUG
+        printk("SMDK24A0 : IDE initialize - hcyun \n");
+        printk("!!FIXME!! IDE and cs8900 are controlled by SROM bank1 and need different timing and bus width\n");
+#endif
+
+        bank1_set_state(B1_IDE_PIO4);
+
+        // ide reset
+        ide_set_reset(0);
+
+        mdelay(250);
+
+        ide_set_reset(1);
+
+        mdelay(500); // wait 250ms see ATA spec
+
+        printk("riging edge interrupt\n");
+        ret = set_external_irq(SMDK_CPLD_IDE_IRQ, EINT_RISING_EDGE, EINT_PULLUP_EN);
+
+        if (ret)
+                printk("ERROR: irq set failed\n");
+
+}
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/io.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/io.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/io.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,45 @@
+/*
+ * include/asm-arm/arch-s3c24a0/io.h
+ *
+ * $Id: io.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)         (PCIO_BASE + (a))
+#define __mem_pci(a)    ((unsigned long)(a))
+#define __mem_isa(a)    ((unsigned long)(a))
+
+#if 0
+/*
+ * Generic virtual read/write
+ */
+#define __arch_getw(a)                  (*(volatile unsigned short *)(a))
+#define __arch_putw(v,a)                (*(volatile unsigned short *)(a) = (v))
+#endif
+
+#define iomem_valid_addr(iomem,sz)      (1)
+#define iomem_to_phys(iomem)            (iomem)
+
+#endif /* __ASM_ARM_ARCH_IO_H */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/irq.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/irq.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/irq.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,16 @@
+/*
+ * include/asm-arm/arch-s3c24a0/irq.h
+ * 
+ * $Id: irq.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This prototype is required for cascading of multiplexed interrupts.
+ * Since it doesn't exist elsewhere, we'll put it here for now.
+ */
+extern unsigned int fixup_irq(int i);
+extern void do_IRQ(int irq, struct pt_regs *regs);
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/irqs.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/irqs.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/irqs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/irqs.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,144 @@
+/*
+ * include/asm-arm/arch-s3c24a0/irqs.h
+ * 
+ * $Id: irqs.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*                    +-+
+ *                    |m|    +---------+
+ *    sub-irq ------\ |a|--> | sub-irq |
+ *    sources ------/ |s|    | status  |\
+ *                    |k|    +---------+ \
+ *                    +-+                 \
+ *                                         \
+ *                    +-+                   \      +-+
+ *                    |m|    +---------+     +---> |m|     +--------+
+ * external irq ----\ |a|--> | ext-irq |---------> |a|--\  |main-irq|
+ *    sources   ----/ |s|    | status  |       +-> |s|--/  | status |
+ *                    |k|    +---------+      /    |k|     +--------+
+ *                    +-+                    /     +-+
+ *                                          /
+ *                                         /
+ *                                        /
+ *  irq sources -------------------------/
+ *
+ */
+
+
+/*
+ * We have three groups.
+ * #0 : Normal (or Main) IRQs
+ * #1 : Sub-IRQs
+ * #2 : External IRQs
+ */
+#define NR_IRQ_GRP			(32)	/* number of irqs in group */
+#define IRQ_GRP0_START		(0)
+#define IRQ_GRP1_START		(IRQ_GRP0_START + NR_IRQ_GRP)
+#define IRQ_GRP2_START		(IRQ_GRP1_START + NR_IRQ_GRP)
+
+#define NR_IRQS				(NR_IRQ_GRP * 3)
+
+#define SUBIRQ_ENC(x)		((x) + IRQ_GRP1_START)
+#define SUBIRQ_DEC(x)		((x) - IRQ_GRP1_START)
+#define EINTIRQ_ENC(x)		((x) + IRQ_GRP2_START)
+#define EINTIRQ_DEC(x)		((x) - IRQ_GRP2_START)
+
+/* Interrupt controller */
+#define IRQ_EINT0_2			(0)		/* External interrupt 0 ~ 2 */
+#define IRQ_EINT3_6			(1)		/* External interrupt 3 ~ 6 */
+#define IRQ_EINT7_10			(2)		/* External interrupt 7 ~ 10 */
+#define IRQ_EINT11_14			(3)		/* External interrupt 11 ~ 14 */
+#define IRQ_EINT15_18			(4)		/* External interrupt 15 ~ 18 */
+#define IRQ_TIC				(5)		/* RTC time tick */
+#define IRQ_DCTQ			(6)		/* DCTQ */
+#define IRQ_MC				(7)		/* MC */
+#define IRQ_ME				(8)		/* ME */
+#define IRQ_KEYPAD			(9)		/* Keypad */
+#define IRQ_TIMER0			(10)	/* Timer 0 */
+#define IRQ_TIMER1			(11)	/* Timer 1 */
+#define IRQ_TIMER2			(12)	/* Timer 2 */
+#define IRQ_TIMER3_4			(13)	/* Timer 3, 4 */
+#define IRQ_LCD_POST			(14)	/* LCD/POST */
+#define IRQ_CAM_C			(15)	/* Camera Codec */
+#define IRQ_WDT_BATFLT			(16)	/* WDT/BATFLT */
+#define IRQ_UART0			(17)	/* UART 0 */
+#define IRQ_CAM_P			(18)	/* Camera Preview */
+#define IRQ_MODEM			(19)	/* Modem */
+#define IRQ_DMA				(20)	/* DMA channels for S-bus */
+#define IRQ_SDI				(21)	/* SDI MMC */
+#define IRQ_SPI0			(22)	/* SPI 0 */
+#define IRQ_UART1			(23)	/* UART 1 */
+#define IRQ_AC97_NFLASH			(24)	/* AC97/NFALASH */
+#define IRQ_USBD			(25)	/* USB device */
+#define IRQ_USBH			(26)	/* USB host */
+#define IRQ_IIC				(27)	/* IIC */
+#define IRQ_IRDA_MSTICK			(28)	/* IrDA/MSTICK */
+#define IRQ_VLX_SPI1			(29)	/* SPI 1 */
+#define IRQ_RTC				(30)	/* RTC alaram */
+#define IRQ_ADC_PENUPDN			(31)	/* ADC EOC/Pen up/Pen down */
+
+/* SUB IRQ */
+#define IRQ_RXD0			SUBIRQ_ENC(0)
+#define IRQ_TXD0			SUBIRQ_ENC(1)
+#define IRQ_ERR0			SUBIRQ_ENC(2)
+#define IRQ_RXD1			SUBIRQ_ENC(3)
+#define IRQ_TXD1			SUBIRQ_ENC(4)
+#define IRQ_ERR1			SUBIRQ_ENC(5)
+#define IRQ_IRDA			SUBIRQ_ENC(6)
+#define IRQ_MSTICK			SUBIRQ_ENC(7)
+#define IRQ_TIMER3			SUBIRQ_ENC(11)
+#define IRQ_TIMER4			SUBIRQ_ENC(12)
+#define IRQ_WDT				SUBIRQ_ENC(13)
+#define IRQ_BATFLT			SUBIRQ_ENC(14)
+#define IRQ_POST			SUBIRQ_ENC(15)
+#define IRQ_DISP_FIFO			SUBIRQ_ENC(16)
+#define IRQ_PENUP			SUBIRQ_ENC(17)
+#define IRQ_PENDN			SUBIRQ_ENC(18)
+#define IRQ_ADC				SUBIRQ_ENC(19)
+#define IRQ_DISP_FRAME			SUBIRQ_ENC(20)
+#define IRQ_NFLASH			SUBIRQ_ENC(21)
+#define IRQ_AC97			SUBIRQ_ENC(22)
+#define IRQ_SPI1			SUBIRQ_ENC(23)
+#define IRQ_VLX				SUBIRQ_ENC(24)
+#define IRQ_DMA0			SUBIRQ_ENC(25)
+#define IRQ_DMA1			SUBIRQ_ENC(26)
+#define IRQ_DMA2			SUBIRQ_ENC(27)
+#define IRQ_DMA3			SUBIRQ_ENC(28)
+
+/* External IRQ */
+#define IRQ_EINT0			EINTIRQ_ENC(0)
+#define IRQ_EINT1			EINTIRQ_ENC(1)
+#define IRQ_EINT2			EINTIRQ_ENC(2)
+#define IRQ_EINT3			EINTIRQ_ENC(3)
+#define IRQ_EINT4			EINTIRQ_ENC(4)
+#define IRQ_EINT5			EINTIRQ_ENC(5)
+#define IRQ_EINT6			EINTIRQ_ENC(6)
+#define IRQ_EINT7			EINTIRQ_ENC(7)
+#define IRQ_EINT8			EINTIRQ_ENC(8)
+#define IRQ_EINT9			EINTIRQ_ENC(9)
+#define IRQ_EINT10			EINTIRQ_ENC(10)
+#define IRQ_EINT11			EINTIRQ_ENC(11)
+#define IRQ_EINT12			EINTIRQ_ENC(12)
+#define IRQ_EINT13			EINTIRQ_ENC(13)
+#define IRQ_EINT14			EINTIRQ_ENC(14)
+#define IRQ_EINT15			EINTIRQ_ENC(15)
+#define IRQ_EINT16			EINTIRQ_ENC(16)
+#define IRQ_EINT17			EINTIRQ_ENC(17)
+#define IRQ_EINT18			EINTIRQ_ENC(18)
+#define IRQ_EINT19			EINTIRQ_ENC(19)
+#define IRQ_EINT20			EINTIRQ_ENC(20)
+#define IRQ_EINT21			EINTIRQ_ENC(21)
+#define IRQ_EINT22			EINTIRQ_ENC(22)
+#define IRQ_EINT23			EINTIRQ_ENC(23)
+#define IRQ_EINT24			EINTIRQ_ENC(24)
+#define IRQ_EINT25			EINTIRQ_ENC(25)
+#define IRQ_EINT26			EINTIRQ_ENC(26)
+#define IRQ_EINT27			EINTIRQ_ENC(27)
+#define IRQ_EINT28			EINTIRQ_ENC(28)
+#define IRQ_EINT29			EINTIRQ_ENC(29)
+#define IRQ_EINT30			EINTIRQ_ENC(30)
+#define IRQ_EINT31			EINTIRQ_ENC(31)
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/keyboard.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/keyboard.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/keyboard.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/keyboard.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,134 @@
+/*
+ * keyboard.h
+ *
+ * $Id: keyboard.h,v 1.2 2004/07/23 07:45:32 hcyun Exp $
+ *
+ */
+
+#ifndef _S3C24A0_KEYBOARD_H
+#define _S3C24A0_KEYBOARD_H
+
+#define kbd_disable_irq()       do { } while(0);
+#define kbd_enable_irq()        do { } while(0);
+
+#define k_leds(x...)
+#define k_setkeycode(x...)
+#define k_getkeycode(x...)
+#define k_unexpected_up(x...)   (1)
+
+/* S3C24A0 SPI */
+
+#if 1 // hcyun
+extern int elfin_kbd_init (void);
+#define kbd_init_hw()           elfin_kbd_init()
+#else
+#define kbd_init_hw()           do {} while(0);
+#endif
+
+/* Generic Keyboard Scan Codes */
+#define KK_NONE         0x00
+#define KK_ESC          0x01
+#define KK_F1           0x3b
+#define KK_F2           0x3c
+#define KK_F3           0x3d
+#define KK_F4           0x3e
+#define KK_F5           0x3f
+#define KK_F6           0x40
+#define KK_F7           0x41
+#define KK_F8           0x42
+#define KK_F9           0x43
+#define KK_F10          0x44
+#define KK_F11          0x57
+#define KK_F12          0x58
+#define KK_PRNT         0x63    /* PrintScreen */
+#define KK_SCRL         0x46    /* Scroll Lock */
+#define KK_BRK          0x77    /* Break */
+#define KK_AGR          0x29    /* ` */
+#define KK_1            0x02
+#define KK_2            0x03
+#define KK_3            0x04
+#define KK_4            0x05
+#define KK_5            0x06
+#define KK_6            0x07
+#define KK_7            0x08
+#define KK_8            0x09
+#define KK_9            0x0a
+#define KK_0            0x0b
+#define KK_MINS         0x0c    /* - */
+#define KK_EQLS         0x0d    /* = */
+#define KK_BKSP         0x0e    /* BKSP */
+#define KK_INS          0x6e    /* Insert */
+#define KK_HOME         0x66
+#define KK_PGUP         0x68
+#define KK_NUML         0x45
+#define KP_SLH          0x62    /* KP / */
+#define KP_STR          0x37    /* KP * */
+#define KP_MNS          0x4a    /* KP - */
+#define KK_TAB          0x0f
+#define KK_Q            0x10
+#define KK_W            0x11
+#define KK_E            0x12
+#define KK_R            0x13
+#define KK_T            0x14
+#define KK_Y            0x15
+#define KK_U            0x16
+#define KK_I            0x17
+#define KK_O            0x18
+#define KK_P            0x19
+#define KK_LSBK         0x1a    /* [ */
+#define KK_RSBK         0x1b    /* ] */
+#define KK_ENTR         0x1c
+#define KK_DEL          0x6f
+#define KK_END          0x6b
+#define KK_PGDN         0x6d
+#define KP_7            0x47
+#define KP_8            0x48
+#define KP_9            0x49
+#define KP_PLS          0x37    /* KP + */
+#define KK_CAPS         0x3a
+#define KK_A            0x1e
+#define KK_S            0x1f
+#define KK_D            0x20
+#define KK_F            0x21
+#define KK_G            0x22
+#define KK_H            0x23
+#define KK_J            0x24
+#define KK_K            0x25
+#define KK_L            0x26
+#define KK_SEMI         0x27    /* ; */
+#define KK_SQOT         0x28    /* ' */
+#define KK_HASH         0x29    /* ` */
+#define KP_4            0x4b
+#define KP_5            0x4c
+#define KP_6            0x4d
+#define KK_LSFT         0x2a    /* L SHIFT */
+#define KK_BSLH         0x2b    /* \ */
+#define KK_Z            0x2c
+#define KK_X            0x2d
+#define KK_C            0x2e
+#define KK_V            0x2f
+#define KK_B            0x30
+#define KK_N            0x31
+#define KK_M            0x32
+#define KK_COMA         0x33    /* , */
+#define KK_DOT          0x34    /* . */
+#define KK_FSLH         0x35    /* / */
+#define KK_RSFT         0x36    /* R SHIFT */
+#define KK_UP           0x67
+#define KP_1            0x4f
+#define KP_2            0x50
+#define KP_3            0x51
+#define KP_ENT          0x60    /* KP Enter */
+#define KK_LCTL         0x1d    /* L CTRL */
+#define KK_LALT         0x38    /* L ALT */
+#define KK_SPCE         0x39    /* SPACE */
+#define KK_RALT         0x64    /* R ALT */
+#define KK_RCTL         0x61    /* R CTRL */
+#define KK_LEFT         0x69
+#define KK_DOWN         0x6c
+#define KK_RGHT         0x6a
+#define KP_0            0x52
+#define KP_DOT          0x53    /* KP . */
+#define KK_21           0x21
+
+#endif  /* _S3C24A0_KEYBOARD_H */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/memory.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/memory.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/memory.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/memory.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ * include/asm-arm/arch-s3c24a0/memory.h
+ *
+ * $Id: memory.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * (C) Heechul Yun <heechul.yun@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H_
+#define __ASM_ARCH_MEMORY_H_
+
+#define TASK_SIZE       (0x13000000UL)
+#define TASK_SIZE_26    TASK_SIZE
+
+#ifndef CONFIG_DRAM_BASE
+#define PHYS_OFFSET (0x10000000UL)
+#define END_MEM     (0x13000000UL)
+#else
+#define PHYS_OFFSET (CONFIG_DRAM_BASE)
+#define END_MEM     (CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+#endif
+#define PAGE_OFFSET (PHYS_OFFSET)
+
+
+#define __virt_to_phys(vpage) ((unsigned long) (vpage))
+#define __phys_to_virt(ppage) ((unsigned long) (ppage))
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+
+#endif /* __ASM_ARCH_MEMORY_H_ */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/param.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/param.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/param.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,11 @@
+/*
+ * include/asm-arm/arch-s3c24a0/param.h
+ * 
+ * $Id: param.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* FIXME: Nothing to do */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-common.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-common.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-common.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-common.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ * include/asm-arm/arch-s3c24a0/s3c24a0-common.h
+ *
+ * $Id: s3c24a0-common.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#ifndef _INCLUDE_LINUETTE_COMMON_H_
+#define _INCLUDE_LINUETTE_COMMON_H_
+#ifndef __ASSEMBLY__
+
+/* 
+ * New Audio Format MSM9842
+ *
+ * NOTE:
+ *  refer to linux/soundcard.h
+ */
+#define AFMT_4_ADPCM2 0x80000000	// 4bit ADPCM2
+#define AFMT_5_ADPCM2 0x40000000	// 5bit ADPCM2
+#define AFMT_6_ADPCM2 0x20000000	// 6bit ADPCM2
+#define AFMT_7_ADPCM2 0x10000000	// 7bit ADPCM2
+#define AFMT_8_ADPCM2 0x08000000	// 8bit ADPCM2
+
+/*
+ * device name
+ */
+#define BIOS_NAME		"apm_bios"
+
+/* definition of key/buttons */
+#include "s3c24a0-key.h"
+
+#endif	/* __ASSEMBLY__ */
+#endif /* _INCLUDE_LINUETTE_COMMON_H_ */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/S3C24A0.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/S3C24A0.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/S3C24A0.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/S3C24A0.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,1462 @@
+/*
+ * linux/include/asm-arm/arch-s3c24a0/S3C24A0.h
+ *
+ * $Id: S3C24A0.h,v 1.2 2004/07/26 13:53:10 hcyun Exp $
+ *
+ */
+
+#ifndef _S3C24A0_H_
+#define _S3C24A0_H_
+
+#include "hardware.h"
+#include "bitfield.h"
+
+/*
+ * clock and power ( chapter 32 )
+ */
+
+#define LOCKTIME        __REG(0x40000000)
+#define XTALWSET        __REG(0x40000004)
+#define MPLLCON         __REG(0x40000010)
+#define UPLLCON         __REG(0x40000014)
+#define CLKCON          __REG(0x40000020)
+#define CLKSRC          __REG(0x40000024)
+#define CLKDIVN         __REG(0x40000028)
+#define POWERMAN        __REG(0x40000030)
+#define SOFTRST         __REG(0x40000038)
+
+/* fields */
+#define fLOCK_U         Fld(12,16) /* UPLL lock time in LOCKTIME */
+#define fLOCK_M         Fld(12,0)  /* MPLL lock time in LOCKTIME */
+#define fXTAL_U         Fld(16,16) /* UPLL wait time in XTALWSET */
+#define fXTAL_M         Fld(16,0)  /* MPLL wait time in XTALWSET */
+#define fPLL_MDIV       Fld(8,12)
+#define fPLL_PDIV       Fld(6,4)
+#define fPLL_SDIV       Fld(2,0)
+#define fEXTDIV         Fld(3,0)   /* external clock div. in CLKSRC */
+#define fCLK_CAMDIV     Fld(4,8)   /* CAM clock div. in CLKDIV */
+#define fCLK_MP4DIV     Fld(4,4)   /* MPEG4 clock div. in CLKDIV */
+#define fCNFG_BF        Fld(2,9)   /* battery fault handling config in PWRMAN */
+#define fSLEEP_CODE     Fld(8,0)   /* sleep mode setting code in PWRMAN */
+/* bits */
+#define CLKCON_VPOST    (1<<25) /* CLKCON */
+#define CLKCON_MPEG4IF  (1<<24)
+#define CLKCON_CAM_UPLL (1<<23)
+#define CLKCON_LCD      (1<<22)
+#define CLKCON_CAM_HCLK (1<<21)
+#define CLKCON_MPEG4    (1<<20)
+#define CLKCON_KEYPAD   (1<<19)
+#define CLKCON_ADC      (1<<18)
+#define CLKCON_SD       (1<<17)
+#define CLKCON_MS       (1<<16)      /* memory stick */
+#define CLKCON_USBD     (1<<15)
+#define CLKCON_GPIO     (1<<14)
+#define CLKCON_IIS      (1<<13)
+#define CLKCON_IIC      (1<<12)
+#define CLKCON_SPI      (1<<11)
+#define CLKCON_UART1    (1<<10)
+#define CLKCON_UART0    (1<<9)
+#define CLKCON_PWM      (1<<8)
+#define CLKCON_USBH     (1<<7)
+#define CLKCON_AC97     (1<<6)
+#define CLKCON_EAHB     (1<<5)
+#define CLKCON_IrDA     (1<<4)
+#define CLKCON_IDLE     (1<<2)
+#define CLKCON_MON      (1<<1)
+#define CLKCON_STOP     (1<<0)
+#define CLKSRC_OSC      (1<<8) /* CLKSRC */
+#define CLKSRC_nUPLL    (1<<7)
+#define CLKSRC_nPLL     (1<<5)
+#define CLKSRC_EXT      (1<<4)
+#define CLKDIV_HCLK     (1<<1) /* CLKDIV */
+#define CLKDIV_PCLK     (1<<0)
+#define PWRMAN_MASKTS   (1<<8) /* PWRMAN */
+
+//#define fCLKDIVN_BUS    Fld(2,0)      /* S3C24A0X */
+#define fCLKDIVN_BUS    Fld(3,0)        /* SW.LEE: S3C24A0A */
+#define CLKDIVN_BUS     FExtr(CLKDIVN, fCLKDIVN_BUS)
+#define CLKDIVN_CAM(x)  FInsrt((x), fCLK_CAMDIV)
+#define CLKDIVN_CAM_MSK FMsk(fCLK_CAMDIV)
+#define CLKDIVN_CAM_VAL FExtr(CLKDIVN, fCLK_CAMDIV)
+#define CLKDIVN_MP4(x)  FInsrt((x), fCLK_MP4DIV)
+#define CLKDIVN_MP4_MSK FMsk(fCLK_MP4DIV)
+
+
+/*
+ * PWM timer ( chapter 7 )
+ *
+ * five 16bit timers.
+ * two 8bit prescalers, four 4bit dividers
+ * programmable duty control of output waveform
+ * auto-load mode, one-shot pulse mode
+ * dead-zone generator
+ */
+#define bPWM_TIMER(Nb)      __REG(0x44000000 + (Nb))
+#define bPWM_BUFn(Nb,x)     bPWM_TIMER(0x0c + (Nb)*0x0c + (x))
+/* Registers */
+#define TCFG0           __REG(0x44000000)
+#define TCFG1           __REG(0x44000004)
+#define TCON            __REG(0x44000008)
+#define TCNTB0          __REG(0x4400000C)
+#define TCMPB0          __REG(0x44000010)
+#define TCNTO0          __REG(0x44000014)
+#define TCNTB1          bPWM_BUFn(1,0x0)
+#define TCMPB1          bPWM_BUFn(1,0x4)
+#define TCNTO1          bPWM_BUFn(1,0x8)
+#define TCNTB2          bPWM_BUFn(2,0x0)
+#define TCMPB2          bPWM_BUFn(2,0x4)
+#define TCNTO2          bPWM_BUFn(2,0x8)
+#define TCNTB3          bPWM_BUFn(3,0x0)
+#define TCMPB3          bPWM_BUFn(3,0x4)
+#define TCNTO3          bPWM_BUFn(3,0x8)
+#define TCNTB4          bPWM_BUFn(4,0x0)
+#define TCNTO4          bPWM_BUFn(4,0x4)
+
+#define fTCFG0_DZONE    Fld(8,16) /* the dead zone length (= timer 0) */
+#define fTCFG0_PRE1     Fld(8,8)  /* prescaler value for time 2,3,4 */
+#define fTCFG0_PRE0     Fld(8,0)  /* prescaler value for time 0,1 */
+#define SET_PRESCALER0(x)       ({ TCFG0 = (TCFG0 & ~(0xff)) | (x); })
+#define GET_PRESCALER0()        FExtr(TCFG0, fTCFG0_PRE0)
+#define SET_PRESCALER1(x)       ({ TCFG0 = (TCFG0 & ~(0xff << 8)) | ((x) << 8); })
+#define GET_PRESCALER1()        FExtr(TCFG0, fTCFG0_PRE0)
+
+#define fTCFG1_DMA      Fld(4,20) /* select DMA request channel */
+#define fTCFG1_T4MUX    Fld(4,16) /* timer4 input mux */
+#define fTCFG1_T3MUX    Fld(4,12) /* timer3 input mux */
+#define fTCFG1_T2MUX    Fld(4,8)  /* timer2 input mux */
+#define fTCFG1_T1MUX    Fld(4,4)  /* timer1 input mux */
+#define fTCFG1_T0MUX    Fld(4,0)  /* timer0 input mux */
+#define TIMER0_DIV(x)   FInsrt((x), fTCFG1_T0MUX)
+#define TIMER1_DIV(x)   FInsrt((x), fTCFG1_T1MUX)
+#define TIMER2_DIV(x)   FInsrt((x), fTCFG1_T2MUX)
+#define TIMER3_DIV(x)   FInsrt((x), fTCFG1_T3MUX)
+#define TIMER4_DIV(x)   FInsrt((x), fTCFG1_T4MUX)
+
+#define fTCON_TIMER4    Fld(3,20)
+#define fTCON_TIMER3    Fld(4,16)
+#define fTCON_TIMER2    Fld(4,12)
+#define fTCON_TIMER1    Fld(4,8)
+#define fTCON_TIMER0    Fld(5,0)
+
+#define fCNTB           Fld(16,0)
+#define fCNTO           Fld(16,0)
+#define fCMPB           Fld(16,0)
+
+#define TCFG0_DZONE(x)  FInsrt((x), fTCFG0_DZONE)
+#define TCFG0_PRE1(x)   FInsrt((x), fTCFG0_PRE1)
+#define TCFG0_PRE0(x)   FInsrt((x), fTCFG0_PRE0)
+#define TCON_4_AUTO             (1 << 22)       /* auto reload on/off for Timer 4 */
+#define TCON_4_UPDATE   (1 << 21)       /* manual Update TCNTB4 */
+#define TCON_4_ONOFF    (1 << 20)       /* 0: Stop, 1: start Timer 4 */
+#define COUNT_4_ON              (TCON_4_ONOFF*1)
+#define COUNT_4_OFF             (TCON_4_ONOFF*0)
+#define TCON_3_AUTO             (1 << 19)       /* auto reload on/off for Timer 3 */
+#define TCON_3_INVERT   (1 << 18)       /* 1: Inverter on for TOUT3 */
+#define TCON_3_MAN              (1 << 17)       /* manual Update TCNTB3,TCMPB3 */
+#define TCON_3_ONOFF    (1 << 16)       /* 0: Stop, 1: start Timer 3 */
+#define TCON_2_AUTO             (1 << 15)       /* auto reload on/off for Timer 3 */
+#define TCON_2_INVERT   (1 << 14)       /* 1: Inverter on for TOUT3 */
+#define TCON_2_MAN              (1 << 13)       /* manual Update TCNTB3,TCMPB3 */
+#define TCON_2_ONOFF    (1 << 12)       /* 0: Stop, 1: start Timer 3 */
+#define TCON_1_AUTO             (1 << 11)       /* auto reload on/off for Timer 3 */
+#define TCON_1_INVERT   (1 << 10)       /* 1: Inverter on for TOUT3 */
+#define TCON_1_MAN              (1 << 9)        /* manual Update TCNTB3,TCMPB3 */
+#define TCON_1_ONOFF    (1 << 8)        /* 0: Stop, 1: start Timer 3 */
+#define TCON_0_AUTO             (1 << 3)        /* auto reload on/off for Timer 3 */
+#define TCON_0_INVERT   (1 << 2)        /* 1: Inverter on for TOUT3 */
+#define TCON_0_MAN              (1 << 1)        /* manual Update TCNTB3,TCMPB3 */
+#define TCON_0_ONOFF    (1 << 0)        /* 0: Stop, 1: start Timer 3 */
+
+#define TIMER3_ATLOAD_ON        (TCON_3_AUTO*1)
+#define TIMER3_ATLAOD_OFF       FClrBit(TCON, TCON_3_AUTO)
+#define TIMER3_IVT_ON           (TCON_3_INVERT*1)
+#define TIMER3_IVT_OFF          (FClrBit(TCON, TCON_3_INVERT))
+#define TIMER3_MANUP            (TCON_3_MAN*1)
+#define TIMER3_NOP              (FClrBit(TCON, TCON_3_MAN))
+#define TIMER3_ON               (TCON_3_ONOFF*1)
+#define TIMER3_OFF              (FClrBit(TCON, TCON_3_ONOFF))
+#define TIMER2_ATLOAD_ON        (TCON_2_AUTO*1)
+#define TIMER2_ATLAOD_OFF       FClrBit(TCON, TCON_2_AUTO)
+#define TIMER2_IVT_ON           (TCON_2_INVERT*1)
+#define TIMER2_IVT_OFF          (FClrBit(TCON, TCON_2_INVERT))
+#define TIMER2_MANUP            (TCON_2_MAN*1)
+#define TIMER2_NOP              (FClrBit(TCON, TCON_2_MAN))
+#define TIMER2_ON               (TCON_2_ONOFF*1)
+#define TIMER2_OFF              (FClrBit(TCON, TCON_2_ONOFF))
+#define TIMER1_ATLOAD_ON        (TCON_1_AUTO*1)
+#define TIMER1_ATLAOD_OFF       FClrBit(TCON, TCON_1_AUTO)
+#define TIMER1_IVT_ON           (TCON_1_INVERT*1)
+#define TIMER1_IVT_OFF          (FClrBit(TCON, TCON_1_INVERT))
+#define TIMER1_MANUP            (TCON_1_MAN*1)
+#define TIMER1_NOP              (FClrBit(TCON, TCON_1_MAN))
+#define TIMER1_ON               (TCON_1_ONOFF*1)
+#define TIMER1_OFF              (FClrBit(TCON, TCON_1_ONOFF))
+#define TIMER0_ATLOAD_ON        (TCON_0_AUTO*1)
+#define TIMER0_ATLAOD_OFF       FClrBit(TCON, TCON_0_AUTO)
+#define TIMER0_IVT_ON           (TCON_0_INVERT*1)
+#define TIMER0_IVT_OFF          (FClrBit(TCON, TCON_0_INVERT))
+#define TIMER0_MANUP            (TCON_0_MAN*1)
+#define TIMER0_NOP              (FClrBit(TCON, TCON_0_MAN))
+#define TIMER0_ON               (TCON_0_ONOFF*1)
+#define TIMER0_OFF              (FClrBit(TCON, TCON_0_ONOFF))
+
+#define TCON_TIMER1_CLR         FClrFld(TCON, fTCON_TIMER1);
+#define TCON_TIMER2_CLR         FClrFld(TCON, fTCON_TIMER2);
+#define TCON_TIMER3_CLR         FClrFld(TCON, fTCON_TIMER3);
+
+
+/*
+ * NAND ( chapter 4 )
+ *
+ */
+#include "s3c24a0_nand.h"
+
+/* S3C24A0-A LCD CONTROLLER DEVICE ONLY */
+#ifdef  CONFIG_ARCH_S3C24A0A
+#define bLCD_CTL(Nb)            __REG(0x4a000000 + (Nb))
+#define LCDCON1                 bLCD_CTL(0x00) /* LCD CONTROL 1 */
+#define LCDCON2                 bLCD_CTL(0x04) /* LCD CONTROL 2 */
+#define LCDTCON1                bLCD_CTL(0x08) /* LCD TIME CONTROL 1 */
+#define LCDTCON2                bLCD_CTL(0x0c) /* LCD TIME CONTROL 2 */
+#define LCDTCON3                bLCD_CTL(0x10) /* LCD TIME CONTROL 3 */
+#define LCDOSD1                 bLCD_CTL(0x14) /* LCD OSD CONTROL REGISTER */
+#define LCDOSD2                 bLCD_CTL(0x18) /* Foreground image(OSD Image) left top position set */
+#define LCDOSD3                 bLCD_CTL(0x1c) /* Foreground image(OSD Image) right bottom position set */
+#define LCDSADDRB1              bLCD_CTL(0x20) /* Frame buffer start address 1 (Background buffer 1) */
+#define LCDSADDRB2              bLCD_CTL(0x24) /* Frame buffer start address 2 (Background buffer 2) */
+#define LCDSADDRF1              bLCD_CTL(0x28) /* Frame buffer start address 1 (Foreground buffer 1) */
+#define LCDSADDRF2              bLCD_CTL(0x2c) /* Frame buffer start address 2 (Foreground buffer 2) */
+#define LCDEADDRB1              bLCD_CTL(0x30) /* Frame buffer end address 1 (Background buffer 1) */
+#define LCDEADDRB2              bLCD_CTL(0x34) /* Frame buffer end address 2 (Background buffer 2) */
+#define LCDEADDRF1              bLCD_CTL(0x38) /* Frame buffer end address 1 (Foreground buffer 1) */
+#define LCDEADDRF3              bLCD_CTL(0x3c) /* Frame buffer end address 2 (Foreground buffer 2) */
+#define LCDVSCRB1               bLCD_CTL(0x40) /* Virture Screen OFFSIZE and PAGE WIDTH (Background buffer 1) */
+#define LCDVSCRB2               bLCD_CTL(0x44) /* Virture Screen OFFSIZE and PAGE WIDTH (Background buffer 2) */
+#define LCDVSCRF1               bLCD_CTL(0x48) /* Virture Screen OFFSIZE and PAGE WIDTH (Foreground buffer 1) */
+#define LCDVSCRF2               bLCD_CTL(0x4c) /* Virture Screen OFFSIZE and PAGE WIDTH (Foreground buffer 2) */
+#define LCDINTCON               bLCD_CTL(0x50) /* LCD Interrupt Control */
+#define LCDKEYCON               bLCD_CTL(0x54) /* COLOR KEY CONTROL 1 */
+#define LCDKEYVAL               bLCD_CTL(0x58) /* COLOR KEY CONTROL 2 */
+#define LCDBGCON                bLCD_CTL(0x5c) /* Background color Control */
+#define LCDFGCON                bLCD_CTL(0x60) /* Foreground color Control */
+#define LCDDITHCON              bLCD_CTL(0x64) /* LCD Dithering control active Matrix */
+
+#define PALETTEBG                       0x4A001000 //Background Palette start address
+#define PALETTEFG                       0x4A002000 //Background Palette start address
+
+/*  LCDCON1 */
+#define fBURSTLEN       Fld(2,28)       /* DMA's BURST length selection*/
+#define BURSTLEN4       FInsrt(0x2, fBURSTLEN)
+#define BURSTLEN8       FInsrt(0x1, fBURSTLEN)
+#define BURSTLEN16      FInsrt(0x0, fBURSTLEN)
+#define BDBCON_BUF1     (0 << 21)       /* Active frame slect control background image */
+#define BDBCON_BUF2     (1 << 21)     /* it will be adoted from next frame data */
+#define FDBCON_BUF1     (0 << 20)     /* Active frame select control foreground image */
+#define FDBCON_BUF2     (1 << 20)       /* it will adopted from next frame data  */
+#define DIVEN           (1 << 19)       /* 1:ENABLE 0:Disable */
+#define DIVDIS          (0 << 19)       /* 0:disable */
+#define fCLKVAL         Fld(6,13)
+#define CLKVALMSK       FMsk(fCLKVAL)   /* clk value bit clear */
+#define CLKVAL(x)       FInsrt((x), fCLKVAL) /*  VCLK = HCLK / [(CLKVAL+1)x2] */
+#define CLKDIR_DIVIDE   (1 << 12)    /* Select the clk src as 0:direct or 1:divide using CLKVAl register*/
+#define CLKDIR_DIRECT   (0 << 12)    /* Select the clk src as 0:direct or 1:divide using CLKVAl register*/
+#define fPNRMODE        Fld(2,9)        /* Select Disaplay mode */
+#define PNRMODE_PRGB    FInsrt(0x00, fPNRMODE)  /* parallel RGB */
+#define PNRMODE_PBGR    FInsrt(0x01, fPNRMODE)  /* parallel BGR */
+#define PNRMODE_SRGB    FInsrt(0x02, fPNRMODE)  /* Serial RGB */
+#define PNRMODE_SBGR    FInsrt(0x03, fPNRMODE)  /* Serial RGB */
+#define fBPPMODEF       Fld(3,6)        /* SELECT THE BPP MODE FOR FOREGROUND IMAGE (OSD)*/
+#define BPPMODEF_8_P    FInsrt(0x3, fBPPMODEF)  /* 8BPP palettized */
+#define BPPMODEF_8_NP   FInsrt(0x4, fBPPMODEF)  /* 8BPP non palettized RGB-3:3:2 */
+#define BPPMODEF_565    FInsrt(0x5, fBPPMODEF)  /* 16BPP NON palettized RGB-5:6:5 */
+#define BPPMODEF_5551   FInsrt(0x6, fBPPMODEF)  /* 16BPP NON palettized RGB-5:5:5:1*/
+#define BPPMODEF_18_UP  FInsrt(0x7, fBPPMODEF)  /* unpaked 18BPP non-palettized */
+#define fBPPMODEB       Fld(4,2)        /* select the BPP mode for fore ground image*/
+#define MPPMODEB_1      FInsrt(0x00, fBPPMODEB) /* 1bpp */
+#define MPPMODEB_2      FInsrt(0x01, fBPPMODEB) /* 2bpp */
+#define MPPMODEB_4      FInsrt(0x02, fBPPMODEB) /* 4bpp */
+#define MPPMODEB_8      FInsrt(0x03, fBPPMODEB) /* 8bpp palettized */
+#define MPPMODEB_8N     FInsrt(0x04, fBPPMODEB) /* 8bpp non palettized 3:3:2*/
+#define MPPMODEB_565    FInsrt(0x05, fBPPMODEB) /* 16bpp non palettized 5:6:5*/
+#define MPPMODEB_5551   FInsrt(0x06, fBPPMODEB) /* 16bpp non palettized 5:5:5:1*/
+#define MPPMODEB_18     FInsrt(0x07, fBPPMODEB) /* unpacked 18bpp */
+#define ENVID           (1 << 1) /* 0:Disable 1:Enable LCD video output and logic immediatly */
+#define ENVID_F         (1 << 0) /* 0:Dis 1:Ena wait until Current frame end. */
+
+/* LCDCON2 */
+#define fPALFRM         Fld(2,9) /* this bit determines the size of the palette data*/
+#define PALFRM_666      FInsrt(0x01, fPALFRM)   /* 18 BIT RGB-6:6:6 */
+#define PALFRM_565      FInsrt(0x02, fPALFRM)   /* 16 BIT RGB-5:6:5 */
+#define PALFRM_5551     FInsrt(0x03, fPALFRM)   /* 16 BIT RGB-5:5:5:1 */
+#define IVCLK_RISING    (1 << 7) /* this bit controls the polarity of the VCLK active edge */
+#define IVCLK_FALLING   (0 << 7) /* 1 :rising edge 0: falling edge */
+#define IHSYNC_INVERT   (1 << 6) /* HSYNC polarity inverted */
+#define IHSYNC_NORMAL   (0 << 6) /* HSYNC polarity normal  */
+#define IVSYNC_INVERT   (1 << 5) /* VSYNC polarity inverted */
+#define IVSYNC_NORMAL   (0 << 5) /* VSYNC polarity normal  */
+#define IVDE_INVERT     (1 << 3) /* DE polarity inverted */
+#define IVDE_NORMAL     (0 << 3) /* DE polarity normal  */
+#define BITSWP_EN       (1 << 2) /* 1:BIT Swap Enable */
+#define BITSWP_DIS      (0 << 2) /* 0:BIT Swap Disable */
+#define BYTESWP_EN      (1 << 1) /* 1:BYTE Swap Enable */
+#define BUTESWP_DIS     (0 << 1) /* 0:BYTE Swap Disable */
+#define HAWSWP_EN       (1 << 0) /* 1:HALF WORD Swap Enable */
+#define HAWSWP_DIS      (0 << 0) /* 0:HALF WORD swap Disable */
+
+/* LCD Time Control 1 Register */
+#define VBPD(x)         FInsrt((x), Fld(8,16))  /* VSync Back porch */
+#define VFPD(x)         FInsrt((x), Fld(8, 8))  /* VSync Front porch */
+#define VSPW(x)         FInsrt((x), Fld(8, 0))  /* VSync level width */
+/* LCD Time Control 2 Register */
+#define HBPD(x)         FInsrt((x), Fld(8,16))  /* VSync Back porch */
+#define HFPD(x)         FInsrt((x), Fld(8, 8))  /* VSync Front porch */
+#define HSPW(x)         FInsrt((x), Fld(8, 0))  /* VSync level width */
+/* LCD Time Control 3 register */
+#define LINEVAL(x)      FInsrt((x), Fld(11,11)) /* these bits determine the vertical size of lcd panel */
+#define HOZVAL(x)       FInsrt((x), Fld(11, 0)) /* these bits determine the horizontal size of lcd panel*//* LCD OSD Control 1 register */
+#define OSDEN           (1 << 9)        /* OSD  Enable */
+#define OSDDIS          (0 << 9)        /* OSD Disable */
+#define OSD_BLD_PIX     (1 << 8)        /* BLENDING MODE Per pixel blending (18 BPP only) */
+#define OSD_BLD_PLANE   (0 << 8)        /* Per plane blending (8/16/18 BPP mode) */
+#define OSD_ALPHA(x)    FInsrt((x), Fld(8,0))   /* 8-bit Alpha value for Per plane defined by Equation 28-1. */
+/* LCD OSD Control 2 Register */
+#define OSD_LEFTTOP_X(x)  FInsrt((x), Fld(11,11)) /*Horizontal screen coordinate for left top pixel of OSD image*/
+#define OSD_LEFTTOP_Y(x)  FInsrt((y), Fld(11, 0)) /* Vertical screen coordinate for left top pixel of OSD image*/
+/* LCD OSD Control 3 Register */
+/*OSD_RIGHTBOT_X,_Y <= LCD Panel size of X, Y */
+#define OSD_RIGHTBOT_X(x) FInsrt((x), Fld(11,11)) /*Hor scr coordinate for right bottom pixel of OSD image. */
+#define OSD_RIGHTBOT_Y(y) FInsrt((y), Fld(11, 0)) /* Ver scr coordinate for right bottom pixel of OSD image.*/
+/* FRAME Buffer start address Register
+        LCDSADDRB1 Frame buffer start address register for Background buffer 1
+        LCDSADDRB2 Frame buffer start address register for Background buffer 2
+        LCDSADDRF1 Frame buffer start address register for Foreground(OSD) buffer 1
+        LCDSADDRF2 Frame buffer start address register for Foreground(OSD) buffer 2*/
+#define LCDBANK(x)      FInsrt((x), Fld( 8,24)) /* the bank location for the video buffer in the system memory. */
+#define LCDBASEU(x)     FInsrt((x), Fld(24, 0)) /* the start address of the LCD frame buffer. */
+/* FRAME BUFFER END address Register
+        LCDEADDRB1 Frame buffer end address register for Background buffer 1
+        LCDEADDRB2 Frame buffer end address register for Background buffer 2
+        LCDEADDRF1 Frame buffer end address register for Foreground(OSD)  buffer 1
+        LCDEADDRF2 Frame buffer end address register for Foreground(OSD) buffer 2
+
+        LCDBASEL = LCDBASEU + (PAGEWIDTH+OFFSIZE) x (LINEVAL+1)    */
+#define LCDBASEL(x)     FInsrt((x), Fld(24,0)) /* the end address of the LCD frame buffer. */
+/* Virture Screen offsize and page width registers
+        LCDVSCRB1 Virtual screen OFFSIZE and PAGEWIDTH for Background buffer 1
+        LCDVSCRB2 Virtual screen OFFSIZE and PAGEWIDTH for Background buffer 2
+        LCDVSCRF1 Virtual screen OFFSIZE and PAGEWIDTH for Foreground(OSD) buffer 1
+        LCDVSCRF2 Virtual screen OFFSIZE and PAGEWIDTH for Foreground(OSD) buffer 2*/
+#define OFFSIZE(x)      FInsrt((x), Fld(13,13)) /* Virtual screen offset size (the number of byte). */
+#define PAGEWIDTH(x)    FInsrt((x), Fld(13, 0)) /* Virtual screen page width (the number of byte). */
+/* LCD Interrupt Control Register */
+#define fFRAME_INT2     Fld(2,10)       /* LCD Frame Interrupt 2 at start of  */
+#define FRAMESEL0_BP    FInsrt(0x0, fFRAME_INT2) /* BACK Porch */
+#define FRAMESEL0_VS    FInsrt(0x1, fFRAME_INT2) /* VSYNC */
+#define FRAMESEL0_ACT   FInsrt(0x2, fFRAME_INT2) /* ACTIVE */
+#define FRAMESEL0_FP    FInsrt(0x3, fFRAME_INT2) /* FRONT  */
+#define fFRAME_INT1     Fld(2,8)        /* LCD Frame Interrupt 1 at start of */
+#define FRAMESEL1_BP    FInsrt(0x1, fFRAME_INT1) /* BACK Porch */
+#define FRAMESEL1_VS    FInsrt(0x2, fFRAME_INT1) /* VSYNC */
+#define FRAMESEL1_FP    FInsrt(0x3, fFRAME_INT1) /* FRONTPorch */
+#define INTFRAME_EN     (1 << 7) /* LCD Frame interrupt Enable */
+#define INTFRAME_DIS    (0 << 7) /* LCD Frame interrupt Disable */
+#define fFIFOSEL        Fld(2,5) /* LCD FIFO INTERRUPT SELECT BIT */
+#define FIFO_ALL        FInsrt(0x00, fFIFOSEL) /* All fifi or CASE */
+#define FIFO_BG         FInsrt(0x01, fFIFOSEL) /* Background only */
+#define FIFO_FG         FInsrt(0x02, fFIFOSEL) /* FOREGROUND FIFO ONLY */
+#define fFIFOLEVEL      Fld(3,2) /* LCD FIFO interrupt level select 1~128 word */
+#define FIFO_32W        FInsrt(0x00, fFIFOLEVEL) /* 32 WORD LEFT */
+#define FIFO_64W        FInsrt(0x01, fFIFOLEVEL) /* 64 WORD */
+#define FIFO_96W        FInsrt(0x02, fFIFOLEVEL) /* 96 WORD */
+#define FIFO_OR         FInsrt(0x03, fFIFOLEVEL) /* 32,64,96 WORD */
+#define INTFIFO_EN      (1<<1)
+#define INTFIFO_DIS     (1<<1)
+#define LCD_INTEN       (1 << 0) /* LCD interrupt Enable  */
+#define LCD_INTDIS      (0 << 0) /* LCD Interrupt Disable */
+/* LCD color key LCDKEYCON 1 register */
+#define KEYEN           (1 << 25) /* color key enable, blending disable */
+#define KEYDIS          (0 << 25) /* color key disable, blending enable */
+#define DIRCON_FORE     (1 << 24) /* pixel from foreground image is displayed (only in OSD area) */
+#define DIRCON_BACK     (0 << 24) /* pixel from background image is displayed (only in OSD area) */
+#define COMPKEY(x)      FInsrt((X), Fld(24,0)) /* Each bit is correspond to the COLVAL[23:0]. */
+/* color key 2 register LCDCOLVAL */
+#define COLVAL(x)       FInsrt((x), Fld(24,0)) /* Color key value for the transparent pixel effect. */
+/* Background Color MAP */
+#define BGCOLEN         (1 << 24) /* Background color mapping control bit enable */
+#define BGCOLDIS        (0 << 24) /* Background color mapping control bit disable */
+#define BGCOLOR(x)      FInsrt((x), Fld(24,0)) /* Color Value */
+/* Foreground Color MAP LCDFGCON */
+#define FGCOLEN         (1 << 24) /* Foreground color mapping control bit Enable. */
+#define FGCOLDIS        (0 << 24) /* Foreground color mapping control bit Disable */
+#define FGCOLOR(x)      FInsrt((x), Fld(24,0)) /* Color Value  */
+/* Dithering Contrl 1 Register LCD DITHERING MODE */
+#define RDITHPOS_6BIT   FInsrt(0x01, Fld(2,5)) /* Red Dither bit control 6bit */
+#define RDITHPOS_5BIT   FInsrt(0x02, Fld(2,5)) /* Red Dither bit control 5bit */
+#define GDITHPOS_6BIT   FInsrt(0x01, Fld(2,3)) /* Green Dither bit control 6bit */
+#define GDITHPOS_5BIT   FInsrt(0x02, Fld(2,3)) /* Green Dither bit control 5bit */
+#define BDITHPOS_6BIT   FInsrt(0x01, Fld(2,5)) /* Blue Dither bit control 6bit */
+#define BDITHPOS_5BIT   FInsrt(0x02, Fld(2,5)) /* Blue Dither bit control 5bit */
+#define DITHEN          (1 << 0) /* Dithering Enable bit */
+#define DITHDIS         (0 << 0) /* Dithering Disable bit */
+
+#else
+/* S3C24A0-X DEVICE ONLY */
+/*
+ * LCD (chapter 27 )
+ */
+#define bLCD_CTL(Nb)     __REG(0x4a000000 + (Nb))
+#define LCDCON1          bLCD_CTL(0x00)
+#define LCDCON2          bLCD_CTL(0x04)
+#define LCDCON3          bLCD_CTL(0x08)
+#define LCDCON4          bLCD_CTL(0x0c)
+#define LCDCON5          bLCD_CTL(0x10)
+#define LCDADDR1         bLCD_CTL(0x14)
+#define LCDADDR2         bLCD_CTL(0x18)
+#define LCDADDR3         bLCD_CTL(0x1c)
+#define TPAL             bLCD_CTL(0x50)
+#define LCDINTPND        bLCD_CTL(0x54)
+#define LCDSRCPND        bLCD_CTL(0x58)
+#define LCDINTMSK        bLCD_CTL(0x5c)
+#define OSD_SADDR        bLCD_CTL(0x6c)
+#define OSD_EADDR        bLCD_CTL(0x70)
+#define OSD_LT           bLCD_CTL(0x74) /* left top */
+#define OSD_RB           bLCD_CTL(0x78) /* right bottom & control */
+#define LCD_PAL          bLCD_CTL(0x400) /* palette register */
+
+#define fLCD1_LINECNT    Fld(10,18)     /* the status of the line counter */
+#define  LCD1_LINECNT    FMsk(fLCD_LINECNT)
+#define fLCD1_CLKVAL     Fld(10,8)      /* rates of VCLK and CLKVAL[9:0] */
+#define  LCD1_CLKVAL(x)  FInsrt((x), fLCD1_CLKVAL)
+#define  LCD1_CLKVAL_MSK FMsk(fLCD1_CLKVAL)
+#define fLCD1_PNR        Fld(2,5)       /* select the display mode */
+#define  LCD1_PNR_TFT    FInsrt(0x3, fLCD1_PNR) /* TFT LCD */
+#define fLCD1_BPP        Fld(4,1)       /* select BPP(Bit Per Pixel) */
+#define  LCD1_BPP_1T     FInsrt(0x8, fLCD1_BPP) /* TFT: 1 bpp */
+#define  LCD1_BPP_2T     FInsrt(0x9, fLCD1_BPP) /* TFT: 2 bpp */
+#define  LCD1_BPP_4T     FInsrt(0xa, fLCD1_BPP) /* TFT: 4 bpp */
+#define  LCD1_BPP_8T     FInsrt(0xb, fLCD1_BPP) /* TFT: 8 bpp */
+#define  LCD1_BPP_16T    FInsrt(0xc, fLCD1_BPP) /* TFT: 16 bpp */
+#define LCD1_ENVID       (1 << 0)       /* 1: Enable the video output */
+#define fLCD2_VBPD       Fld(8,24)      /* Vertical Back Porch */
+#define  LCD2_VBPD(x)    FInsrt(((x)-1), fLCD2_VBPD)
+#define fLCD2_LINEVAL    Fld(10,14)  /* vertical size of LCD */
+#define  LCD2_LINEVAL_MSK FMsk(fLCD2_LINEVAL)
+#define  LCD2_LINEVAL(x) FInsrt(((x)-1), fLCD2_LINEVAL)
+#define fLCD2_VFPD       Fld(8,6)    /* Vertical Front Porch */
+#define  LCD2_VFPD(x)    FInsrt(((x)-1), fLCD2_VFPD)
+#define fLCD2_VSPW       Fld(6,0)    /* Vertical Sync Pulse Width */
+#define  LCD2_VSPW(x)    FInsrt(((x)-1), fLCD2_VSPW)
+#define fLCD3_HBPD       Fld(7,19)   /* Horizontal Back Porch */
+#define  LCD3_HBPD(x)    FInsrt(((x)-1), fLCD3_HBPD)
+#define fLCD3_HOZVAL     Fld(11,8)      /* horizontal size of LCD */
+#define  LCD3_HOZVAL_MSK FMsk(fLCD3_HOZVAL)
+#define  LCD3_HOZVAL(x)  FInsrt(((x)-1), fLCD3_HOZVAL)
+#define fLCD3_HFPD       Fld(8,0)       /* Horizontal Front Porch */
+#define  LCD3_HFPD(x)    FInsrt(((x)-1), fLCD3_HFPD)
+#define fLCD4_HSPW       Fld(8,0)       /* Horizontal Sync Pulse Width */
+#define  LCD4_HSPW(x)    FInsrt(((x)-1), fLCD4_HSPW)
+#define fLCD5_VSTAT      Fld(2,15)      /* Vertical Status (ReadOnly) */
+#define  LCD5_VSTAT      FMsk(fLCD5_VSTAT)
+#define  LCD5_VSTAT_VS   0x00   /* VSYNC */
+#define  LCD5_VSTAT_BP   0x01   /* Back Porch */
+#define  LCD5_VSTAT_AC   0x02   /* Active */
+#define  LCD5_VSTAT_FP   0x03   /* Front Porch */
+#define fLCD5_HSTAT      Fld(2,13)      /* Horizontal Status (ReadOnly) */
+#define  LCD5_HSTAT      FMsk(fLCD5_HSTAT)
+#define  LCD5_HSTAT_HS   0x00   /* HSYNC */
+#define  LCD5_HSTAT_BP   0x01   /* Back Porch */
+#define  LCD5_HSTAT_AC   0x02   /* Active */
+#define  LCD5_HSTAT_FP   0x03   /* Front Porch */
+#define LCD5_FRM565      (1 << 11) /* 1 : RGB 5:6:5 , 0 : RGB 5:5:5:1 */
+#define LCD5_INVVCL      (1 << 10)      /*
+                              1 : video data is fetched at VCLK falling edge
+                              0 : video data is fetched at VCLK rising edge */
+#define LCD5_HSYNC       (1 << 9) /* 1: HSYNC pulse polarity is inverted */
+#define LCD5_VSYNC       (1 << 8) /* 1: VSYNC pulse polarity is inverted */
+#define LCD5_INVVD       (1 << 7) /* 1: VD pulse polarity is inverted */
+#define LCD5_INVVDEN     (1 << 6) /* 1: VDEN signal polarity is inverted */
+#define LCD5_INVPWREN    (1 << 5) /* 1: PWREN signal polarity is inverted */
+#define LCD5_INVLEND     (1 << 4) /* 1: LEND signal polarity is inverted */
+#define LCD5_PWREN       (1 << 3) /* 1: enable PWREN signal */
+#define LCD5_LEND        (1 << 2) /* 1: enable LEND signal */
+#define LCD5_BSWP        (1 << 1) /* 1: Byte swap enable */
+#define LCD5_HWSWP       (1 << 0) /* 1: HalfWord swap enable */
+
+#define fLCDADDR_BANK     Fld(9,21)     /* bank location for video buffer */
+#define  LCDADDR_BANK(x)  FInsrt((x), fLCDADDR_BANK)
+#define fLCDADDR_BASEU    Fld(21,0)     /* address of upper left corner */
+#define  LCDADDR_BASEU(x) FInsrt((x), fLCDADDR_BASEU)
+#define fLCDADDR_BASEL    Fld(21,0)     /* address of lower right corner */
+#define  LCDADDR_BASEL(x) FInsrt((x), fLCDADDR_BASEL)
+#define fLCDADDR_OFFSET   Fld(11,11)    /* Virtual screen offset size
+                                           (# of half words) */
+#define  LCDADDR_OFFSET(x) FInsrt((x), fLCDADDR_OFFSET)
+#define fLCDADDR_PAGE     Fld(11,0)     /* Virtual screen page width
+                                           (# of half words) */
+#define  LCDADDR_PAGE(x)  FInsrt((x), fLCDADDR_PAGE)
+
+#define TPAL_LEN           (1 << 24)    /* 1 : Temp. Pallete Register enable */
+#define fTPAL_VAL          Fld(24,0)    /* Temp. Pallete Register value */
+#define  TPAL_VAL(x)       FInsrt((x), fTPAL_VAL)
+#define  TPAL_VAL_RED(x)   FInsrt((x), Fld(8,16))
+#define  TPAL_VAL_GREEN(x) FInsrt((x), Fld(8,8))
+#define  TPAL_VAL_BLUE(x)  FInsrt((x), Fld(8,0))
+
+#define fOSD_SADDR       Fld(30,0)  /* OSD DMA start address of A[30:1] */
+#define  OSD_Saddr(x)    FInsrt((x), fOSD_SADDR)
+#define fOSD_EADDR       Fld(30,0)  /* OSD DMA end address of A[30:1] */
+#define  OSD_Eaddr(x)    FInsrt((x), fOSD_EADDR)
+#define OSD_BLD          (1<<24) /* 0: per plane blending */
+#define fOSD_ALPHA       Fld(4,20) /* 4-bit alpha value */
+#define  OSD_ALPHA(x)    FInsrt((x), fOSD_ALPHA)
+#define fOSD_LT_X        Fld(10,10) /* left-top X */
+#define  OSD_LT_X(x)     FInsrt((x), fOSD_LT_X)
+#define fOSD_LT_Y        Fld(10,0) /* left-top Y */
+#define  OSD_LT_Y(x)     FInsrt((x), fOSD_LT_Y)
+#define OSD_EN           (1<<31)  /* 1: enable OSD */
+#define fOSD_WIDTH       Fld(11,20) /* OSD width . # of half words */
+#define  OSD_WIDTH(x)    FInsrt((x), fOSD_WIDTH)
+#define fOSD_RB_X        Fld(10,10) /* right bottom X */
+#define  OSD_RB_X(x)     FInsrt((x), fOSD_RB_X)
+#define fOSD_RB_Y        Fld(10,0)  /* right bottom Y */
+#define  OSD_RB_Y(x)     FInsrt((x), fOSD_RB_Y)
+#endif
+
+/*
+ * UART ( chapter 11 )
+ */
+#define UART_CTL_BASE     0x44400000
+#define UART0_CTL_BASE    UART_CTL_BASE
+#define UART1_CTL_BASE    (UART_CTL_BASE + 0x4000)
+#define bUART(x, Nb)      __REG(UART_CTL_BASE + (x)*0x4000 + (Nb))
+/* offset */
+#define oULCON         0x00
+#define oUCON          0x04
+#define oUFCON         0x08
+#define oUMCON         0x0c
+#define oUTRSTAT       0x10
+#define oUERSTAT       0x14
+#define oUFSTAT        0x18
+#define oUMSTAT        0x1c
+#define oUTXH          0x20
+#define oURXH          0x24
+#define oUBRDIV        0x28
+/* Registers */
+#define ULCON0         bUART(0, oULCON)
+#define UCON0          bUART(0, oUCON)
+#define UFCON0         bUART(0, oUFCON)
+#define UMCON0         bUART(0, oUMCON)
+#define UTRSTAT0       bUART(0, oUTRSTAT)
+#define UERSTAT0       bUART(0, oUERSTAT)
+#define UFSTAT0        bUART(0, oUFSTAT)
+#define UMSTAT0        bUART(0, oUMSTAT)
+#define UTXH0          bUART(0, oUTXH)
+#define URXH0          bUART(0, oURXH)
+#define UBRDIV0        bUART(0, oUBRDIV)
+#define ULCON1         bUART(1, oULCON)
+#define UCON1          bUART(1, oUCON)
+#define UFCON1         bUART(1, oUFCON)
+#define UMCON1         bUART(1, oUMCON)
+#define UTRSTAT1       bUART(1, oUTRSTAT)
+#define UERSTAT1       bUART(1, oUERSTAT)
+#define UFSTAT1        bUART(1, oUFSTAT)
+#define UMSTAT1        bUART(1, oUMSTAT)
+#define UTXH1          bUART(1, oUTXH)
+#define URXH1          bUART(1, oURXH)
+#define UBRDIV1        bUART(1, oUBRDIV)
+/* ... */
+
+#define ULCON_IR        (1 << 6)        /* use Infra-Red mode */
+#define fULCON_PAR      Fld(3,3)        /* what parity mode? */
+#define  ULCON_PAR      FMsk(fULCON_PAR)
+#define  ULCON_PAR_NONE FInsrt(0x0, fULCON_PAR) /* No Parity */
+#define  ULCON_PAR_ODD  FInsrt(0x4, fULCON_PAR) /* Odd Parity */
+#define  ULCON_PAR_EVEN FInsrt(0x5, fULCON_PAR) /* Even Parity */
+#define  ULCON_PAR_1    FInsrt(0x6, fULCON_PAR) /* Parity force/checked as 1 */
+#define  ULCON_PAR_0    FInsrt(0x7, fULCON_PAR) /* Parity force/checked as 0 */
+#define ULCON_STOP      (1 << 2)        /* The number of stop bits */
+#define ULCON_ONE_STOP  (0 << 2)        /* 1 stop bit */
+#define ULCON_TWO_STOP  (1 << 2)        /* 2 stop bit */
+#define fULCON_WL       Fld(2, 0)       /* word length */
+#define  ULCON_WL       FMsk(fULCON_WL)
+#define  ULCON_WL5      FInsrt(0x0, fULCON_WL)  /* 5 bits */
+#define  ULCON_WL6      FInsrt(0x1, fULCON_WL)  /* 6 bits */
+#define  ULCON_WL7      FInsrt(0x2, fULCON_WL)  /* 7 bits */
+#define  ULCON_WL8      FInsrt(0x3, fULCON_WL)  /* 8 bits */
+
+#define ULCON_CFGMASK   (ULCON_IR | ULCON_PAR | ULCON_WL)
+
+#define UCON_CLK_SEL      (1 << 10)     /* select clock for UART */
+#define UCON_CLK_PCLK     (0 << 10)     /* PCLK for UART baud rate */
+#define UCON_CLK_UCLK     (1 << 10)     /* UCLK for UART baud rate */
+#define UCON_TX_INT_TYPE  (1 << 9)      /* TX Interrupt request type */
+#define UCON_TX_INT_PLS   (0 << 9)      /* Pulse */
+#define UCON_TX_INT_LVL   (1 << 9)      /* Level */
+#define UCON_RX_INT_TYPE  (1 << 8)      /* RX Interrupt request type */
+#define UCON_RX_INT_PLS   (0 << 8)      /* Pulse */
+#define UCON_RX_INT_LVL   (1 << 8)      /* Level */
+#define UCON_RX_TIMEOUT   (1 << 7)      /* RX timeout enable */
+#define UCON_RX_ERR_INT   (1 << 6)      /* RX error status interrupt enable */
+#define UCON_LOOPBACK     (1 << 5)      /* to enter the loop-back mode */
+#define UCON_BRK_SIG      (1 << 4)      /* to send a break during 1 frame time */
+#define fUCON_TX          Fld(2,2) /* function to write Tx data to the buffer */
+#define  UCON_TX          FMsk(fUCON_TX)
+#define  UCON_TX_DIS      FInsrt(0x0, fUCON_TX) /* Disable */
+#define  UCON_TX_INT      FInsrt(0x1, fUCON_TX) /* Interrupt or polling */
+#define  UCON_TX_DMA02    FInsrt(0x2, fUCON_TX) /* DMA0,2 for UART0 */
+#define  UCON_TX_DMA13    FInsrt(0x3, fUCON_TX) /* DMA1,3 for UART1 */
+#define fUCON_RX          Fld(2,0) /* function to read Rx data from buffer */
+#define  UCON_RX          FMsk(fUCON_RX)
+#define  UCON_RX_DIS      FInsrt(0x0, fUCON_RX) /* Disable */
+#define  UCON_RX_INT      FInsrt(0x1, fUCON_RX) /* Interrupt or polling */
+#define  UCON_RX_DMA02    FInsrt(0x2, fUCON_RX) /* DMA0,2 for UART0 */
+#define  UCON_RX_DMA13    FInsrt(0x3, fUCON_RX) /* DMA1,3 for UART1 */
+
+#define fUFCON_TX_TR      Fld(2,6)      /* trigger level of transmit FIFO */
+#define  UFCON_TX_TR      FMsk(fUFCON_TX_TR)
+#define  UFCON_TX_TR0     FInsrt(0x0, fUFCON_TX_TR)     /* Empty */
+#define  UFCON_TX_TR16    FInsrt(0x1, fUFCON_TX_TR)     /* 16-byte */
+#define  UFCON_TX_TR32    FInsrt(0x2, fUFCON_TX_TR)     /* 32-byte */
+#define  UFCON_TX_TR48    FInsrt(0x3, fUFCON_TX_TR)     /* 48-byte */
+#define fUFCON_RX_TR      Fld(2,4)      /* trigger level of receive FIFO */
+#define  UFCON_RX_TR      FMsk(fUFCON_RX_TR)
+#define  UFCON_RX_TR1     FInsrt(0x0, fUFCON_RX_TR)     /* 1-byte */
+#define  UFCON_RX_TR8     FInsrt(0x1, fUFCON_RX_TR)     /* 8-byte */
+#define  UFCON_RX_TR16    FInsrt(0x2, fUFCON_RX_TR)     /* 16-byte */
+#define  UFCON_RX_TR32    FInsrt(0x3, fUFCON_RX_TR)     /* 32-byte */
+#define UFCON_TX_CLR      (1 << 2)      /* auto-cleared after resetting FIFO */
+#define UFCON_RX_CLR      (1 << 1)      /* auto-cleared after resetting FIFO */
+#define UFCON_FIFO_EN     (1 << 0)      /* FIFO Enable */
+
+#define UMCON_AFC         (1 << 4) /* Enable Auto Flow Control */
+#define UMCON_SEND        (1 << 0) /* if no AFC, set nRTS 1:'L' 0:'H' level */
+
+#define UTRSTAT_TR_EMP    (1 << 2)      /* 1: Transmitter buffer &
+                                                shifter register empty */
+#define UTRSTAT_TX_EMP    (1 << 1)      /* Transmit buffer reg. is empty */
+#define UTRSTAT_RX_RDY    (1 << 0)      /* Receive buffer reg. has data */
+
+#define UERSTAT_OVERRUN   (1 << 0)      /* Overrun Error */
+#define UERSTAT_ERR_MASK  UERSTAT_OVERRUN
+
+#define UFSTAT_TX_FULL    (1 << 14)     /* Transmit FIFO is full */
+#define fUFSTAT_TX_CNT    Fld(6,8)      /* Number of data in Tx FIFO */
+#define  UFSTAT_TX_CNT    FMsk(fUFSTAT_TX_CNT)
+#define UFSTAT_RX_FULL    (1 << 6)      /* Receive FIFO is full */
+#define fUFSTAT_RX_CNT    Fld(6,0)      /* Number of data in Rx FIFO */
+#define  UFSTAT_RX_CNT    FMsk(fUFSTAT_RX_CNT)
+#define UART1_TXFIFO_CNT()      FExtr(UFSTAT1, fUFSTAT_TX_CNT)
+#define UART1_RXFIFO_CNT()      FExtr(UFSTAT1, fUFSTAT_RX_CNT)
+
+#define UMSTAT_dCTS       (1 << 4)      /* delta CTS */
+#define UMSTAT_CTS        (1 << 0)      /* CTS(Clear to Send) signal */
+
+#define UTXH_DATA         0x000000FF    /* Transmit data for UARTn */
+#define URXH_DATA         0x000000FF    /* Receive data for UARTn */
+#define UBRDIVn           0x0000FFFF    /* Baud rate division value (> 0) */
+
+/*
+ * GPIO ( chapter 20 )
+ */
+#define GPIO_CONL_NUM        (2)
+#define GPIO_CONM_NUM        (1)
+#define GPIO_CONU_NUM        (0)
+#define GPIO_CONL_BASE       (0<<3)
+#define GPIO_CONM_BASE       (11<<3)
+#define GPIO_CONU_BASE       (19<<3)
+#define GPIO_CONL            (GPIO_CONL_NUM | GPIO_CONL_BASE)
+#define GPIO_CONM            (GPIO_CONM_NUM | GPIO_CONM_BASE)
+#define GPIO_CONU            (GPIO_CONU_NUM | GPIO_CONU_BASE)
+
+#define GPCON(x)             __REG(0x44800000 + (x) * 0x4)
+#define GPCONU               __REG(0x44800000)
+#define GPCONM               __REG(0x44800004)
+#define GPCONL               __REG(0x44800008)
+#define GPDAT                __REG(0x4480000c)
+#define GPUP                 __REG(0x44800010)
+#define GPIO_OFS_SHIFT       0
+#define GPIO_CON_SHIFT       8
+#define GPIO_PULLUP_SHIFT    16
+#define GPIO_MODE_SHIFT      24
+#define GPIO_OFS_MASK        0x000000ff
+#define GPIO_CON_MASK        0x0000ff00
+#define GPIO_PULLUP_MASK     0x00ff0000
+#define GPIO_MODE_MASK       0xff000000
+#define GPIO_MODE_IN         (0 << GPIO_MODE_SHIFT)
+#define GPIO_MODE_OUT        (1 << GPIO_MODE_SHIFT)
+#define GPIO_MODE_ALT0       (2 << GPIO_MODE_SHIFT)
+#define GPIO_MODE_ALT1       (3 << GPIO_MODE_SHIFT)
+#define GPIO_PULLUP_EN       (0 << GPIO_PULLUP_SHIFT)
+#define GPIO_PULLUP_DIS      (1 << GPIO_PULLUP_SHIFT)
+
+#define MAKE_GPIO_NUM(c, o)  ((c << GPIO_CON_SHIFT) | (o << GPIO_OFS_SHIFT))
+
+#define GRAB_MODE(x)    (((x) & GPIO_MODE_MASK) >> GPIO_MODE_SHIFT)
+#define GRAB_PULLUP(x)  (((x) & GPIO_PULLUP_MASK) >> GPIO_PULLUP_SHIFT)
+#define GRAB_OFS(x)     (((x) & GPIO_OFS_MASK) >> GPIO_OFS_SHIFT)
+#define GRAB_CON_NUM(x) ((((x) & GPIO_CON_MASK) >> GPIO_CON_SHIFT) & 0x07)
+#define GRAB_CON_OFS(x) (GRAB_OFS(x) - (((x) & GPIO_CON_MASK) >> (GPIO_CON_SHIFT+3)))
+
+#define GPIO_0      MAKE_GPIO_NUM(GPIO_CONL, 0)
+#define GPIO_1      MAKE_GPIO_NUM(GPIO_CONL, 1)
+#define GPIO_2      MAKE_GPIO_NUM(GPIO_CONL, 2)
+#define GPIO_3      MAKE_GPIO_NUM(GPIO_CONL, 3)
+#define GPIO_4      MAKE_GPIO_NUM(GPIO_CONL, 4)
+#define GPIO_5      MAKE_GPIO_NUM(GPIO_CONL, 5)
+#define GPIO_6      MAKE_GPIO_NUM(GPIO_CONL, 6)
+#define GPIO_7      MAKE_GPIO_NUM(GPIO_CONL, 7)
+#define GPIO_8      MAKE_GPIO_NUM(GPIO_CONL, 8)
+#define GPIO_9      MAKE_GPIO_NUM(GPIO_CONL, 9)
+#define GPIO_10     MAKE_GPIO_NUM(GPIO_CONL, 10)
+#define GPIO_11     MAKE_GPIO_NUM(GPIO_CONM, 11)
+#define GPIO_12     MAKE_GPIO_NUM(GPIO_CONM, 12)
+#define GPIO_13     MAKE_GPIO_NUM(GPIO_CONM, 13)
+#define GPIO_14     MAKE_GPIO_NUM(GPIO_CONM, 14)
+#define GPIO_15     MAKE_GPIO_NUM(GPIO_CONM, 15)
+#define GPIO_16     MAKE_GPIO_NUM(GPIO_CONM, 16)
+#define GPIO_17     MAKE_GPIO_NUM(GPIO_CONM, 17)
+#define GPIO_18     MAKE_GPIO_NUM(GPIO_CONM, 18)
+#define GPIO_19     MAKE_GPIO_NUM(GPIO_CONU, 19)
+#define GPIO_20     MAKE_GPIO_NUM(GPIO_CONU, 20)
+#define GPIO_21     MAKE_GPIO_NUM(GPIO_CONU, 21)
+#define GPIO_22     MAKE_GPIO_NUM(GPIO_CONU, 22)
+#define GPIO_23     MAKE_GPIO_NUM(GPIO_CONU, 23)
+#define GPIO_24     MAKE_GPIO_NUM(GPIO_CONU, 24)
+#define GPIO_25     MAKE_GPIO_NUM(GPIO_CONU, 25)
+#define GPIO_26     MAKE_GPIO_NUM(GPIO_CONU, 26)
+#define GPIO_27     MAKE_GPIO_NUM(GPIO_CONU, 27)
+#define GPIO_28     MAKE_GPIO_NUM(GPIO_CONU, 28)
+#define GPIO_29     MAKE_GPIO_NUM(GPIO_CONU, 29)
+#define GPIO_30     MAKE_GPIO_NUM(GPIO_CONU, 30)
+#define GPIO_31     MAKE_GPIO_NUM(GPIO_CONU, 31)
+/* major alt. */
+#define GPIO_MODE_EINT            GPIO_MODE_ALT0
+#define GPIO_MODE_RTC_ALARMINT    GPIO_MODE_ALT1
+#define GPIO_MODE_IrDA            GPIO_MODE_ALT1
+#define GPIO_MODE_PWM             GPIO_MODE_ALT0
+#define GPIO_MODE_SPI             GPIO_MODE_ALT1
+#define GPIO_MODE_EXT_DMA         GPIO_MODE_ALT0
+#define GPIO_MODE_EXT_KEYP        GPIO_MODE_ALT1
+#define GPIO_MODE_UART            GPIO_MODE_ALT0
+/* canonical */
+#define GPIO_MODE_IrDA_SDBW       GPIO_MODE_IrDA
+#define GPIO_MODE_IrDA_TXD        GPIO_MODE_IrDA
+#define GPIO_MODE_IrDA_RXD        GPIO_MODE_IrDA
+#define GPIO_MODE_PWM_ECLK        GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT        GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT0       GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT1       GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT2       GPIO_MODE_PWM
+#define GPIO_MODE_PWM_TOUT3       GPIO_MODE_PWM
+#define GPIO_MODE_SPI_MODI        GPIO_MODE_SPI
+#define GPIO_MODE_SPI_MISO        GPIO_MODE_SPI
+#define GPIO_MODE_DMAREQ0         GPIO_MODE_EXT_DMA
+#define GPIO_MODE_DMAREQ1         GPIO_MODE_EXT_DMA
+#define GPIO_MODE_DMAACK0         GPIO_MODE_EXT_DMA
+#define GPIO_MODE_DMAACK1         GPIO_MODE_EXT_DMA
+#define GPIO_MODE_KEYP_ROW0       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_ROW1       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_ROW2       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_ROW3       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_ROW4       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL0       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL1       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL2       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL3       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_KEYP_COL4       GPIO_MODE_EXT_KEYP
+#define GPIO_MODE_uCTSn1          GPIO_MODE_UART
+#define GPIO_MODE_uRTSn1          GPIO_MODE_UART
+#define GPIO_MODE_uTXD1           GPIO_MODE_UART
+#define GPIO_MODE_uRXD1           GPIO_MODE_UART
+
+#define ENPU          __REG(0x44800040) /* normal port pullup in sleep */
+#define ENPU_EN       __REG(0x44800064) /* ENPU enable */
+#define GPDAT_S       __REG(0x44800048) /* GPDAT in sleep */
+#define GPDAT_SEN     __REG(0x4480004c) /* GPDAT_S enable */
+#define GPUP_S        __REG(0x44800050) /* GPUP in sleep */
+#define DATR0_S       __REG(0x44800054) /* data in sleep */
+#define DATR1_S       __REG(0x44800058) /* data in sleep */
+#define OEN0_S        __REG(0x4480005c) /* output in sleep */
+#define OEN1_S        __REG(0x44800060) /* output in sleep */
+
+#define ALIVECON      __REG(0x44800044) /* clock for alive mode in sleep */
+#define RSTCNT        __REG(0x44800068) /* reset count for power settle-down */
+
+#define set_gpio_ctrl(x) \
+        ({ GPCON(GRAB_CON_NUM((x))) &= ~(0x3 << (GRAB_CON_OFS((x))*2)); \
+           GPCON(GRAB_CON_NUM(x)) |= (GRAB_MODE(x) << (GRAB_CON_OFS((x))*2)); \
+           GPUP &= ~(1 << GRAB_OFS((x))); \
+           GPUP |= (GRAB_PULLUP((x)) << GRAB_OFS((x))); })
+#define read_gpio_bit(x)        ((GPDAT & (1<<GRAB_OFS((x)))) >> GRAB_OFS((x)))
+#define write_gpio_bit(x, v) \
+        ({ GPDAT &= ~(0x1 << GRAB_OFS((x))); \
+           GPDAT |= ((v) << GRAB_OFS((x))); })
+
+/*
+ * USB Host ( chapter 17 )
+ *  - OHCI 1.0
+ *  - USB 1.1
+ */
+#define USB_OHCI_BASE      __REG(0x41000000)
+
+/*
+ * SROM Bank (chapter 2) for CS8900A
+ */
+#define SROM_BW  __REG(0x40c20000)
+#define SROM_BC1 __REG(0x40c20008)
+
+
+/*
+ * Interrupt ( chpater 6 )
+ */
+#define SRCPND                  __REG(0x40200000)
+#define INTMOD                  __REG(0x40200004)
+#define INTMSK                  __REG(0x40200008)
+#define PRIORITY                __REG(0x4020000c)
+#define INTPND                  __REG(0x40200010)
+#define INTOFFSET               __REG(0x40200014)
+#define SUBSRCPND               __REG(0x40200018)
+#define INTSUBMSK               __REG(0x4020001c)
+
+#define EINTMASK                __REG(0x44800034)
+#define EINTPEND                __REG(0x44800038)
+
+#define EINTCR0                 __REG(0x44800018)
+#define EINTCR1                 __REG(0x4480001c)
+#define EINTCR2                 __REG(0x44800020)
+
+
+/*
+ * BUS Martrix
+ */
+
+#define PRIORITY0               __REG(0x40ce0000)
+#define PRIORITY1               __REG(0x40ce0004)
+#define PRIORITY_S_FIX           0x0
+#define PRIORITY_I_FIX           0x2
+
+/*
+ * Watchdog timer ( chapter 8 )
+ */
+#define WTCON                   __REG(0x44100000)
+#define WTDAT                   __REG(0x44100004)
+#define WTCNT                   __REG(0x44100008)
+
+/*
+ * Real time clock ( chapter 10 )
+ *
+ * Note: All RTC registers have to be accessed by byte unit
+ *       using STRB and LDRB instructions or char type pointer (page on 10-4)
+ */
+#define RTCCON                  __REG(0x44200040)
+#define TICNT                   __REG(0x44200044)
+#define RTCALM                  __REG(0x44200050)
+#define ALMSEC                  __REG(0x44200054)
+#define ALMMIN                  __REG(0x44200058)
+#define ALMHOUR                 __REG(0x4420005c)
+#define ALMDATE                 __REG(0x44200060)
+#define ALMMON                  __REG(0x44200064)
+#define ALMYEAR                 __REG(0x44200068)
+#define RTCRST                  __REG(0x4420006c)
+#define BCDSEC                  __REG(0x44200070)
+#define BCDMIN                  __REG(0x44200074)
+#define BCDHOUR                 __REG(0x44200078)
+#define BCDDATE                 __REG(0x4420007c)
+#define BCDDAY                  __REG(0x44200080)
+#define BCDMON                  __REG(0x44200084)
+#define BCDYEAR                 __REG(0x44200088)
+
+/* Fields */
+#define fRTC_SEC                Fld(7,0)
+#define fRTC_MIN                Fld(7,0)
+#define fRTC_HOUR               Fld(6,0)
+#define fRTC_DATE               Fld(6,0)
+#define fRTC_DAY                Fld(2,0)
+#define fRTC_MON                Fld(5,0)
+#define fRTC_YEAR               Fld(8,0)
+/* Mask */
+#define Msk_RTCSEC              FMsk(fRTC_SEC)
+#define Msk_RTCMIN              FMsk(fRTC_MIN)
+#define Msk_RTCHOUR             FMsk(fRTC_HOUR)
+#define Msk_RTCDAY              FMsk(fRTC_DAY)
+#define Msk_RTCDATE             FMsk(fRTC_DATE)
+#define Msk_RTCMON              FMsk(fRTC_MON)
+#define Msk_RTCYEAR             FMsk(fRTC_YEAR)
+/* bits */
+#define RTCCON_EN               (1 << 0) /* RTC Control Enable */
+#define RTCCON_CLKSEL           (1 << 1) /* BCD clock as XTAL 1/2^25 clock */
+#define RTCCON_CNTSEL           (1 << 2) /* 0: Merge BCD counters */
+#define RTCCON_CLKRST           (1 << 3) /* RTC clock count reset */
+
+/* Tick Time count register */
+#define RTCALM_GLOBAL           (1 << 6) /* Global alarm enable */
+#define RTCALM_YEAR                     (1 << 5) /* Year alarm enable */
+#define RTCALM_MON                      (1 << 4) /* Month alarm enable */
+#define RTCALM_DAY                      (1 << 3) /* Day alarm enable */
+#define RTCALM_HOUR                     (1 << 2) /* Hour alarm enable */
+#define RTCALM_MIN                      (1 << 1) /* Minute alarm enable */
+#define RTCALM_SEC                      (1 << 0) /* Second alarm enable */
+#define RTCALM_EN                       (RTCALM_GLOBAL | RTCALM_YEAR | RTCALM_MON |\
+                                                        RTCALM_DAY | RTCALM_HOUR | RTCALM_MIN |\
+                                                        RTCALM_SEC)
+#define RTCALM_DIS                      (~RTCALM_EN)
+
+/* ADC and Touch Screen Interface */
+#define ADC_CTL_BASE    0x45800000
+#define bADC_CTL(Nb)    __REG(ADC_CTL_BASE + (Nb))
+// Registers
+#define ADCCON          bADC_CTL(0x00) // R/W, ADC control register
+#define ADCTSC          bADC_CTL(0x04) // R/W, ADC touch screen ctl reg
+#define ADCDLY          bADC_CTL(0x08) // R/W, ADC start or interval delay reg
+#define ADCDAX          bADC_CTL(0x0c) // R  , ADC conversion data reg
+#define ADCDAY          bADC_CTL(0x10) // R  , ADC conversion data reg
+// ADCCON
+#define fECFLG          Fld(1, 15)      // R , End of conversion flag
+#define ECFLG_VAL       FExtr(ADCCON, fECFLG)
+#define CONV_PROCESS    0
+#define CONV_END        1
+
+#define fPRSCEN         Fld(1, 14)
+#define PRSCEN_DIS      FInsrt(0, fPRSCEN)
+#define PRSCEN_EN       FInsrt(1, fPRSCEN)
+
+#define fPRSCVL         Fld(8, 6)
+#define PRSCVL(x)       FInsrt(x, fPRSCVL)
+
+#define fSEL_MUX        Fld(3, 3)
+#define ADC_IN_SEL(x)   FInsrt(x, fSEL_MUX)
+#define ADC_IN0         0
+#define ADC_IN1         1
+#define ADC_IN2         2
+#define ADC_IN3         3
+#define ADC_IN4         4
+#define ADC_IN5         5
+#define ADC_IN6         6
+#define ADC_IN7         7
+
+#define fSTDBM          Fld(1, 2) // Standby mode select
+#define STDBM_NORMAL    FInsrt(0, fSTDBM)
+#define STDBM_STANDBY   FInsrt(1, fSTDBM)
+
+#define fREAD_START     Fld(1, 1)
+#define READ_START_DIS  FInsrt(0, fREAD_START)
+#define READ_START_EN   FInsrt(1, fREAD_START)
+
+#define fENABLE_START   Fld(1, 0)
+#define ENABLE_START_NOOP    FInsrt(0, fENABLE_START)
+#define ENABLE_START_START   FInsrt(1, fENABLE_START)
+
+// ADCTSC
+#define fYM_SEN         Fld(1, 7)
+#define YM_HIZ          FInsrt(0, fYM_SEN)
+#define YM_GND          FInsrt(1, fYM_SEN)
+#define fYP_SEN         Fld(1, 6)
+#define YP_EXTVLT       FInsrt(0, fYP_SEN)
+#define YP_AIN5         FInsrt(1, fYP_SEN)
+#define fXM_SEN         Fld(1, 5)
+#define XM_HIZ          FInsrt(0, fXM_SEN)
+#define XM_GND          FInsrt(1, fXM_SEN)
+#define fXP_SEN         Fld(1, 4)
+#define XP_EXTVLT       FInsrt(0, fXP_SEN)
+#define XP_AIN7         FInsrt(1, fXP_SEN)
+#define fPULL_UP        Fld(1, 3)
+#define XP_PULL_UP_EN   FInsrt(0, fPULL_UP)
+#define XP_PULL_UP_DIS  FInsrt(1, fPULL_UP)
+#define fAUTO_PST       Fld(1, 2)
+#define AUTO_PST_NORMAL FInsrt(0, fAUTO_PST)
+#define AUTO_PST_AUTO   FInsrt(1, fAUTO_PST)
+#define fXY_PST         Fld(2, 0)
+#define XY_PST_NOOP     FInsrt(0, fXY_PST)
+#define XY_PST_X_POS    FInsrt(1, fXY_PST)
+#define XY_PST_Y_POS    FInsrt(2, fXY_PST)
+#define XY_PST_WAIT_INT FInsrt(3, fXY_PST)
+
+// ADC Conversion DATA Field, commons
+#define fUPDOWN         Fld(1, 15)
+#define fDAT_AUTO_PST   Fld(1, 14)
+#define fDAT_XY_PST     Fld(2, 12)
+#define fPST_DATA       Fld(10, 0) // PST : position
+
+#define PST_DAT_MSK     0x3FF
+#define PST_DAT_VAL(x)  (FExtr(x, fPST_DATA) & PST_DAT_MSK)
+// ADCDAX
+#define XPDATA          PST_DAT_VAL(ADCDAX)
+// ADCDAY
+#define YPDATA          PST_DAT_VAL(ADCDAY)
+
+/*
+ * IIS Bus Interface  ( chapter 14 )
+ */
+#define IISCON          __REG(0x44700000)
+#define IISMOD          __REG(0x44700004)
+#define IISPSR          __REG(0x44700008)
+#define IISFIFOC        __REG(0x4470000c)
+#define IISFIFOE        __REG(0x44700010)
+
+#define IISCON_CH_RIGHT (1 << 8)        /* Right channel */
+#define IISCON_CH_LEFT  (0 << 8)        /* Left channel */
+#define IISCON_TX_RDY   (1 << 7)        /* Transmit FIFO is ready(not empty) */
+#define IISCON_RX_RDY   (1 << 6)        /* Receive FIFO is ready (not full) */
+#define IISCON_TX_DMA   (1 << 5)        /* Transmit DMA service reqeust */
+#define IISCON_RX_DMA   (1 << 4)        /* Receive DMA service reqeust */
+#define IISCON_TX_IDLE  (1 << 3)        /* Transmit Channel idle */
+#define IISCON_RX_IDLE  (1 << 2)        /* Receive Channel idle */
+#define IISCON_PRESCALE (1 << 1)        /* IIS Prescaler Enable */
+#define IISCON_EN       (1 << 0)        /* IIS enable(start) */
+
+#define IISMOD_SEL_MA   (0 << 8)        /* Master mode
+                                                                                      (IISLRCK, IISCLK are Output) */
+#define IISMOD_SEL_SL   (1 << 8)        /* Slave mode
+                                                                                      (IISLRCK, IISCLK are Input) */
+#define fIISMOD_SEL_TR  Fld(2, 6)       /* Transmit/Receive mode */
+#define IISMOD_SEL_TR   FMsk(fIISMOD_SEL_TR)
+#define IISMOD_SEL_NO   FInsrt(0x0, fIISMOD_SEL_TR)     /* No Transfer */
+#define IISMOD_SEL_RX   FInsrt(0x1, fIISMOD_SEL_TR)     /* Receive */
+#define IISMOD_SEL_TX   FInsrt(0x2, fIISMOD_SEL_TR)     /* Transmit */
+#define IISMOD_SEL_BOTH FInsrt(0x3, fIISMOD_SEL_TR)     /* Tx & Rx */
+#define IISMOD_CH_RIGHT (0 << 5)        /* high for right channel */
+#define IISMOD_CH_LEFT  (1 << 5)        /* high for left channel */
+#define IISMOD_FMT_IIS  (0 << 4)        /* IIS-compatible format */
+#define IISMOD_FMT_MSB  (1 << 4)        /* MSB(left)-justified format */
+#define IISMOD_BIT_8    (0 << 3)        /* Serial data bit/channel is 8 bit*/
+#define IISMOD_BIT_16   (1 << 3)        /* Serial data bit/channel is 16 bit*/
+#define IISMOD_FREQ_256 (0 << 2)        /* Master clock freq = 256 fs */
+#define IISMOD_FREQ_384 (1 << 2)        /* Master clock freq = 384 fs */
+#define fIISMOD_SFREQ   Fld(2, 0)       /* Serial bit clock frequency */
+#define IISMOD_SFREQ    FMsk(fIISMOD_SFREQ)     /* fs = sampling frequency */
+#define IISMOD_SFREQ_16 FInsrt(0x0, fIISMOD_SFREQ)      /* 16 fs */
+#define IISMOD_SFREQ_32 FInsrt(0x1, fIISMOD_SFREQ)      /* 32 fs */
+#define IISMOD_SFREQ_48 FInsrt(0x2, fIISMOD_SFREQ)      /* 48 fs */
+
+#define fIISPSR_A       Fld(5, 5)       /* Prescaler Control A */
+#define IISPSR_A(x)     FInsrt((x), fIISPSR_A)
+#define fIISPSR_B       Fld(5, 0)       /* Prescaler Control B */
+#define IISPSR_B(x)     FInsrt((x), fIISPSR_B)
+
+#define IISFCON_TX_NORM (0 << 15)       /* Transmit FIFO access mode: normal */
+#define IISFCON_TX_DMA  (1 << 15)       /* Transmit FIFO access mode: DMA */
+#define IISFCON_RX_NORM (0 << 14)       /* Receive FIFO access mode: normal */
+#define IISFCON_RX_DMA  (1 << 14)       /* Receive FIFO access mode: DMA */
+#define IISFCON_TX_EN   (1 << 13)        /* Transmit FIFO enable */
+#define IISFCON_RX_EN   (1 << 12)        /* Recevice FIFO enable */
+#define fIISFCON_TX_CNT Fld(6, 6)       /* Tx FIFO data count (Read-Only) */
+#define IISFCON_TX_CNT  FMsk(fIISFCON_TX_CNT)
+#define fIISFCON_RX_CNT Fld(6, 0)       /* Rx FIFO data count (Read-Only) */
+#define IISFCON_RX_CNT  FMsk(fIISFCON_RX_CNT)
+
+/*
+ * DMA controller ( chapter 9 )
+ */
+#define DMA_CTL_BASE    0x40400000
+#define bDMA_CTL(Nb,x)  __REG(DMA_CTL_BASE + (0x100000*Nb) + (x))
+/* DMA channel 0 */
+#define DISRC0                  bDMA_CTL(0, 0x00)
+#define DISRCC0                 bDMA_CTL(0, 0x04)
+#define DIDST0                  bDMA_CTL(0, 0x08)
+#define DIDSTC0                 bDMA_CTL(0, 0x0c)
+#define DCON0                   bDMA_CTL(0, 0x10)
+#define DSTAT0                  bDMA_CTL(0, 0x14)
+#define DCSRC0                  bDMA_CTL(0, 0x18)
+#define DCDST0                  bDMA_CTL(0, 0x1c)
+#define DMTRIG0                 bDMA_CTL(0, 0x20)
+/* DMA channel 1 */
+#define DISRC1                  bDMA_CTL(1, 0x00)
+#define DISRCC1                 bDMA_CTL(1, 0x04)
+#define DIDST1                  bDMA_CTL(1, 0x08)
+#define DIDSTC1                 bDMA_CTL(1, 0x0c)
+#define DCON1                   bDMA_CTL(1, 0x10)
+#define DSTAT1                  bDMA_CTL(1, 0x14)
+#define DCSRC1                  bDMA_CTL(1, 0x18)
+#define DCDST1                  bDMA_CTL(1, 0x1c)
+#define DMTRIG1                 bDMA_CTL(1, 0x20)
+/* DMA channel 2 */
+#define DISRC2                  bDMA_CTL(2, 0x00)
+#define DISRCC2                 bDMA_CTL(2, 0x04)
+#define DIDST2                  bDMA_CTL(2, 0x08)
+#define DIDSTC2                 bDMA_CTL(2, 0x0c)
+#define DCON2                   bDMA_CTL(2, 0x10)
+#define DSTAT2                  bDMA_CTL(2, 0x14)
+#define DCSRC2                  bDMA_CTL(2, 0x18)
+#define DCDST2                  bDMA_CTL(2, 0x1c)
+#define DMTRIG2                 bDMA_CTL(2, 0x20)
+/* DMA channel 3 */
+#define DISRC3                  bDMA_CTL(3, 0x00)
+#define DISRCC3                 bDMA_CTL(3, 0x04)
+#define DIDST3                  bDMA_CTL(3, 0x08)
+#define DIDSTC3                 bDMA_CTL(3, 0x0c)
+#define DCON3                   bDMA_CTL(3, 0x10)
+#define DSTAT3                  bDMA_CTL(3, 0x14)
+#define DCSRC3                  bDMA_CTL(3, 0x18)
+#define DCDST3                  bDMA_CTL(3, 0x1c)
+#define DMTRIG3                 bDMA_CTL(3, 0x20)
+
+/* DISRC, DIDST Control registers */
+#define fDMA_BASE_ADDR          Fld(30, 0)      /* base address of src/dst data */
+#define DMA_BASE_ADDR(x)        FInsrt(x, fDMA_BASE_ADDR)
+#define LOC_SRC                 (1 << 1)        /* select the location of source */
+#define ON_AHB                  (LOC_SRC*0)
+#define ON_APB                  (LOC_SRC*1)
+#define ADDR_MODE               (1 << 0)       /* select the address increment */
+#define ADDR_INC                (ADDR_MODE*0)
+#define ADDR_FIX                (ADDR_MODE*1)
+
+/* DCON Definitions */
+#define DCON_MODE               (1 << 31)       /* 0: demand, 1: handshake */
+#define DEMAND_MODE             (DCON_MODE*0)
+#define HS_MODE                 (DCON_MODE*1)
+#define DCON_SYNC               (1 << 30)       /* sync to 0:PCLK, 1:HCLK */
+#define SYNC_PCLK               (DCON_SYNC*0)
+#define SYNC_HCLK               (DCON_SYNC*1)
+#define DCON_INT                (1 << 29)
+#define POLLING_MODE            (DCON_INT*0)
+#define INT_MODE                (DCON_INT*1)
+#define DCON_TSZ                (1 << 28)       /* tx size 0: a unit, 1: burst */
+#define TSZ_UNIT                (DCON_TSZ*0)
+#define TSZ_BURST               (DCON_TSZ*1)
+#define DCON_SERVMODE           (1 << 27)       /* 0: single, 1: whole service */
+#define SINGLE_SERVICE          (DCON_SERVMODE*0)
+#define WHOLE_SERVICE           (DCON_SERVMODE*1)
+#define fDCON_HWSRC             Fld(3, 24)      /* select request source */
+#define CH0_nXDREQ0             0
+#define CH0_UART0               1
+#define CH0_I2SSDI              2
+#define CH0_TIMER               3
+#define CH0_USBEP1              4
+#define CH0_AC97_PCMOUT         5
+#define CH0_MSTICK              6
+#define CH0_IRDA                7
+#define CH1_nXDREQ1             0
+#define CH1_UART1               1
+#define CH1_I2SSDO              2
+#define CH1_SPI                 3
+#define CH1_USBEP2              4
+#define CH1_AC97_PCMIN          5
+#define CH1_AC97_PCMOUT         6
+#define CH1_IRDA                7
+#define CH2_UART0               0
+#define CH2_I2SSDO              1
+#define CH2_SDMMC               2
+#define CH2_TIMER               3
+#define CH2_USBEP3              4
+#define CH2_AC97_MICIN          5
+#define CH2_AC97_PCMIN          6
+#define CH3_UART1               0
+#define CH3_SDMMC               1
+#define CH3_SPI                 2
+#define CH3_TIMER               3
+#define CH3_USBEP4              4
+#define CH3_MSTICK              5
+#define CH3_AC97_MICIN          6
+#define HWSRC(x)                FInsrt(x, fDCON_HWSRC)
+#define DCON_SWHW_SEL           (1 << 23)       /* DMA src 0: s/w 1: h/w */
+#define DMA_SRC_SW              (DCON_SWHW_SEL*0)
+#define DMA_SRC_HW              (DCON_SWHW_SEL*1)
+#define DCON_RELOAD             (1 << 22)       /* set auto-reload */
+#define SET_ATRELOAD            (DCON_RELOAD*0)
+#define CLR_ATRELOAD            (DCON_RELOAD*1)
+#define fDCON_DSZ               Fld(2, 20)
+#define DSZ_BYTE                0
+#define DSZ_HALFWORD            1
+#define DSZ_WORD                2
+#define DSZ(x)                  FInsrt(x, fDCON_DSZ)
+#define readDSZ(x)              FExtr(x, fDCON_DSZ)
+#define fDCON_TC                Fld(20,0)
+#define TX_CNT(x)               FInsrt(x, fDCON_TC)
+/* STATUS Register Definitions  */
+#define fDSTAT_ST               Fld(2,20)       /* Status of DMA Controller */
+#define fDSTAT_TC               Fld(20,0)       /* Current value of transfer count */
+#define DMA_STATUS(chan)        FExtr((DSTAT0 + (0x20 * chan)), fDSTAT_ST)
+#define DMA_BUSY                (1 << 0)
+#define DMA_READY               (0 << 0)
+#define DMA_CURR_TC(chan)       FExtr((DSTAT0 + (0x20 * chan)), fDSTAT_TC)
+/* DMA Trigger Register Definitions */
+#define DMASKTRIG_STOP          (1 << 2)        /* Stop the DMA operation */
+#define DMA_STOP                (DMASKTRIG_STOP*1)
+#define DMA_STOP_CLR            (DMASKTRIG_STOP*0)
+#define DMASKTRIG_ONOFF         (1 << 1)        /* DMA channel on/off */
+#define CHANNEL_ON              (DMASKTRIG_ONOFF*1)
+#define CHANNEL_OFF             (DMASKTRIG_ONOFF*0)
+#define DMASKTRIG_SW            (1 << 0)        /* Trigger DMA ch. in S/W req. mode */
+#define DMA_SW_REQ_CLR          (DMASKTRIG_SW*0)
+#define DMA_SW_REQ              (DMASKTRIG_SW*1)
+
+/*
+ * KeyIF - keypad interface
+ * chapter 28
+ */
+#define KEYDAT    __REG(0x44900000)
+#define KEYINTC   __REG(0x44900004)
+#define KEYFLT0   __REG(0x44900008)
+#define KEYFLT1   __REG(0x4490000C)
+#define  fKEYDAT_KEYS       Fld(5,0) /* RO : intput decoding data */
+#define KEYDAT_KEYS         FExtr(KEYDAT, fKEYDAT_KEYS)
+#define KEYDAT_KEYVAL       (1<<5) /* RO : 0=valid, 1=invalid */
+#define KEYDAT_KEYCLR       (1<<6) /* WO : 0=noaction, 1=clear */
+#define KEYDAT_KEYEN        (1<<7) /* RW : 0=disable, 1=enable */
+#define  fKEYINTLV          Fld(3,0)
+#define  KEYINTLV_LL        0 /* low level */
+#define  KEYINTLV_HL        1 /* high level */
+#define  KEYINTLV_RE        2 /* rising edge */
+#define  KEYINTLV_FE        4 /* falling edge */
+#define  KEYINTLV_BE        6 /* both edges */
+#define KEYINTLV(x)         FInsrt((x), fKEYINTLV)
+#define KEYINTEN            (1<<3) /* interrupt enable */
+#define  fKEYFLT_SELCLK     Fld(1,0)
+#define  SELCLK_RTC         0
+#define  SELCLK_GCLK        1
+#define KEYFLT_SELCLK(x)    FInsrt((x),fKEYFLT_SELCLK)
+#define KEYFLT_FILEN        (1<<1)
+#define  fKEYFLT_WIDTH Fld( 14,0)
+#define KEYFLT_WIDTH(x)     FInsrt((x), fKEYFLT_WIDTH)
+#define  KEYP_STAT                      (((GPDAT & 0x00FF0000) >> 16 ) & 0x7D )
+
+/*
+ * Video Post Processor ?
+ *
+ * chapter 26.
+ */
+#define VP_MODE       __REG(0x4a100000) /* RW */
+#define VP_RATIO_Y    __REG(0x4a100004) /* RW */
+#define VP_RATIO_CB   __REG(0x4a100008) /* RW */
+#define VP_RATIO_CR   __REG(0x4a10000c) /* RW */
+#define VP_SRC_WIDTH  __REG(0x4a100010) /* RW */
+#define VP_SRC_HEIGHT __REG(0x4a100014) /* RW */
+#define VP_DST_WIDTH  __REG(0x4a100018) /* RW */
+#define VP_DST_HEIGHT __REG(0x4a10001c) /* RW */
+#define VP_START_Y1   __REG(0x4a100020) /* RW */
+#define VP_START_Y2   __REG(0x4a100024) /* RW */
+#define VP_START_Y3   __REG(0x4a100028) /* RW */
+#define VP_START_Y4   __REG(0x4a10002c) /* RW */
+#define VP_START_CB1  __REG(0x4a100030) /* RW */
+#define VP_START_CB2  __REG(0x4a100034) /* RW */
+#define VP_START_CB3  __REG(0x4a100038) /* RW */
+#define VP_START_CB4  __REG(0x4a10003c) /* RW */
+#define VP_START_CR1  __REG(0x4a100040) /* RW */
+#define VP_START_CR2  __REG(0x4a100044) /* RW */
+#define VP_START_CR3  __REG(0x4a100048) /* RW */
+#define VP_START_CR4  __REG(0x4a10004c) /* RW */
+#define VP_START_RGB1 __REG(0x4a100050) /* RW */
+#define VP_START_RGB2 __REG(0x4a100054) /* RW */
+#define VP_START_RGB3 __REG(0x4a100058) /* RW */
+#define VP_START_RGB4 __REG(0x4a10005c) /* RW */
+#define VP_END_Y1     __REG(0x4a100060) /* RW */
+#define VP_END_Y2     __REG(0x4a100064) /* RW */
+#define VP_END_Y3     __REG(0x4a100068) /* RW */
+#define VP_END_Y4     __REG(0x4a10006c) /* RW */
+#define VP_END_CB1    __REG(0x4a100070) /* RW */
+#define VP_END_CB2    __REG(0x4a100074) /* RW */
+#define VP_END_CB3    __REG(0x4a100078) /* RW */
+#define VP_END_CB4    __REG(0x4a10007c) /* RW */
+#define VP_END_CR1    __REG(0x4a100080) /* RW */
+#define VP_END_CR2    __REG(0x4a100084) /* RW */
+#define VP_END_CR3    __REG(0x4a100088) /* RW */
+#define VP_END_CR4    __REG(0x4a10008c) /* RW */
+#define VP_END_RGB1   __REG(0x4a100090) /* RW */
+#define VP_END_RGB2   __REG(0x4a100094) /* RW */
+#define VP_END_RGB3   __REG(0x4a100098) /* RW */
+#define VP_END_RGB4   __REG(0x4a10009c) /* RW */
+#define VP_BYPASS     __REG(0x4a1000f0) /* RW */
+#define VP_OFS_Y      __REG(0x4a1000f4) /* RW */
+#define VP_OFS_CB     __REG(0x4a1000f8) /* RW */
+#define VP_OFS_CR     __REG(0x4a1000fc) /* RW */
+#define VP_OFS_RGB    __REG(0x4a100100) /* RW */
+
+#define VP_STY(__x)   __REG(0x4a100020 + 4*(__x))
+#define VP_STCB(__x)  __REG(0x4a100030 + 4*(__x))
+#define VP_STCR(__x)  __REG(0x4a100040 + 4*(__x))
+#define VP_STRGB(__x) __REG(0x4a100050 + 4*(__x))
+#define VP_EDY(__x)   __REG(0x4a100060 + 4*(__x))
+#define VP_EDCB(__x)  __REG(0x4a100070 + 4*(__x))
+#define VP_EDCR(__x)  __REG(0x4a100080 + 4*(__x))
+#define VP_EDRGB(__x) __REG(0x4a100090 + 4*(__x))
+
+#define  fVP_MODE_FRMCNT  Fld(2,10)
+#define VP_MODE_FRMCNT(x) FExtr((x), fVP_MODE_FRMCNT)
+#define VP_MODE_BYPASSFC  (1<<9)
+#define VP_MODE_BYPASSCSC (1<<8)
+#define VP_MODE_INT       (1<<7)
+#define VP_MODE_INTPND    (1<<6)
+#define VP_MODE_EN        (1<<5)
+#define VP_MODE_ORGB24    (1<<4) /* output : 0=RGB16(565) , 1=RGB24 */
+#define VP_MODE_IFMT      (1<<3) /* input  : 0=YUV , 1=RGB */
+#define VP_MODE_INTLV     (1<<2)
+#define VP_MODE_IRGB24    (1<<1) /* input  : 0=RGB16(565) , 1=RGB24 */
+#define VP_MODE_IYUV      (1<<0) /* if (VP_MODE_IFMT==0 && VP_MODE_INTLV==1)
+                                       0=YUYV , 1=UYVY */
+
+#define  fVP_RATIO_V      Fld(16,16)
+#define  fVP_RATIO_H      Fld(16,0)
+#define VP_RATIO_V(x)     FInsrt((x), fVP_RATIO_V)
+#define VP_RATIO_H(x)     FInsrt((x), fVP_RATIO_H)
+
+#define  fVP_IMG_SIZE_Y   Fld(10,20)
+#define  fVP_IMG_SIZE_CB  Fld(10,10)
+#define  fVP_IMG_SIZE_CR  Fld(10,0)
+#define VP_IMG_SIZE_Y(x)  FInsrt((x), fVP_IMG_SIZE_Y)
+#define VP_IMG_SIZE_CB(x) FInsrt((x), fVP_IMG_SIZE_CB)
+#define VP_IMG_SIZE_CR(x) FInsrt((x), fVP_IMG_SIZE_CR)
+#define VP_IMG_SIZE_R(x)  FInsrt((x), fVP_IMG_SIZE_Y)
+#define VP_IMG_SIZE_G(x)  FInsrt((x), fVP_IMG_SIZE_CB)
+#define VP_IMG_SIZE_B(x)  FInsrt((x), fVP_IMG_SIZE_CR)
+#define VP_SIZE_XX(__x)   ((__x)-1)
+
+#define VP_BYPASS_EN      (1<<24)
+#define  fVP_BYPASS_LOW   Fld(12,12)
+#define  fVP_BYPASS_HIGH  Fld(12,0)
+#define VP_BYPASS_LOW(x)  FInsrt((x), fVP_BYPASS_LOW)
+#define VP_BYPASS_HIGH(x) FInsrt((x), fVP_BYPASS_HIGH)
+
+
+/*
+ * IrDA Controller (Chapter 12)
+ */
+#define IRDACNT         __REG(0x41800000)       /* Control */
+#define IRDAMDR         __REG(0x41800004)       /* Mode definition */
+#define IRDACNF         __REG(0x41800008)       /* IRQ//DMA configuration */
+#define IRDAIER         __REG(0x4180000c)       /* IRQ enable */
+#define IRDAIIR         __REG(0x41800010)       /* IRQ indentification */
+#define IRDALSR         __REG(0x41800014)       /* Line status */
+#define IRDAFCR         __REG(0x41800018)       /* FIFO control */
+#define IRDAPRL         __REG(0x4180001c)       /* Preamble length */
+#define IRDARBR         __REG(0x41800020)       /* Tx/Rx Buffer */
+#define IRDATXNO        __REG(0x41800024)       /* Total number of data bytes remained in Tx FIFO */
+#define IRDARXNO        __REG(0x41800028)       /* Total number of data remained in Rx FIFO (in bytes) */
+#define IRDATXFLL       __REG(0x4180002c)       /* Tx frame length (Low) */
+#define IRDATXFLH       __REG(0x41800030)       /* Tx frame length (High) */
+#define IRDARXFLL       __REG(0x41800034)       /* Rx frame length (Low) */
+#define IRDARXFLH       __REG(0x41800038)       /* Rx frame length (High */
+#define IRDATIME        __REG(0x4180003c)       /* Timing control */
+
+/*
+ * SPI Interface
+ */
+#define SPCON0          __REG(0x44500000)
+#define SPSTA0          __REG(0x44500004)
+#define SPPIN0          __REG(0x44500008)
+#define SPPRE0          __REG(0x4450000C)
+#define SPTDAT0         __REG(0x44500010)
+#define SPRDAT0         __REG(0x44500014)
+#define SPCON1          __REG(0x44500020)
+#define SPSTA1          __REG(0x44500024)
+#define SPPIN1          __REG(0x44500028)
+#define SPPRE1          __REG(0x4450002C)
+#define SPTDAT1         __REG(0x44500030)
+#define SPRDAT1         __REG(0x44500034)
+
+#define fSPCON_SMOD     Fld(2,5)                /* SPI mode select */
+#define SPCON_SMOD      FMsk(fSPCON_SMOD)
+#define SPCON_SMOD_POLL FInsrt(0x0, fSPCON_SMOD)
+#define SPCON_SMOD_INT  FInsrt(0x1, fSPCON_SMOD)
+#define SPCON_SMOD_DMA  FInsrt(0x2, fSPCON_SMOD)
+#define SPCON_ENSCK     (1 << 4)
+#define SPCON_MSTR      (1 << 3)
+#define SPCON_CPOL      (1 << 2)
+#define SPCON_CPOL_LOW  (1 << 2)
+#define SPCON_CPOL_HIGH (0 << 2)
+#define SPCON_CPHA      (1 << 1)
+#define SPCON_CPHA_FMTA (0 << 1)
+#define SPCON_CPHA_FMTB (1 << 1)
+#define SPCON_TAGD      (1 << 0)
+
+#define SPSTA_DCOL      (1 << 2)                /* Data Collision Error */
+#define SPSTA_MULF      (1 << 1)                /* Multi Master Error */
+#define SPSTA_READY     (1 << 0)                /* Data Tx/Rx ready */
+
+/*
+ * IIC Controller (Chapter 13)
+ */
+
+#define IICCON          __REG(0x44600000)
+#define IICSTAT         __REG(0x44600004)
+#define IICADD          __REG(0x44600008)
+#define IICDS           __REG(0x4460000C)
+#define IICADADLY       __REG(0x44600010)
+
+/*
+ * Memory Stick Controller (Chapter 31)
+ */
+#define _MS_BASE0       0x46100000
+#define _MS_BASE1       0x46108000
+#define bMS_CTL0(x)     __REG(_MS_BASE0 + (x))
+#define bMS_CTL1(x)     __REG(_MS_BASE1 + 4*(x))
+#define MSPRE           bMS_CTL0(0)     /* Prescaler Control */
+#define MSFINTCON       bMS_CTL0(4)     /* FIFO Interrupt Control */
+#define MS_TP_CMD       bMS_CTL1(0)     /* Transfer Protocol Command */
+#define MS_CTRL_STA     bMS_CTL1(1)     /* Control1 and Status */
+#define MS_DAT          bMS_CTL1(2)     /* Data FIFO */
+#define MS_INT          bMS_CTL1(3)     /* Interrupt Control and Status */
+#define MS_INS          bMS_CTL1(4)     /* INS port Control and Status */
+#define MS_ACMD         bMS_CTL1(5)     /* Auto Command/Polarity Control */
+#define MS_ATP_CMD      bMS_CTL1(6)     /* Auto Transfer Protocol Command */
+
+#define MSPRE_EN        (1 << 2)        /* Prescaler control,
+                                           0:Disable, 1:Enable. */
+#define MSPRE_VAL       (0x3 << 0)      /* Prescaler value */
+#define MSPRE_VAL1      (0x0 << 0)      /* 1/1 */
+#define MSPRE_VAL2      (0x1 << 0)      /* 1/2 */
+#define MSPRE_VAL4      (0x2 << 0)      /* 1/4 */
+#define MSPRE_VAL8      (0x3 << 0)      /* 1/8 */
+
+#define MSFINTCON_EN    0x1             /* FIFO interrupt control,
+                                           0:only for XINT,
+                                           1:FIFO interrupt enable */
+
+#define MS_CTRL_RST     (1 << 15)       /* Internal logic reset */
+#define MS_CTRL_PWS     (1 << 14)       /* Power save mode */
+#define MS_CTRL_SIEN    (1 << 13)       /* Serial interface enable */
+#define MS_CTRL_NOCRC   (1 << 11)       /* INT_CRC disable */
+#define MS_CTRL_BSYCNT  (0x7 << 8)      /* Busy timeout count
+                                           timeout time = BSYCNT*4+2[pclks] */
+#define fMS_CTRL_BSYCNT Fld(3,8)
+#define MS_CTRL_BSY(x)  FInsrt((x), fMS_CTRL_BSYCNT)
+#define MS_INT_STA      (1 << 7)        /* interrupt generated */
+#define MS_DRQ_STA      (1 << 6)        /* DMA requested */
+#define MS_RBE_STA      (1 << 3)        /* Receive buffer empty */
+#define MS_RBF_STA      (1 << 2)        /* Receive buffer full */
+#define MS_TBE_STA      (1 << 1)        /* Transmit buffer empty */
+#define MS_TBF_STA      (1 << 0)        /* Transmit buffer full */
+
+#define MS_INT_EN       (1 << 15)       /* Memory stick Interrupt enable */
+#define MS_TR_INTEN     (1 << 14)       /* Data transfer interrupt enable */
+#define MS_INS_INTEN    (1 << 13)       /* Insertion interrupt enable */
+#define MS_INT_P_END    (1 << 7)        /* Protocol end interrupt status
+                                           0 = In progress 1 = Complete */
+#define MS_INT_SIF      (1 << 6)        /* Serial interface receive INTd */
+#define MS_INT_TR       (1 << 5)        /* Data transfer request INTd */
+#define MS_INT_INS      (1 << 4)        /* Insertion INTd */
+#define MS_INT_CRC      (1 << 1)        /* INT_CRC error */
+#define MS_INT_TOE      (1 << 0)        /* BUSY timeout error */
+
+#define MS_INS_EN       (1 << 12)       /* INS port enable */
+#define MS_INS_STA      (1 << 4)        /* INS port status. 1:Low(Insert) */
+
+#define MS_ACMD_EN      (1 << 15)       /* Auto Command op. enable */
+#define MS_ACMD_RISING  (0 << 14)       /* serial data input is rising Edge */
+#define MS_ACMD_FALLING (1 << 14)       /* serial data input is falling Edge */
+
+/*
+ * Modem Interface (Chapter 19)
+ */
+#define INT2AP          __REG(0x41180000)
+#define INT2MDM         __REG(0x41180004)
+
+#define fINT2AP_ADR     Fld(11,0)       /* IRQ to AP address */
+#define INT2AP_ADR      FMsk(fINT2AP_ADR)
+#define fINT2MDM_ADR    Fld(11,0)       /* IRQ to Modem address */
+#define INT2MDM_ADR     FMsk(fINT2MDM_ADR)
+
+/*
+ * Power management
+ */
+#define ALIVECON        __REG(0x44800044)
+#define GPDATINSLEEP    __REG(0x44800048)
+#define ENGPINSLEEP     __REG(0x4480004c)
+#define GPUPINSLEEP     __REG(0x44800050)
+#define DATRINSLEEP0    __REG(0x44800054)
+#define DATRINSLEEP1    __REG(0x44800058)
+#define OENINSLEEP0     __REG(0x4480005c)
+#define OENINSLEEP1     __REG(0x44800060)
+#define ENPUINSLEEP     __REG(0x44800064)
+#define RSTCNT          __REG(0x44800068)
+
+#endif /* _S3C24A0_H_ */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-ioctl.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-ioctl.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-ioctl.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-ioctl.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,156 @@
+/*
+ * include/asm-arm/arch-s3c24a0/s3c24a0-ioctl.h
+ * 
+ * ioctl's defintion.
+ *
+ * $Id: s3c24a0-ioctl.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#include <linux/ioctl.h>
+#include "s3c24a0-common.h"
+
+#ifndef _INCLUDE_LINUETTE_IOCTL_H_
+#define _INCLUDE_LINUETTE_IOCTL_H_
+#ifndef __ASSEMBLY__
+
+/*
+ * see Documentation/ioctl-number.txt
+ */
+#define IOC_MAGIC		('h')
+
+/*
+ * for touch devices
+ */
+typedef struct {
+  unsigned short pressure;
+  unsigned short x;
+  unsigned short y;
+  unsigned short pad;
+} TS_RET;
+
+typedef struct {
+  int xscale;
+  int xtrans;
+  int yscale;
+  int ytrans;
+  int xyswap;
+} TS_CAL;
+
+#define TS_GET_CAL		_IOR(IOC_MAGIC, 0x81, TS_CAL)
+#define TS_SET_CAL		_IOW(IOC_MAGIC, 0x82, TS_CAL)
+#define TS_ENABLE		_IO (IOC_MAGIC, 0x90)
+#define TS_DISABLE		_IO (IOC_MAGIC, 0x91)
+
+/*
+ * below ioctl function is for hacker and iom
+ */
+/*
+ * brightness control
+ */
+#define GET_BRIGHTNESS	_IOR(IOC_MAGIC, 0x83, unsigned int)
+#define SET_BRIGHTNESS	_IOW(IOC_MAGIC, 0x84, unsigned int)
+#define GET_BRIGHTNESS_INFO	_IOR(IOC_MAGIC, 0x8e, unsigned int)
+
+/*
+    . BATTERY_RET.level
+          0~   : valid (usually, values from ADC or 0 ~ 100%)
+          -1   : Unknown
+      _ Remaining battery life
+
+    . BATTERY_RET.ac
+          0x00 : Off-line
+          0x01 : On-line
+          0xff : Unknown
+      _ AC line status
+
+    . BATTERY_RET.battery
+          0x01 : Full		(== 100%)
+          0x02 : Critical	(sleep definitely)
+          0x03 : Charging
+          0x04 : Low		(warning)
+          0x10 : backup battery is low, change it
+          0x40 : backup battery is present
+          0x80 : system battery is present
+          0xff : Unknown
+      _ Battery status
+*/
+
+#define AC_OFF_LINE		0x00
+#define AC_ON_LINE		0x01
+#define AC_UNKNOWN		0xff
+
+#define BATTERY_FULL		0x01
+#define BATTERY_CRIT		0x02
+#define BATTERY_CHARGE		0x03
+#define BATTERY_LOW		0x04
+#define battery_stat(x)	((x) & 0xf)
+#define BATTERY_BAK_LOW		0x10
+#define BATTERY_BAK		0x40
+#define BATTERY_SYS		0x80
+#define BATTERY_UNKNOWN		0xff
+
+#define BATTERY_TIMER_STOP	0	/* unit: sec. */
+
+typedef struct {
+    int level, voltage, raw;
+    unsigned char ac;
+    unsigned char battery;
+} BATTERY_RET;
+#define GET_BATTERY_STATUS	_IOR(IOC_MAGIC, 0x85, BATTERY_RET)
+#define SET_BATTERY_TIMER	_IOR(IOC_MAGIC, 0x8f, unsigned int)
+
+/*
+ * for apm_bios
+ */
+#define PM_STATE_QUERY	0x20
+#define PM_STATE_D0		0
+#define PM_STATE_D1		1
+#define PM_STATE_D2		2
+#define PM_STATE_D3		3
+#define PM_STATE_UNKNOWN	(-1)
+
+struct pm_usr_dev {
+    unsigned long dev;
+    unsigned long type, id;
+    int state;
+};
+#define PM_DEV		_IOW(IOC_MAGIC, 0x86, struct pm_usr_dev) 
+
+/* if some devices gives veto, do not sleep */
+#define USR_SUSPEND		_IO (IOC_MAGIC, 0x87)
+/* sleep simply */
+#define SYS_SUSPEND		_IO (IOC_MAGIC, 0x88)
+/* LCD/INPUT/removable sleep
+   or if not, sleep as soon as possible */
+#define STANDBY		_IO (IOC_MAGIC, 0x89)
+/* wakeup devices */
+#define RESUME		_IO (IOC_MAGIC, 0x8a)
+
+/*
+ * for /dev/misc/apm_bios
+ */
+#define LED_ON		0x01
+#define LED_OFF		0x00
+#define LED_BLINK		0x04
+#define LED_BLINK_RATE	0x08	/* variable-rate blink */
+#define LED_READ_ONLY	0x80
+#define LED_COLOR		0x40
+
+typedef struct {
+  unsigned int index;		/* LED index to control */
+  unsigned int stat;		/* control command or current status */
+  unsigned int rate;		/* blinking rate */
+  unsigned int color;		/* LED color */
+  unsigned int info;		/* capable function */
+} LED_RET;
+
+#define GET_LED_NO		_IOR(IOC_MAGIC, 0x8b, unsigned int)
+#define GET_LED_STATUS	_IOR(IOC_MAGIC, 0x8c, LED_RET)
+#define SET_LED_STATUS	_IOW(IOC_MAGIC, 0x8d, LED_RET)
+
+#include "s3c24a0-machine.h"
+#endif	/* __ASSEMBLY__ */
+#endif /* _INCLUDE_LINUETTE_IOCTL_H_ */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-key.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-key.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-key.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-key.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,116 @@
+/*
+ * include/asm-arm/arch-s3c24a0/s3c24a0-key.h
+ *
+ * $Id: s3c24a0-key.h,v 1.2 2004/06/15 06:42:28 hcyun Exp $
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ * 
+ * Changes 
+ * 
+ * 2004/06/15 <heechul.yun@samsung.com>   Added SPJ key scancode 
+ */
+
+#ifndef _SPJ_KEY_H_
+#define _SPJ_KEY_H_
+#ifndef __ASSEMBLY__
+
+#define KEY_RELEASED	0
+#define KEY_PRESSED	1
+
+/*
+ * Definition of Generic Key Scancode
+ */
+#define SCANCODE_LEFT		0x69
+#define SCANCODE_RIGHT		0x6a
+#define SCANCODE_UP			0x67
+#define SCANCODE_DOWN		0x6c
+#define SCANCODE_ENTER		0x1c
+#define SCANCODE_PAGE_UP		0x68	/* Page Up */
+#define SCANCODE_PAGE_DOWN		0x6d	/* Page Down */
+#define SCANCODE_BKSP		0x0e	/* Back Space */
+
+/*
+ * Key PAD
+ */
+#define SCANCODE_PAD_0		0x52
+#define SCANCODE_PAD_1		0x4f
+#define SCANCODE_PAD_2		0x50
+#define SCANCODE_PAD_3		0x51
+#define SCANCODE_PAD_4		0x4b
+#define SCANCODE_PAD_5		0x4c
+#define SCANCODE_PAD_6		0x4d
+#define SCANCODE_PAD_7		0x47
+#define SCANCODE_PAD_8		0x48
+#define SCANCODE_PAD_9		0x49
+#define SCANCODE_PAD_MINUS		0x4a
+#define SCANCODE_PAD_PLUS		0x4e
+#define SCANCODE_PAD_ENTER		0x60
+#define SCANCODE_PAD_PERIOD		0x53
+#define SCANCODE_PAD_SLASH		0x62
+#define SCANCODE_PAD_ASTERISK	0x37
+
+/*
+ * Function Key
+ */
+#define SCANCODE_F5			0x3f
+#define SCANCODE_F6			0x40
+#define SCANCODE_F7			0x41
+#define SCANCODE_F8			0x42
+#define SCANCODE_F9			0x43
+#define SCANCODE_F10			0x44
+#define SCANCODE_F11			0x57
+#define SCANCODE_F12			0x58
+
+/*
+ * Undefined Region
+ */
+#define SCANCODE_U1			0x78	/* Unknown */
+#define SCANCODE_U2			0x79	/* Unknown */
+#define SCANCODE_U3			0x70	/* Unknown */
+#define SCANCODE_U4			0x71	/* Unknown */
+#define SCANCODE_U5			0x72	/* Unknown */
+#define SCANCODE_U6			0x73	/* Unknown */
+#define SCANCODE_U7			0x74	/* Unknown */
+#define SCANCODE_U8			0x75	/* Unknown */
+#define SCANCODE_U9			0x76	/* Unknown */
+
+/*
+ * Common key definition for PDA
+ */
+#define SCANCODE_POWER		0x7a
+#define SCANCODE_RECORD		0x7b
+#define SCANCODE_ACTION		SCANCODE_ENTER
+#define SCANCODE_SLIDE_UP		SCANCODE_PAGE_UP
+#define SCANCODE_SLIDE_DOWN		SCANCODE_PAGE_DOWN
+#define SCANCODE_SLIDE_CENTER	SCANCODE_PAD_ENTER
+
+/*
+ * Common key definition for Phone
+ */
+#define SCANCODE_ASTERISK		SCANCODE_PAD_ASTERISK
+#define SCANCODE_SHARP		SCANCODE_PAD_MINUS
+#define SCANCODE_SEND		0x7c
+#define SCANCODE_END			0x7d
+#define SCANCODE_MENU		0x7e
+#define NCODE_CLR			0x7f
+
+
+/* These are the scancodes for SPJ buttons on the SMDK24a0 */
+
+#define scPOWER    	120 /* sw1 - 0x78 */ 
+#define scMENU    	121 /* sw3 - 0x79 */
+#define scTOOL     	122 /* sw13 - 0x7a */
+#define scRETURN   	123 /* sw11 - 0x7b */ 
+#define scVOLUP    	124 /* sw5 - 0x7c */ 
+#define scVOLDOWN 	125 /* sw10 - 0x7d */ 
+#define scHOLD     	126 /* sw21 - 0x7e*/ 
+#define scUP       	103 /* sw2, - 0x67 keycode up*/
+#define scRIGHT    	106 /* sw8, - 0x6a keycode right */
+#define scLEFT     	105 /* sw6, - 0x69 keycode left */
+#define scDOWN     	108 /* sw12, - 0x6c keycode down */
+#define scACTION   	96  /* sw7, - 0x60 keycode keypad enter */ 
+
+#endif	/* __ASSEMBLY__ */
+#endif /* _SPJ_KEY_H_ */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-machine.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-machine.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-machine.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0-machine.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,223 @@
+/*
+ * include/asm-arm/arch-s3c24a0/s3c24a0-machine.h
+ *
+ * $Id: s3c24a0-machine.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * vendor/machine specifice ioctl function
+ *
+ * extended ioctl for MTD
+ * change the permission of MTDPART
+ */
+
+/*
+ *for CONFIG_SA1100_WISMO
+ */
+#define WS_SET_MODEM_MODE	_IOW(IOC_MAGIC, 0xc0, unsigned long)
+#define WS_GET_MODEM_MODE	_IOR(IOC_MAGIC, 0xc1, unsigned long)
+#define WS_MODEM_MODE_OFF	0x01
+#define WS_MODEM_MODE_READY	0x02	/* i,e,. PowerDown Mode */
+#define WS_MODEM_MODE_CALL	0x03	/* i,e,. Normal Mode */
+
+#define WS_KEYPAD_LED		0
+#define WS_7COLOR_LED		1
+
+#define WS_SUBLCD_ON		_IO (IOC_MAGIC, 0xc2)
+#define WS_SUBLCD_OFF		_IO (IOC_MAGIC, 0xc3)
+#define WS_SUBLCD_DRAW		_IO (IOC_MAGIC, 0xc4)
+#define WS_SUBLCD_BLITE_ON	_IO (IOC_MAGIC, 0xc5)
+#define WS_SUBLCD_BLITE_OFF	_IO (IOC_MAGIC, 0xc6)
+
+
+typedef struct {
+	unsigned char reserved;
+	unsigned char sec; 	/* seconds  0 ~ 59 */
+	unsigned char min;     /* min 0 - 59 */
+	unsigned char hour; 	/* Hour     0 ~ 59 */
+	unsigned char day;     /* Day 	    0 ~ 23 */
+	unsigned char month; 	/* Month    1 ~ 12 */
+} WS_DATE_T;
+#define WS_SET_DATE		_IOW(IOC_MAGIC, 0xc7, WS_DATE_T)
+
+typedef struct {
+	unsigned char reserved;
+	unsigned char batt;
+	unsigned char rssi;
+	unsigned char msg;
+	unsigned char alarm;
+	unsigned char alert;
+	unsigned char unused[2];
+} WS_ICON_T;
+#define WS_SET_ICON		_IOW(IOC_MAGIC, 0xc8, WS_ICON_T)
+
+typedef struct {
+	unsigned char    hlt;
+	unsigned char   llt;
+} WS_MOTOR_T;
+#define WS_MOTOR_ON		_IOW(IOC_MAGIC, 0xc9, WS_MOTOR_T)
+#define WS_MOTOR_OFF		_IO (IOC_MAGIC, 0xca)
+#define WS_TOUCH_ON             _IO (IOC_MAGIC, 0xcb)
+#define WS_TOUCH_OFF            _IO (IOC_MAGIC, 0xcc)
+#define WS_SUBLCD_TIMER         _IO (IOC_MAGIC, 0xce) 
+
+#define WS_LCD_POWER_ON		_IO (IOC_MAGIC, 0xd1)
+#define WS_LCD_POWER_OFF	_IO (IOC_MAGIC, 0xd2)
+#define WS_LCD_BLITE_ON		_IO (IOC_MAGIC, 0xd3)
+#define WS_LCD_BLITE_OFF	_IO (IOC_MAGIC, 0xd4)
+
+
+
+/* button definition */
+#define WS_SIDE_UP_BUTTON	SCANCODE_SLIDE_UP
+#define WS_VOICE_BUTTON		SCANCODE_RECORD
+#define WS_SIDE_DOWN_BUTTON	SCANCODE_SLIDE_DOWN
+
+#define WS_SK1_BUTTON		SCANCODE_U1
+#define WS_SK2_BUTTON		SCANCODE_U2
+#define WS_SK3_BUTTON		SCANCODE_U3
+
+#define WS_WAP_BUTTON		SCANCODE_MENU
+#define WS_CLR_BUTTON		SCANCODE_CLR
+#define WS_SEND_BUTTON		SCANCODE_SEND
+#define WS_END_BUTTON		SCANCODE_END
+
+#define WS_1_BUTTON		SCANCODE_PAD_1
+#define WS_2_BUTTON		SCANCODE_PAD_2
+#define WS_3_BUTTON		SCANCODE_PAD_3
+#define WS_4_BUTTON		SCANCODE_PAD_4
+#define WS_5_BUTTON		SCANCODE_PAD_5
+#define WS_6_BUTTON		SCANCODE_PAD_6
+#define WS_7_BUTTON		SCANCODE_PAD_7
+#define WS_8_BUTTON		SCANCODE_PAD_8
+#define WS_9_BUTTON		SCANCODE_PAD_9
+#define WS_0_BUTTON		SCANCODE_PAD_0
+#define WS_ASTERISK_BUTTON	SCANCODE_ASTERISK
+#define WS_SHARP_BUTTON		SCANCODE_SHARP
+
+#define WS_UP_BUTTON		SCANCODE_UP
+#define WS_DOWN_BUTTON		SCANCODE_DOWN
+#define WS_LEFT_BUTTON		SCANCODE_LEFT
+#define WS_RIGHT_BUTTON		SCANCODE_RIGHT
+
+/* camera definition */
+#define WS_CAM_IOC_MAGIC 'C'
+
+#define WS_CAM_ZOOM_21 0 /* cam : disp = 2 : 1 <== zoom-out */
+#define WS_CAM_ZOOM_11 1 /* cam : disp = 1 : 1 <== normal   */
+#define WS_CAM_ZOOM_12 2 /* cam : disp = 1 : 2 <== zoom-in  */
+#define WS_CAM_SET_ZOOM  _IOW(WS_CAM_IOC_MAGIC, 10, int)
+
+struct ws_cam_set {
+    int res;          /* resolution, WS_CAM_SIZE_???  */
+#define WS_CAM_SIZE_320x240    0 /* capture only            */
+#define WS_CAM_SIZE_240x180    1 /* capture only            */
+#define WS_CAM_SIZE_240x320_OV 2 /* overlay(preview) only   */
+#define WS_CAM_SIZE_240x180_OV 3 /* overlay(preview) only   */
+    int preview_ypos; /* Y position when _res_ is WS_CAM_SIZE_240x180_OV */
+};
+#define WS_CAM_SET_PARAM _IOW(WS_CAM_IOC_MAGIC, 11, struct ws_cam_set)
+
+#define WS_CAM_SET_X_MIRROR _IOW(WS_CAM_IOC_MAGIC, 12, int)
+#define WS_CAM_SET_Y_MIRROR _IOW(WS_CAM_IOC_MAGIC, 13, int)
+#define WS_CAM_SET_EXPOSURE _IOW(WS_CAM_IOC_MAGIC, 14, unsigned long)
+#define WS_CAM_SET_WHITBLNC _IOW(WS_CAM_IOC_MAGIC, 15, unsigned long)
+
+/*
+ * for CONFIG_ARCH_I519
+ */
+/* Audio Path Control */
+#define HN_AUDIO_PATH		_IOW(IOC_MAGIC, 0xc0, unsigned long)
+#define MIC_PDA		0x0001
+#define PDA_SPK		0x0010
+#define MIC_PHONE		0x0002
+#define PHONE_RCV		0x0020
+#define PHONE_SPK		0x2000
+
+#define HFK_PDA		0x0004
+#define PDA_HFK		0x0040
+#define HFK_PHONE		0x0008
+#define PHONE_HFK		0x0080
+
+#define PHONE_PDA		0x0100
+#define PDA_PHONE		0x0200
+
+/* for PXA-ac97 control (debugging only) */
+struct hn_ac97 {
+     unsigned int reg;
+     unsigned int val;
+};
+#define HN_AC97_REG_WRITE	_IOW(IOC_MAGIC, 0xc3, struct hn_ac97)
+#define HN_AC97_REG_READ	_IOR(IOC_MAGIC, 0xc4, struct hn_ac97)
+
+#define HN_ONLY_PDA_SPK		_IO ('h', 0xe3)
+
+/* rescan external perpheral device */
+#define HN_RESCAN_ACCESSARY	_IO (IOC_MAGIC, 0xc1)
+
+/* rescan & get battery type */
+#define HN_RESCAN_BATTERY_TYPE	_IOR(IOC_MAGIC, 0xc2, unsigned int)
+#define HN_BATTERY_TYPE_STD	0x0
+#define HN_BATTERY_TYPE_EXT	0x1
+#define HN_RESCAN_BATTERY_TYPE2	_IOR(IOC_MAGIC, 0xc5, unsigned int)
+
+/* UART & USB port switching */
+#define HN_UART_TO_PHONE	_IO (IOC_MAGIC, 0xc8)
+#define HN_UART_TO_PDA		_IO (IOC_MAGIC, 0xc9)
+#define HN_USB_TO_PHONE		_IO (IOC_MAGIC, 0xca)
+#define HN_USB_TO_PDA		_IO (IOC_MAGIC, 0xcb)
+#define HN_USB_UART_STATE	_IO (IOC_MAGIC, 0xce)
+
+#define HN_UART_PATH_PDA	0x0001
+#define HN_UART_PATH_PHONE	0x0002
+#define HN_USB_PATH_PDA		0x0010
+#define HN_USB_PATH_PHONE	0x0020
+
+/* Vibrator Control */
+#define HN_MOTOR_ON		_IO (IOC_MAGIC, 0xcc)
+#define HN_MOTOR_OFF		_IO (IOC_MAGIC, 0xcd)
+
+/* DPRAM Control for communication between PDA and Phone */
+
+/* DPRAM ioctls for DPRAM tty devices */
+#define HN_DPRAM_PHONE_ON		_IO (IOC_MAGIC, 0xd0)
+#define HN_DPRAM_PHONE_OFF		_IO (IOC_MAGIC, 0xd1)
+#define HN_DPRAM_PHONE_GETSTATUS	_IOR(IOC_MAGIC, 0xd2, unsigned int)
+#define HN_DPRAM_PHONE_DOWNLOAD		_IO (IOC_MAGIC, 0xd5)
+
+/* return codes for HN_DPRAM_PHONE_GETSTATUS */
+#define HN_DPRAM_PHONE_STATUS_OFF	0x00
+#define HN_DPRAM_PHONE_STATUS_ON	0x01
+
+/* DPRAM ioctls for DPRAM ctl device */
+#define HN_DPRAM_PPP_ENABLE		_IO (IOC_MAGIC, 0xd3)
+#define HN_DPRAM_PPP_DISABLE		_IO (IOC_MAGIC, 0xd4)
+#define HN_DPRAM_PPP_AC_ENABLE		_IO (IOC_MAGIC, 0xd6)
+#define HN_DPRAM_PPP_AC_DISABLE		_IO (IOC_MAGIC, 0xd7)
+
+/* DPRAM events through /dev/dpram/ctl */
+#define HN_DPRAM_EVENT_PPP_ACCESS	0x0001
+#define HN_DPRAM_EVENT_PHONE_DN_DONE	0x0002
+
+/* button definition */
+#define HN_POWER_BUTTON		SCANCODE_POWER
+#define HN_CAMERA_BUTTON	SCANCODE_U1
+#define HN_VOICE_BUTTON		SCANCODE_RECORD
+
+#define HN_SIDE_UP_BUTTON	SCANCODE_SLIDE_UP
+#define HN_SIDE_DOWN_BUTTON	SCANCODE_SLIDE_DOWN
+
+#define HN_HOME_BUTTON		SCANCODE_MENU
+#define HN_BACK_BUTTON		SCANCODE_CLR
+#define HN_SEND_BUTTON		SCANCODE_SEND
+#define HN_END_BUTTON		SCANCODE_END
+
+#define HN_UP_BUTTON		SCANCODE_UP
+#define HN_DOWN_BUTTON		SCANCODE_DOWN
+#define HN_LEFT_BUTTON		SCANCODE_LEFT
+#define HN_RIGHT_BUTTON		SCANCODE_RIGHT
+#define HN_OK_BUTTON		SCANCODE_ENTER
+
+#define HN_EAR_SEND_BUTTON	SCANCODE_U2
+
+/* PXA255 clock control */
+#define HN_CLOCK_WRITE		_IOW(IOC_MAGIC, 0xe1, unsigned int)
+#define HN_CLOCK_READ		_IOR(IOC_MAGIC, 0xe2, unsigned int)
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0_nand.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0_nand.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/s3c24a0_nand.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/s3c24a0_nand.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,485 @@
+/*
+ * s3c24a0_nand.h
+ *
+ * s3c24a0 NAND specific definiton
+ *
+ * $Id: s3c24a0_nand.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * Copyright (C) SAMSUNG MOBILE
+ */
+
+#ifndef _S3C24A0_NAND_H_
+#define _S3C24A0_NAND_H_
+
+#define bNAND_CTL(Nb)	__REG(0x40c00000 + (Nb))
+
+#define NFCONF			bNAND_CTL(0x00)
+#define NFCONT			bNAND_CTL(0x04)
+#define NFCMMD			bNAND_CTL(0x08)
+#define NFADDR			bNAND_CTL(0x0c)
+#define NFDATA			bNAND_CTL(0x10)
+#define NFMECCDATA0		bNAND_CTL(0x14)
+#define NFMECCDATA1		bNAND_CTL(0x18)
+#define NFMECCDATA2		bNAND_CTL(0x1c)
+#define NFMECCDATA3		bNAND_CTL(0x20)
+#define NFSECCDATA0		bNAND_CTL(0x24)
+#define NFSECCDATA1		bNAND_CTL(0x28)
+#define NFSTAT			bNAND_CTL(0x2c)
+#define NFESTAT0		bNAND_CTL(0x30)
+#define NFESTAT1		bNAND_CTL(0x34)
+#define NFMECC0			bNAND_CTL(0x38)
+#define NFMECC1			bNAND_CTL(0x3c)
+#define NFSECC			bNAND_CTL(0x40)
+#define NFSBLK			bNAND_CTL(0x44)
+#define NFEBLK			bNAND_CTL(0x48)
+
+
+/*
+ * NFCONF
+ */
+#define fNFCONF_AdvanceFlash	Fld(1,22)
+#define fNFCONF_TCEH			Fld(6,16)
+#define fNFCONF_TACLS			Fld(3,12)
+#define fNFCONF_TWRPH0			Fld(3,8)
+#define fNFCONF_X16Device		Fld(1,7)
+#define fNFCONF_TWRPH1			Fld(3,4)
+#define fNFCONF_Hardware_nCE	Fld(1,3)
+#define fNFCONF_BusWidth		Fld(1,2)
+#define fNFCONF_PageSize		Fld(1,1)
+#define fNFCONF_AddressCycle	Fld(1,0)
+
+#define m1NFCONF_AdvanceFlash	FMsk(fNFCONF_AdvanceFlash)
+#define m1NFCONF_TCEH			FMsk(fNFCONF_TCEH)
+#define m1NFCONF_TACLS			FMsk(fNFCONF_TACLS)
+#define m1NFCONF_TWRPH0			FMsk(fNFCONF_TWRPH0)
+#define m1NFCONF_X16Device		FMsk(fNFCONF_X16Device)
+#define m1NFCONF_TWRPH1			FMsk(fNFCONF_TWRPH1)
+#define m1NFCONF_Hardware_nCE	FMsk(fNFCONF_Hardware_nCE)
+#define m1NFCONF_BusWidth		FMsk(fNFCONF_BusWidth)
+#define m1NFCONF_PageSize		FMsk(fNFCONF_PageSize)
+#define m1NFCONF_AddressCycle	FMsk(fNFCONF_AddressCycle)
+
+#define m0NFCONF_AdvanceFlash		(~m1NFCONF_AdvanceFlash)
+#define m0NFCONF_TCEH				(~m1NFCONF_TCEH)
+#define m0NFCONF_TACLS				(~m1NFCONF_TACLS)
+#define m0NFCONF_TWRPH0				(~m1NFCONF_TWRPH0)
+#define m0NFCONF_X16Device			(~m1NFCONF_X16Device)
+#define m0NFCONF_TWRPH1				(~m1NFCONF_TWRPH1)
+#define m0NFCONF_Hardware_nCE		(~m1NFCONF_Hardware_nCE)
+#define m0NFCONF_BusWidth			(~m1NFCONF_BusWidth)
+#define m0NFCONF_PageSize			(~m1NFCONF_PageSize)
+#define m0NFCONF_AddressCycle		(~m1NFCONF_AddressCycle)
+
+#define sNFCONF_TCEH(f_)			(FInsrt(f_,fNFCONF_TCEH)			& m1NFCONF_TCEH)
+#define sNFCONF_TACLS(f_)			(FInsrt(f_,fNFCONF_TACLS)			& m1NFCONF_TACLS)
+#define sNFCONF_TWRPH0(f_)			(FInsrt(f_,fNFCONF_TWRPH0)			& m1NFCONF_TWRPH0)
+#define sNFCONF_TWRPH1(f_)			(FInsrt(f_,fNFCONF_TWRPH1)			& m1NFCONF_TWRPH1)
+#define sNFCONF_Hardware_nCE(f_)	(FInsrt(f_,fNFCONF_Hardware_nCE)	& m1NFCONF_Hardware_nCE)
+
+
+/*
+ * NFCONT
+ */
+#define fNFCONT_LdStrAddr			Fld(12,16)
+#define fNFCONT_EnbIllegalAccINT	Fld(1,15)
+#define fNFCONT_EnbLoadINT			Fld(1,14)
+#define fNFCONT_EnbStoreINT			Fld(1,13)
+#define fNFCONT_EnbRnBINT			Fld(1,12)
+#define fNFCONT_RnB_TransMode		Fld(1,11)
+#define fNFCONT_SpareECCLock		Fld(1,10)
+#define fNFCONT_MainECCLock			Fld(1,9)
+#define fNFCONT_InitECC				Fld(1,8)
+#define fNFCONT_Reg_nCE				Fld(1,7)
+#define fNFCONT_LoadPageSize		Fld(3,4)
+#define fNFCONT_Lock_tight			Fld(1,3)
+#define fNFCONT_Lock				Fld(1,2)
+#define fNFCONT_Mode				Fld(2,0)
+
+#define m1NFCONT_LdStrAddr			FMsk(fNFCONT_LdStrAddr)
+#define m1NFCONT_EnbIllegalAccINT	FMsk(fNFCONT_EnbIllegalAccINT)
+#define m1NFCONT_EnbLoadINT			FMsk(fNFCONT_EnbLoadINT)
+#define m1NFCONT_EnbStoreINT		FMsk(fNFCONT_EnbStoreINT)
+#define m1NFCONT_EnbRnBINT			FMsk(fNFCONT_EnbRnBINT)
+#define m1NFCONT_RnB_TransMode		FMsk(fNFCONT_RnB_TransMode)
+#define m1NFCONT_SpareECCLock		FMsk(fNFCONT_SpareECCLock)
+#define m1NFCONT_MainECCLock		FMsk(fNFCONT_MainECCLock)
+#define m1NFCONT_InitECC			FMsk(fNFCONT_InitECC)
+#define m1NFCONT_Reg_nCE			FMsk(fNFCONT_Reg_nCE)
+#define m1NFCONT_LoadPageSize		FMsk(fNFCONT_LoadPageSize)
+#define m1NFCONT_Lock_tight			FMsk(fNFCONT_Lock_tight)
+#define m1NFCONT_Lock				FMsk(fNFCONT_Lock)
+#define m1NFCONT_Mode				FMsk(fNFCONT_Mode)
+
+#define m0NFCONT_LdStrAddr			(~m1NFCONT_LdStrAddr)
+#define m0NFCONT_EnbIllegalAccINT	(~m1NFCONT_EnbIllegalAccINT)
+#define m0NFCONT_EnbLoadINT			(~m1NFCONT_EnbLoadINT)
+#define m0NFCONT_EnbStoreINT		(~m1NFCONT_EnbStoreINT)
+#define m0NFCONT_EnbRnBINT			(~m1NFCONT_EnbRnBINT)
+#define m0NFCONT_RnB_TransMode		(~m1NFCONT_RnB_TransMode)
+#define m0NFCONT_SpareECCLock		(~m1NFCONT_SpareECCLock)
+#define m0NFCONT_MainECCLock		(~m1NFCONT_MainECCLock)
+#define m0NFCONT_InitECC			(~m1NFCONT_InitECC)
+#define m0NFCONT_Reg_nCE			(~m1NFCONT_Reg_nCE)
+#define m0NFCONT_LoadPageSize		(~m1NFCONT_LoadPageSize)
+#define m0NFCONT_Lock_tight			(~m1NFCONT_Lock_tight)
+#define m0NFCONT_Lock				(~m1NFCONT_Lock)
+#define m0NFCONT_Mode				(~m1NFCONT_Mode)
+
+#define sNFCONT_LdStrAddr(f_)			(FInsrt(f_,fNFCONT_LdStrAddr)			& m1NFCONT_LdStrAddr)
+#define sNFCONT_EnbIllegalAccINT(f_)	(FInsrt(f_,fNFCONT_EnbIllegalAccINT)	& m1NFCONT_EnbIllegalAccINT)
+#define sNFCONT_EnbLoadINT(f_)			(FInsrt(f_,fNFCONT_EnbLoadINT)			& m1NFCONT_EnbLoadINT)
+#define sNFCONT_EnbStoreINT(f_)			(FInsrt(f_,fNFCONT_EnbStoreINT)			& m1NFCONT_EnbStoreINT)
+#define sNFCONT_EnbRnBINT(f_)			(FInsrt(f_,fNFCONT_EnbRnBINT)			& m1NFCONT_EnbRnBINT)
+#define sNFCONT_RnB_TransMode(f_)		(FInsrt(f_,fNFCONT_RnB_TransMode)		& m1NFCONT_RnB_TransMode)
+#define sNFCONT_SpareECCLock(f_)		(FInsrt(f_,fNFCONT_SpareECCLock)		& m1NFCONT_SpareECCLock)
+#define sNFCONT_MainECCLock(f_)			(FInsrt(f_,fNFCONT_MainECCLock)			& m1NFCONT_MainECCLock)
+#define sNFCONT_InitECC(f_)				(FInsrt(f_,fNFCONT_InitECC)				& m1NFCONT_InitECC)
+#define sNFCONT_Reg_nCE(f_)				(FInsrt(f_,fNFCONT_Reg_nCE)				& m1NFCONT_Reg_nCE)
+#define sNFCONT_LoadPageSize(f_)		(FInsrt(f_,fNFCONT_LoadPageSize)		& m1NFCONT_LoadPageSize)
+#define sNFCONT_Lock_tight(f_)			(FInsrt(f_,fNFCONT_Lock_tight)			& m1NFCONT_Lock_tight)
+#define sNFCONT_Lock(f_)				(FInsrt(f_,fNFCONT_Lock)				& m1NFCONT_Lock)
+#define sNFCONT_Mode(f_)				(FInsrt(f_,fNFCONT_Mode)				& m1NFCONT_Mode)
+
+
+/*
+ * NFCMMD
+ */
+#define fNFCMMD_NFCMMD1		Fld(8,8)
+#define fNFCMMD_NFCMMD0		Fld(8,0)
+
+#define m1NFCMMD_NFCMMD1	FMsk(fNFCMMD_NFCMMD1)
+#define m1NFCMMD_NFCMMD0	FMsk(fNFCMMD_NFCMMD0)
+
+#define m0NFCMMD_NFCMMD1	(~m1NFCMMD_NFCMMD1)
+#define m0NFCMMD_NFCMMD0	(~m1NFCMMD_NFCMMD0)
+
+#define sNFCMMD_NFCMMD1(f_)	(FInsrt(f_,fNFCMMD_NFCMMD1)	& m1NFCMMD_NFCMMD1)
+#define sNFCMMD_NFCMMD0(f_)	(FInsrt(f_,fNFCMMD_NFCMMD0)	& m1NFCMMD_NFCMMD0)
+
+
+/*
+ * NFADDR
+ */
+#define fNFADDR_NFADDR3		Fld(8,24)
+#define fNFADDR_NFADDR2		Fld(8,16)
+#define fNFADDR_NFADDR1		Fld(8,8)
+#define fNFADDR_NFADDR0		Fld(8,0)
+
+#define m1NFADDR_NFADDR3	FMsk(fNFADDR_NFADDR3)
+#define m1NFADDR_NFADDR2	FMsk(fNFADDR_NFADDR2)
+#define m1NFADDR_NFADDR1	FMsk(fNFADDR_NFADDR1)
+#define m1NFADDR_NFADDR0	FMsk(fNFADDR_NFADDR0)
+
+#define m0NFADDR_NFADDR3	(~m1NFADDR_NFADDR3)
+#define m0NFADDR_NFADDR2	(~m1NFADDR_NFADDR2)
+#define m0NFADDR_NFADDR1	(~m1NFADDR_NFADDR1)
+#define m0NFADDR_NFADDR0	(~m1NFADDR_NFADDR0)
+
+#define sNFADDR_NFADDR3(f_)	(FInsrt(f_,fNFADDR_NFADDR3)	& m1NFADDR_NFADDR3)
+#define sNFADDR_NFADDR2(f_)	(FInsrt(f_,fNFADDR_NFADDR2)	& m1NFADDR_NFADDR2)
+#define sNFADDR_NFADDR1(f_)	(FInsrt(f_,fNFADDR_NFADDR1)	& m1NFADDR_NFADDR1)
+#define sNFADDR_NFADDR0(f_)	(FInsrt(f_,fNFADDR_NFADDR0)	& m1NFADDR_NFADDR0)
+
+
+/*
+ * NFDATA
+ */
+#define fNFDATA_NFDATA1		Fld(8,8)
+#define fNFDATA_NFDATA0		Fld(8,0)
+
+#define m1NFDATA_NFDATA1	FMsk(fNFDATA_NFDATA1)
+#define m1NFDATA_NFDATA0	FMsk(fNFDATA_NFDATA0)
+
+#define m0NFDATA_NFDATA1	(~m1NFDATA_NFDATA1)
+#define m0NFDATA_NFDATA0	(~m1NFDATA_NFDATA0)
+
+#define sNFDATA_NFDATA1(f_)	(FInsrt(f_,fNFDATA_NFDATA1)	& m1NFDATA_NFDATA1)
+#define sNFDATA_NFDATA0(f_)	(FInsrt(f_,fNFDATA_NFDATA0)	& m1NFDATA_NFDATA0)
+
+
+/*
+ * NFMECCDATA0
+ */
+#define fNFMECCDATA0_ECCData0_1		Fld(8,8)
+#define fNFMECCDATA0_ECCData0_0		Fld(8,0)
+
+#define m1NFMECCDATA0_ECCData0_1	FMsk(fNFMECCDATA0_ECCData0_1)
+#define m1NFMECCDATA0_ECCData0_0	FMsk(fNFMECCDATA0_ECCData0_0)
+
+#define m0NFMECCDATA0_ECCData0_1	(~m1NFMECCDATA0_ECCData0_1)
+#define m0NFMECCDATA0_ECCData0_0	(~m1NFMECCDATA0_ECCData0_0)
+
+#define sNFMECCDATA0_ECCData0_1(f_)	(FInsrt(f_,fNFMECCDATA0_ECCData0_1)	& m1NFMECCDATA0_ECCData0_1)
+#define sNFMECCDATA0_ECCData0_0(f_)	(FInsrt(f_,fNFMECCDATA0_ECCData0_0)	& m1NFMECCDATA0_ECCData0_0)
+
+/*
+ * NFMECCDATA1
+ */
+#define fNFMECCDATA1_ECCData1_1		Fld(8,8)
+#define fNFMECCDATA1_ECCData1_0		Fld(8,0)
+
+#define m1NFMECCDATA1_ECCData1_1	FMsk(fNFMECCDATA1_ECCData1_1)
+#define m1NFMECCDATA1_ECCData1_0	FMsk(fNFMECCDATA1_ECCData1_0)
+
+#define m0NFMECCDATA1_ECCData1_1	(~m1NFMECCDATA1_ECCData1_1)
+#define m0NFMECCDATA1_ECCData1_0	(~m1NFMECCDATA1_ECCData1_0)
+
+#define sNFMECCDATA1_ECCData1_1(f_)	(FInsrt(f_,fNFMECCDATA1_ECCData1_1)	& m1NFMECCDATA1_ECCData1_1)
+#define sNFMECCDATA1_ECCData1_0(f_)	(FInsrt(f_,fNFMECCDATA1_ECCData1_0)	& m1NFMECCDATA1_ECCData1_0)
+
+/*
+ * NFMECCDATA2
+ */
+#define fNFMECCDATA2_ECCData2_1		Fld(8,8)
+#define fNFMECCDATA2_ECCData2_0		Fld(8,0)
+
+#define m1NFMECCDATA2_ECCData2_1	FMsk(fNFMECCDATA2_ECCData2_1)
+#define m1NFMECCDATA2_ECCData2_0	FMsk(fNFMECCDATA2_ECCData2_0)
+
+#define m0NFMECCDATA2_ECCData2_1	(~m1NFMECCDATA2_ECCData2_1)
+#define m0NFMECCDATA2_ECCData2_0	(~m1NFMECCDATA2_ECCData2_0)
+
+#define sNFMECCDATA2_ECCData2_1(f_)	(FInsrt(f_,fNFMECCDATA2_ECCData2_1)	& m1NFMECCDATA2_ECCData2_1)
+#define sNFMECCDATA2_ECCData2_0(f_)	(FInsrt(f_,fNFMECCDATA2_ECCData2_0)	& m1NFMECCDATA2_ECCData2_0)
+
+/*
+ * NFMECCDATA3
+ */
+#define fNFMECCDATA3_ECCData3_1		Fld(8,8)
+#define fNFMECCDATA3_ECCData3_0		Fld(8,0)
+
+#define m1NFMECCDATA3_ECCData3_1	FMsk(fNFMECCDATA3_ECCData3_1)
+#define m1NFMECCDATA3_ECCData3_0	FMsk(fNFMECCDATA3_ECCData3_0)
+
+#define m0NFMECCDATA3_ECCData3_1	(~m1NFMECCDATA3_ECCData3_1)
+#define m0NFMECCDATA3_ECCData3_0	(~m1NFMECCDATA3_ECCData3_0)
+
+#define sNFMECCDATA3_ECCData3_1(f_)	(FInsrt(f_,fNFMECCDATA3_ECCData3_1)	& m1NFMECCDATA3_ECCData3_1)
+#define sNFMECCDATA3_ECCData3_0(f_)	(FInsrt(f_,fNFMECCDATA3_ECCData3_0)	& m1NFMECCDATA3_ECCData3_0)
+
+
+/*
+ * NFSECCDATA0
+ */
+#define fNFSECCDATA0_ECCData0_1		Fld(8,8)
+#define fNFSECCDATA0_ECCData0_0		Fld(8,0)
+
+#define m1NFSECCDATA0_ECCData0_1	FMsk(fNFSECCDATA0_ECCData0_1)
+#define m1NFSECCDATA0_ECCData0_0	FMsk(fNFSECCDATA0_ECCData0_0)
+
+#define m0NFSECCDATA0_ECCData0_1	(~m1NFSECCDATA0_ECCData0_1)
+#define m0NFSECCDATA0_ECCData0_0	(~m1NFSECCDATA0_ECCData0_0)
+
+#define sNFSECCDATA0_ECCData0_1(f_)	(FInsrt(f_,fNFSECCDATA0_ECCData0_1)	& m1NFSECCDATA0_ECCData0_1)
+#define sNFSECCDATA0_ECCData0_0(f_)	(FInsrt(f_,fNFSECCDATA0_ECCData0_0)	& m1NFSECCDATA0_ECCData0_0)
+
+/*
+ * NFSECCDATA1
+ */
+#define fNFSECCDATA1_ECCData1_1		Fld(8,8)
+#define fNFSECCDATA1_ECCData1_0		Fld(8,0)
+
+#define m1NFSECCDATA1_ECCData1_1	FMsk(fNFSECCDATA1_ECCData1_1)
+#define m1NFSECCDATA1_ECCData1_0	FMsk(fNFSECCDATA1_ECCData1_0)
+
+#define m0NFSECCDATA1_ECCData1_1	(~m1NFSECCDATA1_ECCData1_1)
+#define m0NFSECCDATA1_ECCData1_0	(~m1NFSECCDATA1_ECCData1_0)
+
+#define sNFSECCDATA1_ECCData1_1(f_)	(FInsrt(f_,fNFSECCDATA1_ECCData1_1)	& m1NFSECCDATA1_ECCData1_1)
+#define sNFSECCDATA1_ECCData1_0(f_)	(FInsrt(f_,fNFSECCDATA1_ECCData1_0)	& m1NFSECCDATA1_ECCData1_0)
+
+
+/*
+ * NFSTAT
+ */
+#define fNFSTAT_IllegalAccess		Fld(1,16)
+#define fNFSTAT_AutoLoadDone		Fld(1,15)
+#define fNFSTAT_AutoStoreDone		Fld(1,14)
+#define fNFSTAT_RnB_TransDetect		Fld(1,13)
+#define fNFSTAT_Flash_nCE			Fld(1,12)
+#define fNFSTAT_Flash_RnB1			Fld(1,11)
+#define fNFSTAT_Flash_RnB0			Fld(1,10)
+#define fNFSTAT_STON_A2				Fld(10,0)
+
+#define m1NFSTAT_IllegalAccess		FMsk(fNFSTAT_IllegalAccess)
+#define m1NFSTAT_AutoLoadDone		FMsk(fNFSTAT_AutoLoadDone)
+#define m1NFSTAT_AutoStoreDone		FMsk(fNFSTAT_AutoStoreDone)
+#define m1NFSTAT_RnB_TransDetect	FMsk(fNFSTAT_RnB_TransDetect)
+#define m1NFSTAT_Flash_nCE			FMsk(fNFSTAT_Flash_nCE)
+#define m1NFSTAT_Flash_RnB1			FMsk(fNFSTAT_Flash_RnB1)
+#define m1NFSTAT_Flash_RnB0			FMsk(fNFSTAT_Flash_RnB0)
+#define m1NFSTAT_STON_A2			FMsk(fNFSTAT_STON_A2)
+
+#define m0NFSTAT_IllegalAccess		(~m1NFSTAT_IllegalAccess)
+#define m0NFSTAT_AutoLoadDone		(~m1NFSTAT_AutoLoadDone)
+#define m0NFSTAT_AutoStoreDone		(~m1NFSTAT_AutoStoreDone)
+#define m0NFSTAT_RnB_TransDetect	(~m1NFSTAT_RnB_TransDetect)
+#define m0NFSTAT_Flash_nCE			(~m1NFSTAT_Flash_nCE)
+#define m0NFSTAT_Flash_RnB1			(~m1NFSTAT_Flash_RnB1)
+#define m0NFSTAT_Flash_RnB0			(~m1NFSTAT_Flash_RnB0)
+#define m0NFSTAT_STON_A2			(~m1NFSTAT_STON_A2)
+
+#define sNFSTAT_IllegalAccess(f_)	(FInsrt(f_,fNFSTAT_IllegalAccess)	& m1NFSTAT_IllegalAccess)
+#define sNFSTAT_AutoLoadDone(f_)	(FInsrt(f_,fNFSTAT_AutoLoadDone)	& m1NFSTAT_AutoLoadDone)
+#define sNFSTAT_AutoStoreDone(f_)	(FInsrt(f_,fNFSTAT_AutoStoreDone)	& m1NFSTAT_AutoStoreDone)
+#define sNFSTAT_RnB_TransDetect(f_)	(FInsrt(f_,fNFSTAT_RnB_TransDetect)	& m1NFSTAT_RnB_TransDetect)
+
+
+/*
+ * NFESTAT0
+ */
+#define fNFESTAT0_SErrorDataNo		Fld(4,21)
+#define fNFESTAT0_SErrorBitNo		Fld(3,18)
+#define fNFESTAT0_MErrorDataNo		Fld(11,7)
+#define fNFESTAT0_MErrorBitNo		Fld(3,4)
+#define fNFESTAT0_SpareError		Fld(2,2)
+#define fNFESTAT0_MainError			Fld(2,0)
+
+#define m1NFESTAT0_SErrorDataNo		FMsk(fNFESTAT0_SErrorDataNo)
+#define m1NFESTAT0_SErrorBitNo		FMsk(fNFESTAT0_SErrorBitNo)
+#define m1NFESTAT0_MErrorDataNo		FMsk(fNFESTAT0_MErrorDataNo)
+#define m1NFESTAT0_MErrorBitNo		FMsk(fNFESTAT0_MErrorBitNo)
+#define m1NFESTAT0_SpareError		FMsk(fNFESTAT0_SpareError)
+#define m1NFESTAT0_MainError		FMsk(fNFESTAT0_MainError)
+
+#define m0NFESTAT0_SErrorDataNo		(~m1NFESTAT0_SErrorDataNo)
+#define m0NFESTAT0_SErrorBitNo		(~m1NFESTAT0_SErrorBitNo)
+#define m0NFESTAT0_MErrorDataNo		(~m1NFESTAT0_MErrorDataNo)
+#define m0NFESTAT0_MErrorBitNo		(~m1NFESTAT0_MErrorBitNo)
+#define m0NFESTAT0_SpareError		(~m1NFESTAT0_SpareError)
+#define m0NFESTAT0_MainError		(~m1NFESTAT0_MainError)
+
+#define sNFESTAT0_SErrorDataNo(f_)	(FInsrt(f_,fNFESTAT0_SErrorDataNo)	& m1NFESTAT0_SErrorDataNo)
+#define sNFESTAT0_SErrorBitNo(f_)	(FInsrt(f_,fNFESTAT0_SErrorBitNo)	& m1NFESTAT0_SErrorBitNo)
+#define sNFESTAT0_MErrorDataNo(f_)	(FInsrt(f_,fNFESTAT0_MErrorDataNo)	& m1NFESTAT0_MErrorDataNo)
+#define sNFESTAT0_MErrorBitNo(f_)	(FInsrt(f_,fNFESTAT0_MErrorBitNo)	& m1NFESTAT0_MErrorBitNo)
+#define sNFESTAT0_SpareError(f_)	(FInsrt(f_,fNFESTAT0_SpareError)	& m1NFESTAT0_SpareError)
+#define sNFESTAT0_MainError(f_)		(FInsrt(f_,fNFESTAT0_MainError)		& m1NFESTAT0_MainError)
+
+/*
+ * NFESTAT1
+ */
+#define fNFESTAT1_SErrorDataNo		Fld(4,21)
+#define fNFESTAT1_SErrorBitNo		Fld(3,18)
+#define fNFESTAT1_MErrorDataNo		Fld(11,7)
+#define fNFESTAT1_MErrorBitNo		Fld(3,4)
+#define fNFESTAT1_SpareError		Fld(2,2)
+#define fNFESTAT1_MainError			Fld(2,0)
+
+#define m1NFESTAT1_SErrorDataNo		FMsk(fNFESTAT1_SErrorDataNo)
+#define m1NFESTAT1_SErrorBitNo		FMsk(fNFESTAT1_SErrorBitNo)
+#define m1NFESTAT1_MErrorDataNo		FMsk(fNFESTAT1_MErrorDataNo)
+#define m1NFESTAT1_MErrorBitNo		FMsk(fNFESTAT1_MErrorBitNo)
+#define m1NFESTAT1_SpareError		FMsk(fNFESTAT1_SpareError)
+#define m1NFESTAT1_MainError		FMsk(fNFESTAT1_MainError)
+
+#define m0NFESTAT1_SErrorDataNo		(~m1NFESTAT1_SErrorDataNo)
+#define m0NFESTAT1_SErrorBitNo		(~m1NFESTAT1_SErrorBitNo)
+#define m0NFESTAT1_MErrorDataNo		(~m1NFESTAT1_MErrorDataNo)
+#define m0NFESTAT1_MErrorBitNo		(~m1NFESTAT1_MErrorBitNo)
+#define m0NFESTAT1_SpareError		(~m1NFESTAT1_SpareError)
+#define m0NFESTAT1_MainError		(~m1NFESTAT1_MainError)
+
+#define sNFESTAT1_SErrorDataNo(f_)	(FInsrt(f_,fNFESTAT1_SErrorDataNo)	& m1NFESTAT1_SErrorDataNo)
+#define sNFESTAT1_SErrorBitNo(f_)	(FInsrt(f_,fNFESTAT1_SErrorBitNo)	& m1NFESTAT1_SErrorBitNo)
+#define sNFESTAT1_MErrorDataNo(f_)	(FInsrt(f_,fNFESTAT1_MErrorDataNo)	& m1NFESTAT1_MErrorDataNo)
+#define sNFESTAT1_MErrorBitNo(f_)	(FInsrt(f_,fNFESTAT1_MErrorBitNo)	& m1NFESTAT1_MErrorBitNo)
+#define sNFESTAT1_SpareError(f_)	(FInsrt(f_,fNFESTAT1_SpareError)	& m1NFESTAT1_SpareError)
+#define sNFESTAT1_MainError(f_)		(FInsrt(f_,fNFESTAT1_MainError)		& m1NFESTAT1_MainError)
+
+
+/*
+ * NFMECC0
+ */
+#define fNFMECC0_MECC0_3	Fld(8,24)
+#define fNFMECC0_MECC0_2	Fld(8,16)
+#define fNFMECC0_MECC0_1	Fld(8,8)
+#define fNFMECC0_MECC0_0	Fld(8,0)
+
+#define m1NFMECC0_MECC0_3	FMsk(fNFMECC0_MECC0_3)
+#define m1NFMECC0_MECC0_2	FMsk(fNFMECC0_MECC0_2)
+#define m1NFMECC0_MECC0_1	FMsk(fNFMECC0_MECC0_1)
+#define m1NFMECC0_MECC0_0	FMsk(fNFMECC0_MECC0_0)
+
+#define m0NFMECC0_MECC0_3	(~m1NFMECC0_MECC0_3)
+#define m0NFMECC0_MECC0_2	(~m1NFMECC0_MECC0_2)
+#define m0NFMECC0_MECC0_1	(~m1NFMECC0_MECC0_1)
+#define m0NFMECC0_MECC0_0	(~m1NFMECC0_MECC0_0)
+
+/*
+ * NFMECC1
+ */
+#define fNFMECC1_MECC1_3	Fld(8,24)
+#define fNFMECC1_MECC1_2	Fld(8,16)
+#define fNFMECC1_MECC1_1	Fld(8,8)
+#define fNFMECC1_MECC1_0	Fld(8,0)
+
+#define m1NFMECC1_MECC1_3	FMsk(fNFMECC1_MECC1_3)
+#define m1NFMECC1_MECC1_2	FMsk(fNFMECC1_MECC1_2)
+#define m1NFMECC1_MECC1_1	FMsk(fNFMECC1_MECC1_1)
+#define m1NFMECC1_MECC1_0	FMsk(fNFMECC1_MECC1_0)
+
+#define m0NFMECC1_MECC1_3	(~m1NFMECC1_MECC1_3)
+#define m0NFMECC1_MECC1_2	(~m1NFMECC1_MECC1_2)
+#define m0NFMECC1_MECC1_1	(~m1NFMECC1_MECC1_1)
+#define m0NFMECC1_MECC1_0	(~m1NFMECC1_MECC1_0)
+
+
+/*
+ * NFSECC
+ */
+#define fNFSECC_SECC1_1		Fld(8,24)
+#define fNFSECC_SECC1_0		Fld(8,16)
+#define fNFSECC_SECC0_1		Fld(8,8)
+#define fNFSECC_SECC0_0		Fld(8,0)
+
+#define m1NFSECC_SECC1_1	FMsk(fNFSECC_SECC1_1)
+#define m1NFSECC_SECC1_0	FMsk(fNFSECC_SECC1_0)
+#define m1NFSECC_SECC0_1	FMsk(fNFSECC_SECC0_1)
+#define m1NFSECC_SECC0_0	FMsk(fNFSECC_SECC0_0)
+
+#define m0NFSECC_SECC1_1	(~m1NFSECC_SECC1_1)
+#define m0NFSECC_SECC1_0	(~m1NFSECC_SECC1_0)
+#define m0NFSECC_SECC0_1	(~m1NFSECC_SECC0_1)
+#define m0NFSECC_SECC0_0	(~m1NFSECC_SECC0_0)
+
+
+/*
+ * NFSBLK
+ */
+#define fNFSBLK_SBLK_ADDR2	Fld(8,16)
+#define fNFSBLK_SBLK_ADDR1	Fld(8,8)
+#define fNFSBLK_SBLK_ADDR0	Fld(8,0)
+
+#define m1NFSBLK_SBLK_ADDR2	FMsk(fNFSBLK_SBLK_ADDR2)
+#define m1NFSBLK_SBLK_ADDR1	FMsk(fNFSBLK_SBLK_ADDR1)
+#define m1NFSBLK_SBLK_ADDR0	FMsk(fNFSBLK_SBLK_ADDR0)
+
+#define m0NFSBLK_SBLK_ADDR2	(~m1NFSBLK_SBLK_ADDR2)
+#define m0NFSBLK_SBLK_ADDR1	(~m1NFSBLK_SBLK_ADDR1)
+#define m0NFSBLK_SBLK_ADDR0	(~m1NFSBLK_SBLK_ADDR0)
+
+#define sNFSBLK_SBLK_ADDR2(f_)	(FInsrt(f_,fNFSBLK_SBLK_ADDR2)	& m1NFSBLK_SBLK_ADDR2)
+#define sNFSBLK_SBLK_ADDR1(f_)	(FInsrt(f_,fNFSBLK_SBLK_ADDR1)	& m1NFSBLK_SBLK_ADDR1)
+#define sNFSBLK_SBLK_ADDR0(f_)	(FInsrt(f_,fNFSBLK_SBLK_ADDR0)	& m1NFSBLK_SBLK_ADDR0)
+
+/*
+ * NFEBLK
+ */
+#define fNFEBLK_EBLK_ADDR2	Fld(8,16)
+#define fNFEBLK_EBLK_ADDR1	Fld(8,8)
+#define fNFEBLK_EBLK_ADDR0	Fld(8,0)
+
+#define m1NFEBLK_EBLK_ADDR2	FMsk(fNFEBLK_EBLK_ADDR2)
+#define m1NFEBLK_EBLK_ADDR1	FMsk(fNFEBLK_EBLK_ADDR1)
+#define m1NFEBLK_EBLK_ADDR0	FMsk(fNFEBLK_EBLK_ADDR0)
+
+#define m0NFEBLK_EBLK_ADDR2	(~m1NFEBLK_EBLK_ADDR2)
+#define m0NFEBLK_EBLK_ADDR1	(~m1NFEBLK_EBLK_ADDR1)
+#define m0NFEBLK_EBLK_ADDR0	(~m1NFEBLK_EBLK_ADDR0)
+
+#define sNFEBLK_EBLK_ADDR2(f_)	(FInsrt(f_,fNFEBLK_EBLK_ADDR2)	& m1NFEBLK_EBLK_ADDR2)
+#define sNFEBLK_EBLK_ADDR1(f_)	(FInsrt(f_,fNFEBLK_EBLK_ADDR1)	& m1NFEBLK_EBLK_ADDR1)
+#define sNFEBLK_EBLK_ADDR0(f_)	(FInsrt(f_,fNFEBLK_EBLK_ADDR0)	& m1NFEBLK_EBLK_ADDR0)
+
+#endif /* _S3C24A0_NAND_H_ */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/smdk.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/smdk.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/smdk.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/smdk.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,144 @@
+/*
+ * include/asm-arm/arch-s3c24a0/smdk.h
+ *
+ * Changes
+ *
+ * 2004/06/10 <heechul.yun@samsung.com>  CPLD IDE code added
+ *
+ */
+
+#ifndef _SMDK24A0_H_
+#define _SMDK24A0_H_
+
+/* Externl clock frequency used by CPU */
+#define FIN     12000000
+
+/*
+ * on SMDK24A0,
+ * there are so many cross-interference jumpers (h/w switch).
+ */
+
+/*
+ * This is for SPJ Board - hcyun
+
+ XgpIO0  <------ EINT0
+ XgpIO1  <------ EINT1
+ XgpIO2  <------ SD_INT
+ XgpIO3  ------> XGPIO_nSS              <-- not used
+ XgpIO4  ------> LED0
+ XgpIO5  ------> LED1
+ XgpIO6  ------> LED2
+ XgpIO7  ------> LED3
+ XgpIO8  <----->
+ XgpIO9  ------>
+ XgpIO10 <------ EINT10                 <-- not used
+ XgpIO11 <------ EINT11                 <-- not used
+ XgpIO12 <------ MODEM_INT              <-- not used
+ XgpIO13 <------ ETHER_INT
+ XgpIO14 <------ SMC_INT                <-- not used
+ XgpIO15 ------> SMC_WP                 <-- l3-bit-elfin.c I2C??? l3 bus
+ XgpIO16 <------ SPJ IDE                <-- IDE & l3-bit-elfin.c I2C??? l3 bus
+ XgpIO17 <------ SPJ USB                <-- USB
+ XgpIO18 <-----> KP_ROW0
+ XgpIO19 <-----> KP_ROW1                <-- s3c24a0_keyif.c
+ XgpIO20 <-----> KP_ROW2                <-- s3c24a0_keyif.c
+ XgpIO21 <-----> KP_ROW3
+ XgpIO22 <-----> KP_ROW4
+ XgpIO23 <-----> KP_COL0
+ XgpIO24 <-----> KP_COL1
+ XgpIO25 <-----> KP_COL2
+ XgpIO26 <-----> KP_COL3
+ XgpIO27 <-----> KP_COL4
+ XgpIO28 <----->
+ XgpIO29 <----->
+ XgpIO30 <----->
+ XgpIO31 <----->
+
+ *
+ */
+
+#define SMDK_SMC_WP      GPIO_15    /* O   : SMC Write-Protect */
+
+#define SMDK_CAM_SCL     GPIO_9     /* O   : Camera I2C/SCCB clock */
+#define SMDK_CAM_SDA     GPIO_8     /* I/O : Camera I2C/SCCB data */
+#define SMDK_LED7        GPIO_7     /* O   : LED3, Low-Active */
+#define SMDK_LED6        GPIO_6     /* O   : LED2, LOw-Active */
+#define SMDK_LED5        GPIO_5     /* O   : LED1, LOw-Active */
+#define SMDK_LED4        GPIO_4     /* O   : LED0, Low-Active */
+
+/* GPIO buttons. EINT 0,1,10,11 */
+#define SMDK_EINT0_IRQ  IRQ_EINT0
+#define SMDK_EINT1_IRQ  IRQ_EINT1
+#define SMDK_EINT10_IRQ IRQ_EINT10
+#define SMDK_EINT11_IRQ IRQ_EINT11
+#define SMDK_EINT0_GPIO GPIO_0
+#define SMDK_EINT1_GPIO GPIO_1
+#define SMDK_EINT10_GPIO GPIO_10
+#define SMDK_EINT11_GPIO GPIO_11
+
+#ifndef CONFIG_UCLINUX
+  #define SROM_BANK1_PBASE                        0x04000000
+  #define SROM_BANK1_VBASE                        0xf0000000
+#else /* UCLINUX */
+  #define SROM_BANK1_PBASE                        0x04000000
+  #define SROM_BANK1_VBASE                        0x04000000
+#endif /* UCLINUX */
+
+#ifndef __ASSEMBLY__
+/*
+ * BANK1 control for cs89x0, IDE, USB2.0 - hcyun
+ */
+typedef struct {
+        unsigned long bw;
+        unsigned long bc;
+} bank_param_t;
+
+#define B1_STATE_NONE -1
+#define B1_IDE_PIO0 0
+#define B1_IDE_PIO4 1
+#define B1_CS89x0       2
+#define B1_USB2         3
+#define B1_STATE_LIMIT 3
+
+#endif
+
+
+/* CPLD IDE - hcyun
+ * 0x07000000   [0] : IDE reset
+ *                              [1] : 0 - USB, 1 - IDE
+ */
+
+#define SMDK_CPLD_IDE_IRQ_GPIO          GPIO_4
+#define SMDK_CPLD_IDE_IRQ               IRQ_EINT4
+#define SMDK_CPLD_IDE_VIO               (SROM_BANK1_VBASE + 0x03000000) // 0xf3000000
+#define SMDK_CPLD_IDE_PIO               (SROM_BANK1_PBASE + 0x03000000) // 0x04000000
+
+
+/* CPLD USB - hcyun
+ * 0x06000000   [0] : USB reset
+ */
+/*seo 20040616 */
+#define SMDK_CPLD_USB_IRQ_GPIO          GPIO_5
+#define SMDK_CPLD_USB_IRQ               IRQ_EINT5
+#define SMDK_CPLD_USB_VIO               (SROM_BANK1_VBASE + 0x02000000)
+#define SMDK_CPLD_USB_PIO               (SROM_BANK1_PBASE + 0x02000000)
+
+
+/* CS8900A */
+#define SMDK_CS8900_IRQ_GPIO   GPIO_13
+#define SMDK_CS8900_IRQ        IRQ_EINT13
+#define SMDK_CS8900_VIO        SROM_BANK1_VBASE
+#define SMDK_CS8900_PIO        (SROM_BANK1_PBASE | (1<<24))
+
+/* IRDA */
+#define SMDK_IRDA_SDBW          (GPIO_MODE_IrDA_SDBW | GPIO_16 | GPIO_PULLUP_DIS)
+#define SMDK_IRDA_TXD           (GPIO_MODE_IrDA_TXD | GPIO_17 | GPIO_PULLUP_DIS)
+#define SMDK_IRDA_RXD           (GPIO_MODE_IrDA_RXD | GPIO_18 | GPIO_PULLUP_DIS)
+
+/* UART */
+#define SMDK_UART1_nCTS         (GPIO_MODE_UART | GPIO_28 | GPIO_PULLUP_DIS)
+#define SMDK_UART1_nRTS         (GPIO_MODE_UART | GPIO_29 | GPIO_PULLUP_DIS)
+#define SMDK_UART1_TXD          (GPIO_MODE_UART | GPIO_30 | GPIO_PULLUP_DIS)
+#define SMDK_UART1_RXD          (GPIO_MODE_UART | GPIO_31 | GPIO_PULLUP_DIS)
+
+#endif /* _SMDK24A0_H_ */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/system.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/system.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/system.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-s3c24a0/system.h
+ * 
+ * $Id: system.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <asm/arch/hardware.h>
+
+static inline 
+void arch_idle(void)
+{
+	/* TODO */
+	cpu_do_idle(/*0*/);
+}
+
+static inline 
+void arch_reset(char mode)
+{
+	if (mode == 's') {
+		/* Jump into ROM at address 0 */
+		cpu_reset(0);
+	} else {
+		WTCNT = 0x100;
+		WTDAT = 0x100;
+		WTCON = 0x8021;
+	}
+}
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/time.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/time.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/time.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,231 @@
+/*
+ * include/asm-arm/arch-s3c24a0/time.h
+ *
+ * $Id: time.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on linux/include/asm-arm/arch-s3c2410/time.h
+ */
+
+#include <linux/time.h> /* for mktime() */
+#include <linux/rtc.h>  /* struct rtc_time */
+#include "clocks.h"
+
+/* copy from linux/arch/arm/kernel/time.c */
+#ifndef BCD_TO_BIN
+#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+#ifndef RTC_LEAP_YEAR
+#define RTC_LEAP_YEAR        2000
+#endif
+
+extern spinlock_t rtc_lock;
+
+unsigned long elfin_get_rtc_time(void)
+{
+        unsigned int year, mon, day, hour, min, sec;
+
+        spin_lock_irq(&rtc_lock);
+read_rtc_bcd_time:
+        year = BCDYEAR & Msk_RTCYEAR;
+        mon  = BCDMON  & Msk_RTCMON;
+        day  = BCDDAY  & Msk_RTCDAY;
+        hour = BCDHOUR & Msk_RTCHOUR;
+        min  = BCDMIN  & Msk_RTCMIN;
+        sec  = BCDSEC  & Msk_RTCSEC;
+        if (sec == 0) {
+                /* If BCDSEC is zero, reread all bcd registers.
+                   See Section 17.2 READ/WRITE REGISTERS for more info. */
+                goto read_rtc_bcd_time;
+        }
+        spin_unlock_irq(&rtc_lock);
+
+        BCD_TO_BIN(year);
+        BCD_TO_BIN(mon);
+        BCD_TO_BIN(day);
+        BCD_TO_BIN(hour);
+        BCD_TO_BIN(min);
+        BCD_TO_BIN(sec);
+
+        year += RTC_LEAP_YEAR;
+
+        return (mktime(year, mon, day, hour, min, sec));
+}
+
+/*
+ * Copyed from drivers/char/sa1100-rtc.c.
+ */
+#define epoch                   1970
+
+static const unsigned char days_in_mo[] =
+        {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+#ifndef is_leap
+#define is_leap(year) \
+        ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+#endif
+
+/*
+ * Converts seconds since 1970-01-01 00:00:00 to Gregorian date.
+ */
+static void decodetime (unsigned long t, struct rtc_time *tval)
+{
+        unsigned long days, month, year, rem;
+
+        days = t / 86400;
+        rem = t % 86400;
+        tval->tm_hour = rem / 3600;
+        rem %= 3600;
+        tval->tm_min = rem / 60;
+        tval->tm_sec = rem % 60;
+        tval->tm_wday = (4 + days) % 7;
+
+#define LEAPS_THRU_END_OF(y) ((y)/4 - (y)/100 + (y)/400)
+
+        year = epoch;
+        while (days >= (365 + is_leap(year))) {
+                unsigned long yg = year + days / 365;
+                days -= ((yg - year) * 365
+                                + LEAPS_THRU_END_OF (yg - 1)
+                                - LEAPS_THRU_END_OF (year - 1));
+                year = yg;
+        }
+        tval->tm_year = year - 1900;
+        tval->tm_yday = days + 1;
+
+        month = 0;
+        if (days >= 31) {
+                days -= 31;
+                month++;
+                if (days >= (28 + is_leap(year))) {
+                        days -= (28 + is_leap(year));
+                        month++;
+                        while (days >= days_in_mo[month]) {
+                                days -= days_in_mo[month];
+                                month++;
+                        }
+                }
+        }
+        tval->tm_mon = month;
+        tval->tm_mday = days + 1;
+}
+
+int elfin_set_rtc(void)
+{
+        unsigned long current_time = xtime.tv_sec;
+        unsigned char year, mon, day, hour, min, sec;
+        signed int yeardiff;
+        struct rtc_time rtc_tm;
+
+        decodetime(current_time, &rtc_tm);
+
+        yeardiff = (rtc_tm.tm_year + 1900) - RTC_LEAP_YEAR;
+        if (yeardiff < 0) {
+                /* S3C2410 RTC forces that the year must be higher or
+                   equal than 2000, so initailize it. */
+                yeardiff = 0;
+        }
+
+        year = (unsigned char) yeardiff;
+        mon = rtc_tm.tm_mon + 1; /* tm_mon starts at zero */
+        day = rtc_tm.tm_mday;
+        hour = rtc_tm.tm_hour;
+        min = rtc_tm.tm_min;
+        sec = rtc_tm.tm_sec;
+
+        BIN_TO_BCD(sec);
+        BIN_TO_BCD(min);
+        BIN_TO_BCD(hour);
+        BIN_TO_BCD(day);
+        BIN_TO_BCD(mon);
+        BIN_TO_BCD(year);
+
+        spin_lock_irq(&rtc_lock);
+        RTCCON |= RTCCON_EN;
+        BCDSEC  = sec  & Msk_RTCSEC;
+        BCDMIN  = min  & Msk_RTCMIN;
+        BCDHOUR = hour & Msk_RTCHOUR;
+        BCDDAY  = day  & Msk_RTCDAY;
+        BCDMON  = mon  & Msk_RTCMON;
+        BCDYEAR = year & Msk_RTCYEAR;
+        RTCCON &= ~RTCCON_EN;
+        spin_unlock_irq(&rtc_lock);
+
+        return 0;
+}
+
+static unsigned long elfin_gettimeoffset(void)
+{
+        unsigned long elapsed, usec;
+        unsigned long latch;
+
+        /* Use TCNTB4 as LATCH */
+        latch = TCNTB4;
+
+        elapsed = latch - TCNTO4;
+        usec = (elapsed * (tick_nsec / 1000)) / latch; // hcyun
+
+        return usec;
+}
+
+static irqreturn_t elfin_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+
+        do_leds();
+//      do_set_rtc();
+        do_timer(regs);
+
+        return IRQ_HANDLED;
+
+}
+
+#define TCON4_PRESCALER_VALUE   15
+#define TCON4_DIVIDER_VALUE     2
+#define TCON4_PERIOD            10      /* miliseconds */
+void __init time_init(void)
+{
+        gettimeoffset = elfin_gettimeoffset;
+        set_rtc = elfin_set_rtc;
+        xtime.tv_sec = elfin_get_rtc_time();
+
+        /* set timer interrupt */
+        TCFG0 = (TCFG0_DZONE(0) | TCFG0_PRE1(TCON4_PRESCALER_VALUE) | TCFG0_PRE0(TCON4_PRESCALER_VALUE));
+
+        /*
+         * period = (prescaler value + 1) * (divider value) * buffer count / PCLK
+         * buffer count = period * PCLK / divider value / (prescaler value + 1)
+         *
+         * e.g.)
+         *
+         * PCLK = 50700000 Hz, divider value = 2, prescaler value = 15
+         * period = 10ms
+         *
+         * buffer count = ((10 / 1000) * 50700000) / 2 / (15+1)
+         *              = 15843.75
+         */
+
+        printk("DEBUG: PCLK=%d, Prescaler=%d, Divider=%d\n", elfin_get_bus_clk(GET_PCLK), TCON4_PRESCALER_VALUE+1, TCON4_DIVIDER_VALUE );
+        TCNTB4 = ((TCON4_PERIOD * ((elfin_get_bus_clk(GET_PCLK))/1000)) / TCON4_DIVIDER_VALUE) / (TCON4_PRESCALER_VALUE + 1);
+        printk("DEBUG: timer count %d\n", TCNTB4);
+
+
+        TCON = (TCON_4_AUTO | TCON_4_UPDATE | (0 << 20));
+        timer_irq.handler = elfin_timer_interrupt;
+
+        printk("Timer Initialized.. IRQ=%d\n", IRQ_TIMER4);
+
+        setup_irq(IRQ_TIMER4, &timer_irq);
+
+        TCON = (TCON_4_AUTO | (0 << 21) | TCON_4_ONOFF);
+}
+
+EXPORT_SYMBOL(elfin_get_rtc_time);
+EXPORT_SYMBOL(elfin_set_rtc);
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/timex.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/timex.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/timex.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,27 @@
+/*
+ * include/asm-arm/arch-s3c24a0/timex.h
+ *
+ * $Id: timex.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on linux/include/asm-arm/arch-s3c2410/timex.h
+ */
+
+
+/* If a value of TCFG1 is a, a value of divider is 2 << a */
+#define CLK_DIVIDER             2
+/* a value of TCFG0_PRE1 */
+#define CLK_PRESCALE            15
+
+#include <asm/arch/clocks.h>
+
+/* PCLK */
+// #define CLK_INPUT               elfin_get_bus_clk(GET_PCLK)
+#define CLK_INPUT               51000000 /* 204-102-51 MHz */
+
+/*#define CLOCK_TICK_RATE               1562500 */
+#define CLOCK_TICK_RATE         (CLK_INPUT / (CLK_PRESCALE ) / CLK_DIVIDER)
+#define CLOCK_TICK_FACTOR       80
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/uncompress.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/uncompress.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/uncompress.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/uncompress.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,85 @@
+/*
+ * include/asm-arm/arch-s3c24a0/uncompress.h
+ *
+ * $Id: uncompress.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader. We use only UART1 on S3C24xx
+ */
+#include <linux/config.h>
+
+#ifdef CONFIG_ARCH_S3C24A0
+
+#define ULCON                   0x0
+#define UTRSTAT                 0x10
+#define UTXH                    0x20
+#define UTRSTAT_TX_EMPTY        (1 << 2)
+
+#define UART0                   0x44400000
+#define UART1                   0x44404000
+
+#define UART(x)                 (*(volatile unsigned long *)(serial_port + (x)))
+
+static void puts(const char *s)
+{
+        unsigned long serial_port;
+
+        do {
+                serial_port = UART0;
+                if (UART(ULCON) == 0x3) break;
+                serial_port = UART1;
+                if (UART(ULCON) == 0x3) break;
+        } while (0);
+
+        for (; *s; s++) {
+                /* wait */
+                while (!(UART(UTRSTAT) & UTRSTAT_TX_EMPTY));
+
+                /* send the character out. */
+                UART(UTXH) = *s;
+
+                /* if a LF, also do CR... */
+                if (*s == 10) {
+                        while (!(UART(UTRSTAT) & UTRSTAT_TX_EMPTY));
+
+                        UART(UTXH) = 13;
+                }
+        }
+}
+
+#else
+
+#define UART_UTRSTAT            (*(volatile unsigned long *)0x44400010)
+#define UART_UTXH               (*(volatile unsigned long *)0x44400020) /* littel endian */
+#define UTRSTAT_TX_EMPTY        (1 << 2)
+
+static void puts(const char *s)
+{
+        while (*s) {
+                while (!(UART_UTRSTAT & UTRSTAT_TX_EMPTY));
+
+                UART_UTXH = *s;
+
+                if (*s == '\n') {
+                        while (!(UART_UTRSTAT & UTRSTAT_TX_EMPTY));
+
+                        UART_UTXH = '\r';
+                }
+                s++;
+        }
+        while (!(UART_UTRSTAT & UTRSTAT_TX_EMPTY));
+}
+#endif
+
+/*
+ * Nothing to do for these
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/uncompress-jtag.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/uncompress-jtag.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/uncompress-jtag.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/uncompress-jtag.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,58 @@
+/*
+ *  linux/include/asm-armnommu/arch-s5c7375/uncompress.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi, Samsung Electronics Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm-armnommu/hardware/t32.h>
+
+#ifndef __UNCOMPRESS_H__
+#define __UNCOMPRESS_H__
+
+/*
+ * just use T32 JTAG1 port
+ */
+static inline void puts(const char *s)
+{
+	t32_puts(s);
+}
+
+static void puts_hex(unsigned long i)
+{
+	char lhex_buf[]="0x00000000";
+	unsigned long ii,v;
+
+	for(ii=9;ii>1;ii--)
+	{
+		v=(((0x0000000F << ((9-ii)*4)) & i) >> ((9-ii)*4));
+		if(v>9)
+			lhex_buf[ii]=(char)('A'+v-10);
+		else
+			lhex_buf[ii]=(char)('0'+v);
+	}
+
+	t32_puts(lhex_buf);
+}
+
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/vmalloc.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/vmalloc.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c24a0/vmalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c24a0/vmalloc.h	2004-11-23 11:22:05.000000000 +0900
@@ -0,0 +1,24 @@
+/*
+ * include/asm-arm/arch-s3c24a0/vmalloc.h
+ * 
+ * $Id: vmalloc.h,v 1.1 2004/06/03 01:35:47 hcyun Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Based on linux/include/asm-arm/arch-pxa/vmalloc.h
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/time.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c3410/time.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c3410/time.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c3410/time.h	2004-11-23 10:13:19.000000000 +0900
@@ -18,59 +18,6 @@
 
 #define CLOCKS_PER_USEC	(CONFIG_ARM_CLK/1000000)
 
-unsigned long s3c3410_gettimeoffset (void)
-{
-	return (inw(S3C3410X_TCNT0) / CLOCKS_PER_USEC);
-}
-
-static irqreturn_t
-s3c3410_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-    do_timer(regs);
-    do_profile(regs);
-
-    return IRQ_HANDLED;
-}
-
 #define S3C3410X_TIMER0_PRESCALER 100
 
-/*
- * Set up timer interrupt, and return the current time in seconds.
- */
-
-void __init  time_init (void)
-{
-	u_int8_t tmod;
-	u_int16_t period;
-	
-	/*
-	 * disable and clear timer 0, set to
-	 * internal clock and interval mode
-	 */
-	tmod = S3C3410X_T16_OMS_INTRV | S3C3410X_T16_CL;
-	outb(tmod, S3C3410X_TCON0);
-
-	/* initialize the timer period and prescaler */
-	period = (CONFIG_ARM_CLK/S3C3410X_TIMER0_PRESCALER)/HZ;
-	outw(period, S3C3410X_TDAT0);
-	outb(S3C3410X_TIMER0_PRESCALER-1, S3C3410X_TPRE0);
-
-	/*
-	 * @todo do those really need to be function pointers ?
-	 */
-	gettimeoffset     = s3c3410_gettimeoffset;
-	timer_irq.handler = s3c3410_timer_interrupt;
-
-	/* set up the interrupt vevtor for timer 0 match */
-	setup_irq(S3C3410X_INTERRUPT_TMC0, &timer_irq);
-	
-	/* enable the timer IRQ */
-	s3c3410_unmask_irq(S3C3410X_INTERRUPT_TMC0);
-
-	/* let timer 0 run... */
-	tmod |= S3C3410X_T16_TEN;
-	tmod &= ~S3C3410X_T16_CL;
-	outb(tmod, S3C3410X_TCON0);
-}
-
 #endif
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/time.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c44b0x/time.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s3c44b0x/time.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s3c44b0x/time.h	2004-11-23 11:27:28.000000000 +0900
@@ -4,63 +4,4 @@
 
 #ifndef __ASM_ARCH_TIME_H__
 #define __ASM_ARCH_TIME_H__
-
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/hardware.h>
-#include <asm/arch/timex.h>
-
-/*
- * Set up timer interrupt.
- */
-#if	CONFIG_ARM_CLK_ADJUST
-void s3c44b0x_systimer_setup(void);
-void s3c44b0x_led_off(int);
-void s3c44b0x_led_on(int);
-#else
-void __init s3c44b0x_systimer_setup(void);
-#endif
-
-void __inline__ s3c44b0x_systimer_start(void);
-
-unsigned long s3c44b0x_gettimeoffset (void)
-{
-	return SYSREG_GETW(S3C44B0X_TCNTB5);
-}
-
-static irqreturn_t s3c44b0x_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-#if	CONFIG_DEBUG_NICKMIT
-	static int cnt = 0;
-	++cnt;
-	if (cnt == HZ) {
-		static int stat = 0;
-		cnt = 0;
-		if (stat)
-			s3c44b0x_led_on(0);
-		else
-			s3c44b0x_led_off(0);
-		stat = 1 - stat;
-	}
-#endif
-	do_timer(regs);
-	do_profile(regs);
-	return IRQ_HANDLED;
-}
-
-void __init time_init(void) 
-{
-	s3c44b0x_systimer_setup();
-	/*
-	 * @todo do those really need to be function pointers ?
-	 */
-	gettimeoffset     = s3c44b0x_gettimeoffset;
-	timer_irq.handler = s3c44b0x_timer_interrupt;
-
-	setup_irq(S3C44B0X_INTERRUPT_TIMER5, &timer_irq);
-	s3c44b0x_clear_pb(S3C44B0X_INTERRUPT_TIMER5);
-	s3c44b0x_unmask_irq(S3C44B0X_INTERRUPT_TIMER5);
-
-	s3c44b0x_systimer_start();
-}
 #endif
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/time.h linux-2.6.9-hsc0/include/asm-armnommu/arch-s5c7375/time.h
--- linux-2.6.9-uc0/include/asm-armnommu/arch-s5c7375/time.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/arch-s5c7375/time.h	2004-11-19 15:01:39.000000000 +0900
@@ -86,62 +86,3 @@
 							//(ECLK/1000000) /* (ARM_CLK/1000000) */
 							/* this is the newer version */
 
-unsigned long s5c7375_gettimeoffset (void)
-{
-	return (((RESCHED_PERIOD  * CLOCKS_PER_USEC) /1000) - rT3LDR)  / CLOCKS_PER_USEC;
-}
-
-static irqreturn_t
-s5c7375_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-    /* clear interrupt pending bit */
-    rT3ISR = 0;
-    do_timer(regs);
-    do_profile(regs);
-
-    return IRQ_HANDLED;
-}
-
-/*
- * Set up timer interrupt, and return the current time in seconds.
- */
-
-void __init  time_init (void)
-{
-	//- APB bus speed setting
-	/*
-	 * Number of AHB clock cycles allocated in the ENABLE or
-	 * SETUP state of the 2-nd APB peripheral minus one.
-	 */
-	rAPBCON2=(unsigned long)0x00010000; 
-
-	gettimeoffset = s5c7375_gettimeoffset;
-	timer_irq.handler = s5c7375_timer_interrupt;
-
-	/*
-	 * Timer 3 is used for OS_timer by external clock.
-	 */
-	rT3CTR = TMR_TE_DISABLE | TMR_IE_PULSE | TMR_OE_ENABLE | TMR_UD_DOWN \
-			| TMR_UDS_TxCTR | TMR_OM_PULSE | TMR_ES_POS | TMR_M_PERIODIC_TIMER;
-
-	/*
-	 * prescaler to 0x6B 'cause : 
-	 * 	27M / (0x6B +1) = 4usec
-	 */
-	rT3PSR = SYS_TIMER03_PRESCALER; // 0x6B
-	/* rT3LDR  =  X second * (frequency/second ) */
-	rT3LDR = RESCHED_PERIOD  * CLOCKS_PER_USEC /1000;
-			/* is equal to 
-			 *	RESCHED_PERIOD * 1000    // for msec to usec
-			 * 	   * (ECLK/ (SYS_TIMER03_PRESCALER +1)) /1000000;
-			 *	= 2500
-			 */
-   	/* clear interrupt pending bit */
-	rT3ISR = 0;
-
-	setup_irq(INT_N_TIMER3, &timer_irq);
-
-	/* timer 3 enable it! */
-	rT3CTR |= TMR_TE_ENABLE;
-
-}
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/cacheflush.h linux-2.6.9-hsc0/include/asm-armnommu/cacheflush.h
--- linux-2.6.9-uc0/include/asm-armnommu/cacheflush.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/cacheflush.h	2004-11-22 15:35:36.000000000 +0900
@@ -50,7 +50,7 @@
 #endif
 
 #if defined(CONFIG_CPU_ARM920T) || defined(CONFIG_CPU_ARM922T) || \
-    defined(CONFIG_CPU_ARM1020)
+    defined(CONFIG_CPU_ARM925T) || defined(CONFIG_CPU_ARM1020)
 # define MULTI_CACHE 1
 #endif
 
@@ -82,7 +82,7 @@
  *	Start addresses are inclusive and end addresses are exclusive;
  *	start addresses should be rounded down, end addresses up.
  *
- *	See linux/Documentation/cachetlb.txt for more information.
+ *	See Documentation/cachetlb.txt for more information.
  *	Please note that the implementation of these, and the required
  *	effects are cache-type (VIVT/VIPT/PIPT) specific.
  *
@@ -142,6 +142,7 @@
 	void (*flush_user_range)(unsigned long, unsigned long, unsigned int);
 
 	void (*coherent_kern_range)(unsigned long, unsigned long);
+	void (*coherent_user_range)(unsigned long, unsigned long);
 	void (*flush_kern_dcache_page)(void *);
 
 	void (*dma_inv_range)(unsigned long, unsigned long);
@@ -207,20 +208,26 @@
  */
 #define flush_cache_all()	__cpuc_flush_kern_all()
 
-#define flush_cache_mm(mm) __cpuc_flush_user_all()
-#define flush_cache_range(vma, start, end)	\
-	__cpuc_flush_user_range((start) & PAGE_MASK, \
+#define flush_cache_mm(mm) __cpuc_flush_kern_all()
+#define flush_cache_range(vma, start, end)	flush_cache_all()
+#if 0
+	__cpuc_flush_kern_range((start) & PAGE_MASK, \
 	PAGE_ALIGN(end), (vma)->vm_flags)
+#endif
 
 #define flush_dcache_range(start,len)		flush_cache_all()
 #define flush_dcache_page(page)			flush_cache_all()
+#define flush_icache_user_range(vma,page,addr,len) 	flush_cache_all()
+
 /*
  * Perform necessary cache operations to ensure that data previously
  * stored within this range of addresses can be executed by the CPU.
  */
 #define flush_icache_range(s,e)		__cpuc_coherent_kern_range(s,e)
 #define flush_icache_page(vma,pg)		do { } while (0)
-#define flush_icache_user_range(vma,pg,adr,len)	flush_cache_all()
+#define flush_cache_page(vma,pg)		do { } while (0)
+#define flush_cache_user_range(vma,s,e)  flush_cache_range(vma,s,e)
+
 
 #define flush_cache_vmap(start, end)		flush_cache_all()
 #define flush_cache_vunmap(start, end)		flush_cache_all()
@@ -230,11 +237,4 @@
 #define copy_from_user_page(vma, page, vaddr, dst, src, len) \
 	memcpy(dst, src, len)
 
-static inline void
-flush_cache_page(struct vm_area_struct *vma, unsigned long user_addr)
-{
-	unsigned long addr = user_addr & PAGE_MASK;
-	__cpuc_flush_user_range(addr, addr + PAGE_SIZE, vma->vm_flags);
-}
-
 #endif
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/cpu-multi32.h linux-2.6.9-hsc0/include/asm-armnommu/cpu-multi32.h
--- linux-2.6.9-uc0/include/asm-armnommu/cpu-multi32.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/cpu-multi32.h	2004-11-22 15:37:53.000000000 +0900
@@ -8,9 +8,6 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-#ifndef __ASSEMBLY__
-
-#include <asm/memory.h>
 #include <asm/page.h>
 
 struct mm_struct;
@@ -60,7 +57,4 @@
 #define cpu_reset(addr)			processor.reset(addr)
 #define cpu_do_idle()			processor._do_idle()
 #define cpu_dcache_clean_area(addr,sz)	processor.dcache_clean_area(addr,sz)
-
-#define cpu_switch_mm(pgd,mm)	processor.switch_mm(__virt_to_phys((unsigned long)(pgd)),mm)
-
-#endif
+#define cpu_do_switch_mm(pgd,mm)	processor.switch_mm(pgd,mm)
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/cpu-single.h linux-2.6.9-hsc0/include/asm-armnommu/cpu-single.h
--- linux-2.6.9-uc0/include/asm-armnommu/cpu-single.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/cpu-single.h	2004-11-22 15:39:35.000000000 +0900
@@ -28,11 +28,8 @@
 #define cpu_reset			__cpu_fn(CPU_NAME,_reset)
 #define cpu_do_idle			__cpu_fn(CPU_NAME,_do_idle)
 #define cpu_dcache_clean_area		__cpu_fn(CPU_NAME,_dcache_clean_area)
-#define cpu__switch_mm			__cpu_fn(CPU_NAME,_switch_mm)
+#define cpu_do_switch_mm		__cpu_fn(CPU_NAME,_switch_mm)
 
-#ifndef __ASSEMBLY__
-
-#include <asm/memory.h>
 #include <asm/page.h>
 
 struct mm_struct;
@@ -42,10 +39,5 @@
 extern void cpu_proc_fin(void);
 extern int cpu_do_idle(void);
 extern void cpu_dcache_clean_area(void *, int);
-extern void cpu__switch_mm(unsigned long pgd_phys, struct mm_struct *mm);
-
+extern void cpu_do_switch_mm(unsigned long pgd_phys, struct mm_struct *mm);
 extern volatile void cpu_reset(unsigned long addr);
-
-#define cpu_switch_mm(pgd,mm) cpu__switch_mm(__virt_to_phys((unsigned long)(pgd)),mm)
-
-#endif
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/dma-mapping.h linux-2.6.9-hsc0/include/asm-armnommu/dma-mapping.h
--- linux-2.6.9-uc0/include/asm-armnommu/dma-mapping.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/dma-mapping.h	2004-11-23 10:08:21.000000000 +0900
@@ -5,8 +5,6 @@
 
 #ifdef CONFIG_PCI
 #include <asm-generic/dma-mapping.h>
-#else
-#include <asm-generic/dma-mapping-broken.h>
 #endif
 
 #endif /* _ARMNOMMU_DMA_MAPPING_H */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/mach/arch.h linux-2.6.9-hsc0/include/asm-armnommu/mach/arch.h
--- linux-2.6.9-uc0/include/asm-armnommu/mach/arch.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/mach/arch.h	2004-11-19 15:01:39.000000000 +0900
@@ -13,7 +13,7 @@
  * The size of struct machine_desc
  *   (for assembler code)
  */
-#define SIZEOF_MACHINE_DESC	44
+//#define SIZEOF_MACHINE_DESC	48
 
 #ifndef __ASSEMBLY__
 
@@ -43,6 +43,7 @@
 					 struct tag *, char **,
 					 struct meminfo *);
 	void			(*init_irq)(void);
+	void			(*init_time)(void);
 	void			(*init_machine)(void);
 };
 
@@ -81,6 +82,9 @@
 #define INITIRQ(_func)				\
 	.init_irq	= _func,
 
+#define INITTIME(_func)				\
+	.init_time	= _func,
+
 #define INIT_MACHINE(_func)			\
 	.init_machine	= _func,
 
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/mach/time.h linux-2.6.9-hsc0/include/asm-armnommu/mach/time.h
--- linux-2.6.9-uc0/include/asm-armnommu/mach/time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/mach/time.h	2004-11-19 15:01:39.000000000 +0900
@@ -0,0 +1 @@
+#include <asm-arm/mach/time.h>
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/memory.h linux-2.6.9-hsc0/include/asm-armnommu/memory.h
--- linux-2.6.9-uc0/include/asm-armnommu/memory.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/memory.h	2004-11-22 15:33:08.000000000 +0900
@@ -14,9 +14,11 @@
 #define __ASM_ARMNOMMU_MEMORY_H
 
 #include <linux/config.h>
+#include <linux/compiler.h>
 #include <asm/arch/memory.h>
 
 
+#ifndef __ASSEMBLY__
 
 #define virt_to_bus(x) ((unsigned long) (x))
 #define bus_to_virt(x) ((void *) (x))
@@ -34,6 +36,20 @@
 #define __pa(x)			__virt_to_phys((unsigned long)(x))
 #define __va(x)			((void *)__phys_to_virt((unsigned long)(x)))
 
+/*
+ * The DMA mask corresponding to the maximum bus address allocatable
+ * using GFP_DMA.  The default here places no restriction on DMA
+ * allocations.  This must be the smallest DMA mask in the system,
+ * so a successful GFP_DMA allocation will always satisfy this.
+ */
+#ifndef ISA_DMA_THRESHOLD
+#define ISA_DMA_THRESHOLD	(0xffffffffULL)
+#endif
+
+#ifndef arch_adjust_zones
+#define arch_adjust_zones(node,size,holes) do { } while (0)
+#endif
+
 #ifndef CONFIG_DISCONTIGMEM
 /*
  * PFNs are used to describe any physical page; this means
@@ -65,5 +81,5 @@
  */
 #define page_to_bus(page)	(virt_to_bus(page_address(page)))
 
-
+#endif /* !__ASSEMBLY */
 #endif /* __ASM_ARMNOMMU_MEMORY_H */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/proc-fns.h linux-2.6.9-hsc0/include/asm-armnommu/proc-fns.h
--- linux-2.6.9-uc0/include/asm-armnommu/proc-fns.h	2004-11-19 15:00:55.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/proc-fns.h	2004-11-22 15:42:13.000000000 +0900
@@ -133,11 +133,18 @@
 # endif
 #endif
 
+#ifndef __ASSEMBLY__
+
 #ifndef MULTI_CPU
 #include "asm/cpu-single.h"
 #else
 #include "asm/cpu-multi32.h"
 #endif
 
+#include <asm/memory.h>
+
+#define cpu_switch_mm(pgd,mm) cpu_do_switch_mm(virt_to_phys(pgd),mm)
+
+#endif /* __ASSEMBLY__ */
 #endif /* __KERNEL__ */
 #endif /* __ASM_PROCFNS_H */
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/system.h linux-2.6.9-hsc0/include/asm-armnommu/system.h
--- linux-2.6.9-uc0/include/asm-armnommu/system.h	2004-11-19 15:00:56.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/system.h	2004-11-22 15:20:47.000000000 +0900
@@ -53,9 +53,10 @@
 
 #ifndef __ASSEMBLY__
 
-#include <linux/kernel.h>
+#include <linux/linkage.h>
 
 struct thread_info;
+struct task_struct;
 
 /* information about the system we're running on */
 extern unsigned int system_rev;
@@ -85,19 +86,8 @@
 
 extern int cpu_architecture(void);
 
-#define set_cr(x)					\
-	__asm__ __volatile__(				\
-	"mcr	p15, 0, %0, c1, c0, 0	@ set CR"	\
-	: : "r" (x) : "cc")
-
-#define get_cr()					\
-	({						\
-	unsigned int __val;				\
-	__asm__ __volatile__(				\
-	"mrc	p15, 0, %0, c1, c0, 0	@ get CR"	\
-	: "=r" (__val) : : "cc");			\
-	__val;						\
-	})
+#define set_cr(x)
+#define get_cr(x) 
 
 extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
 extern unsigned long cr_alignment;	/* defined in entry-armv.S */
@@ -163,8 +153,6 @@
  * `prev' will never be the same as `next'.  schedule() itself
  * contains the memory barrier to tell GCC not to cache `current'.
  */
-struct thread_info;
-struct task_struct;
 extern struct task_struct *__switch_to(struct task_struct *, struct thread_info *, struct thread_info *);
 
 #define switch_to(prev,next,last)						\
diff -Naur linux-2.6.9-uc0/include/asm-armnommu/uaccess.h linux-2.6.9-hsc0/include/asm-armnommu/uaccess.h
--- linux-2.6.9-uc0/include/asm-armnommu/uaccess.h	2004-11-19 15:00:56.000000000 +0900
+++ linux-2.6.9-hsc0/include/asm-armnommu/uaccess.h	2004-11-22 15:25:37.000000000 +0900
@@ -382,6 +382,9 @@
 	return __arch_copy_to_user(to, from, n);
 }
 
+#define __copy_to_user_inatomic __copy_to_user
+#define __copy_from_user_inatomic __copy_from_user
+
 static inline unsigned long clear_user (void __user *to, unsigned long n)
 {
 	if (access_ok(VERIFY_WRITE, to, n))
diff -Naur linux-2.6.9-uc0/Makefile linux-2.6.9-hsc0/Makefile
--- linux-2.6.9-uc0/Makefile	2004-11-19 15:00:56.000000000 +0900
+++ linux-2.6.9-hsc0/Makefile	2004-11-23 09:30:28.000000000 +0900
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 9
-EXTRAVERSION = -uc0
+EXTRAVERSION = -hsc0
 NAME=Zonked Quokka
 
 # *DOCUMENTATION*
diff -Naur linux-2.6.9-uc0/mm/page_alloc.c linux-2.6.9-hsc0/mm/page_alloc.c
--- linux-2.6.9-uc0/mm/page_alloc.c	2004-11-19 15:00:56.000000000 +0900
+++ linux-2.6.9-hsc0/mm/page_alloc.c	2004-11-22 20:39:55.000000000 +0900
@@ -2052,6 +2052,9 @@
 
 	do {
 		size = bucketsize << log2qty;
+#ifndef CONFIG_MMU
+		if(size < PAGE_SIZE) size = PAGE_SIZE;
+#endif
 		table = alloc_bootmem(size);
 	} while (!table && size > PAGE_SIZE && --log2qty);
 
